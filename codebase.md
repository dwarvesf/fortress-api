# docker-compose.yml

```yml
version: "3"
services:
#  api:
#    build:
#      context: .
#    env_file: .env.docker
#    ports:
#      - "8201:8200"
#    expose:
#      - 8201
  postgres:
    image: postgres:13
    restart: always
    environment:
      POSTGRES_DB: fortress_local
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    container_name: fortress_local
    ports:
      - "25432:5432"
    expose:
      - 25432

  postgres_test:
    image: postgres:13
    restart: always
    environment:
      POSTGRES_DB: fortress_local_test
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    container_name: fortress_local_test
    ports:
      - "35432:5432"
    expose:
      - 35432

```

# dbconfig.yml

```yml
local:
  dialect: postgres
  datasource: host=localhost port=25432 user=postgres password=postgres dbname=fortress_local sslmode=disable
  dir: migrations/schemas
  table: migrations

test:
  dialect: postgres
  datasource: host=localhost port=35432 user=postgres password=postgres dbname=fortress_local_test sslmode=disable
  dir: migrations/schemas
  table: migrations

dev:
  dialect: postgres
  datasource: host=${DB_HOST} port=${DB_PORT} user=${DB_USER} password=${DB_PASS} dbname=${DB_NAME} sslmode=${DB_SSL_MODE}
  dir: migrations/schemas
  table: migrations

prod:
  dialect: postgres
  datasource: host=${DB_HOST} port=${DB_PORT} user=${DB_USER} password=${DB_PASS} dbname=${DB_NAME} sslmode=${DB_SSL_MODE}
  dir: migrations/schemas
  table: migrations

```

# README.md

```md
# Fortress API

<p align="center">
  <img src="https://img.shields.io/badge/golang-1.18-blue" />
  <img src="https://img.shields.io/badge/strategy-gitflow-%23561D25" />
  <a href="https://github.com/consolelabs/mochi-api/blob/main/LICENSE">
    <img src="https://img.shields.io/badge/license-GNU-blue" />
  </a>
</p>

## Overview

This repository is the official BE service for Fortress

## How to contribute

### Setup local development environment (pick one of following ways)

#### Using DEVBOX

1. Create isolated shell using devbox

\`\`\`
make shell
\`\`\`

2. Start Colima as container runtime 

\`\`\`
make colima-start
\`\`\`

Related issue when initiating development environment first time using colima
- [docker-credential-desktop not installed or not available in PATH](https://stackoverflow.com/questions/67642620/docker-credential-desktop-not-installed-or-not-available-in-path/72888813#72888813)
  - tltr: Cheating by removing `credsStore` in the `~/.docker/config.json`. Or installing `osxkeychain`

####  Using your machine environment

1. Install Golang

2. Install Docker

### How to run source code locally

1. Set up source

Set up infras, install dependencies, etc.

\`\`\`
make init
\`\`\`

2. Set up env

Create a file `.env` with these values:

\`\`\`
DB_HOST="127.0.0.1"
DB_PORT="25432"
DB_USER="postgres"
DB_PASS="postgres"
DB_NAME="fortress_local"
DB_SSL_MODE="disable"
ALLOWED_ORIGINS="*"
ENV=dev
DEBUG=true
JWT_SECRET_KEY=JWTSecretKey
\`\`\`

3. Run source

\`\`\`
make dev
\`\`\`

The service starts with port 8080 as the default

### How to work on a TODO

1. Feel free to pick any TODO for you from [Board View](https://www.notion.so/dwarves/4d756d46e90240918cd2505f962cacd1?v=d65335d1772f4532ab1bc274a1ae8c76)
2. **Assign** that item to your account
3. Remember to update item’s **status** based on your working progress
   - `Not Started`: not started yet
   - `Planned`: working on this sprint
   - `In Progress`: still working on
   - `In Review`: Task done = PR has been merged to `develop` branch at least
   - `Complete`: Confirmation from the team that the TODO is finished

### PR template

\`\`\`markdown
#### What's this PR do?

- [x] Add new routes for user
- [x] Add instruction for using docker-compose

#### What are the relevant Git tickets?

// Put in link to Git Issue

#### Screenshots (if appropriate)

// Use [Licecap](http://www.cockos.com/licecap/) to share a screencast gif.

#### Any background context you want to provide? (if appropriate)

- Is there a blog post?
- Does the knowledge base need an update?
- Does this add new dependencies which need to be added to?
\`\`\`

## Technical Document

### Project structure

- `cmd/` this folder contains the main application entry point files for the project
- `docs/`: contains Swagger documentation files generated by [swaggo](https://github.com/swaggo/swag)
- `migrations/`: contains seeds and SQL migration files
  - `schemas/`: contains DB schema migration files
  - `seed/`: contains seed files which will initialize DB with sets of dummy data
  - `test-seed/`: also seed files but for test DB
- `pkg/`: contains core source code of service
  - `config/`: contains configs for application
  - `handler/`: handling API requests
  - `logger/`: logging initial and functional methods
  - `model/`: DB model structs
  - `mw/`: middleware
  - `request/`: API request models
  - `routes/`: API routing (see [gin](https://github.com/gin-gonic/gin))
  - `service/`: contains interaction with external services (google API, etc.)
  - `store/`: data access layers, contains DB CRUD operations (see [gorm](https://gorm.io/))
  - `utils/`: utility methods
  - `view/`: API view models

### Sample usecases

1. Create new API

- Check out file `/pkg/routes/v1.go` and explore the code flow to see how to create and handle an API
- Remember to annotate handler functions with [swaggo](https://github.com/swaggo/swag). Then run `make gen-swagger` to generate Swagger documentations

2. New DB migration

Check out `.sql` files under `/migrations` to write a valid schema migration / seed file

- To apply new migration files, run `make migrate-up`
- To apply seed files, run `make seed-db`
- To apply new migration files for test DB, run `make migrate-test`

**Note:** remember to run these 2 every time you pulling new code

\`\`\`shell
make migrate-up
make migrate-test
\`\`\`

3. DB repositories

Check out dirs under `/pkg/store`

4. New API Implementation Steps

- Add the new route to `/pkg/routes/v1.go`
  - Check if the new route is in a new group or an existing one
    - Implement `interface IHandler` in `pkg/handler/[name]/interface.go`
    - Implement handling functions that takes a `*gin.Context` in `pkg/handler/[name]/[name].go`
    - Add Swagger doc to handler
    - Add the sub handler to the main handler in `pkg/handler/handler.go`
  - Check if the new route needs authentication
  - Check if the new route needs authorization (permission)
    - If a new permission is needed then define it in `pkg/model/permissions.go`
- Add the new table
  - Create new migration by `make migrate-new`
  - Add seed file to `migrations/seed`
  - Include the new seed file in `migrations/seed/seed.sql`
  - Check if existing seed data needs modification (`roles.sql`, `permisions.sql`, etc.)
  - Implement the model in `pkg/model`
  - After the model is defined, implement the CRUD functions in `pkg/store`
    - Implement `interface IStore` in `pkg/store/[name]/interface.go`
    - Implement the details in `pkg/store/[name]/[name].go`
    - Add the sub store to the main store in `pkg/store/store.go`
- Glue the implemented handler and the implemented store

## :pray: Credits

A big thanks to all who contributed to this project!

If you'd like to contribute, please contact us.

```

# Makefile

```
APP_NAME=fortress-api
DEFAULT_PORT=8200
POSTGRES_TEST_SERVICE?=postgres_test
POSTGRES_TEST_CONTAINER?=fortress_local_test
POSTGRES_CONTAINER?=fortress_local
TOOLS_IMAGE=dwarvesv/fortress-tools:latest
APP_ENVIRONMENT=docker run --rm -v ${PWD}:/${APP_NAME} -w /${APP_NAME} --net=host ${TOOLS_IMAGE}
SWAGGER_VERSION = v1.16.1

.PHONY: setup shel colima-start colima-stop init build dev test migrate-up migrate-down ci

shell:
	@if ! command -v devbox >/dev/null 2>&1; then curl -fsSL https://get.jetpack.io/devbox | bash; fi
	@devbox install
	@devbox shell
	
colima-start:
	colima start --cpu 1 --memory 2 --disk 30
	
colima-stop:
	@colima stop 

setup:
	docker pull ${TOOLS_IMAGE}

init:
	@if [[ "$(docker images -q dwarvesv/fortress-tools:latest 2> /dev/null)" == "" ]]; then \
		docker pull ${TOOLS_IMAGE}; \
	fi

	make remove-infras
	docker compose up -d
	@echo "Waiting for database connection..."
	@while ! docker exec ${POSTGRES_CONTAINER} pg_isready > /dev/null; do \
		sleep 1; \
	done
	@while ! docker exec $(POSTGRES_TEST_CONTAINER) pg_isready > /dev/null; do \
		sleep 1; \
	done
	make migrate-up
	make migrate-test
	make seed
	make seed-test

seed:
	@docker exec -t $(POSTGRES_CONTAINER) sh -c "mkdir -p /seed"
	@docker exec -t $(POSTGRES_CONTAINER) sh -c "rm -rf /seed/*"
	@docker cp migrations/seed $(POSTGRES_CONTAINER):/
	@docker exec -t $(POSTGRES_CONTAINER) sh -c "PGPASSWORD=postgres psql -U postgres -d fortress_local -f /seed/seed.sql"

seed-test:
	@docker exec -t $(POSTGRES_TEST_CONTAINER) sh -c "mkdir -p /seed"
	@docker exec -t $(POSTGRES_TEST_CONTAINER) sh -c "rm -rf /seed/*"
	@docker cp migrations/test_seed $(POSTGRES_TEST_CONTAINER):/
	@docker exec -t $(POSTGRES_TEST_CONTAINER) sh -c "PGPASSWORD=postgres psql -U postgres -d $(POSTGRES_TEST_CONTAINER) -f /test_seed/seed.sql"

remove-infras:
	docker compose down --remove-orphans --volumes

build:
	env GOOS=darwin GOARCH=amd64 go build -o bin ./...

dev:
	go run ./cmd/server/main.go

air:
	air -c .air.toml

cronjob:
	go run ./cmd/cronjob/main.go

test: setup-test
	@PROJECT_PATH=$(shell pwd) go test -cover ./... -count=1 -p=1

setup-test:
	docker rm --volumes -f ${POSTGRES_TEST_CONTAINER}
	docker compose up -d ${POSTGRES_TEST_SERVICE}
	@while ! docker exec $(POSTGRES_TEST_CONTAINER) pg_isready > /dev/null; do \
		sleep 1; \
	done
	make migrate-test
	make seed-test
migrate-test:
	${APP_ENVIRONMENT} sql-migrate up -env=test

migrate-new:
	${APP_ENVIRONMENT} sql-migrate new -env=local ${name}

migrate-up:
	${APP_ENVIRONMENT} sql-migrate up -env=local

migrate-down:
	${APP_ENVIRONMENT} sql-migrate down -env=local

docker-build:
	docker build \
	--build-arg DEFAULT_PORT="${DEFAULT_PORT}" \
	-t ${APP_NAME}:latest .

reset-db:
	${APP_ENVIRONMENT} sql-migrate down -env=local -limit=0
	${APP_ENVIRONMENT} sql-migrate up -env=local
	make seed

reset-test-db:
	${APP_ENVIRONMENT} sql-migrate down -env=test -limit=0
	${APP_ENVIRONMENT} sql-migrate up -env=test
	make seed-test

gen-mock:
	echo "add later"

gen-swagger:
	swag init --parseDependency -g ./cmd/server/main.go

ci: init
	@PROJECT_PATH=$(shell pwd) go test -cover ./... -count=1 -p=1

WD := $(shell pwd)
lint:
	docker run -t --rm -v $(WD):/app -w /app golangci/golangci-lint:v1.52.2 golangci-lint run -v

```

# CODEOWNERS

```
# Default reviewers for every PR
*           @huynguyenh @namnhce @lmquang
.github/    @huynguyenh @namnhce @lmquang
cmd/        @huynguyenh @namnhce @lmquang
docs/       @huynguyenh @namnhce @lmquang
migrations/ @huynguyenh @namnhce @lmquang
pkg/        @huynguyenh @namnhce @lmquang

```

# .air.toml

```toml
root = "."
testdata_dir = "testdata"
tmp_dir = "tmp"

[build]
  args_bin = []
  bin = "./tmp/main"
  cmd = "go build -o ./tmp/main ./cmd/server/main.go"
  delay = 3000
  exclude_dir = ["assets", "tmp", "vendor", "testdata"]
  exclude_file = []
  exclude_regex = ["_test.go"]
  exclude_unchanged = false
  follow_symlink = false
  full_bin = ""
  include_dir = []
  include_ext = ["go", "tpl", "tmpl", "html"]
  kill_delay = "0s"
  log = "build-errors.log"
  send_interrupt = false
  stop_on_error = true

[color]
  app = ""
  build = "yellow"
  main = "magenta"
  runner = "green"
  watcher = "cyan"

[log]
  time = false

[misc]
  clean_on_exit = false

[screen]
  clear_on_rebuild = false

```

# .aidigestignore

```
Dockerfile
tools.Dockerfile
go.*
devbox.*
.golangci.yml
.gitignore
docs/*
migrations/seed/*
migrations/test_seed/*
pkg/templates/*
pkg/contracts/*
pkg/handler/dashboard/util/mocks/*
pkg/handler/survey/testdata/*
pkg/handler/project/testdata/*
pkg/handler/dashboard/testdata/*
pkg/handler/profile/testdata/*
pkg/handler/feedback/testdata/*
pkg/handler/metadata/testdata/*
pkg/handler/invoice/testdata/*
pkg/handler/employee/testdata/*
pkg/handler/bankaccount/testdata/*
pkg/handler/client/testdata/*
*/*_test.go
```

# pkg/worker/worker.go

```go
package worker

import (
	"context"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type Worker struct {
	ctx     context.Context
	service *service.Service
	queue   chan model.WorkerMessage
	logger  logger.Logger
}

func New(ctx context.Context, queue chan model.WorkerMessage, service *service.Service, logger logger.Logger) *Worker {
	return &Worker{
		ctx:     ctx,
		service: service,
		queue:   queue,
		logger:  logger,
	}
}

func (w *Worker) ProcessMessage() error {
	consumeErr := make(chan error, 1)
	go func() {
		for {
			if w.ctx.Err() != nil {
				consumeErr <- w.ctx.Err()
				return
			}
			message := <-w.queue
			switch message.Type {
			case bcModel.BasecampCommentMsg:
				_ = w.handleCommentMessage(w.logger, message.Payload)

			case bcModel.BasecampTodoMsg:
				_ = w.handleTodoMessage(w.logger, message.Payload)
			default:
				continue
			}
		}
	}()

	select {
	case err := <-consumeErr:
		return err
	case <-w.ctx.Done():
		return nil
	}
}

func (w *Worker) Enqueue(action string, msg interface{}) {
	w.queue <- model.WorkerMessage{Type: action, Payload: msg}
}

func (w *Worker) handleCommentMessage(l logger.Logger, payload interface{}) error {
	m := payload.(bcModel.BasecampCommentMessage)
	err := w.service.Basecamp.Comment.Create(m.ProjectID, m.RecordingID, m.Payload)
	if err != nil {
		l.Errorf(err, "failed to create basecamp comment", "payload", m.Payload.Content)
		return err
	}

	return nil
}

func (w *Worker) handleTodoMessage(l logger.Logger, payload interface{}) error {
	m := payload.(bcModel.BasecampTodoMessageModel)
	_, err := w.service.Basecamp.Todo.Create(m.ProjectID, m.ListID, m.Payload)
	if err != nil {
		l.Errorf(err, "failed to create basecamp todo", "payload", m.Payload.Content)
		return err
	}

	return nil
}

```

# pkg/utils/strings_test.go

```go
package utils

import (
	"testing"
)

func TestIsNumber(t *testing.T) {
	type args struct {
		s string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "TestIsNumber",
			args: args{
				s: "123",
			},
			want: true,
		},
		{
			name: "TestIsNumber",
			args: args{
				s: "abc",
			},
			want: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsNumber(tt.args.s); got != tt.want {
				t.Errorf("IsNumber() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHasDomain(t *testing.T) {
	testCases := []struct {
		url      string
		expected bool
	}{
		{"https://www.example.com", true},
		{"https://www.facebook.com", true},
		{"http://google.com", true},
		{"https://docs.google.co.uk", true},
		{"https://example.com", true},
		{"https://example.co.uk", true},
		{"https://sub.example.co.uk", true},
		{"https://sub.sub.example.co.uk", true},
		{"https://example..com", false},
		{"ftp://example.com", true},
		{"not a url", false},
		{"mailto:test@example.com", true},
	}

	for _, tc := range testCases {
		t.Run(tc.url, func(t *testing.T) {
			result := HasDomain(tc.url)
			if result != tc.expected {
				t.Errorf("HasDomain() = %v, want %v", result, tc.expected)
			}
		})
	}
}

func TestProcessString(t *testing.T) {
	type args struct {
		input string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			name: "success with case project name length greater than 5",
			args: args{
				input: "Test Project",
			},
			want: "testp",
		},
		{
			name: "success with case project name length less than 5",
			args: args{
				input: "Te st",
			},
			want: "test",
		},
		{
			name: "success with case project name length equal to 5",
			args: args{
				input: "Te std",
			},
			want: "testd",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ProcessString(tt.args.input); got != tt.want {
				t.Errorf("ProcessString() = %v, want %v", got, tt.want)
			}
		})
	}
}

```

# pkg/utils/strings.go

```go
package utils

import (
	"math"
	"net/url"
	"regexp"
	"strconv"
	"strings"

	"github.com/Rhymond/go-money"
)

// IsNumber checks if a string is a number
func IsNumber(s string) bool {
	_, err := strconv.Atoi(s)
	return err == nil
}

func FormatNumber(n int64) string {
	in := strconv.FormatInt(n, 10)
	out := make([]byte, len(in)+(len(in)-2+int(in[0]/'0'))/3)
	if in[0] == '-' {
		in, out[0] = in[1:], '-'
	}

	for i, j, k := len(in)-1, len(out)-1, 0; ; i, j = i-1, j-1 {
		out[j] = in[i]
		if i == 0 {
			return string(out)
		}
		if k++; k == 3 {
			j, k = j-1, 0
			out[j] = ','
		}
	}
}

func RemoveEmptyString(in []string) []string {
	out := make([]string, 0)
	for _, status := range in {
		if RemoveAllSpace(status) != "" {
			out = append(out, status)
		}
	}

	return out
}

func RemoveAllSpace(str string) string {
	return strings.ReplaceAll(str, " ", "")
}

func HasDomain(str string) bool {
	u, err := url.Parse(str)
	if u.Scheme == "mailto" {
		return true
	}
	return err == nil && u.Scheme != "" && u.Host != "" && regexp.MustCompile(`^[^.]+\.[^.]+(\.[^.]+)*$`).MatchString(u.Host)
}

func FormatMoney(value float64, currencyCode string) string {
	var result string

	currency := money.New(1, currencyCode)
	tmpValue := value * math.Pow(10, float64(currency.Currency().Fraction))

	formatted := currency.Multiply(int64(tmpValue)).Display()
	parts := strings.Split(formatted, ".00")
	if len(parts) > 0 {
		result = parts[0]
	}

	return result
}

func FloatToString(value float64) string {
	roundedNumber := int(math.Round(value))
	return strconv.Itoa(roundedNumber)
}

func ProcessString(input string) string {
	input = strings.ReplaceAll(input, " ", "")

	input = strings.ToLower(input)

	if len(input) <= 5 {
		return input
	}

	return input[:5]
}

```

# pkg/utils/response.go

```go
package utils

import (
	"encoding/json"
)

func RemoveFieldInResponse(data []byte, field string) ([]byte, error) {
	var res map[string]interface{}

	if err := json.Unmarshal(data, &res); err != nil {
		return nil, err
	}

	if res["data"] != nil {
		if data, ok := res["data"].(map[string]interface{}); ok {
			data[field] = ""
			res["data"] = data
		}
	}

	return json.Marshal(res)
}

func RemoveFieldInSliceResponse(data []byte, field string) ([]byte, error) {
	var res map[string]interface{}
	if err := json.Unmarshal(data, &res); err != nil {
		return nil, err
	}

	if res["data"] != nil {
		if resData, ok := res["data"].([]interface{}); ok {
			for i, v := range resData {
				if v, ok := v.(map[string]interface{}); ok {
					v[field] = ""
				}
				resData[i] = v
			}
			res["data"] = resData
		}
	}

	return json.Marshal(res)
}

```

# pkg/utils/errors.go

```go
package utils

import (
	"errors"
)

var (
	ErrInvalidToken                    = errors.New("token expired, please log out and log in again")
	ErrInvalidSignature                = errors.New("invalid signature")
	ErrBadToken                        = errors.New("bad token")
	ErrAuthenticationTypeHeaderInvalid = errors.New("authentication type header is invalid")
	ErrUnexpectedAuthorizationHeader   = errors.New("unexpected authorization headers")
	ErrInvalidUUID                     = errors.New("invalid UUID")
)

```

# pkg/utils/erc20.go

```go
package utils

import (
	"math"
	"math/big"

	"github.com/ethereum/go-ethereum/params"
)

// ConvertFromString convert string to big.Float with given decimal
func ConvertFromString(amount string, decimals int64) *big.Float {
	wei := new(big.Int)
	wei.SetString(amount, 10)
	return WeiToEther(wei, int(decimals))
}

// WeiToEther convert wei to ether
// example: WeiToEther("2000000000000000000", 18) => 2
func WeiToEther(wei *big.Int, decimals ...int) *big.Float {
	f := new(big.Float)
	f.SetPrec(236) //  IEEE 754 octuple-precision binary floating-point format: binary256
	f.SetMode(big.ToNearestEven)
	fWei := new(big.Float)
	fWei.SetPrec(236) //  IEEE 754 octuple-precision binary floating-point format: binary256
	fWei.SetMode(big.ToNearestEven)

	var e *big.Float
	if len(decimals) == 0 {
		e = big.NewFloat(params.Ether)
	} else {
		e = big.NewFloat(math.Pow(10, float64(decimals[0])))
	}
	return f.Quo(fWei.SetInt(wei), e)
}

```

# pkg/utils/currency.go

```go
package utils

import (
	"fmt"
)

func FormatCurrencyAmount(n int) string {
	milPart := n / 1000000
	thouPart := (n % 1000000) / 1000
	hunPart := n % 1000
	var res string
	if milPart != 0 {
		res = fmt.Sprintf("%d", milPart)
		if thouPart == 0 {
			res = fmt.Sprintf("%v,000", res)
		}
	}
	if thouPart != 0 {
		if res == "" {
			res = fmt.Sprintf("%d", thouPart)
		} else {
			res = fmt.Sprintf("%v,%03d", res, thouPart)
		}
	}
	if hunPart != 0 {
		if res == "" {
			res = fmt.Sprintf("%d", hunPart)
		} else {
			res = fmt.Sprintf("%v.%03d", res, hunPart)
		}
	}

	if milPart != 0 || thouPart != 0 {
		return fmt.Sprintf("%vk", res)
	}
	return res
}

```

# pkg/view/work_unit.go

```go
package view

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type BasicMember struct {
	EmployeeID  string `json:"employeeID"`
	FullName    string `json:"fullName"`
	DisplayName string `json:"displayName"`
	Avatar      string `json:"avatar"`
	Username    string `json:"username"`
} // @name BasicMember

func toBasicMember(employee model.Employee) *BasicMember {
	return &BasicMember{
		EmployeeID:  employee.ID.String(),
		FullName:    employee.FullName,
		DisplayName: employee.DisplayName,
		Avatar:      employee.Avatar,
		Username:    employee.Username,
	}
}

type WorkUnit struct {
	ID        string        `json:"id"`
	Name      string        `json:"name"`
	URL       string        `json:"url"`
	Members   []BasicMember `json:"members"`
	Stacks    []Stack       `json:"stacks"`
	Type      string        `json:"type"`
	Status    string        `json:"status"`
	ProjectID string        `json:"projectID"`
	Code      string        `json:"code"`
} // @name WorkUnit

func ToWorkUnit(workUnit *model.WorkUnit, projectCode string) WorkUnit {
	rs := WorkUnit{
		ID:        workUnit.ID.String(),
		Name:      workUnit.Name,
		Type:      workUnit.Type.String(),
		Status:    workUnit.Status.String(),
		URL:       workUnit.SourceURL,
		ProjectID: workUnit.ProjectID.String(),
		Code:      projectCode,
	}

	members := make([]BasicMember, 0, len(workUnit.WorkUnitMembers))
	for _, v := range workUnit.WorkUnitMembers {
		members = append(members, *toBasicMember(v.Employee))
	}
	rs.Members = members

	stacks := make([]Stack, 0, len(workUnit.WorkUnitStacks))
	for _, v := range workUnit.WorkUnitStacks {
		stack := Stack{
			ID:     v.Stack.ID.String(),
			Code:   v.Stack.Code,
			Name:   v.Stack.Name,
			Avatar: v.Stack.Avatar,
		}
		stacks = append(stacks, stack)
	}
	rs.Stacks = stacks

	return rs
}

type ListWorkUnitResponse struct {
	Data []WorkUnit `json:"data"`
} // @name ListWorkUnitResponse

type WorkUnitResponse struct {
	Data WorkUnit `json:"data"`
} // @name WorkUnitResponse

func ToWorkUnitList(workUnits []*model.WorkUnit, projectID string, projectCode string) []*WorkUnit {
	var rs []*WorkUnit

	for _, wu := range workUnits {
		newWorkUnit := &WorkUnit{
			ID:        wu.ID.String(),
			Name:      wu.Name,
			URL:       wu.SourceURL,
			Type:      wu.Type.String(),
			Status:    wu.Status.String(),
			ProjectID: projectID,
			Code:      projectCode,
		}

		for _, member := range wu.WorkUnitMembers {
			newWorkUnit.Members = append(newWorkUnit.Members, *toBasicMember(member.Employee))
		}

		for _, wStack := range wu.WorkUnitStacks {
			newWorkUnit.Stacks = append(newWorkUnit.Stacks, Stack{
				ID:     wStack.Stack.ID.String(),
				Name:   wStack.Stack.Name,
				Code:   wStack.Stack.Code,
				Avatar: wStack.Stack.Avatar,
			})
		}

		rs = append(rs, newWorkUnit)
	}

	return rs
}

```

# pkg/view/valuation.go

```go
package view

type Valuation struct {
	// basic info
	Year     string  `json:"year"`
	Rate     float64 `json:"rate"`
	Currency string  `json:"currency"`

	// valuation info
	Assets float64 `json:"assets"`

	// money that company will receive in the future
	AccountReceivable struct {
		Total float64          `json:"total"`
		Items []AccountingItem `json:"items"`
	} `json:"accountReceivable"`

	// money that company will pay in the future
	Liabilities struct {
		Total float64          `json:"total"`
		Items []AccountingItem `json:"items"`
	} `json:"liabilities"`

	// Total paid invoice, investment & bank interest
	Income struct {
		Total  float64 `json:"total"`
		Detail struct {
			ConsultantService float64 `json:"consultantService"`
			Investment        float64 `json:"investment"`
			Interest          float64 `json:"interest"`
		} `json:"detail"`
	} `json:"income"`

	// Sum of Expenses and payroll
	Outcome struct {
		Total  float64 `json:"total"`
		Detail struct {
			Payroll    float64 `json:"payroll"`
			Expense    float64 `json:"expense"`
			Investment float64 `json:"investment"`
		} `json:"detail"`
	} `json:"outcome"`
} // @name Valuation

type AccountingItem struct {
	Name   string  `json:"name"`
	Amount float64 `json:"amount"`
} // @name AccountingItem

type CurrencyView struct {
	USD float64
	VND float64
	EUR float64
	GBP float64
	SGD float64
} // @name CurrencyView

```

# pkg/view/uuid_test.go

```go
package view

import (
	"database/sql/driver"
	"errors"
	"reflect"
	"testing"

	uuid "github.com/satori/go.uuid"
)

func TestUUIDFromString(t *testing.T) {
	type args struct {
		s string
	}
	tests := []struct {
		name    string
		args    args
		want    UUID
		wantErr error
	}{
		{
			name:    "correct uuid",
			args:    args{"a98484cb-cc66-4687-8e66-837e5997c427"},
			want:    UUID(uuid.Must(uuid.FromString("a98484cb-cc66-4687-8e66-837e5997c427"))),
			wantErr: nil,
		},
		{
			name:    "correct uuid zero value",
			args:    args{"00000000-0000-0000-0000-000000000000"},
			want:    UUID(uuid.Must(uuid.FromString("00000000-0000-0000-0000-000000000000"))),
			wantErr: nil,
		},
		{
			name:    "incorrect uuid by wrong character",
			args:    args{"a98484cb-cc66-4687-8e66-837e5997c42l"},
			wantErr: errors.New("encoding/hex: invalid byte: U+006C 'l'"),
		},
		{
			name:    "incorrect uuid by invalid length",
			args:    args{"a98484cb-cc66-4687-8e66-837e5997c42"},
			wantErr: errors.New("uuid: incorrect UUID length: a98484cb-cc66-4687-8e66-837e5997c42"),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := UUIDFromString(tt.args.s)
			if err != nil {
				if tt.wantErr == nil {
					t.Errorf("UUIDFromString() error = %v, wantErr %v", err, tt.wantErr)
					return
				}

				if tt.wantErr.Error() != err.Error() {
					t.Errorf("UUIDFromString() error = %v, wantErr %v", err, tt.wantErr)
					return
				}

				return
			}

			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UUIDFromString() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMustGetUUIDFromString(t *testing.T) {
	type args struct {
		s string
	}
	tests := []struct {
		name    string
		args    args
		want    UUID
		wantErr error
	}{
		{
			name:    "correct uuid",
			args:    args{"a98484cb-cc66-4687-8e66-837e5997c427"},
			want:    UUID(uuid.Must(uuid.FromString("a98484cb-cc66-4687-8e66-837e5997c427"))),
			wantErr: nil,
		},
		{
			name:    "correct uuid zero value",
			args:    args{"00000000-0000-0000-0000-000000000000"},
			want:    UUID(uuid.Must(uuid.FromString("00000000-0000-0000-0000-000000000000"))),
			wantErr: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := MustGetUUIDFromString(tt.args.s)

			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UUIDFromString() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUUID_IsZero(t *testing.T) {
	tests := []struct {
		name string
		u    UUID
		want bool
	}{
		{
			name: "zero uuid",
			u:    UUID(uuid.Must(uuid.FromString("00000000-0000-0000-0000-000000000000"))),
			want: true,
		},
		{
			name: "normal uuid",
			u:    UUID(uuid.Must(uuid.FromString("c2186152-0e6e-437f-bf16-d0b291e98100"))),
			want: false,
		},
		{
			name: "nil uuid",
			u:    UUID{},
			want: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := (&tt.u).IsZero(); got != tt.want {
				t.Errorf("UUID.IsZero() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUUID_MarshalJSON(t *testing.T) {
	tests := []struct {
		name    string
		u       UUID
		want    []byte
		wantErr bool
	}{
		{
			name:    "success marshal json",
			u:       UUID(uuid.Must(uuid.FromString("c2186152-0e6e-437f-bf16-d0b291e98100"))),
			want:    []byte("\"c2186152-0e6e-437f-bf16-d0b291e98100\""),
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.u.MarshalJSON()
			if (err != nil) != tt.wantErr {
				t.Errorf("UUID.MarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UUID.MarshalJSON() = %v, want %v", string(got), string(tt.want))
			}
		})
	}
}

func TestUUID_UnmarshalJSON(t *testing.T) {
	type args struct {
		data []byte
	}
	tests := []struct {
		name    string
		u       UUID
		args    args
		wantErr bool
	}{
		{
			name:    "success unmarshal json",
			u:       UUID{},
			args:    args{[]byte("\"c2186152-0e6e-437f-bf16-d0b291e98100\"")},
			wantErr: false,
		},
		{
			name:    "fail unmarshal json by length",
			u:       UUID{},
			args:    args{[]byte("\"c2186152-0e6e-437f-bf16-d0b291e9810\"")},
			wantErr: true,
		},
		{
			name:    "fail unmarshal json by wrong character",
			u:       UUID{},
			args:    args{[]byte("\"c2186152-0e6e-437f-bf16-d0b291e981l\"")},
			wantErr: true,
		},
		{
			name:    "fail unmarshal json by missing double quote character",
			u:       UUID{},
			args:    args{[]byte("c2186152-0e6e-437f-bf16-d0b291e9810")},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := (&tt.u).UnmarshalJSON(tt.args.data); (err != nil) != tt.wantErr {
				t.Errorf("UUID.UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestUUID_Value(t *testing.T) {
	tests := []struct {
		name    string
		u       UUID
		want    driver.Value
		wantErr bool
	}{
		{
			name:    "correct uuid",
			u:       UUID(uuid.Must(uuid.FromString("c2186152-0e6e-437f-bf16-d0b291e98100"))),
			want:    driver.Value("c2186152-0e6e-437f-bf16-d0b291e98100"),
			wantErr: false,
		},
		{
			name:    "zero uuid",
			u:       UUID(uuid.Must(uuid.FromString("00000000-0000-0000-0000-000000000000"))),
			want:    nil,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.u.Value()
			if (err != nil) != tt.wantErr {
				t.Errorf("UUID.Value() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UUID.Value() = %v, want %v", got, tt.want)
			}
		})
	}
}

```

# pkg/view/uuid.go

```go
package view

import (
	"database/sql/driver"
	"errors"

	"github.com/dwarvesf/fortress-api/pkg/model"
	uuid "github.com/satori/go.uuid"
)

// UUID implement for go-pg convert uuid
type UUID [16]byte // @name UUID

func ToModelUUIDs(ids []UUID) []model.UUID {
	if len(ids) == 0 {
		return nil
	}
	result := make([]model.UUID, 0, len(ids))
	for _, id := range ids {
		result = append(result, model.UUID(id))
	}
	return result
}

// IsZero check uuid is zero
func (u *UUID) IsZero() bool {
	if u == nil {
		return true
	}
	for _, c := range u {
		if c != 0 {
			return false
		}
	}
	return true
}

func (u UUID) String() string {
	if u.IsZero() {
		return ""
	}
	return uuid.UUID(u).String()
}

// MarshalJSON implement for json encoding
func (u UUID) MarshalJSON() ([]byte, error) {
	if len(u) == 0 {
		return []byte(`""`), nil
	}
	return []byte(`"` + u.String() + `"`), nil
}

// UnmarshalJSON implement for json decoding
func (u *UUID) UnmarshalJSON(data []byte) error {
	if len(data) == 0 || string(data) == `""` {
		return nil
	}

	if len(data) < 2 || data[0] != '"' || data[len(data)-1] != '"' {
		return errors.New("invalid UUID format")
	}
	data = data[1 : len(data)-1]
	uu, err := uuid.FromString(string(data))
	if err != nil {
		return errors.New("invalid UUID format")
	}
	*u = UUID(uu)
	return nil
}

// Value .
func (u UUID) Value() (driver.Value, error) {
	if u.IsZero() {
		return nil, nil
	}
	return uuid.UUID(u).String(), nil
}

func UUIDFromString(s string) (UUID, error) {
	id, err := uuid.FromString(s)
	return UUID(id), err
}

func MustGetUUIDFromString(s string) UUID {
	id, err := uuid.FromString(s)
	if err != nil {
		panic(err)
	}
	return UUID(id)
}

```

# pkg/view/survey.go

```go
package view

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type Survey struct {
	ID        string        `json:"id"`
	Title     string        `json:"title"`
	Type      string        `json:"type"`
	Subtype   string        `json:"subtype"`
	Status    string        `json:"status"`
	StartDate *time.Time    `json:"startDate"`
	EndDate   *time.Time    `json:"endDate"`
	Count     FeedbackCount `json:"count"`
	Domains   []Domain      `json:"domains"`
} // @name Survey

type FeedbackCount struct {
	Total int `json:"total"`
	Sent  int `json:"sent"`
	Done  int `json:"done"`
} // @name FeedbackCount

type Domain struct {
	Name    string           `json:"name"`
	Average float32          `json:"average"`
	Count   LikertScaleCount `json:"count"`
} // @name Domain

type LikertScaleCount struct {
	StronglyDisagree int `json:"stronglyDisagree" gorm:"column:strongly_disagree"`
	Disagree         int `json:"disagree" gorm:"column:disagree"`
	Mixed            int `json:"mixed" gorm:"column:mixed"`
	Agree            int `json:"agree" gorm:"column:agree"`
	StronglyAgree    int `json:"stronglyAgree" gorm:"column:strongly_agree"`
} // @name LikertScaleCount

func ToListSurvey(events []*model.FeedbackEvent) []Survey {
	var results = make([]Survey, 0, len(events))

	for _, e := range events {
		var sent, done int

		// calculate feedback count
		for _, topic := range e.Topics {
			var topicSent, topicDone int

			for _, reviewer := range topic.EmployeeEventReviewers {
				if reviewer.AuthorStatus != model.EventAuthorStatusDraft {
					topicSent++
				}
				if reviewer.AuthorStatus == model.EventAuthorStatusDone {
					topicDone++
				}
			}

			if topicSent == len(topic.EmployeeEventReviewers) {
				sent++
			}

			if topicDone == len(topic.EmployeeEventReviewers) {
				done++
			}
		}

		// calculate domain value
		// average = (count1 * weight1 + count2 * weight2 + ...) / (count1 + count2 + ...)
		var domains []Domain
		if e.Subtype == model.EventSubtypeWork && len(e.QuestionDomainCounts) > 0 {
			domains = make([]Domain, 0)
			for _, count := range e.QuestionDomainCounts {
				var average float32
				total := count.StronglyDisagree +
					count.Disagree +
					count.Mixed +
					count.Agree +
					count.StronglyAgree

				if total > 0 {
					average = float32(count.StronglyDisagree+
						count.Disagree*2+
						count.Mixed*3+
						count.Agree*4+
						count.StronglyAgree*5) / float32(total)
				}

				domains = append(domains, Domain{
					Name:    count.Domain.String(),
					Average: average,
					Count: LikertScaleCount{
						StronglyDisagree: count.StronglyDisagree,
						Disagree:         count.Disagree,
						Mixed:            count.Mixed,
						Agree:            count.Agree,
						StronglyAgree:    count.StronglyAgree,
					},
				})
			}
		}

		results = append(results, Survey{
			ID:        e.ID.String(),
			Title:     e.Title,
			Type:      e.Type.String(),
			Subtype:   e.Subtype.String(),
			Status:    e.Status.String(),
			StartDate: e.StartDate,
			EndDate:   e.EndDate,
			Count: FeedbackCount{
				Total: len(e.Topics),
				Sent:  sent,
				Done:  done,
			},
			Domains: domains,
		})
	}

	return results
}

type ListSurveyResponse struct {
	PaginationResponse
	Data []Survey `json:"data"`
} // @name ListSurveyResponse

type SurveyDetail struct {
	EventID   string             `json:"eventID"`
	Title     string             `json:"title"`
	Type      string             `json:"type"`
	Subtype   string             `json:"subtype"`
	Status    string             `json:"status"`
	StartDate *time.Time         `json:"startDate"`
	EndDate   *time.Time         `json:"endDate"`
	Author    *BasicEmployeeInfo `json:"author"`
	Topics    []Topic            `json:"topics"`
} // @name SurveyDetail

type Topic struct {
	ID           string              `json:"id"`
	EventID      string              `json:"eventID"`
	ReviewID     string              `json:"reviewID,omitempty"`
	Title        string              `json:"title"`
	Type         string              `json:"type"`
	Subtype      string              `json:"subtype"`
	Status       string              `json:"status,omitempty"`
	IsForcedDone bool                `json:"isForcedDone"`
	Employee     BasicEmployeeInfo   `json:"employee"`
	Participants []BasicEmployeeInfo `json:"participants"`
	Count        *FeedbackCount      `json:"count"`
	Domains      []Domain            `json:"domains"`
	Comments     int                 `json:"comments"`
	Project      *BasicProjectInfo   `json:"project"`
} // @name Topic

type SurveyResult struct {
	StronglyDisagree int `json:"stronglyDisagree"`
	Disagree         int `json:"disagree"`
	Mixed            int `json:"mixed"`
	Agree            int `json:"agree"`
	StronglyAgree    int `json:"stronglyAgree"`
}

func ToSurveyDetail(event *model.FeedbackEvent) SurveyDetail {
	result := SurveyDetail{
		EventID:   event.ID.String(),
		Title:     event.Title,
		Type:      event.Type.String(),
		Subtype:   event.Subtype.String(),
		Status:    event.Status.String(),
		StartDate: event.StartDate,
		EndDate:   event.EndDate,
		Author:    toBasicEmployeeInfo(event.Employee),
	}

	var topics = make([]Topic, 0, len(event.Topics))

	for _, topic := range event.Topics {
		newTopic := Topic{
			ID:       topic.ID.String(),
			EventID:  topic.EventID.String(),
			Title:    topic.Title,
			Type:     topic.Event.Type.String(),
			Subtype:  topic.Event.Subtype.String(),
			Employee: *toBasicEmployeeInfo(*topic.Employee),
		}

		switch topic.Event.Subtype {
		case model.EventSubtypePeerReview:
			{
				participants := make([]BasicEmployeeInfo, 0, len(topic.EmployeeEventReviewers))
				for _, reviewer := range topic.EmployeeEventReviewers {
					employee := toBasicEmployeeInfo(*reviewer.Reviewer)
					participants = append(participants, *employee)
				}

				var sent, done int
				for _, reviewer := range topic.EmployeeEventReviewers {
					if reviewer.AuthorStatus != model.EventAuthorStatusDraft {
						sent++
					}
					if reviewer.AuthorStatus == model.EventAuthorStatusDone {
						done++
					}
				}

				newTopic.Participants = participants
				newTopic.Count = &FeedbackCount{
					Total: len(topic.EmployeeEventReviewers),
					Sent:  sent,
					Done:  done,
				}
			}
		case model.EventSubtypeWork:
			{
				// only 1 reviewer for each topic
				if len(topic.EmployeeEventReviewers) > 0 {
					newTopic.ReviewID = topic.EmployeeEventReviewers[0].ID.String()
					newTopic.Status = topic.EmployeeEventReviewers[0].AuthorStatus.String()
					newTopic.IsForcedDone = topic.EmployeeEventReviewers[0].IsForcedDone

					if topic.Project != nil {
						newTopic.Project = toBasicProjectInfo(*topic.Project)
					}

					totalComment := 0
					answerMap := make(map[string]int)

					for _, question := range topic.EmployeeEventReviewers[0].EmployeeEventQuestions {
						if question.Note != "" {
							totalComment++
						}

						answerMap[question.Answer]++
					}

					newTopic.Comments = totalComment
					newTopic.Domains = toDomains(topic.EmployeeEventReviewers[0].EmployeeEventQuestions)
				}
			}
		case model.EventSubtypeEngagement:
			{
				// only 1 reviewer for each topic
				if len(topic.EmployeeEventReviewers) > 0 {
					newTopic.ReviewID = topic.EmployeeEventReviewers[0].ID.String()
					newTopic.Status = topic.EmployeeEventReviewers[0].AuthorStatus.String()
					newTopic.IsForcedDone = topic.EmployeeEventReviewers[0].IsForcedDone
				}
			}
		}

		topics = append(topics, newTopic)
	}

	result.Topics = topics
	return result
}

type PeerReviewer struct {
	EventReviewerID string              `json:"eventReviewerID"`
	Reviewer        *BasicEmployeeInfo  `json:"reviewer"`
	Status          EventReviewerStatus `json:"status"`
	Relationship    Relationship        `json:"relationship"`
	IsForcedDone    bool                `json:"isForcedDone"`
} // @name PeerReviewer

// EventReviewerStatus event_reviewer_status for table employee event reviewer
type EventReviewerStatus string // @name EventReviewerStatus

// EventReviewerStatus values
const (
	EventReviewerStatusNone  EventReviewerStatus = "none"
	EventReviewerStatusNew   EventReviewerStatus = "new"
	EventReviewerStatusDraft EventReviewerStatus = "draft"
	EventReviewerStatusDone  EventReviewerStatus = "done"
)

// IsValid validation for EventReviewerStatus
func (e EventReviewerStatus) IsValid() bool {
	switch e {
	case
		EventReviewerStatusNone,
		EventReviewerStatusDraft,
		EventReviewerStatusDone,
		EventReviewerStatusNew:
		return true
	}
	return false
}

// String returns the string type from the EventReviewerStatus type
func (e EventReviewerStatus) String() string {
	return string(e)
}

// Relationship relationships for table employee_event_topics
type Relationship string // @name Relationship

// values for Relationship
const (
	RelationshipPeer        Relationship = "peer"
	RelationshipLineManager Relationship = "line-manager"
	RelationshipChapterLead Relationship = "chapter-lead"
	RelationshipSelf        Relationship = "self"
)

// IsValid validation for Relationship
func (e Relationship) IsValid() bool {
	switch e {
	case
		RelationshipPeer,
		RelationshipLineManager,
		RelationshipChapterLead,
		RelationshipSelf:
		return true
	}
	return false
}

// IsValid validation for Relationship
func (e Relationship) String() string {
	return string(e)
}

type SurveyTopicDetail struct {
	TopicID      string             `json:"topicID"`
	Title        string             `json:"title"`
	Employee     *BasicEmployeeInfo `json:"employee"`
	Participants []PeerReviewer     `json:"participants"`
} // @name SurveyTopicDetail

type SurveyTopicDetailResponse struct {
	Data SurveyTopicDetail `json:"data"`
} // @name SurveyTopicDetailResponse

func ToPeerReviewDetail(topic *model.EmployeeEventTopic) SurveyTopicDetail {
	rs := SurveyTopicDetail{
		TopicID:  topic.ID.String(),
		Employee: toBasicEmployeeInfo(*topic.Employee),
		Title:    topic.Title,
	}

	for _, eventReviewer := range topic.EmployeeEventReviewers {
		participant := PeerReviewer{
			EventReviewerID: eventReviewer.ID.String(),
			Status:          EventReviewerStatus(eventReviewer.AuthorStatus),
			Relationship:    Relationship(eventReviewer.Relationship),
			IsForcedDone:    eventReviewer.IsForcedDone,
		}

		if eventReviewer.Reviewer != nil {
			participant.Reviewer = toBasicEmployeeInfo(*eventReviewer.Reviewer)
		}

		rs.Participants = append(rs.Participants, participant)
	}

	return rs
}

type ListSurveyDetailResponse struct {
	PaginationResponse
	Data SurveyDetail `json:"data"`
} // @name ListSurveyDetailResponse

func toDomains(questions []model.EmployeeEventQuestion) []Domain {
	domainMap := make(map[string]map[string]int)
	domainMap[""] = make(map[string]int)
	domainMap[model.QuestionDomainWorkload.String()] = make(map[string]int)
	domainMap[model.QuestionDomainDeadline.String()] = make(map[string]int)
	domainMap[model.QuestionDomainLearning.String()] = make(map[string]int)

	for _, q := range questions {
		domainMap[q.Domain.String()][model.AgreementLevelValueMap[q.Answer].String()]++
	}

	wlCount := model.LikertScaleCount{
		StronglyDisagree: domainMap[model.QuestionDomainWorkload.String()][model.AgreementLevelStronglyDisagree.String()],
		Disagree:         domainMap[model.QuestionDomainWorkload.String()][model.AgreementLevelDisagree.String()],
		Mixed:            domainMap[model.QuestionDomainWorkload.String()][model.AgreementLevelMixed.String()],
		Agree:            domainMap[model.QuestionDomainWorkload.String()][model.AgreementLevelAgree.String()],
		StronglyAgree:    domainMap[model.QuestionDomainWorkload.String()][model.AgreementLevelStronglyAgree.String()],
	}
	dlCount := model.LikertScaleCount{
		StronglyDisagree: domainMap[model.QuestionDomainDeadline.String()][model.AgreementLevelStronglyDisagree.String()],
		Disagree:         domainMap[model.QuestionDomainDeadline.String()][model.AgreementLevelDisagree.String()],
		Mixed:            domainMap[model.QuestionDomainDeadline.String()][model.AgreementLevelMixed.String()],
		Agree:            domainMap[model.QuestionDomainDeadline.String()][model.AgreementLevelAgree.String()],
		StronglyAgree:    domainMap[model.QuestionDomainDeadline.String()][model.AgreementLevelStronglyAgree.String()],
	}
	lnCount := model.LikertScaleCount{
		StronglyDisagree: domainMap[model.QuestionDomainLearning.String()][model.AgreementLevelStronglyDisagree.String()],
		Disagree:         domainMap[model.QuestionDomainLearning.String()][model.AgreementLevelDisagree.String()],
		Mixed:            domainMap[model.QuestionDomainLearning.String()][model.AgreementLevelMixed.String()],
		Agree:            domainMap[model.QuestionDomainLearning.String()][model.AgreementLevelAgree.String()],
		StronglyAgree:    domainMap[model.QuestionDomainLearning.String()][model.AgreementLevelStronglyAgree.String()],
	}

	wlDomain := Domain{
		Name:    model.QuestionDomainWorkload.String(),
		Average: countLikertScaleAverage(wlCount),
		Count: LikertScaleCount{
			StronglyDisagree: wlCount.StronglyDisagree,
			Disagree:         wlCount.Disagree,
			Mixed:            wlCount.Mixed,
			Agree:            wlCount.Agree,
			StronglyAgree:    wlCount.StronglyAgree,
		},
	}
	dlDomain := Domain{
		Name:    model.QuestionDomainDeadline.String(),
		Average: countLikertScaleAverage(dlCount),
		Count: LikertScaleCount{
			StronglyDisagree: dlCount.StronglyDisagree,
			Disagree:         dlCount.Disagree,
			Mixed:            dlCount.Mixed,
			Agree:            dlCount.Agree,
			StronglyAgree:    dlCount.StronglyAgree,
		},
	}
	lnDomain := Domain{
		Name:    model.QuestionDomainLearning.String(),
		Average: countLikertScaleAverage(lnCount),
		Count: LikertScaleCount{
			StronglyDisagree: lnCount.StronglyDisagree,
			Disagree:         lnCount.Disagree,
			Mixed:            lnCount.Mixed,
			Agree:            lnCount.Agree,
			StronglyAgree:    lnCount.StronglyAgree,
		},
	}

	return []Domain{wlDomain, dlDomain, lnDomain}
}

func countLikertScaleAverage(count model.LikertScaleCount) float32 {
	var average float32
	total := count.StronglyDisagree +
		count.Disagree +
		count.Mixed +
		count.Agree +
		count.StronglyAgree

	if total > 0 {
		average = float32(count.StronglyDisagree+
			count.Disagree*2+
			count.Mixed*3+
			count.Agree*4+
			count.StronglyAgree*5) / float32(total)
	}
	return average
}

```

# pkg/view/stack.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type Stack struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Code   string `json:"code"`
	Avatar string `json:"avatar"`
} // @name Stack

func ToEmployeeStacks(stacks []model.EmployeeStack) []Stack {
	rs := make([]Stack, 0, len(stacks))
	for _, v := range stacks {
		r := Stack{
			ID:     v.Stack.ID.String(),
			Code:   v.Stack.Code,
			Name:   v.Stack.Name,
			Avatar: v.Stack.Avatar,
		}
		rs = append(rs, r)
	}

	return rs
}

func ToProjectStacks(stacks []model.ProjectStack) []Stack {
	rs := make([]Stack, 0, len(stacks))
	for _, v := range stacks {
		r := Stack{
			ID:     v.Stack.ID.String(),
			Code:   v.Stack.Code,
			Name:   v.Stack.Name,
			Avatar: v.Stack.Avatar,
		}
		rs = append(rs, r)
	}

	return rs
}

```

# pkg/view/seniority.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type Seniority struct {
	ID   string `json:"id"`
	Code string `json:"code"`
	Name string `json:"name"`
} // @name Seniority

func ToSeniority(seniority model.Seniority) Seniority {
	return Seniority{
		ID:   seniority.ID.String(),
		Code: seniority.Code,
		Name: seniority.Name,
	}
}

```

# pkg/view/salary.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type CheckSalaryAdvance struct {
	AmountICY string `json:"amountICY"`
	AmountUSD string `json:"amountUSD"`
} // @name CheckSalaryAdvance

type CheckSalaryAdvanceResponse struct {
	Data CheckSalaryAdvance `json:"data"`
} // @name CheckSalaryAdvanceResponse

func ToCheckSalaryAdvance(amountIcy, amountUSD string) *CheckSalaryAdvance {
	return &CheckSalaryAdvance{
		AmountICY: amountIcy,
		AmountUSD: amountUSD,
	}
}

type SalaryAdvance struct {
	AmountICY       string `json:"amountICY"`
	AmountUSD       string `json:"amountUSD"`
	TransactionID   string `json:"transactionID"`
	TransactionHash string `json:"transactionHash"`
} // @name SalaryAdvance

type SalaryAdvanceResponse struct {
	Data SalaryAdvance `json:"data"`
} // @name SalaryAdvanceResponse

func ToSalaryAdvance(amountIcy, amountUSD, transactionID, transactionHash string) *SalaryAdvance {
	return &SalaryAdvance{
		AmountICY:       amountIcy,
		AmountUSD:       amountUSD,
		TransactionID:   transactionID,
		TransactionHash: transactionHash,
	}
}

type SalaryAdvanceReportResponse struct {
	PaginationResponse
	Data SalaryAdvanceReport `json:"data"`
} // @name SalaryAdvanceReportResponse

type AggregatedSalaryAdvance struct {
	EmployeeID      string  `json:"employeeID"`
	DiscordID       string  `json:"discordID"`
	DiscordUsername string  `json:"discordUsername"`
	AmountICY       int64   `json:"amountICY"`
	AmountUSD       float64 `json:"amountUSD"`
} // @name AggregatedSalaryAdvance

type SalaryAdvanceReport struct {
	SalaryAdvances []AggregatedSalaryAdvance `json:"salaryAdvances"`
	TotalICY       int64                     `json:"totalICY"`
	TotalUSD       float64                   `json:"totalUSD"`
} // @name SalaryAdvanceReport

func ToSalaryAdvanceReport(result model.SalaryAdvanceReport) *SalaryAdvanceReport {
	var salaryAdvances []AggregatedSalaryAdvance
	for _, v := range result.SalaryAdvances {
		salaryAdvances = append(salaryAdvances, AggregatedSalaryAdvance{
			EmployeeID:      v.EmployeeID,
			DiscordID:       v.Employee.DiscordAccount.DiscordID,
			DiscordUsername: v.Employee.DiscordAccount.DiscordUsername,
			AmountICY:       v.AmountICY,
			AmountUSD:       v.AmountUSD,
		})
	}

	return &SalaryAdvanceReport{
		SalaryAdvances: salaryAdvances,
		TotalICY:       result.TotalICY,
		TotalUSD:       result.TotalUSD,
	}
}

```

# pkg/view/roles.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type Role struct {
	ID   string `json:"id"`
	Code string `json:"code"`
	Name string `json:"name"`
} // @name Role

func ToEmployeeRoles(roles []model.EmployeeRole) []Role {
	rs := make([]Role, 0, len(roles))
	for _, v := range roles {
		r := Role{
			ID:   v.Role.ID.String(),
			Code: v.Role.Code,
			Name: toRoleName(&v.Role),
		}
		rs = append(rs, r)
	}

	return rs
}

func toRoleName(role *model.Role) string {
	roleName := ""
	switch role.Color {
	case "red":
		roleName = "🔴 " + role.Name
	case "yellow":
		roleName = "🟡 " + role.Name
	case "green":
		roleName = "🟢 " + role.Name
	default:
		roleName = "⚪️ " + role.Name
	}

	return roleName
}

```

# pkg/view/response.go

```go
package view

import (
	"errors"
	"reflect"
	"strings"

	"github.com/go-playground/validator/v10"
)

// ApiError is a struct for error response
// @Description validation error details
type ApiError struct {
	Field string   `json:"field"`           // the field cause the error
	Msg   string   `json:"msg"`             // error message
	Enums []string `json:"enums,omitempty"` // available options incase of field's payload is enums
} // @name ApiError

type Response[T any] struct {
	*PaginationResponse `json:",omitempty"`
	Data                T          `json:"data"`
	Message             string     `json:"message,omitempty"`
	Error               string     `json:"error,omitempty"`
	ErrorDetails        []ApiError `json:"errors,omitempty"`
}

type ErrorResponse struct {
	Error        string     `json:"error"`
	ErrorDetails []ApiError `json:"errors"`
} // @name ErrorResponse

type MessageResponse struct {
	Message string `json:"message"`
} // @name MessageResponse

type ResponseString struct {
	Data string `json:"data"`
} // @name ResponseString

func CreateResponse[T any](data T, paging *PaginationResponse, err error, payload any, message string) Response[T] {
	resp := Response[T]{
		Data: data,
	}

	if paging != nil {
		resp.PaginationResponse = paging
	}

	if message != "" {
		resp.Message = message
	}

	var ve validator.ValidationErrors
	if err != nil {
		resp.Error = err.Error()
	}
	if err != nil && errors.As(err, &ve) {
		errs := make([]ApiError, len(ve))

		for i, fe := range ve {
			var msg string
			var enums []string
			if payload != nil {
				field, ok := reflect.TypeOf(payload).FieldByName(fe.StructField())
				if ok {
					msg = field.Tag.Get("msg")
					if len(field.Tag.Get("enums")) > 0 {
						enums = strings.Split(field.Tag.Get("enums"), ",")
					}
				}
			}
			if msg == "" {
				splitErrMsg := strings.Split(fe.Error(), "Error:")
				if len(splitErrMsg) > 1 {
					msg = splitErrMsg[1]
				} else {
					msg = splitErrMsg[0]
				}
			}
			errs[i] = ApiError{Field: fe.Field(), Msg: msg, Enums: enums}
		}
		resp.ErrorDetails = errs
	}

	return resp
}

```

# pkg/view/research_topic.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

// DiscordResearchTopic represents discord research topic
type DiscordResearchTopic struct {
	Name              string
	URL               string
	MsgCount          int64
	SortedActiveUsers []DiscordTopicActiveUser
} // @name DiscordResearchTopic

// DiscordTopicActiveUser represents active users who send most messages in topic
type DiscordTopicActiveUser struct {
	UserID   string
	MsgCount int64
} // @name DiscordTopicActiveUser

// ListResearchTopicResponse represents list of research topic
type ListResearchTopicResponse struct {
	PaginationResponse
	Data []DiscordResearchTopic `json:"data"`
} // @name ListResearchTopicResponse

// ToListResearchTopicResponse returns list of research topic
func ToListResearchTopicResponse(rs []model.DiscordResearchTopic) []DiscordResearchTopic {
	data := make([]DiscordResearchTopic, 0)
	for _, r := range rs {
		data = append(data, DiscordResearchTopic{
			Name:              r.Name,
			URL:               r.URL,
			MsgCount:          r.MsgCount,
			SortedActiveUsers: ToDiscordTopicActiveUsers(r.SortedActiveUsers),
		})
	}
	return data
}

// ToDiscordTopicActiveUser returns list of active users who send most messages in topic
func ToDiscordTopicActiveUsers(rs []model.DiscordTopicActiveUser) []DiscordTopicActiveUser {
	data := make([]DiscordTopicActiveUser, 0)
	for _, r := range rs {
		data = append(data, DiscordTopicActiveUser{
			UserID:   r.UserID,
			MsgCount: r.MsgCount,
		})
	}
	return data
}

```

# pkg/view/project.go

```go
package view

import (
	"strings"
	"time"

	"github.com/shopspring/decimal"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
)

type Project struct {
	ID                  string                   `json:"id"`
	CreatedAt           time.Time                `json:"createdAt"`
	UpdatedAt           *time.Time               `json:"updatedAt"`
	Name                string                   `json:"name"`
	CountryID           string                   `json:"countryID"`
	Type                string                   `json:"type"`
	StartDate           *time.Time               `json:"startDate"`
	EndDate             *time.Time               `json:"end_date"`
	Status              string                   `json:"status"`
	ProjectEmail        string                   `json:"projectEmail"`
	ClientEmail         string                   `json:"clientEmail"`
	Avatar              string                   `json:"avatar"`
	AllowsSendingSurvey bool                     `json:"allowsSendingSurvey"`
	Code                string                   `json:"code"`
	Function            string                   `json:"function"`
	BankAccountID       string                   `json:"bankAccountID"`
	CompanyInfoID       string                   `json:"companyInfoID"`
	ClientID            string                   `json:"clientID"`
	OrganizationID      string                   `json:"organizationID"`
	AccountRating       int                      `json:"accountRating"`
	DeliveryRating      int                      `json:"deliveryRating"`
	LeadRating          int                      `json:"leadRating"`
	ImportantLevel      string                   `json:"importantLevel"`
	ProjectNotion       *ProjectNotion           `json:"projectNotion"`
	Organization        *Organization            `json:"organization"`
	BankAccount         *BankAccount             `json:"bankAccount"`
	Country             *Country                 `json:"country"`
	Client              *Client                  `json:"client"`
	CompanyInfo         *CompanyInfo             `json:"companyInfo"`
	Slots               []ProjectSlot            `json:"slots"`
	Heads               []*ProjectHead           `json:"heads"`
	ProjectMembers      []ProjectMember          `json:"projectMembers"`
	ProjectStacks       []Stack                  `json:"projectStacks"`
	CommissionConfigs   ProjectCommissionConfigs `json:"commissionConfigs"`
	ProjectInfo         *ProjectInfo             `json:"projectInfo"`
} // @name Project

func ToProjects(projects []model.Project) []Project {
	rs := make([]Project, 0, len(projects))
	for _, project := range projects {
		rs = append(rs, *ToProject(&project))
	}

	return rs
}

func ToProject(project *model.Project) *Project {
	if project == nil {
		return nil
	}

	return &Project{
		ID:                  project.ID.String(),
		CreatedAt:           project.CreatedAt,
		UpdatedAt:           project.UpdatedAt,
		Name:                project.Name,
		CountryID:           project.CountryID.String(),
		Type:                project.Type.String(),
		StartDate:           project.StartDate,
		EndDate:             project.EndDate,
		Status:              project.Status.String(),
		ProjectEmail:        project.ProjectEmail,
		ClientEmail:         project.ClientEmail,
		Avatar:              project.Avatar,
		AllowsSendingSurvey: project.AllowsSendingSurvey,
		Code:                project.Code,
		Function:            project.Function.String(),
		BankAccountID:       project.BankAccountID.String(),
		CompanyInfoID:       project.CompanyInfoID.String(),
		ClientID:            project.ClientID.String(),
		OrganizationID:      project.OrganizationID.String(),
		AccountRating:       project.AccountRating,
		DeliveryRating:      project.DeliveryRating,
		LeadRating:          project.LeadRating,
		ImportantLevel:      project.ImportantLevel.String(),
		ProjectNotion:       ToProjectNotion(project.ProjectNotion),
		Organization:        ToOrganization(project.Organization),
		BankAccount:         ToBankAccount(project.BankAccount),
		Country:             ToCountry(project.Country),
		Client:              ToClient(project.Client),
		CompanyInfo:         ToCompanyInfo(project.CompanyInfo),
		Slots:               ToProjectSlotList(project.Slots),
		Heads:               ToProjectHeads(project.Heads),
		ProjectMembers:      ToProjectMembers(project.ProjectMembers),
		ProjectStacks:       ToProjectStacks(project.ProjectStacks),
		CommissionConfigs:   ToProjectCommissionConfigs(project.CommissionConfigs),
		ProjectInfo:         ToProjectInfo(project.ProjectInfo),
	}
}

type ProjectInfo struct {
	ID                     string     `json:"id"`
	CreatedAt              time.Time  `json:"createdAt"`
	UpdatedAt              *time.Time `json:"updatedAt"`
	ProjectID              *string    `json:"projectID"`
	BasecampBucketID       int64      `json:"basecampBucketID"`
	BasecampScheduleID     int64      `json:"basecampScheduleID"`
	BasecampCampfireID     int64      `json:"basecampCampfireID"`
	BasecampTodolistID     int64      `json:"basecampTodolistID"`
	BasecampMessageBoardID int64      `json:"basecampMessageBoardID"`
	BasecampSentryID       int64      `json:"basecampSentryID"`
	GitlabID               int64      `json:"gitlabID"`
	Repositories           []byte     `json:"repositories"`
	Project                *Project   `json:"project"`
} // @name ProjectInfo

func ToProjectInfo(projectInfo *model.ProjectInfo) *ProjectInfo {
	if projectInfo == nil {
		return nil
	}

	var projectID *string
	if projectInfo.ProjectID != nil {
		id := projectInfo.ProjectID.String()
		projectID = &id
	}

	return &ProjectInfo{
		ID:                     projectInfo.ID.String(),
		CreatedAt:              projectInfo.CreatedAt,
		UpdatedAt:              projectInfo.UpdatedAt,
		ProjectID:              projectID,
		BasecampBucketID:       projectInfo.BasecampBucketID,
		BasecampScheduleID:     projectInfo.BasecampScheduleID,
		BasecampCampfireID:     projectInfo.BasecampCampfireID,
		BasecampTodolistID:     projectInfo.BasecampTodolistID,
		BasecampMessageBoardID: projectInfo.BasecampMessageBoardID,
		BasecampSentryID:       projectInfo.BasecampSentryID,
		GitlabID:               projectInfo.GitlabID,
		Repositories:           projectInfo.Repositories,
		Project:                ToProject(projectInfo.Project),
	}
}

type ProjectCommissionConfigs []ProjectCommissionConfig // @name ProjectCommissionConfigs

func ToProjectCommissionConfigs(configs []model.ProjectCommissionConfig) ProjectCommissionConfigs {
	rs := make(ProjectCommissionConfigs, 0, len(configs))
	for _, config := range configs {
		rs = append(rs, ToProjectCommissionConfig(&config))
	}

	return rs
}

type ProjectCommissionConfig struct {
	ID             string          `json:"id"`
	CreatedAt      time.Time       `json:"createdAt"`
	UpdatedAt      *time.Time      `json:"updatedAt"`
	ProjectID      string          `json:"projectID"`
	Position       string          `json:"position"`
	CommissionRate decimal.Decimal `json:"commissionRate"`
} // @name ProjectCommissionConfig

func ToProjectCommissionConfig(config *model.ProjectCommissionConfig) ProjectCommissionConfig {
	if config == nil {
		return ProjectCommissionConfig{}
	}

	return ProjectCommissionConfig{
		ID:             config.ID.String(),
		CreatedAt:      config.CreatedAt,
		UpdatedAt:      config.UpdatedAt,
		ProjectID:      config.ProjectID.String(),
		Position:       config.Position.String(),
		CommissionRate: config.CommissionRate,
	}
}

type ProjectNotion struct {
	ID            string     `json:"id"`
	CreatedAt     time.Time  `json:"createdAt"`
	UpdatedAt     *time.Time `json:"updatedAt"`
	ProjectID     string     `json:"projectID"`
	AuditNotionID string     `json:"auditNotionID"`
	Project       *Project   `json:"project"`
} // @name ProjectNotion

func ToProjectNotion(p *model.ProjectNotion) *ProjectNotion {
	if p == nil {
		return nil
	}

	return &ProjectNotion{
		ID:            p.ID.String(),
		CreatedAt:     p.CreatedAt,
		UpdatedAt:     p.UpdatedAt,
		ProjectID:     p.ProjectID.String(),
		AuditNotionID: p.AuditNotionID.String(),
		Project:       ToProject(p.Project),
	}
}

type ProjectSlot struct {
	ID                   string          `json:"id"`
	CreatedAt            time.Time       `json:"createdAt"`
	UpdatedAt            *time.Time      `json:"updatedAt"`
	ProjectID            string          `json:"projectID"`
	SeniorityID          string          `json:"seniorityID"`
	UpsellPersonID       string          `json:"upsellPersonID"`
	DeploymentType       string          `json:"deploymentType"`
	Status               string          `json:"status"`
	Rate                 decimal.Decimal `json:"rate"`
	Discount             decimal.Decimal `json:"discount"`
	Note                 string          `json:"note"`
	Seniority            Seniority       `json:"seniority"`
	Project              Project         `json:"project"`
	ProjectMember        ProjectMember   `json:"projectMember"`
	ProjectSlotPositions []Position      `json:"projectSlotPositions"`
	UpsellPerson         *EmployeeData   `json:"upsellPerson"`
} // @name ProjectSlot

func ToProjectSlot(slot *model.ProjectSlot) *ProjectSlot {
	if slot == nil {
		return nil
	}

	project := ToProject(&slot.Project)
	if project == nil {
		// make sure project is not nil
		project = &Project{}
	}

	projectMember := ToProjectMember(&slot.ProjectMember)
	if projectMember == nil {
		// make sure project member is not nil
		projectMember = &ProjectMember{}
	}

	return &ProjectSlot{
		ID:                   slot.ID.String(),
		CreatedAt:            slot.CreatedAt,
		UpdatedAt:            slot.UpdatedAt,
		ProjectID:            slot.ProjectID.String(),
		SeniorityID:          slot.SeniorityID.String(),
		UpsellPersonID:       slot.UpsellPersonID.String(),
		DeploymentType:       slot.DeploymentType.String(),
		Status:               slot.Status.String(),
		Rate:                 slot.Rate,
		Discount:             slot.Discount,
		Note:                 slot.Note,
		Seniority:            ToSeniority(slot.Seniority),
		Project:              *project,
		ProjectMember:        *projectMember,
		ProjectSlotPositions: ToProjectSlotPositions(slot.ProjectSlotPositions),
		UpsellPerson:         ToEmployeeData(slot.UpsellPerson),
	}
}

func ToProjectSlotList(slots []model.ProjectSlot) []ProjectSlot {
	rs := make([]ProjectSlot, 0, len(slots))
	for _, slot := range slots {
		projectSlot := ToProjectSlot(&slot)
		if projectSlot != nil {
			rs = append(rs, *projectSlot)
		}
	}

	return rs
}

type ProjectData struct {
	ID        string     `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`

	Name                string                `json:"name"`
	Avatar              string                `json:"avatar"`
	Type                string                `json:"type"`
	Status              string                `json:"status"`
	ProjectEmail        string                `json:"projectEmail"`
	ClientEmail         []string              `json:"clientEmail"`
	Industry            string                `json:"industry"`
	AllowsSendingSurvey bool                  `json:"allowsSendingSurvey"`
	Country             *BasicCountryInfo     `json:"country"`
	StartDate           *time.Time            `json:"startDate"`
	EndDate             *time.Time            `json:"endDate"`
	Members             []ProjectMember       `json:"members"`
	TechnicalLead       []ProjectHead         `json:"technicalLeads"`
	AccountManagers     []ProjectHead         `json:"accountManagers"`
	DeliveryManagers    []ProjectHead         `json:"deliveryManagers"`
	SalePersons         []ProjectHead         `json:"salePersons"`
	Stacks              []Stack               `json:"stacks"`
	Code                string                `json:"code"`
	Function            string                `json:"function"`
	AuditNotionID       string                `json:"auditNotionID"`
	AccountRating       int                   `json:"accountRating"`
	DeliveryRating      int                   `json:"deliveryRating"`
	LeadRating          int                   `json:"leadRating"`
	ImportantLevel      string                `json:"importantLevel"`
	BankAccount         *BasicBankAccountInfo `json:"bankAccount"`
	Client              *BasicClientInfo      `json:"client"`
	CompanyInfo         *BasicCompanyInfo     `json:"companyInfo"`
	Organization        *Organization         `json:"organization"`
	MonthlyChargeRate   decimal.Decimal       `json:"monthlyChargeRate"`
	Currency            *Currency             `json:"currency"`
} // @name ProjectData

type BasicClientInfo struct {
	ID                 string          `json:"id"`
	Name               string          `json:"name"`
	Description        string          `json:"description"`
	RegistrationNumber string          `json:"registrationNumber"`
	Address            string          `json:"address"`
	Country            string          `json:"country"`
	Contacts           []ClientContact `json:"contacts"`
} // @name BasicClientInfo

func ToBasicClientInfo(client *model.Client) *BasicClientInfo {
	if client == nil {
		return nil
	}

	//clientContacts := make([]ClientContact, 0, len(client.Contacts))
	//for _, contact := range client.Contacts {
	//	emails := make([]string, 0)
	//	_ = json.Unmarshal(contact.Emails, &emails)
	//
	//	clientContacts = append(clientContacts, ClientContact{
	//		ID:     contact.ID.String(),
	//		Name:   contact.Name,
	//		Role:   contact.Role,
	//		Emails: emails,
	//	})
	//}

	return &BasicClientInfo{
		ID:   client.ID.String(),
		Name: client.Name,
		//Description:        client.Description,
		//RegistrationNumber: client.RegistrationNumber,
		Address: client.Address,
		Country: client.Country,
		//Contacts:           clientContacts,
	}
}

type BasicCompanyInfo struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	//Description        string `json:"description"`
	//RegistrationNumber string `json:"registrationNumber"`
} // @name BasicCompanyInfo

func ToBasicCompanyInfo(company *model.CompanyInfo) *BasicCompanyInfo {
	return &BasicCompanyInfo{
		ID:   company.ID.String(),
		Name: company.Name,
		//Description:        company.Description,
		//RegistrationNumber: company.RegistrationNumber,
	}
}

type UpdatedProject struct {
	ID        string     `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`

	Name      string     `json:"name"`
	Type      string     `json:"type"`
	Status    string     `json:"status"`
	StartDate *time.Time `json:"startDate"`
	EndDate   *time.Time `json:"endDate"`
} // @name UpdatedProject

type ProjectMember struct {
	ProjectMemberID      string          `json:"projectMemberID"`
	ProjectSlotID        string          `json:"projectSlotID"`
	EmployeeID           string          `json:"employeeID"`
	FullName             string          `json:"fullName"`
	DisplayName          string          `json:"displayName"`
	Avatar               string          `json:"avatar"`
	Username             string          `json:"username"`
	Status               string          `json:"status"`
	IsLead               bool            `json:"isLead"`
	DeploymentType       string          `json:"deploymentType"`
	StartDate            *time.Time      `json:"startDate"`
	EndDate              *time.Time      `json:"endDate"`
	Rate                 decimal.Decimal `json:"rate"`
	Discount             decimal.Decimal `json:"discount"`
	UpsellCommissionRate decimal.Decimal `json:"upsellCommissionRate"`
	LeadCommissionRate   decimal.Decimal `json:"leadCommissionRate"`
	Currency             *Currency       `json:"currency"`
	Note                 string          `json:"note"`

	Seniority    *Seniority         `json:"seniority"`
	Positions    []Position         `json:"positions"`
	UpsellPerson *BasicEmployeeInfo `json:"upsellPerson"`
} // @name ProjectMember

func ToProjectMembers(members []model.ProjectMember) []ProjectMember {
	res := make([]ProjectMember, 0, len(members))
	for _, m := range members {
		res = append(res, *ToProjectMember(&m))
	}

	return res
}

func ToProjectMember(member *model.ProjectMember) *ProjectMember {
	var seniority *Seniority
	if member.Seniority != nil {
		s := ToSeniority(*member.Seniority)
		seniority = &s
	}

	return &ProjectMember{
		ProjectMemberID:      member.ID.String(),
		ProjectSlotID:        member.ProjectSlotID.String(),
		EmployeeID:           member.EmployeeID.String(),
		FullName:             member.Employee.FullName,
		DisplayName:          member.Employee.DisplayName,
		Avatar:               member.Employee.Avatar,
		Username:             member.Employee.Username,
		Status:               member.Status.String(),
		IsLead:               member.IsLead,
		DeploymentType:       member.DeploymentType.String(),
		StartDate:            member.StartDate,
		EndDate:              member.EndDate,
		Rate:                 member.Rate,
		Discount:             member.Discount,
		UpsellCommissionRate: member.UpsellCommissionRate,
		Note:                 member.Note,
		Seniority:            seniority,
		Positions:            ToProjectMemberPositions(member.ProjectMemberPositions),
		UpsellPerson:         toBasicEmployeeInfo(*member.UpsellPerson),
	}
}

type ProjectHead struct {
	EmployeeID          string          `json:"employeeID"`
	FullName            string          `json:"fullName"`
	DisplayName         string          `json:"displayName"`
	Avatar              string          `json:"avatar"`
	Username            string          `json:"username"`
	CommissionRate      decimal.Decimal `json:"commissionRate"`
	FinalCommissionRate decimal.Decimal `json:"finalCommissionRate"`
} // @name ProjectHead

func ToProjectHeads(heads []*model.ProjectHead) []*ProjectHead {
	res := make([]*ProjectHead, 0, len(heads))
	for _, h := range heads {
		ph := ToProjectHead(nil, h, nil)
		res = append(res, &ph)
	}

	return res
}

func ToProjectHead(userInfo *model.CurrentLoggedUserInfo, head *model.ProjectHead, commissionConfig map[string]decimal.Decimal) ProjectHead {
	res := ProjectHead{
		EmployeeID:  head.EmployeeID.String(),
		FullName:    head.Employee.FullName,
		DisplayName: head.Employee.DisplayName,
		Avatar:      head.Employee.Avatar,
		Username:    head.Employee.Username,
	}

	if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateRead) {
		res.CommissionRate = head.CommissionRate
		rate := decimal.Zero
		v, ok := commissionConfig[head.Position.String()]
		if ok {
			rate = v.Mul(head.CommissionRate).Div(decimal.NewFromInt(100))
		}
		res.FinalCommissionRate = rate
	}

	return res
}

type UpdateProjectStatusResponse struct {
	Data UpdatedProject `json:"data"`
} // @name UpdateProjectStatusResponse

func ToUpdateProjectStatusResponse(p *model.Project) UpdatedProject {
	return UpdatedProject{
		ID:        p.ID.String(),
		CreatedAt: p.CreatedAt,
		UpdatedAt: p.UpdatedAt,

		Name:      p.Name,
		Type:      p.Type.String(),
		Status:    p.Status.String(),
		StartDate: p.StartDate,
		EndDate:   p.EndDate,
	}
}

func ToProjectData(in *model.Project, userInfo *model.CurrentLoggedUserInfo) ProjectData {
	leadMap := map[string]bool{}
	var technicalLeads = make([]ProjectHead, 0, len(in.Heads))
	var accountManagers, salePersons, deliveryManagers []ProjectHead
	commissionConfig := in.CommissionConfigs.ToMap()
	for _, h := range in.Heads {
		head := ToProjectHead(userInfo, h, commissionConfig)

		switch h.Position {
		case model.HeadPositionTechnicalLead:
			leadMap[h.EmployeeID.String()] = true
			technicalLeads = append(technicalLeads, head)
		case model.HeadPositionAccountManager:
			accountManagers = append(accountManagers, head)
		case model.HeadPositionDeliveryManager:
			deliveryManagers = append(deliveryManagers, head)
		case model.HeadPositionSalePerson:
			salePersons = append(salePersons, head)
		}
	}

	var projectCurrency *Currency
	if in.BankAccount != nil {
		projectCurrency = toCurrency(in.BankAccount.Currency)
	}

	monthlyRevenue := decimal.Zero
	var members = make([]ProjectMember, 0, len(in.ProjectMembers))
	for _, m := range in.ProjectMembers {
		var seniority *Seniority
		if m.Seniority != nil {
			s := ToSeniority(*m.Seniority)
			seniority = &s
		}

		member := ProjectMember{
			Status:      m.Status.String(),
			EmployeeID:  m.EmployeeID.String(),
			FullName:    m.Employee.FullName,
			DisplayName: m.Employee.DisplayName,
			Avatar:      m.Employee.Avatar,
			Username:    m.Employee.Username,
			Seniority:   seniority,
			IsLead:      leadMap[m.EmployeeID.String()],
			Positions:   ToProjectMemberPositions(m.ProjectMemberPositions),
		}

		if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadFullAccess) {
			member.DeploymentType = m.DeploymentType.String()

			if m.UpsellPerson != nil {
				member.UpsellPerson = toBasicEmployeeInfo(*m.UpsellPerson)
			}

			member.Rate = m.Rate
			member.Currency = projectCurrency
		}

		if m.DeploymentType == model.MemberDeploymentTypeOfficial && m.Status == model.ProjectMemberStatusActive {
			monthlyRevenue = monthlyRevenue.Add(m.Rate)
		}

		members = append(members, member)
	}

	projectData := ProjectData{
		ID:                  in.ID.String(),
		CreatedAt:           in.CreatedAt,
		UpdatedAt:           in.UpdatedAt,
		Avatar:              in.Avatar,
		Name:                in.Name,
		Type:                in.Type.String(),
		Status:              in.Status.String(),
		Stacks:              ToProjectStacks(in.ProjectStacks),
		StartDate:           in.StartDate,
		EndDate:             in.EndDate,
		Members:             members,
		TechnicalLead:       technicalLeads,
		DeliveryManagers:    deliveryManagers,
		AccountManagers:     accountManagers,
		SalePersons:         salePersons,
		ProjectEmail:        in.ProjectEmail,
		AllowsSendingSurvey: in.AllowsSendingSurvey,
		Code:                in.Code,
		Function:            in.Function.String(),
		Currency:            projectCurrency,
	}

	var clientEmail []string
	if in.ClientEmail != "" {
		clientEmail = strings.Split(in.ClientEmail, ",")
	}

	if in.Organization != nil {
		projectData.Organization = &Organization{
			ID:     in.Organization.ID.String(),
			Code:   in.Organization.Code,
			Name:   in.Organization.Name,
			Avatar: in.Organization.Avatar,
		}
	}

	if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadMonthlyRevenue) {
		projectData.MonthlyChargeRate = monthlyRevenue
	}

	if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadFullAccess) {
		if in.ProjectNotion != nil && !in.ProjectNotion.AuditNotionID.IsZero() {
			projectData.AuditNotionID = in.ProjectNotion.AuditNotionID.String()
		}

		projectData.ClientEmail = clientEmail

		if in.BankAccount != nil {
			projectData.BankAccount = &BasicBankAccountInfo{
				ID:       in.BankAccount.ID.String(),
				BankName: in.BankAccount.BankName,
			}
		}

		if in.Client != nil {
			projectData.Client = ToBasicClientInfo(in.Client)
		}

		if in.CompanyInfo != nil {
			projectData.CompanyInfo = ToBasicCompanyInfo(in.CompanyInfo)
		}

		projectData.AccountRating = in.AccountRating
		projectData.DeliveryRating = in.DeliveryRating
		projectData.LeadRating = in.LeadRating
		projectData.ImportantLevel = in.ImportantLevel.String()
	}

	if in.Country != nil {
		projectData.Country = &BasicCountryInfo{
			ID:   UUID(in.Country.ID),
			Name: in.Country.Name,
			Code: in.Country.Code,
		}
	}

	return projectData
}

func ToProjectsData(projects []*model.Project, userInfo *model.CurrentLoggedUserInfo) []ProjectData {
	var results = make([]ProjectData, 0, len(projects))

	for _, p := range projects {
		// If the project belongs user, append it in the list
		_, ok := userInfo.Projects[p.ID]
		if ok && p.Status == model.ProjectStatusActive && model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) {
			results = append(results, ToProjectData(p, userInfo))
			continue
		}

		// If the project is not belong user, check if the user has permission to view the project
		if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadFullAccess) ||
			(authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadReadActive) &&
				p.Status == model.ProjectStatusActive) {
			results = append(results, ToProjectData(p, userInfo))
			continue
		}
	}

	return results
}

type ProjectListDataResponse struct {
	PaginationResponse
	Data []ProjectData `json:"data"`
} // @name ProjectListDataResponse

type ProjectDataResponse struct {
	Data ProjectData `json:"data"`
} // @name ProjectDataResponse

type CreateMemberData struct {
	ProjectSlotID        string             `json:"projectSlotID"`
	ProjectMemberID      string             `json:"projectMemberID"`
	EmployeeID           string             `json:"employeeID"`
	FullName             string             `json:"fullName"`
	DisplayName          string             `json:"displayName"`
	Avatar               string             `json:"avatar"`
	Positions            []Position         `json:"positions"`
	DeploymentType       string             `json:"deploymentType"`
	Status               string             `json:"status"`
	IsLead               bool               `json:"isLead"`
	Seniority            Seniority          `json:"seniority"`
	Username             string             `json:"username"`
	Rate                 decimal.Decimal    `json:"rate"`
	Discount             decimal.Decimal    `json:"discount"`
	UpsellPerson         *BasicEmployeeInfo `json:"upsellPerson"`
	UpsellCommissionRate decimal.Decimal    `json:"upsellCommissionRate"`
	LeadCommissionRate   decimal.Decimal    `json:"leadCommissionRate"`
	Note                 string             `json:"note"`
} // @name CreateMemberData

type CreateMemberDataResponse struct {
	Data CreateMemberData `json:"data"`
} // @name CreateMemberDataResponse

func ToCreateMemberData(userInfo *model.CurrentLoggedUserInfo, slot *model.ProjectSlot) CreateMemberData {
	rs := CreateMemberData{
		ProjectSlotID:  slot.ID.String(),
		FullName:       slot.ProjectMember.Employee.FullName,
		DisplayName:    slot.ProjectMember.Employee.DisplayName,
		Avatar:         slot.ProjectMember.Employee.Avatar,
		Username:       slot.ProjectMember.Employee.Username,
		DeploymentType: slot.DeploymentType.String(),
		Status:         slot.Status.String(),
		Positions:      ToProjectSlotPositions(slot.ProjectSlotPositions),
		IsLead:         slot.ProjectMember.IsLead,
		Seniority:      ToSeniority(slot.Seniority),
		Note:           slot.Note,
	}

	if !slot.ProjectMember.ID.IsZero() {
		rs.ProjectMemberID = slot.ProjectMember.ID.String()
		rs.EmployeeID = slot.ProjectMember.EmployeeID.String()
		rs.Note = slot.ProjectMember.Note

		if slot.ProjectMember.UpsellPerson != nil {
			rs.UpsellPerson = toBasicEmployeeInfo(*slot.ProjectMember.UpsellPerson)
		}
	}

	if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateRead) {
		rs.UpsellCommissionRate = slot.ProjectMember.UpsellCommissionRate
	}

	if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateRead) {
		rs.Rate = slot.Rate
		rs.Discount = slot.Discount

		if !slot.ProjectMember.ID.IsZero() {
			rs.Rate = slot.ProjectMember.Rate
			rs.Discount = slot.ProjectMember.Discount
		}
	}

	return rs
}

type CreateProjectRestponse struct {
	ID        UUID       `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`

	Name             string                `json:"name"`
	Type             string                `json:"type"`
	Status           string                `json:"status"`
	StartDate        string                `json:"startDate"`
	AccountManagers  []ProjectHead         `json:"accountManagers"`
	DeliveryManagers []ProjectHead         `json:"deliveryManagers"`
	SalePersons      []ProjectHead         `json:"salePersons"`
	Members          []CreateMemberData    `json:"members"`
	ClientEmail      []string              `json:"clientEmail"`
	ProjectEmail     string                `json:"projectEmail"`
	Country          *BasicCountryInfo     `json:"country"`
	Code             string                `json:"code"`
	Function         string                `json:"function"`
	BankAccount      *BasicBankAccountInfo `json:"bankAccount"`
	Client           *Client               `json:"client"`
	Organization     *Organization         `json:"organization"`
} // @name CreateProjectRestponse

type BasicBankAccountInfo struct {
	ID            string `json:"id"`
	AccountNumber string `json:"accountNumber"`
	BankName      string `json:"bankName"`
	OwnerName     string `json:"ownerName"`
} // @name BasicBankAccountInfo

func ToCreateProjectDataResponse(userInfo *model.CurrentLoggedUserInfo, project *model.Project) CreateProjectRestponse {
	var clientEmail []string
	if project.ClientEmail != "" {
		clientEmail = strings.Split(project.ClientEmail, ",")
	}

	result := CreateProjectRestponse{
		ID:           UUID(project.ID),
		CreatedAt:    project.CreatedAt,
		UpdatedAt:    project.UpdatedAt,
		Name:         project.Name,
		Type:         project.Type.String(),
		Status:       project.Status.String(),
		ClientEmail:  clientEmail,
		ProjectEmail: project.ProjectEmail,
		Code:         project.Code,
		Function:     project.Function.String(),
	}

	if project.Country != nil {
		result.Country = &BasicCountryInfo{
			ID:   UUID(project.Country.ID),
			Name: project.Country.Name,
			Code: project.Country.Code,
		}
	}

	if project.BankAccount != nil {
		result.BankAccount = &BasicBankAccountInfo{
			ID:            project.BankAccount.ID.String(),
			AccountNumber: project.BankAccount.AccountNumber,
			BankName:      project.BankAccount.BankName,
			OwnerName:     project.BankAccount.OwnerName,
		}
	}

	if project.Organization != nil {
		result.Organization = &Organization{
			ID:     project.Organization.ID.String(),
			Code:   project.Organization.Code,
			Name:   project.Organization.Name,
			Avatar: project.Organization.Avatar,
		}
	}

	if project.Client != nil {
		result.Client = ToClient(project.Client)
	}

	if project.StartDate != nil {
		result.StartDate = project.StartDate.Format("2006-01-02")
	}

	commisionRate := project.CommissionConfigs.ToMap()

	for _, head := range project.Heads {
		switch head.Position {
		case model.HeadPositionAccountManager:
			result.AccountManagers = append(result.AccountManagers, ToProjectHead(userInfo, head, commisionRate))
		case model.HeadPositionDeliveryManager:
			result.DeliveryManagers = append(result.DeliveryManagers, ToProjectHead(userInfo, head, commisionRate))
		case model.HeadPositionSalePerson:
			result.SalePersons = append(result.SalePersons, ToProjectHead(userInfo, head, commisionRate))
		}
	}

	result.Members = make([]CreateMemberData, 0, len(project.Slots))
	for _, slot := range project.Slots {
		result.Members = append(result.Members, ToCreateMemberData(userInfo, &slot))
	}

	return result
}

func ToProjectMemberListData(userInfo *model.CurrentLoggedUserInfo, members []*model.ProjectMember, projectHeads []*model.ProjectHead, project *model.Project, distinct bool) []ProjectMember {
	var results = make([]ProjectMember, 0, len(members))

	leadMap := map[string]*model.ProjectHead{}
	for _, v := range projectHeads {
		if v.IsLead() {
			leadMap[v.EmployeeID.String()] = v
		}
	}

	for _, m := range members {
		var member ProjectMember
		var seniority *Seniority
		if m.Seniority != nil {
			s := ToSeniority(*m.Seniority)
			seniority = &s
		}

		if m.ID.IsZero() {
			member = ProjectMember{
				ProjectSlotID:  m.ProjectSlotID.String(),
				Status:         m.Status.String(),
				DeploymentType: m.DeploymentType.String(),
				Seniority:      seniority,
				Note:           m.Note,
				Positions:      ToPositions(m.Positions),
			}
		} else {
			member = ProjectMember{
				ProjectSlotID:   m.ProjectSlotID.String(),
				ProjectMemberID: m.ID.String(),
				EmployeeID:      m.EmployeeID.String(),
				FullName:        m.Employee.FullName,
				DisplayName:     m.Employee.DisplayName,
				Avatar:          m.Employee.Avatar,
				Username:        m.Employee.Username,
				StartDate:       m.StartDate,
				EndDate:         m.EndDate,
				IsLead:          leadMap[m.EmployeeID.String()] != nil,
				Status:          m.Status.String(),
				DeploymentType:  m.DeploymentType.String(),
				Seniority:       seniority,
				Note:            m.Note,
				Positions:       ToProjectMemberPositions(m.ProjectMemberPositions),
			}
		}

		if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadFullAccess) &&
			project.BankAccount != nil &&
			project.BankAccount.Currency != nil {
			member.Currency = toCurrency(project.BankAccount.Currency)

			if m.UpsellPerson != nil {
				member.UpsellPerson = toBasicEmployeeInfo(*m.UpsellPerson)
			}
		}

		// add commission rate
		if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateRead) {
			if leadMap[m.EmployeeID.String()] != nil {
				member.LeadCommissionRate = leadMap[m.EmployeeID.String()].CommissionRate
			}

			member.UpsellCommissionRate = m.UpsellCommissionRate
		}

		if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateRead) {
			member.Rate = m.Rate
			member.Discount = m.Discount
		}

		results = append(results, member)
	}

	// Remove duplicate members
	if distinct {
		uniqueResults := make([]ProjectMember, 0, len(results))
		uniqueMap := map[string]bool{}
		for _, v := range results {
			if _, ok := uniqueMap[v.EmployeeID]; !ok {
				uniqueMap[v.EmployeeID] = true
				uniqueResults = append(uniqueResults, v)
			}
		}

		return uniqueResults
	}

	return results
}

type ProjectMemberListResponse struct {
	PaginationResponse
	Data []ProjectMember `json:"data"`
} // @name ProjectMemberListResponse

type BasicCountryInfo struct {
	ID   UUID   `json:"id"`
	Name string `json:"name"`
	Code string `json:"code"`
} // @name BasicCountryInfo

type UpdateProjectGeneralInfo struct {
	Name          string                `json:"name"`
	StartDate     *time.Time            `json:"startDate"`
	Country       *BasicCountryInfo     `json:"country"`
	Stacks        []Stack               `json:"stacks"`
	Function      ProjectFunction       `json:"function"`
	AuditNotionID string                `json:"auditNotionID"`
	BankAccount   *BasicBankAccountInfo `json:"bankAccount"`
	Client        *Client               `json:"client"`
	Organization  *Organization         `json:"organization"`
} // @name UpdateProjectGeneralInfo

type ProjectFunction string // @name ProjectFunction

const (
	ProjectFunctionDevelopment ProjectFunction = "development"
	ProjectFunctionLearning    ProjectFunction = "learning"
	ProjectFunctionTraining    ProjectFunction = "training"
	ProjectFunctionManagement  ProjectFunction = "management"
)

func (e ProjectFunction) IsValid() bool {
	switch e {
	case
		ProjectFunctionDevelopment,
		ProjectFunctionLearning,
		ProjectFunctionTraining,
		ProjectFunctionManagement:
		return true
	}
	return false
}

func (e ProjectFunction) String() string {
	return string(e)
}

type UpdateProjectGeneralInfoResponse struct {
	Data UpdateProjectGeneralInfo `json:"data"`
} // @name UpdateProjectGeneralInfoResponse

func ToUpdateProjectGeneralInfo(project *model.Project) UpdateProjectGeneralInfo {
	stacks := make([]Stack, 0, len(project.ProjectStacks))
	for _, v := range project.ProjectStacks {
		s := Stack{
			ID:     v.Stack.ID.String(),
			Name:   v.Stack.Name,
			Code:   v.Stack.Code,
			Avatar: v.Stack.Avatar,
		}
		stacks = append(stacks, s)
	}

	rs := UpdateProjectGeneralInfo{
		Name:      project.Name,
		StartDate: project.StartDate,
		Stacks:    stacks,
		Function:  ProjectFunction(project.Function),
	}

	if project.ProjectNotion != nil && !project.ProjectNotion.AuditNotionID.IsZero() {
		rs.AuditNotionID = project.ProjectNotion.AuditNotionID.String()
	}

	if project.Country != nil {
		rs.Country = &BasicCountryInfo{
			ID:   UUID(project.Country.ID),
			Name: project.Country.Name,
			Code: project.Country.Code,
		}
	}

	if project.BankAccount != nil {
		rs.BankAccount = &BasicBankAccountInfo{
			ID:            project.BankAccount.ID.String(),
			AccountNumber: project.BankAccount.AccountNumber,
			BankName:      project.BankAccount.BankName,
			OwnerName:     project.BankAccount.OwnerName,
		}
	}

	if project.Organization != nil {
		rs.Organization = &Organization{
			ID:     project.Organization.ID.String(),
			Code:   project.Organization.Code,
			Name:   project.Organization.Name,
			Avatar: project.Organization.Avatar,
		}
	}

	if project.Client != nil {
		rs.Client = ToClient(project.Client)
	}

	return rs
}

type WorkUnitType string // @name WorkUnitType

const (
	WorkUnitTypeDevelopment WorkUnitType = "development"
	WorkUnitTypeManagement  WorkUnitType = "management"
	WorkUnitTypeTraining    WorkUnitType = "training"
	WorkUnitTypeLearning    WorkUnitType = "learning"
)

func (e WorkUnitType) IsValid() bool {
	switch e {
	case
		WorkUnitTypeDevelopment,
		WorkUnitTypeManagement,
		WorkUnitTypeTraining,
		WorkUnitTypeLearning:
		return true
	}
	return false
}

func (e WorkUnitType) String() string {
	return string(e)
}

type BasicProjectHeadInfo struct {
	EmployeeID     string          `json:"employeeID"`
	FullName       string          `json:"fullName"`
	DisplayName    string          `json:"displayName"`
	Avatar         string          `json:"avatar"`
	Position       HeadPosition    `json:"position"`
	Username       string          `json:"username"`
	CommissionRate decimal.Decimal `json:"commissionRate"`
} // @name BasicProjectHeadInfo

type HeadPosition string // @name HeadPosition

type UpdateProjectContactInfo struct {
	ClientEmail  []string               `json:"clientEmail"`
	ProjectEmail string                 `json:"projectEmail"`
	ProjectHead  []BasicProjectHeadInfo `json:"projectHead"`
} // @name UpdateProjectContactInfo

type UpdateProjectContactInfoResponse struct {
	Data UpdateProjectContactInfo `json:"data"`
} // @name UpdateProjectContactInfoResponse

func ToUpdateProjectContactInfo(project *model.Project, userInfo *model.CurrentLoggedUserInfo) UpdateProjectContactInfo {
	projectHeads := make([]BasicProjectHeadInfo, 0, len(project.Heads))
	for _, v := range project.Heads {
		ph := BasicProjectHeadInfo{
			EmployeeID:  v.Employee.ID.String(),
			FullName:    v.Employee.FullName,
			Avatar:      v.Employee.Avatar,
			DisplayName: v.Employee.DisplayName,
			Position:    HeadPosition(v.Position),
			Username:    v.Employee.Username,
		}

		if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateRead) {
			ph.CommissionRate = v.CommissionRate
		}

		projectHeads = append(projectHeads, ph)
	}

	var clientEmail []string
	if project.ClientEmail != "" {
		clientEmail = strings.Split(project.ClientEmail, ",")
	}

	return UpdateProjectContactInfo{
		ClientEmail:  clientEmail,
		ProjectEmail: project.ProjectEmail,
		ProjectHead:  projectHeads,
	}
}

type BasicProjectInfo struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Type   string `json:"type"`
	Status string `json:"status"`
	Code   string `json:"code"`
	Avatar string `json:"avatar"`
} // @name BasicProjectInfo

func toBasicProjectInfo(project model.Project) *BasicProjectInfo {
	return &BasicProjectInfo{
		ID:     project.ID.String(),
		Type:   project.Type.String(),
		Name:   project.Name,
		Status: project.Status.String(),
		Code:   project.Code,
		Avatar: project.Avatar,
	}
}

type ProjectContentData struct {
	Url string `json:"url"`
} // @name ProjectContentData

type ProjectContentDataResponse struct {
	Data *ProjectContentData `json:"data"`
} // @name ProjectContentDataResponse

func ToProjectContentData(url string) *ProjectContentData {
	return &ProjectContentData{
		Url: url,
	}
}

```

# pkg/view/profile.go

```go
package view

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type ProfileData struct {
	ID                 string     `json:"id"`
	FullName           string     `json:"fullName"`
	DisplayName        string     `json:"displayName"`
	Avatar             string     `json:"avatar"`
	Gender             string     `json:"gender"`
	DateOfBirth        *time.Time `json:"birthday"`
	TeamEmail          string     `json:"teamEmail"`
	PersonalEmail      string     `json:"personalEmail"`
	PhoneNumber        string     `json:"phoneNumber"`
	GithubID           string     `json:"githubID"`
	NotionID           string     `json:"notionID"`
	NotionName         string     `json:"notionName"`
	NotionEmail        string     `json:"notionEmail"`
	DiscordID          string     `json:"discordID"`
	DiscordName        string     `json:"discordName"`
	Username           string     `json:"username"`
	PlaceOfResidence   string     `json:"placeOfResidence"`
	Address            string     `json:"address"`
	Country            string     `json:"country"`
	City               string     `json:"city"`
	LinkedInName       string     `json:"linkedInName"`
	Roles              []Role     `json:"roles"`
	WiseRecipientID    string     `json:"wiseRecipientID"`
	WiseAccountNumber  string     `json:"wiseAccountNumber"`
	WiseRecipientEmail string     `json:"wiseRecipientEmail"`
	WiseRecipientName  string     `json:"wiseRecipientName"`
	WiseCurrency       string     `json:"wiseCurrency"`
} // @name ProfileData

type UpdateProfileInfoData struct {
	ID        string     `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`

	// basic info
	TeamEmail          string `json:"teamEmail"`
	PhoneNumber        string `json:"phoneNumber"`
	GithubID           string `json:"githubID"`
	NotionID           string `json:"notionID"`
	NotionName         string `json:"notionName"`
	NotionEmail        string `json:"notionEmail"`
	DiscordID          string `json:"discordID"`
	DiscordName        string `json:"discordName"`
	Username           string `json:"username"`
	PlaceOfResidence   string `json:"placeOfResidence"`
	Address            string `json:"address"`
	Country            string `json:"country"`
	City               string `json:"city"`
	LinkedInName       string `json:"linkedInName"`
	WiseRecipientID    string `json:"wiseRecipientID"`
	WiseAccountNumber  string `json:"wiseAccountNumber"`
	WiseRecipientEmail string `json:"wiseRecipientEmail"`
	WiseRecipientName  string `json:"wiseRecipientName"`
	WiseCurrency       string `json:"wiseCurrency"`
} // @name UpdateProfileInfoData

type ProfileDataResponse struct {
	Data ProfileData `json:"data"`
} // @name ProfileDataResponse

type UpdateProfileInfoResponse struct {
	Data UpdateProfileInfoData `json:"data"`
} // @name UpdateProfileInfoResponse

func ToUpdateProfileInfoData(employee *model.Employee) *UpdateProfileInfoData {
	rs := &UpdateProfileInfoData{
		ID:                 employee.ID.String(),
		CreatedAt:          employee.CreatedAt,
		UpdatedAt:          employee.UpdatedAt,
		TeamEmail:          employee.TeamEmail,
		PhoneNumber:        employee.PhoneNumber,
		Username:           employee.Username,
		PlaceOfResidence:   employee.PlaceOfResidence,
		Address:            employee.Address,
		Country:            employee.Country,
		City:               employee.City,
		WiseRecipientID:    employee.WiseRecipientID,
		WiseAccountNumber:  employee.WiseAccountNumber,
		WiseRecipientEmail: employee.WiseRecipientEmail,
		WiseRecipientName:  employee.WiseRecipientName,
		WiseCurrency:       employee.WiseCurrency,
	}

	if len(employee.SocialAccounts) > 0 {
		for _, sa := range employee.SocialAccounts {
			switch sa.Type {
			case model.SocialAccountTypeGitHub:
				rs.GithubID = sa.AccountID
			case model.SocialAccountTypeNotion:
				rs.NotionID = sa.AccountID
				rs.NotionName = sa.Name
			case model.SocialAccountTypeLinkedIn:
				rs.LinkedInName = sa.Name
			}
		}
	}

	if employee.DiscordAccount != nil {
		rs.DiscordID = employee.DiscordAccount.DiscordID
		rs.DiscordName = employee.DiscordAccount.DiscordUsername
	}

	return rs
}

func ToProfileData(employee *model.Employee) *ProfileData {
	empSocialData := SocialAccount{}
	for _, sa := range employee.SocialAccounts {
		switch sa.Type {
		case model.SocialAccountTypeGitHub:
			empSocialData.GithubID = sa.AccountID
		case model.SocialAccountTypeNotion:
			empSocialData.NotionID = sa.AccountID
			empSocialData.NotionName = sa.Name
		case model.SocialAccountTypeLinkedIn:
			empSocialData.LinkedInName = sa.AccountID
		}
	}

	rs := &ProfileData{
		ID:                 employee.ID.String(),
		FullName:           employee.FullName,
		DisplayName:        employee.DisplayName,
		Avatar:             employee.Avatar,
		Gender:             employee.Gender,
		DateOfBirth:        employee.DateOfBirth,
		TeamEmail:          employee.TeamEmail,
		PersonalEmail:      employee.PersonalEmail,
		PhoneNumber:        employee.PhoneNumber,
		Username:           employee.Username,
		PlaceOfResidence:   employee.PlaceOfResidence,
		Address:            employee.Address,
		Country:            employee.Country,
		City:               employee.City,
		WiseRecipientID:    employee.WiseRecipientID,
		WiseAccountNumber:  employee.WiseAccountNumber,
		WiseRecipientEmail: employee.WiseRecipientEmail,
		WiseRecipientName:  employee.WiseRecipientName,
		WiseCurrency:       employee.WiseCurrency,
		GithubID:           empSocialData.GithubID,
		NotionID:           empSocialData.NotionID,
		NotionName:         empSocialData.NotionName,
		NotionEmail:        empSocialData.NotionEmail,
		LinkedInName:       empSocialData.LinkedInName,
		Roles:              ToEmployeeRoles(employee.EmployeeRoles),
	}

	if employee.DiscordAccount != nil {
		rs.DiscordID = employee.DiscordAccount.DiscordID
		rs.DiscordName = employee.DiscordAccount.DiscordUsername
	}

	return rs
}

```

# pkg/view/position.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type Position struct {
	ID   string `json:"id"`
	Code string `json:"code"`
	Name string `json:"name"`
} // @name Position

func ToPosition(pos *model.Position) *Position {
	if pos == nil {
		return nil
	}

	return &Position{
		ID:   pos.ID.String(),
		Code: pos.Code,
		Name: pos.Name,
	}
}

func ToPositions(pos []model.Position) []Position {
	rs := make([]Position, 0, len(pos))
	for _, p := range pos {
		r := Position{
			ID:   p.ID.String(),
			Code: p.Code,
			Name: p.Name,
		}
		rs = append(rs, r)
	}

	return rs
}

func ToEmployeePositions(pos []model.EmployeePosition) []Position {
	rs := make([]Position, 0, len(pos))
	for _, v := range pos {
		r := Position{
			ID:   v.Position.ID.String(),
			Code: v.Position.Code,
			Name: v.Position.Name,
		}
		rs = append(rs, r)
	}

	return rs
}

func ToProjectSlotPositions(pos []model.ProjectSlotPosition) []Position {
	rs := make([]Position, 0, len(pos))
	for _, v := range pos {
		r := Position{
			ID:   v.Position.ID.String(),
			Code: v.Position.Code,
			Name: v.Position.Name,
		}
		rs = append(rs, r)
	}

	return rs
}

func ToProjectMemberPositions(pos []model.ProjectMemberPosition) []Position {
	rs := make([]Position, 0, len(pos))
	for _, v := range pos {
		r := Position{
			ID:   v.Position.ID.String(),
			Code: v.Position.Code,
			Name: v.Position.Name,
		}
		rs = append(rs, r)
	}

	return rs
}

```

# pkg/view/pagination_view.go

```go
package view

type PaginationResponse struct {
	Pagination
	Total int64 `json:"total"`
} // @name PaginationResponse

```

# pkg/view/pagination.go

```go
package view

type Pagination struct {
	Page int64  `json:"page" form:"page,default=0"`            // page index
	Size int64  `json:"size" form:"size"`                      // page size
	Sort string `json:"sort" form:"sort" swaggerignore:"true"` // sort field
} // @name Pagination

```

# pkg/view/organizations.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type Organization struct {
	ID     string `json:"id"`
	Code   string `json:"code"`
	Name   string `json:"name"`
	Avatar string `json:"avatar"`
} // @name Organization

func ToOrganization(org *model.Organization) *Organization {
	if org == nil {
		return nil
	}

	return &Organization{
		ID:     org.ID.String(),
		Code:   org.Code,
		Name:   org.Name,
		Avatar: org.Avatar,
	}
}

func ToOrganizations(orgs []model.EmployeeOrganization) []Organization {
	rs := make([]Organization, 0, len(orgs))
	for _, v := range orgs {
		r := Organization{
			ID:     v.Organization.ID.String(),
			Code:   v.Organization.Code,
			Name:   v.Organization.Name,
			Avatar: v.Organization.Avatar,
		}
		rs = append(rs, r)
	}

	return rs
}

```

# pkg/view/news.go

```go
package view

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type News struct {
	Title        string    `json:"title"`
	URL          string    `json:"url"`
	Popularity   int64     `json:"popularity"`
	CommentCount int64     `json:"comment_count"`
	Flag         int64     `json:"flag"`
	Description  string    `json:"description"`
	Tags         []string  `json:"tags"`
	CreatedAt    time.Time `json:"timestamp"`
}

type FetchNewsResponse struct {
	Data []News `json:"data"`
} // @name FetchNewsResponse

func ToFetchNewsResponse(emerging []model.News) []News {
	return ToListNews(emerging)
}

func ToListNews(news []model.News) []News {
	res := make([]News, 0)
	for _, n := range news {
		res = append(res, News{
			Title:        n.Title,
			URL:          n.URL,
			Popularity:   n.Popularity,
			CommentCount: n.CommentCount,
			Flag:         n.Flag,
			Description:  n.Description,
			Tags:         n.Tags,
			CreatedAt:    n.CreatedAt,
		})
	}

	return res
}

```

# pkg/view/metadata.go

```go
package view

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type MetaData struct {
	ID   string `json:"id"`
	Code string `json:"code"`
	Name string `json:"name"`
} // @name MetaData

type MetadataResponse struct {
	Data []MetaData `json:"data"`
} // @name MetaDataResponse

type SeniorityResponse struct {
	Data []Seniority `json:"data"`
} // @name SeniorityResponse

type ChapterResponse struct {
	Data []Chapter `json:"data"`
} // @name ChapterResponse

type StackResponse struct {
	PaginationResponse
	Data []Stack `json:"data"`
} // @name StackResponse

type RolesResponse struct {
	Data []Role `json:"data"`
} // @name RolesResponse

type PositionResponse struct {
	Data []Position `json:"data"`
} // @name PositionResponse

type CountriesResponse struct {
	Data []Country `json:"data"`
} // @name CountriesResponse

type CitiesResponse struct {
	Data []string `json:"data"`
} // @name CitiesResponse

type OrganizationsResponse struct {
	Data []Organization `json:"data"`
} // @name OrganizationsResponse

// Question model question for get list question api
type Question struct {
	ID          string `json:"id"`
	Type        string `json:"type"`
	Category    string `json:"category"`
	Subcategory string `json:"subcategory"`
	Content     string `json:"content"`
	Order       int64  `json:"order"`
} // @name Question

// GetQuestionResponse response for get question api
type GetQuestionResponse struct {
	Data []Question `json:"data"`
} // @name GetQuestionResponse

func ToListQuestion(questions []*model.Question) []*Question {
	var rs []*Question
	for _, q := range questions {
		rs = append(rs, &Question{
			ID:          q.ID.String(),
			Category:    q.Category.String(),
			Subcategory: q.Subcategory.String(),
			Content:     q.Content,
			Type:        q.Type.String(),
			Order:       q.Order,
		})
	}

	return rs
}

func ToRoles(roles []*model.Role) []*Role {
	var rs []*Role
	for _, r := range roles {
		rs = append(rs, &Role{
			ID:   r.ID.String(),
			Code: r.Code,
			Name: toRoleName(r),
		})
	}

	return rs
}

type Country struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Code   string `json:"code"`
	Cities []City `json:"cities"`
} // @name Country

type City struct {
	Name string `json:"name"`
	Lat  string `json:"lat"`
	Long string `json:"long"`
} // @name City

func ToCountry(c *model.Country) *Country {
	if c == nil {
		return nil
	}

	cities := make([]City, len(c.Cities))
	for i, city := range c.Cities {
		cities[i] = City{
			Name: city.Name,
			Lat:  city.Lat,
			Long: city.Long,
		}
	}

	return &Country{
		ID:     c.ID.String(),
		Name:   c.Name,
		Code:   c.Code,
		Cities: cities,
	}
}

func ToCountryView(countries []*model.Country) ([]Country, error) {
	var rs []Country
	for _, c := range countries {
		cities := make([]City, len(c.Cities))
		for i, city := range c.Cities {
			cities[i] = City{
				Name: city.Name,
				Lat:  city.Lat,
				Long: city.Long,
			}
		}

		rs = append(rs, Country{
			ID:     c.ID.String(),
			Name:   c.Name,
			Code:   c.Code,
			Cities: cities,
		})
	}

	return rs, nil
}

```

# pkg/view/memo.go

```go
package view

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/shopspring/decimal"
)

type MemoLog struct {
	ID          string          `json:"id"`
	Title       string          `json:"title"`
	URL         string          `json:"url"`
	Authors     []MemoLogAuthor `json:"authors"`
	Description string          `json:"description"`
	PublishedAt *time.Time      `json:"publishedAt"`
	Reward      decimal.Decimal `json:"reward"`
	Category    []string        `json:"category"`
} // @name MemoLog

// MemoLogAuthor is the author of the memo log
type MemoLogAuthor struct {
	EmployeeID      string `json:"employeeID"`
	GithubUsername  string `json:"githubUsername"`
	DiscordID       string `json:"discordID"`
	DiscordUsername string `json:"discordUsername"`
	PersonalEmail   string `json:"personalEmail"`
	MemoUsername    string `json:"memoUsername"`
}

// MemoLogsResponse response for memo logs
type MemoLogsResponse struct {
	Data []MemoLog `json:"data"`
} // @name MemoLogsResponse

func ToMemoLog(memoLogs []model.MemoLog) []MemoLog {
	rs := make([]MemoLog, 0)
	for _, memoLog := range memoLogs {
		authors := make([]MemoLogAuthor, 0)
		for _, author := range memoLog.Authors {
			var employeeID string
			if author.Employee != nil {
				employeeID = author.Employee.ID.String()
			}

			authors = append(authors, MemoLogAuthor{
				EmployeeID:      employeeID,
				GithubUsername:  author.GithubUsername,
				DiscordID:       author.DiscordID,
				PersonalEmail:   author.PersonalEmail,
				DiscordUsername: author.DiscordUsername,
				MemoUsername:    author.MemoUsername,
			})
		}

		rs = append(rs, MemoLog{
			ID:          memoLog.ID.String(),
			Title:       memoLog.Title,
			URL:         memoLog.URL,
			Authors:     authors,
			Description: memoLog.Description,
			PublishedAt: memoLog.PublishedAt,
			Reward:      memoLog.Reward,
			Category:    memoLog.Category,
		})
	}

	return rs
}

// MemoLogByDiscordIDResponse response for memo logs
type MemoLogByDiscordIDResponse struct {
	Data MemoLogsByDiscordID `json:"data"`
} // @name MemoLogByDiscordIDResponse

type MemoLogsByDiscordID struct {
	MemoLogs []MemoLog     `json:"memoLogs"`
	Rank     AuthorRanking `json:"rank"`
} // @name MemoLogsByDiscordID

// ToMemoLogByDiscordID ...
func ToMemoLogByDiscordID(memoLogs []model.MemoLog, discordMemoRank *model.DiscordAccountMemoRank) MemoLogsByDiscordID {
	rs := make([]MemoLog, 0)
	for _, memoLog := range memoLogs {
		authors := make([]MemoLogAuthor, 0)
		for _, author := range memoLog.Authors {
			var employeeID string
			if author.Employee != nil {
				employeeID = author.Employee.ID.String()
			}

			rank := &AuthorRanking{}
			if discordMemoRank != nil {
				rank.DiscordID = discordMemoRank.DiscordID
				rank.TotalMemos = discordMemoRank.TotalMemos
				rank.Rank = discordMemoRank.Rank
			}

			authors = append(authors, MemoLogAuthor{
				EmployeeID:      employeeID,
				GithubUsername:  author.GithubUsername,
				DiscordID:       author.DiscordID,
				PersonalEmail:   author.PersonalEmail,
				DiscordUsername: author.DiscordUsername,
				MemoUsername:    author.MemoUsername,
			})
		}

		rs = append(rs, MemoLog{
			ID:          memoLog.ID.String(),
			Title:       memoLog.Title,
			URL:         memoLog.URL,
			Authors:     authors,
			Description: memoLog.Description,
			PublishedAt: memoLog.PublishedAt,
			Reward:      memoLog.Reward,
			Category:    memoLog.Category,
		})
	}

	authorRank := AuthorRanking{}
	if discordMemoRank != nil {
		authorRank = AuthorRanking{
			DiscordID:  discordMemoRank.DiscordID,
			TotalMemos: discordMemoRank.TotalMemos,
			Rank:       discordMemoRank.Rank,
		}
	}

	return MemoLogsByDiscordID{
		MemoLogs: rs,
		Rank:     authorRank,
	}
}

type AuthorRanking struct {
	DiscordID       string `json:"discordID"`
	DiscordUsername string `json:"discordUsername"`
	MemoUsername    string `json:"memoUsername"`
	TotalMemos      int    `json:"totalMemos"`
	Rank            int    `json:"rank"`
} // @name AuthorRanking

// MemoTopAuthorsResponse response for memo top authors
type MemoTopAuthorsResponse struct {
	Data []AuthorRanking `json:"data"`
} // @name MemoTopAuthorsResponse

// ToMemoTopAuthors ...
func ToMemoTopAuthors(discordMemoRank []model.DiscordAccountMemoRank) []AuthorRanking {
	rs := make([]AuthorRanking, 0)
	for _, rank := range discordMemoRank {
		rs = append(rs, AuthorRanking{
			DiscordID:       rank.DiscordID,
			DiscordUsername: rank.DiscordUsername,
			MemoUsername:    rank.MemoUsername,
			TotalMemos:      rank.TotalMemos,
			Rank:            rank.Rank,
		})
	}

	return rs
}

```

# pkg/view/invoice.go

```go
package view

import (
	"encoding/json"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type CreateInvoiceResponse struct {
	Data *model.Invoice `json:"data"`
}

type Invoice struct {
	Number           string        `json:"number"`
	InvoicedAt       *time.Time    `json:"invoicedAt"`
	DueAt            *time.Time    `json:"dueAt"`
	PaidAt           *time.Time    `json:"paidAt"`
	FailedAt         *time.Time    `json:"failedAt"`
	Status           string        `json:"status"`
	Email            string        `json:"email"`
	CC               []string      `json:"cc"`
	Description      string        `json:"description"`
	Note             string        `json:"note"`
	SubTotal         float64       `json:"subTotal"`
	Tax              float64       `json:"tax"`
	Discount         float64       `json:"discount"`
	Total            float64       `json:"total"`
	ConversionAmount float64       `json:"conversionAmount"`
	InvoiceFileURL   string        `json:"invoiceFileURL"`
	ErrorInvoiceID   string        `json:"errorInvoiceID"`
	LineItems        []InvoiceItem `json:"lineItems"`
	Month            int           `json:"month"`
	Year             int           `json:"year"`
	SentBy           string        `json:"sentBy"`
	ThreadID         string        `json:"threadID"`
	ScheduledDate    *time.Time    `json:"scheduledDate"`
	ConversionRate   float64       `json:"conversionRate"`
	BankID           string        `json:"bankID"`
	ProjectID        string        `json:"projectID"`
} // @name Invoice

type ClientInfo struct {
	ClientCompany string              `json:"clientCompany"`
	ClientAddress string              `json:"clientAddress"`
	Contacts      []ClientContactInfo `json:"contacts"`
} // @name ClientInfo

type ClientContactInfo struct {
	ID            string   `json:"id"`
	Name          string   `json:"name"`
	Role          string   `json:"-"`
	Emails        []string `json:"emails"`
	IsMainContact bool     `json:"isMainContact"`
} // @name ClientContactInfo

type CompanyInfo struct {
	ID                 string                        `json:"id"`
	Name               string                        `json:"name"`
	Description        string                        `json:"description"`
	RegistrationNumber string                        `json:"registrationNumber"`
	Info               map[string]CompanyContactInfo `json:"info"`
} // @name CompanyInfo

type CompanyContactInfo struct {
	Address string `json:"address"`
	Phone   string `json:"phone"`
} // @name CompanyContactInfo

func ToCompanyInfo(c *model.CompanyInfo) *CompanyInfo {
	if c == nil {
		return nil
	}

	companyContact := make(map[string]CompanyContactInfo)
	err := json.Unmarshal(c.Info.Bytes, &companyContact)
	if err != nil {
		return nil
	}

	return &CompanyInfo{
		ID:                 c.ID.String(),
		Name:               c.Name,
		Description:        c.Description,
		RegistrationNumber: c.RegistrationNumber,
		Info:               companyContact,
	}
}

type InvoiceItem struct {
	Quantity    float64 `json:"quantity"`
	UnitCost    float64 `json:"unitCost"`
	Discount    float64 `json:"discount"`
	Cost        float64 `json:"cost"`
	Description string  `json:"description"`
	IsExternal  bool    `json:"isExternal"`
} // @name InvoiceItem

func toInvoiceItem(lineItems model.JSON) ([]InvoiceItem, error) {
	var items []InvoiceItem
	var tmp []model.InvoiceItem

	if len(lineItems) == 0 || string(lineItems) == "null" {
		return items, nil
	}

	if err := json.Unmarshal(lineItems, &tmp); err != nil {
		return nil, err
	}

	for _, item := range tmp {
		items = append(items, InvoiceItem{
			Quantity:    item.Quantity,
			UnitCost:    item.UnitCost,
			Discount:    item.Discount,
			Cost:        item.Cost,
			Description: item.Description,
			IsExternal:  item.IsExternal,
		})
	}

	return items, nil
}

type ProjectInvoiceTemplate struct {
	ID            string      `json:"id"`
	Name          string      `json:"name"`
	InvoiceNumber string      `json:"invoiceNumber"`
	LastInvoice   *Invoice    `json:"lastInvoice"`
	Client        ClientInfo  `json:"client"`
	BankAccount   BankAccount `json:"bankAccount"`
	CompanyInfo   CompanyInfo `json:"companyInfo"`
} // @name ProjectInvoiceTemplate

type InvoiceTemplateResponse struct {
	Data ProjectInvoiceTemplate `json:"data"`
} // @name InvoiceTemplateResponse

func ToInvoiceInfo(invoice *model.Invoice) (*Invoice, error) {
	if invoice != nil {
		cc := make([]string, 0)
		if invoice.CC != nil {
			err := json.Unmarshal(invoice.CC, &cc)
			if err != nil {
				return nil, err
			}
		}

		invoiceItems, err := toInvoiceItem(invoice.LineItems)
		if err != nil {
			return nil, err
		}

		rs := &Invoice{
			Number:           invoice.Number,
			InvoicedAt:       invoice.InvoicedAt,
			DueAt:            invoice.DueAt,
			PaidAt:           invoice.PaidAt,
			FailedAt:         invoice.FailedAt,
			Status:           invoice.Status.String(),
			Email:            invoice.Email,
			CC:               cc,
			Description:      invoice.Description,
			Note:             invoice.Note,
			SubTotal:         invoice.SubTotal,
			Tax:              invoice.Tax,
			Discount:         invoice.Discount,
			Total:            invoice.Total,
			ConversionAmount: invoice.ConversionAmount,
			InvoiceFileURL:   invoice.InvoiceFileURL,
			LineItems:        invoiceItems,
			Month:            invoice.Month,
			Year:             invoice.Year,
			ThreadID:         invoice.ThreadID,
			ScheduledDate:    invoice.ScheduledDate,
			ConversionRate:   invoice.ConversionRate,
			BankID:           invoice.BankID.String(),
			ProjectID:        invoice.ProjectID.String(),
		}

		if invoice.SentBy != nil {
			rs.SentBy = invoice.SentBy.String()
		}

		if invoice.ErrorInvoiceID != nil {
			rs.ErrorInvoiceID = invoice.ErrorInvoiceID.String()
		}

		return rs, nil
	}

	return nil, nil
}

func ToInvoiceTemplateResponse(p *model.Project, lastInvoice *model.Invoice, nextInvoiceNUmber string) (*ProjectInvoiceTemplate, error) {
	companyInfo := CompanyInfo{}
	if p.CompanyInfo != nil {
		companyContact := make(map[string]CompanyContactInfo)
		_ = json.Unmarshal(p.CompanyInfo.Info.Bytes, &companyContact)

		companyInfo = CompanyInfo{
			ID:                 p.CompanyInfo.ID.String(),
			Name:               p.CompanyInfo.Name,
			Description:        p.CompanyInfo.Description,
			RegistrationNumber: p.CompanyInfo.RegistrationNumber,
			Info:               companyContact,
		}
	}

	clientInfo := ClientInfo{}
	if p.Client != nil {
		contacts := make([]ClientContactInfo, 0)
		for _, c := range p.Client.Contacts {
			emails := make([]string, 0)
			err := json.Unmarshal(c.Emails, &emails)
			if err != nil {
				return nil, err
			}

			contacts = append(contacts, ClientContactInfo{
				ID:            c.ID.String(),
				Name:          c.Name,
				Role:          c.Role,
				Emails:        emails,
				IsMainContact: c.IsMainContact,
			})
		}
		clientInfo = ClientInfo{
			ClientCompany: p.Client.Name,
			ClientAddress: p.Client.Address,
			Contacts:      contacts,
		}
	}

	bankAccount := BankAccount{}
	if p.BankAccount != nil {
		currency := Currency{
			ID:     p.BankAccount.Currency.ID.String(),
			Name:   p.BankAccount.Currency.Name,
			Symbol: p.BankAccount.Currency.Symbol,
			Locale: p.BankAccount.Currency.Locale,
			Type:   p.BankAccount.Currency.Type,
		}
		bankAccount = BankAccount{
			ID:            p.BankAccount.ID.String(),
			AccountNumber: p.BankAccount.AccountNumber,
			BankName:      p.BankAccount.BankName,
			OwnerName:     p.BankAccount.OwnerName,
			Address:       p.BankAccount.Address,
			SwiftCode:     p.BankAccount.SwiftCode,
			RoutingNumber: p.BankAccount.RoutingNumber,
			Name:          p.BankAccount.Name,
			UKSortCode:    p.BankAccount.UKSortCode,
			CurrencyID:    p.BankAccount.CurrencyID.String(),
			Currency:      currency,
		}
	}

	iv, err := ToInvoiceInfo(lastInvoice)
	if err != nil {
		return nil, err
	}
	return &ProjectInvoiceTemplate{
		ID:            p.ID.String(),
		Name:          p.Name,
		InvoiceNumber: nextInvoiceNUmber,
		LastInvoice:   iv,
		Client:        clientInfo,
		BankAccount:   bankAccount,
		CompanyInfo:   companyInfo,
	}, nil
}

type InvoiceData struct {
	Invoice
	ProjectName string      `json:"projectName"`
	BankAccount BankAccount `json:"bankAccount"`
	CompanyInfo CompanyInfo `json:"companyInfo"`
	Client      ClientInfo  `json:"client"`
} // @name InvoiceData

type InvoiceListResponse struct {
	Total int64         `json:"total"`
	Page  int64         `json:"page"`
	Size  int64         `json:"size"`
	Sort  string        `json:"sort"`
	Data  []InvoiceData `json:"data"`
} // @name InvoiceListResponse

func ToInvoiceListResponse(invoices []*model.Invoice) ([]InvoiceData, error) {
	rs := make([]InvoiceData, 0)

	for _, invoice := range invoices {
		iv, err := ToInvoiceInfo(invoice)
		if err != nil {
			return nil, err
		}

		bankAccount := BankAccount{}
		if invoice.Bank != nil {
			currency := Currency{}
			if invoice.Bank.Currency != nil {
				currency = Currency{
					ID:     invoice.Bank.Currency.ID.String(),
					Name:   invoice.Bank.Currency.Name,
					Symbol: invoice.Bank.Currency.Symbol,
					Locale: invoice.Bank.Currency.Locale,
					Type:   invoice.Bank.Currency.Type,
				}
			}
			bankAccount = BankAccount{
				ID:            invoice.Bank.ID.String(),
				AccountNumber: invoice.Bank.AccountNumber,
				BankName:      invoice.Bank.BankName,
				OwnerName:     invoice.Bank.OwnerName,
				Address:       invoice.Bank.Address,
				SwiftCode:     invoice.Bank.SwiftCode,
				RoutingNumber: invoice.Bank.RoutingNumber,
				Name:          invoice.Bank.Name,
				UKSortCode:    invoice.Bank.UKSortCode,
				CurrencyID:    invoice.Bank.CurrencyID.String(),
				Currency:      currency,
			}
		}

		companyInfo := CompanyInfo{}
		clientInfo := ClientInfo{}
		if invoice.Project != nil {
			if invoice.Project.CompanyInfo != nil {
				companyContact := make(map[string]CompanyContactInfo)
				_ = json.Unmarshal(invoice.Project.CompanyInfo.Info.Bytes, &companyContact)

				companyInfo = CompanyInfo{
					ID:                 invoice.Project.CompanyInfo.ID.String(),
					Name:               invoice.Project.CompanyInfo.Name,
					Description:        invoice.Project.CompanyInfo.Description,
					RegistrationNumber: invoice.Project.CompanyInfo.RegistrationNumber,
					Info:               companyContact,
				}
			}

			if invoice.Project.Client != nil {
				contacts := make([]ClientContactInfo, 0)
				for _, c := range invoice.Project.Client.Contacts {
					emails := make([]string, 0)
					err := json.Unmarshal(c.Emails, &emails)
					if err != nil {
						return nil, err
					}

					contacts = append(contacts, ClientContactInfo{
						ID:            c.ID.String(),
						Name:          c.Name,
						Role:          c.Role,
						Emails:        emails,
						IsMainContact: c.IsMainContact,
					})
				}
				clientInfo = ClientInfo{
					ClientCompany: invoice.Project.Client.Name,
					ClientAddress: invoice.Project.Client.Address,
					Contacts:      contacts,
				}
			}
		}

		rs = append(rs, InvoiceData{
			Invoice:     *iv,
			ProjectName: invoice.Project.Name,
			BankAccount: bankAccount,
			CompanyInfo: companyInfo,
			Client:      clientInfo,
		})
	}

	return rs, nil
}

```

# pkg/view/icy.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type IcyAccounting struct {
	ICY                *TokenInfo    `json:"icy"`
	USDT               *TokenInfo    `json:"usdt"`
	IcySwap            *ContractInfo `json:"icySwap"`
	ConversionRate     float32       `json:"conversionRate"`
	CirculatingICY     string        `json:"circulatingICY"`
	ContractFundInUSDT string        `json:"contractFundInUSDT"`
	OffsetUSDT         string        `json:"offsetUSDT"`
}

func ToIcyAccounting(icyAccounting *model.IcyAccounting) *IcyAccounting {
	if icyAccounting == nil {
		return nil
	}
	return &IcyAccounting{
		ICY:                ToTokenInfo(icyAccounting.ICY),
		USDT:               ToTokenInfo(icyAccounting.USDT),
		IcySwap:            ToContractInfo(icyAccounting.IcySwap),
		ConversionRate:     icyAccounting.ConversionRate,
		CirculatingICY:     icyAccounting.CirculatingICY,
		ContractFundInUSDT: icyAccounting.ContractFundInUSDT,
		OffsetUSDT:         icyAccounting.OffsetUSDT,
	}
}

type TokenInfo struct {
	Name        string `json:"name"`
	Symbol      string `json:"symbol"`
	Address     string `json:"address"`
	Decimals    int    `json:"decimals"`
	Chain       string `json:"chain"`
	ChainID     string `json:"chainID"`
	TotalSupply string `json:"totalSupply"`
}

func ToTokenInfo(tokenInfo *model.TokenInfo) *TokenInfo {
	if tokenInfo == nil {
		return nil
	}
	return &TokenInfo{
		Name:        tokenInfo.Name,
		Symbol:      tokenInfo.Symbol,
		Address:     tokenInfo.Address,
		Decimals:    tokenInfo.Decimals,
		Chain:       tokenInfo.Chain,
		ChainID:     tokenInfo.ChainID,
		TotalSupply: tokenInfo.TotalSupply,
	}
}

type ContractInfo struct {
	Name    string `json:"name"`
	Address string `json:"address"`
	Chain   string `json:"chain"`
}

func ToContractInfo(contractInfo *model.ContractInfo) *ContractInfo {
	if contractInfo == nil {
		return nil
	}
	return &ContractInfo{
		Name:    contractInfo.Name,
		Address: contractInfo.Address,
		Chain:   contractInfo.Chain,
	}
}

```

# pkg/view/hiring.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type HiringResponse struct {
	Data []model.NotionHiringPosition `json:"data"`
}

```

# pkg/view/feedback.go

```go
package view

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

var DwarvesAuthor = BasicEmployeeInfo{
	FullName:    "Dwarves' team",
	DisplayName: "Dwarves' team",
}

type Feedback struct {
	TopicID         string             `json:"topicID"`
	Title           string             `json:"title"`
	EventID         string             `json:"eventID"`
	EmployeeID      string             `json:"employeeID"`
	ProjectID       string             `json:"projectID"`
	EventReviewerID string             `json:"eventReviewerID"`
	Type            string             `json:"type"`
	Subtype         string             `json:"subtype"`
	Status          string             `json:"status"`
	IsRead          bool               `json:"isRead"`
	LastUpdated     *time.Time         `json:"lastUpdated"`
	Author          *BasicEmployeeInfo `json:"author"`
} // @name Feedback

func ToListFeedback(eTopics []*model.EmployeeEventTopic) []Feedback {
	var results = make([]Feedback, 0, len(eTopics))

	for _, topic := range eTopics {
		if len(topic.EmployeeEventReviewers) == 0 {
			continue
		}

		feedback := Feedback{
			Title:           topic.Title,
			TopicID:         topic.ID.String(),
			EventID:         topic.EventID.String(),
			EmployeeID:      topic.EmployeeID.String(),
			ProjectID:       topic.ProjectID.String(),
			Type:            topic.Event.Type.String(),
			Subtype:         topic.Event.Subtype.String(),
			Status:          topic.EmployeeEventReviewers[0].ReviewerStatus.String(),
			IsRead:          topic.EmployeeEventReviewers[0].IsRead,
			EventReviewerID: topic.EmployeeEventReviewers[0].ReviewerID.String(),
			LastUpdated:     topic.EmployeeEventReviewers[0].UpdatedAt,
			Author:          toBasicEmployeeInfo(topic.Event.Employee),
		}

		if topic.Event.Type == model.EventTypeSurvey {
			feedback.Author = &DwarvesAuthor
		}

		results = append(results, feedback)
	}

	return results
}

type ListFeedbackResponse struct {
	PaginationResponse
	Data []Feedback `json:"data"`
} // @name ListFeedbackResponse

type QuestionAnswer struct {
	EventQuestionID string         `json:"eventQuestionID"`
	Content         string         `json:"content"`
	Answer          string         `json:"answer"`
	Note            string         `json:"note"`
	Type            string         `json:"type"`
	Order           int64          `json:"order"`
	Domain          QuestionDomain `json:"domain"`
} // @name QuestionAnswer

type QuestionDomain string // @name QuestionDomain

const (
	QuestionDomainEngagement QuestionDomain = "engagement"
	QuestionDomainWorkload   QuestionDomain = "workload"
	QuestionDomainDeadline   QuestionDomain = "deadline"
	QuestionDomainLearning   QuestionDomain = "learning"
)

func (e QuestionDomain) IsValid() bool {
	switch e {
	case
		QuestionDomainWorkload,
		QuestionDomainDeadline,
		QuestionDomainLearning:
		return true
	}
	return false
}

// String returns the string type from the QuestionDomain type
func (e QuestionDomain) String() string {
	return string(e)
}

type FeedBackReviewDetail struct {
	Questions    []QuestionAnswer  `json:"questions"`
	TopicName    string            `json:"topicName"`
	Relationship string            `json:"relationship"`
	Employee     BasicEmployeeInfo `json:"employee"`
	Reviewer     BasicEmployeeInfo `json:"reviewer"`
	Project      *BasicProjectInfo `json:"project"`
} // @name FeedBackReviewDetail

type FeedbackDetail struct {
	Answers      []*QuestionAnswer `json:"answers"`
	Status       string            `json:"status"`
	EmployeeID   string            `json:"employeeID"`
	Reviewer     BasicEmployeeInfo `json:"reviewer"`
	TopicID      string            `json:"topicID"`
	EventID      string            `json:"eventID"`
	Title        string            `json:"title"`
	Relationship string            `json:"relationship"`
	Project      *BasicProjectInfo `json:"project"`
} // @name FeedbackDetail

type FeedbackDetailResponse struct {
	Data FeedbackDetail `json:"data"`
} // @name FeedbackDetailResponse

type FeedbackDetailInfo struct {
	Status       model.EventReviewerStatus
	EmployeeID   string
	Reviewer     *model.Employee
	TopicID      string
	EventID      string
	Title        string
	Relationship model.Relationship
	Project      *model.Project
}

func ToListFeedbackDetails(questions []*model.EmployeeEventQuestion, detailInfo FeedbackDetailInfo) FeedbackDetail {
	var rs FeedbackDetail

	for _, q := range questions {
		if q.Type == model.QuestionTypeScale.String() {
			q.Answer = model.AgreementLevelValueMap[q.Answer].String()
		}

		rs.Answers = append(rs.Answers, &QuestionAnswer{
			EventQuestionID: q.ID.String(),
			Content:         q.Content,
			Answer:          q.Answer,
			Note:            q.Note,
			Type:            q.Type,
			Order:           q.Order,
			Domain:          QuestionDomain(q.Domain),
		})
	}

	rs.Reviewer = *toBasicEmployeeInfo(*detailInfo.Reviewer)

	if detailInfo.Project != nil {
		rs.Project = toBasicProjectInfo(*detailInfo.Project)
	}

	rs.Status = detailInfo.Status.String()
	rs.EmployeeID = detailInfo.EmployeeID
	rs.TopicID = detailInfo.TopicID
	rs.EventID = detailInfo.EventID
	rs.Title = detailInfo.Title
	rs.Relationship = detailInfo.Relationship.String()

	return rs
}

type SubmitFeedback struct {
	EventID    string            `json:"eventID"`
	TopicID    string            `json:"topicID"`
	EmployeeID string            `json:"employeeID"`
	Title      string            `json:"title"`
	Status     string            `json:"status"`
	Reviewer   BasicEmployeeInfo `json:"reviewer"`
	Answers    []*QuestionAnswer `json:"answers"`
} // @name SubmitFeedback

type SubmitFeedbackResponse struct {
	Data SubmitFeedback `json:"data"`
} // @name SubmitFeedbackResponse

func ToListSubmitFeedback(questions []*model.EmployeeEventQuestion, detailInfo FeedbackDetailInfo) SubmitFeedback {
	var rs SubmitFeedback

	for _, q := range questions {
		if q.Type == model.QuestionTypeScale.String() {
			q.Answer = model.AgreementLevelValueMap[q.Answer].String()
		}

		rs.Answers = append(rs.Answers, &QuestionAnswer{
			EventQuestionID: q.ID.String(),
			Content:         q.Content,
			Answer:          q.Answer,
			Note:            q.Note,
			Type:            q.Type,
			Order:           q.Order,
			Domain:          QuestionDomain(q.Domain),
		})
	}

	if detailInfo.Reviewer != nil {
		rs.Reviewer = *toBasicEmployeeInfo(*detailInfo.Reviewer)
	}

	rs.Status = detailInfo.Status.String()
	rs.EmployeeID = detailInfo.EmployeeID
	rs.TopicID = detailInfo.TopicID
	rs.EventID = detailInfo.EventID
	rs.Title = detailInfo.Title

	return rs
}

type FeedbackReviewDetailResponse struct {
	Data *FeedBackReviewDetail `json:"data"`
} // @name FeedbackReviewDetailResponse

func ToFeedbackReviewDetail(questions []*model.EmployeeEventQuestion, topic *model.EmployeeEventTopic, reviewer *model.EmployeeEventReviewer, project *model.Project) FeedBackReviewDetail {
	var qs []QuestionAnswer

	for _, q := range questions {
		if q.Type == model.QuestionTypeScale.String() {
			q.Answer = model.AgreementLevelValueMap[q.Answer].String()
		}

		qs = append(qs, QuestionAnswer{
			EventQuestionID: q.ID.String(),
			Content:         q.Content,
			Answer:          q.Answer,
			Note:            q.Note,
			Type:            q.Type,
			Order:           q.Order,
			Domain:          QuestionDomain(q.Domain),
		})
	}

	rs := FeedBackReviewDetail{
		Questions:    qs,
		TopicName:    topic.Title,
		Relationship: reviewer.Relationship.String(),
	}

	if topic.Employee != nil {
		rs.Employee = *toBasicEmployeeInfo(*topic.Employee)
	}

	if reviewer.Reviewer != nil {
		rs.Reviewer = *toBasicEmployeeInfo(*reviewer.Reviewer)
	}

	if project != nil {
		rs.Project = toBasicProjectInfo(*project)
	}

	return rs
}

type UnreadFeedbackCountResponse struct {
	Data UnreadFeedbackCountData `json:"data"`
} // @name UnreadFeedbackCountResponse

type UnreadFeedbackCountData struct {
	Count      int64  `json:"count"`
	ReviewerID string `json:"reviewerID"`
} // @name UnreadFeedbackCountData

func ToUnreadFeedbackCountData(reviewerID string, count int64) UnreadFeedbackCountData {
	return UnreadFeedbackCountData{
		ReviewerID: reviewerID,
		Count:      count,
	}
}

```

# pkg/view/event_speaker.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

// OgifStats contains list of ogif and some stats
type OgifStats struct {
	OgifList               []model.EventSpeaker `json:"ogifList"`
	UserAllTimeSpeaksCount int64                `json:"userAllTimeSpeaksCount"`
	UserAllTimeRank        int64                `json:"userAllTimeRank"`
	UserCurrentSpeaksCount int64                `json:"userCurrentSpeaksCount"`
	UserCurrentRank        int64                `json:"userCurrentRank"`
	TotalSpeakCount        int64                `json:"totalSpeakCount"`
	CurrentSpeakCount      int64                `json:"currentSpeakCount"`
}

// OgifStatsResponse return ogif stats response
type OgifStatsResponse struct {
	Data OgifStats `json:"data"`
} // @name OgifStatsResponse

```

# pkg/view/employee.go

```go
package view

import (
	"time"

	"github.com/shopspring/decimal"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
)

// EmployeeData view for listing data
type EmployeeData struct {
	ID        string     `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`

	// basic info
	FullName         string     `json:"fullName"`
	DisplayName      string     `json:"displayName"`
	TeamEmail        string     `json:"teamEmail"`
	PersonalEmail    string     `json:"personalEmail"`
	Avatar           string     `json:"avatar"`
	PhoneNumber      string     `json:"phoneNumber"`
	Address          string     `json:"address"`
	PlaceOfResidence string     `json:"placeOfResidence"`
	Country          string     `json:"country"`
	City             string     `json:"city"`
	MBTI             string     `json:"mbti"`
	Gender           string     `json:"gender"`
	Horoscope        string     `json:"horoscope"`
	DateOfBirth      *time.Time `json:"birthday"`
	Username         string     `json:"username"`
	GithubID         string     `json:"githubID"`
	NotionID         string     `json:"notionID"`
	NotionName       string     `json:"notionName"`
	DiscordID        string     `json:"discordID"`
	DiscordName      string     `json:"discordName"`
	LinkedInName     string     `json:"linkedInName"`

	// working info
	WorkingStatus WorkingStatus `json:"status"`
	JoinedDate    *time.Time    `json:"joinedDate"`
	LeftDate      *time.Time    `json:"leftDate"`

	Seniority          *Seniority            `json:"seniority"`
	LineManager        *BasicEmployeeInfo    `json:"lineManager"`
	ReferredBy         *BasicEmployeeInfo    `json:"referredBy"`
	Organizations      []Organization        `json:"organizations"`
	Positions          []Position            `json:"positions"`
	Projects           []EmployeeProjectData `json:"projects"`
	Stacks             []Stack               `json:"stacks"`
	Roles              []Role                `json:"roles"`
	Chapters           []Chapter             `json:"chapters"`
	Mentees            []*MenteeInfo         `json:"mentees"`
	BaseSalary         *BaseSalary           `json:"baseSalary"`
	WiseRecipientID    string                `json:"wiseRecipientID"`
	WiseAccountNumber  string                `json:"wiseAccountNumber"`
	WiseRecipientEmail string                `json:"wiseRecipientEmail"`
	WiseRecipientName  string                `json:"wiseRecipientName"`
	WiseCurrency       string                `json:"wiseCurrency"`

	BeneficiaryBankName      string `json:"beneficiaryBankName"`
	BeneficiaryBankPostcode  string `json:"beneficiaryBankPostcode"`
	BeneficiaryBankAddress   string `json:"beneficiaryBankAddress"`
	BeneficiaryBankCity      string `json:"beneficiaryBankCity"`
	BeneficiaryRoutingNumber string `json:"beneficiaryRoutingNumber"`
} // @name EmployeeData

type WorkingStatus string // @name WorkingStatus

type MMAScore struct {
	MasteryScore  decimal.Decimal `json:"masteryScore"`
	AutonomyScore decimal.Decimal `json:"autonomyScore"`
	MeaningScore  decimal.Decimal `json:"meaningScore"`
	RatedAt       *time.Time      `json:"ratedAt"`
}

type MenteeInfo struct {
	ID          string     `json:"id"`
	FullName    string     `json:"fullName"`
	DisplayName string     `json:"displayName"`
	Avatar      string     `json:"avatar"`
	Username    string     `json:"username"`
	Seniority   *Seniority `json:"seniority"`
	Positions   []Position `json:"positions"`
} // @name MenteeInfo

type SocialAccount struct {
	GithubID     string `json:"githubID"`
	NotionID     string `json:"notionID"`
	NotionName   string `json:"notionName"`
	NotionEmail  string `json:"notionEmail"`
	LinkedInName string `json:"linkedInName"`
}

type BaseSalary struct {
	ID                    string      `json:"id"`
	EmployeeID            string      `json:"employee_id"`
	ContractAmount        int64       `json:"contract_amount"`
	CompanyAccountAmount  int64       `json:"company_account_amount"`
	PersonalAccountAmount int64       `json:"personal_account_amount"`
	InsuranceAmount       VietnamDong `json:"insurance_amount"`
	Type                  string      `json:"type"`
	Category              string      `json:"category"`
	CurrencyID            string      `json:"currency_id"`
	Currency              *Currency   `json:"currency"`
	Batch                 int         `json:"batch"`
	EffectiveDate         *time.Time  `json:"effective_date"`
} // @name BaseSalary

type VietnamDong int64 // @name VietnamDong

func toMenteeInfo(employee model.Employee) *MenteeInfo {
	rs := &MenteeInfo{
		ID:          employee.ID.String(),
		FullName:    employee.FullName,
		DisplayName: employee.DisplayName,
		Avatar:      employee.Avatar,
		Username:    employee.Username,
		Positions:   ToEmployeePositions(employee.EmployeePositions),
	}

	if employee.Seniority != nil {
		s := ToSeniority(*employee.Seniority)
		rs.Seniority = &s
	}

	return rs
}

type EmployeeProjectData struct {
	ID             string     `json:"id"`
	Name           string     `json:"name"`
	DeploymentType string     `json:"deploymentType"`
	Status         string     `json:"status"`
	Positions      []Position `json:"positions"`
	Code           string     `json:"code"`
	Avatar         string     `json:"avatar"`
	StartDate      *time.Time `json:"startDate"`
	EndDate        *time.Time `json:"endDate"`
} // @name EmployeeProjectData

func ToEmployeeProjectDetailData(pm *model.ProjectMember, userInfo *model.CurrentLoggedUserInfo) EmployeeProjectData {
	rs := EmployeeProjectData{
		ID:        pm.ProjectID.String(),
		Name:      pm.Project.Name,
		Status:    model.ProjectMemberStatusActive.String(),
		Positions: ToProjectMemberPositions(pm.ProjectMemberPositions),
		Code:      pm.Project.Code,
		Avatar:    pm.Project.Avatar,
	}

	if !pm.IsActive() ||
		pm.Project.Status == model.ProjectStatusClosed ||
		pm.Project.Status == model.ProjectStatusPaused {
		rs.Status = model.ProjectMemberStatusInactive.String()
	}

	if authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadProjectsFullAccess) {
		rs.StartDate = pm.StartDate
		rs.EndDate = pm.EndDate
		rs.DeploymentType = pm.DeploymentType.String()
	}

	return rs
}

func ToEmployeeProjectData(pm *model.ProjectMember) EmployeeProjectData {
	return EmployeeProjectData{
		ID:             pm.ProjectID.String(),
		Name:           pm.Project.Name,
		DeploymentType: pm.DeploymentType.String(),
		Status:         pm.Project.Status.String(),
		Positions:      ToProjectMemberPositions(pm.ProjectMemberPositions),
		Code:           pm.Project.Code,
		Avatar:         pm.Project.Avatar,
		StartDate:      pm.StartDate,
		EndDate:        pm.EndDate,
	}
}

type UpdateGeneralInfoEmployeeData struct {
	ID        string     `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`

	// basic info
	FullName      string             `json:"fullName"`
	TeamEmail     string             `json:"teamEmail"`
	PhoneNumber   string             `json:"phoneNumber"`
	GithubID      string             `json:"githubID"`
	NotionID      string             `json:"notionID"`
	NotionName    string             `json:"notionName"`
	NotionEmail   string             `json:"notionEmail"`
	LinkedInName  string             `json:"linkedInName"`
	DiscordID     string             `json:"discordID"`
	DiscordName   string             `json:"discordName"`
	DisplayName   string             `json:"displayName"`
	Organizations []Organization     `json:"organizations"`
	LineManager   *BasicEmployeeInfo `json:"lineManager"`
	ReferredBy    *BasicEmployeeInfo `json:"referredBy"`
} // @name UpdateGeneralInfoEmployeeData

type UpdateSkillEmployeeData struct {
	ID        string     `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`

	Seniority *Seniority `json:"seniority"`
	Positions []Position `json:"positions"`
	Stacks    []Stack    `json:"stacks"`
	Chapters  []Chapter  `json:"chapters"`
} // @name UpdateSkillEmployeeData

type UpdatePersonalEmployeeData struct {
	ID        string     `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`

	PersonalEmail    string     `json:"personalEmail"`
	Address          string     `json:"address"`
	PlaceOfResidence string     `json:"placeOfResidence"`
	Gender           string     `json:"gender"`
	DateOfBirth      *time.Time `json:"birthday"`
	Country          string     `json:"country"`
	City             string     `json:"city"`
} // @name UpdatePersonalEmployeeData

type BasicEmployeeInfo struct {
	ID          string `json:"id"`
	FullName    string `json:"fullName"`
	DisplayName string `json:"displayName"`
	Avatar      string `json:"avatar"`
	Username    string `json:"username"`
} // @name BasicEmployeeInfo

type UpdateEmployeeStatusResponse struct {
	Data EmployeeData `json:"data"`
} // @name UpdateEmployeeStatusResponse

type EmployeeListDataResponse struct {
	PaginationResponse
	Data []EmployeeData `json:"data"`
} // @name EmployeeListDataResponse

type UpdataEmployeeStatusResponse struct {
	Data EmployeeData `json:"data"`
}

type UpdateSkillsEmployeeResponse struct {
	Data UpdateSkillEmployeeData `json:"data"`
} // @name UpdateSkillsEmployeeResponse

type UpdatePersonalEmployeeResponse struct {
	Data UpdatePersonalEmployeeData `json:"data"`
} // @name UpdatePersonalEmployeeResponse

type UpdateGeneralEmployeeResponse struct {
	Data UpdateGeneralInfoEmployeeData `json:"data"`
} // @name UpdateGeneralEmployeeResponse

type UpdateBaseSalaryResponse struct {
	Data BaseSalary `json:"data"`
} // @name UpdateBaseSalaryResponse

func ToUpdatePersonalEmployeeData(employee *model.Employee) *UpdatePersonalEmployeeData {
	return &UpdatePersonalEmployeeData{
		ID:               employee.ID.String(),
		CreatedAt:        employee.CreatedAt,
		UpdatedAt:        employee.UpdatedAt,
		DateOfBirth:      employee.DateOfBirth,
		Gender:           employee.Gender,
		Address:          employee.Address,
		PlaceOfResidence: employee.PlaceOfResidence,
		PersonalEmail:    employee.PersonalEmail,
		Country:          employee.Country,
		City:             employee.City,
	}
}

func ToUpdateSkillEmployeeData(employee *model.Employee) *UpdateSkillEmployeeData {
	positions := make([]model.Position, 0, len(employee.EmployeePositions))
	for _, v := range employee.EmployeePositions {
		positions = append(positions, v.Position)
	}

	rs := &UpdateSkillEmployeeData{
		ID:        employee.ID.String(),
		CreatedAt: employee.CreatedAt,
		UpdatedAt: employee.UpdatedAt,
		Positions: ToPositions(positions),
		Stacks:    ToEmployeeStacks(employee.EmployeeStacks),
		Chapters:  ToChapters(employee.EmployeeChapters),
	}

	if employee.Seniority != nil {
		s := ToSeniority(*employee.Seniority)
		rs.Seniority = &s
	}

	return rs
}

func ToUpdateGeneralInfoEmployeeData(employee *model.Employee) *UpdateGeneralInfoEmployeeData {
	rs := &UpdateGeneralInfoEmployeeData{
		ID:            employee.ID.String(),
		CreatedAt:     employee.CreatedAt,
		UpdatedAt:     employee.UpdatedAt,
		FullName:      employee.FullName,
		TeamEmail:     employee.TeamEmail,
		PhoneNumber:   employee.PhoneNumber,
		DisplayName:   employee.DisplayName,
		Organizations: ToOrganizations(employee.EmployeeOrganizations),
	}

	if len(employee.SocialAccounts) > 0 {
		for _, sa := range employee.SocialAccounts {
			switch sa.Type {
			case model.SocialAccountTypeGitHub:
				rs.GithubID = sa.AccountID
			case model.SocialAccountTypeNotion:
				rs.NotionID = sa.AccountID
				rs.NotionName = sa.Name
			case model.SocialAccountTypeLinkedIn:
				rs.LinkedInName = sa.Name
			}
		}
	}

	if employee.DiscordAccount != nil {
		rs.DiscordID = employee.DiscordAccount.DiscordID
		rs.DiscordName = employee.DiscordAccount.DiscordUsername
	}

	if employee.LineManager != nil {
		rs.LineManager = toBasicEmployeeInfo(*employee.LineManager)
	}

	if !employee.ReferredBy.IsZero() {
		rs.ReferredBy = toBasicEmployeeInfo(*employee.Referrer)
	}

	return rs
}

type EmployeeDataResponse struct {
	Data *EmployeeData `json:"data"`
} // @name EmployeeDataResponse

// ToOneEmployeeData parse employee date to response data
func ToOneEmployeeData(employee *model.Employee, userInfo *model.CurrentLoggedUserInfo) *EmployeeData {
	employeeProjects := make([]EmployeeProjectData, 0, len(employee.ProjectMembers))
	for _, pm := range employee.ProjectMembers {
		if userInfo != nil {
			// If logged user is working on the same project or user have permission to read active, show the project
			_, ok := userInfo.Projects[pm.ProjectID]
			if (ok || authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadProjectsReadActive)) &&
				pm.IsActive() && pm.Project.Status == model.ProjectStatusActive {
				employeeProjects = append(employeeProjects, ToEmployeeProjectDetailData(&pm, userInfo))
				continue
			}

			// If logged user have permission to read all projects, show the project
			if authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadProjectsFullAccess) {
				employeeProjects = append(employeeProjects, ToEmployeeProjectDetailData(&pm, userInfo))
			}
		}
	}

	var lineManager, referrer *BasicEmployeeInfo
	if employee.LineManager != nil {
		lineManager = toBasicEmployeeInfo(*employee.LineManager)
	}
	if employee.Referrer != nil {
		referrer = toBasicEmployeeInfo(*employee.Referrer)
	}

	empSocialData := SocialAccount{}
	for _, sa := range employee.SocialAccounts {
		switch sa.Type {
		case model.SocialAccountTypeGitHub:
			empSocialData.GithubID = sa.AccountID
		case model.SocialAccountTypeNotion:
			empSocialData.NotionID = sa.AccountID
			empSocialData.NotionName = sa.Name
		case model.SocialAccountTypeLinkedIn:
			empSocialData.LinkedInName = sa.AccountID
		}
	}

	rs := &EmployeeData{
		ID:          employee.ID.String(),
		CreatedAt:   employee.CreatedAt,
		UpdatedAt:   employee.UpdatedAt,
		FullName:    employee.FullName,
		DisplayName: employee.DisplayName,
		TeamEmail:   employee.TeamEmail,
		Avatar:      employee.Avatar,

		Gender:      employee.Gender,
		Horoscope:   employee.Horoscope,
		DateOfBirth: employee.DateOfBirth,

		Username:      employee.Username,
		WorkingStatus: WorkingStatus(employee.WorkingStatus.String()),
		Projects:      employeeProjects,
		LineManager:   lineManager,
		Organizations: ToOrganizations(employee.EmployeeOrganizations),

		GithubID: empSocialData.GithubID,

		Roles:     ToEmployeeRoles(employee.EmployeeRoles),
		Positions: ToEmployeePositions(employee.EmployeePositions),
		Stacks:    ToEmployeeStacks(employee.EmployeeStacks),
		Chapters:  ToChapters(employee.EmployeeChapters),
	}

	if employee.DiscordAccount != nil {
		rs.DiscordID = employee.DiscordAccount.DiscordID
		rs.DiscordName = employee.DiscordAccount.DiscordUsername
	}

	if userInfo != nil && authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesBaseSalaryRead) {
		if !employee.BaseSalary.ID.IsZero() {
			rs.BaseSalary = ToBaseSalary(&employee.BaseSalary)
		}
	}

	if userInfo != nil && authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadGeneralInfoFullAccess) {
		rs.NotionID = empSocialData.NotionID
		rs.NotionName = empSocialData.NotionName
		rs.LinkedInName = empSocialData.LinkedInName
		rs.PhoneNumber = employee.PhoneNumber
		rs.JoinedDate = employee.JoinedDate
		rs.LeftDate = employee.LeftDate
		rs.ReferredBy = referrer
		rs.WiseRecipientID = employee.WiseRecipientID
		rs.WiseAccountNumber = employee.WiseAccountNumber
		rs.WiseRecipientEmail = employee.WiseRecipientEmail
		rs.WiseRecipientName = employee.WiseRecipientName
		rs.WiseCurrency = employee.WiseCurrency
		rs.BeneficiaryBankName = employee.BeneficiaryBankName
		rs.BeneficiaryBankPostcode = employee.BeneficiaryBankPostcode
		rs.BeneficiaryBankAddress = employee.BeneficiaryBankAddress
		rs.BeneficiaryBankCity = employee.BeneficiaryBankCity
		rs.BeneficiaryRoutingNumber = employee.BeneficiaryRoutingNumber
	}

	if userInfo != nil && authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadPersonalInfoFullAccess) {
		rs.MBTI = employee.MBTI
		rs.PersonalEmail = employee.PersonalEmail
		rs.Address = employee.Address
		rs.PlaceOfResidence = employee.PlaceOfResidence
		rs.City = employee.City
		rs.Country = employee.Country
	}

	if len(employee.Mentees) > 0 {
		mentees := make([]*MenteeInfo, 0)
		for _, v := range employee.Mentees {
			mentees = append(mentees, toMenteeInfo(*v))
		}

		rs.Mentees = mentees
	}

	if employee.Seniority != nil {
		s := ToSeniority(*employee.Seniority)
		rs.Seniority = &s
	}

	return rs
}

func ToEmployeeData(employee *model.Employee) *EmployeeData {
	employeeProjects := make([]EmployeeProjectData, 0)
	for _, v := range employee.ProjectMembers {
		employeeProjects = append(employeeProjects, ToEmployeeProjectData(&v))
	}

	var lineManager, referrer *BasicEmployeeInfo
	if employee.LineManager != nil {
		lineManager = toBasicEmployeeInfo(*employee.LineManager)
	}
	if employee.Referrer != nil {
		referrer = toBasicEmployeeInfo(*employee.Referrer)
	}

	rs := &EmployeeData{
		ID:               employee.ID.String(),
		CreatedAt:        employee.CreatedAt,
		UpdatedAt:        employee.UpdatedAt,
		FullName:         employee.FullName,
		DisplayName:      employee.DisplayName,
		TeamEmail:        employee.TeamEmail,
		PersonalEmail:    employee.PersonalEmail,
		Avatar:           employee.Avatar,
		PhoneNumber:      employee.PhoneNumber,
		Address:          employee.Address,
		PlaceOfResidence: employee.PlaceOfResidence,
		MBTI:             employee.MBTI,
		Gender:           employee.Gender,
		Horoscope:        employee.Horoscope,
		DateOfBirth:      employee.DateOfBirth,
		Username:         employee.Username,
		WorkingStatus:    WorkingStatus(employee.WorkingStatus.String()),
		JoinedDate:       employee.JoinedDate,
		LeftDate:         employee.LeftDate,
		Organizations:    ToOrganizations(employee.EmployeeOrganizations),
		Projects:         employeeProjects,
		LineManager:      lineManager,
		ReferredBy:       referrer,
		Country:          employee.Country,
		City:             employee.City,
		Roles:            ToEmployeeRoles(employee.EmployeeRoles),
		Positions:        ToEmployeePositions(employee.EmployeePositions),
		Stacks:           ToEmployeeStacks(employee.EmployeeStacks),
		Chapters:         ToChapters(employee.EmployeeChapters),
	}

	if len(employee.SocialAccounts) > 0 {
		for _, sa := range employee.SocialAccounts {
			switch sa.Type {
			case model.SocialAccountTypeGitHub:
				rs.GithubID = sa.AccountID
			case model.SocialAccountTypeNotion:
				rs.NotionID = sa.AccountID
				rs.NotionName = sa.Name
			case model.SocialAccountTypeLinkedIn:
				rs.LinkedInName = sa.Name
			}
		}
	}

	if employee.DiscordAccount != nil {
		rs.DiscordID = employee.DiscordAccount.DiscordID
		rs.DiscordName = employee.DiscordAccount.DiscordUsername
	}

	if len(employee.Mentees) > 0 {
		mentees := make([]*MenteeInfo, 0)
		for _, v := range employee.Mentees {
			mentees = append(mentees, toMenteeInfo(*v))
		}

		rs.Mentees = mentees
	}

	if employee.Seniority != nil {
		s := ToSeniority(*employee.Seniority)
		rs.Seniority = &s
	}

	return rs
}

func ToEmployeeListData(employees []*model.Employee, userInfo *model.CurrentLoggedUserInfo) []EmployeeData {
	rs := make([]EmployeeData, 0, len(employees))
	for _, emp := range employees {
		empRes := ToOneEmployeeData(emp, userInfo)
		rs = append(rs, *empRes)
	}
	return rs
}

type EmployeeContentData struct {
	Url string `json:"url"`
} // @name EmployeeContentData

type EmployeeContentDataResponse struct {
	Data *EmployeeContentData `json:"data"`
} // @name EmployeeContentDataResponse

func ToEmployeeContentData(url string) *EmployeeContentData {
	return &EmployeeContentData{
		Url: url,
	}
}

func toBasicEmployeeInfo(employee model.Employee) *BasicEmployeeInfo {
	return &BasicEmployeeInfo{
		ID:          employee.ID.String(),
		FullName:    employee.FullName,
		DisplayName: employee.DisplayName,
		Avatar:      employee.Avatar,
		Username:    employee.Username,
	}
}

type LineManagersResponse struct {
	Data []BasicEmployeeInfo `json:"data"`
} // @name LineManagersResponse

func ToBasicEmployees(employees []*model.Employee) []BasicEmployeeInfo {
	results := make([]BasicEmployeeInfo, 0, len(employees))

	for _, e := range employees {
		emp := toBasicEmployeeInfo(*e)
		results = append(results, *emp)
	}

	return results
}

func ToBaseSalary(bs *model.BaseSalary) *BaseSalary {
	if bs == nil {
		return nil
	}

	var currency *Currency
	if bs.Currency != nil {
		currency = &Currency{
			ID:     bs.Currency.ID.String(),
			Name:   bs.Currency.Name,
			Symbol: bs.Currency.Symbol,
			Locale: bs.Currency.Locale,
			Type:   bs.Currency.Type,
		}
	}
	return &BaseSalary{
		ID:                    bs.ID.String(),
		EmployeeID:            bs.EmployeeID.String(),
		ContractAmount:        bs.ContractAmount,
		CompanyAccountAmount:  bs.CompanyAccountAmount,
		PersonalAccountAmount: bs.PersonalAccountAmount,
		InsuranceAmount:       VietnamDong(bs.InsuranceAmount),
		Type:                  bs.Type,
		Category:              bs.Category,
		CurrencyID:            bs.CurrencyID.String(),
		Currency:              currency,
		Batch:                 bs.Batch,
		EffectiveDate:         bs.EffectiveDate,
	}
}

type EmployeeInvitationData struct {
	ID                       string               `json:"id"`
	EmployeeID               string               `json:"employeeID"`
	InvitedBy                string               `json:"invitedBy"`
	IsCompleted              bool                 `json:"isCompleted"`
	IsInfoUpdated            bool                 `json:"isInfoUpdated"`
	IsDiscordRoleAssigned    bool                 `json:"isDiscordRoleAssigned"`
	IsBasecampAccountCreated bool                 `json:"isBasecampAccountCreated"`
	IsTeamEmailCreated       bool                 `json:"isTeamEmailCreated"`
	EmployeeData             *InvitedEmployeeInfo `json:"employee"`
} // @name EmployeeInvitationData

type InvitedEmployeeInfo struct {
	ID            string `json:"id"`
	FullName      string `json:"fullName"`
	DisplayName   string `json:"displayName"`
	Avatar        string `json:"avatar"`
	Username      string `json:"username"`
	TeamEmail     string `json:"teamEmail"`
	PersonalEmail string `json:"personalEmail"`
} // @name InvitedEmployeeInfo

type EmployeeInvitationResponse struct {
	Data *EmployeeInvitationData `json:"data"`
} // @name EmployeeInvitationResponse

func ToBasicEmployeeInvitationData(in *model.EmployeeInvitation) *EmployeeInvitationData {
	rs := &EmployeeInvitationData{
		ID:                       in.ID.String(),
		EmployeeID:               in.EmployeeID.String(),
		InvitedBy:                in.InvitedBy.String(),
		IsCompleted:              in.IsCompleted,
		IsInfoUpdated:            in.IsInfoUpdated,
		IsDiscordRoleAssigned:    in.IsDiscordRoleAssigned,
		IsBasecampAccountCreated: in.IsBasecampAccountCreated,
		IsTeamEmailCreated:       in.IsTeamEmailCreated,
	}

	if in.Employee != nil {
		rs.EmployeeData = &InvitedEmployeeInfo{
			ID:            in.Employee.ID.String(),
			FullName:      in.Employee.FullName,
			DisplayName:   in.Employee.DisplayName,
			Avatar:        in.Employee.Avatar,
			Username:      in.Employee.Username,
			TeamEmail:     in.Employee.TeamEmail,
			PersonalEmail: in.Employee.PersonalEmail,
		}
	}

	return rs
}

type EmployeeLocationListResponse struct {
	Data []EmployeeLocation `json:"data"`
} // @name EmployeeLocationListResponse

type EmployeeLocation struct {
	DiscordID   string          `json:"discordID"`
	FullName    string          `json:"fullName"`
	DisplayName string          `json:"displayName"`
	Avatar      string          `json:"avatar"`
	Chapters    []Chapter       `json:"chapters"`
	Address     EmployeeAddress `json:"address"`
} // @name EmployeeLocation

type EmployeeAddress struct {
	Address string `json:"address"`
	Country string `json:"country"`
	City    string `json:"city"`
	Lat     string `json:"lat"`
	Long    string `json:"long"`
} // @name EmployeeAddress

func ToEmployeesWithLocation(in []*model.Employee) []EmployeeLocation {
	rs := make([]EmployeeLocation, len(in))
	for i, v := range in {
		discordID := ""
		if v.DiscordAccount != nil {
			discordID = v.DiscordAccount.DiscordID
		}
		rs[i] = EmployeeLocation{
			DiscordID:   discordID,
			FullName:    v.FullName,
			DisplayName: v.DisplayName,
			Avatar:      v.Avatar,
			Chapters:    ToChapters(v.EmployeeChapters),
			Address: EmployeeAddress{
				Address: v.City + ", " + v.Country,
				Country: v.Country,
				City:    v.City,
				Lat:     v.Lat,
				Long:    v.Long,
			},
		}
	}
	return rs
}

// DiscordEmployeeData view for listing data
type DiscordEmployeeData struct {
	ID        string     `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`

	// basic info
	FullName         string     `json:"fullName"`
	DisplayName      string     `json:"displayName"`
	TeamEmail        string     `json:"teamEmail"`
	PersonalEmail    string     `json:"personalEmail"`
	Avatar           string     `json:"avatar"`
	PhoneNumber      string     `json:"phoneNumber"`
	Address          string     `json:"address"`
	PlaceOfResidence string     `json:"placeOfResidence"`
	Country          string     `json:"country"`
	City             string     `json:"city"`
	MBTI             string     `json:"mbti"`
	Gender           string     `json:"gender"`
	Horoscope        string     `json:"horoscope"`
	DateOfBirth      *time.Time `json:"birthday"`
	Username         string     `json:"username"`
	GithubID         string     `json:"githubID"`
	NotionID         string     `json:"notionID"`
	NotionName       string     `json:"notionName"`
	DiscordID        string     `json:"discordID"`
	DiscordName      string     `json:"discordName"`
	LinkedInName     string     `json:"linkedInName"`

	// working info
	WorkingStatus model.WorkingStatus `json:"status"`
	JoinedDate    *time.Time          `json:"joinedDate"`
	LeftDate      *time.Time          `json:"leftDate"`

	Seniority *model.Seniority      `json:"seniority"`
	Positions []Position            `json:"positions"`
	Stacks    []Stack               `json:"stacks"`
	Projects  []EmployeeProjectData `json:"projects"`

	MMAScore *MMAScore `json:"mmaScore"`
} // @name DiscordEmployeeData

func ToDiscordEmployeeListData(employees []model.Employee, userInfo *model.CurrentLoggedUserInfo) []DiscordEmployeeData {
	rs := make([]DiscordEmployeeData, 0, len(employees))
	for _, emp := range employees {
		empRes := ToDiscordEmployeeDetail(&emp, userInfo)
		rs = append(rs, *empRes)
	}
	return rs
}
func ToDiscordEmployeeDetail(employee *model.Employee, userInfo *model.CurrentLoggedUserInfo) *DiscordEmployeeData {
	if employee == nil {
		return nil
	}

	employeeProjects := make([]EmployeeProjectData, 0, len(employee.ProjectMembers))
	for _, pm := range employee.ProjectMembers {
		if userInfo != nil {
			// If logged user is working on the same project or user have permission to read active, show the project
			if pm.IsActive() && pm.Project.Status == model.ProjectStatusActive {
				employeeProjects = append(employeeProjects, ToEmployeeProjectDetailData(&pm, userInfo))
				continue
			}
		}
	}

	empSocialData := SocialAccount{}
	for _, sa := range employee.SocialAccounts {
		switch sa.Type {
		case model.SocialAccountTypeGitHub:
			empSocialData.GithubID = sa.AccountID
		case model.SocialAccountTypeNotion:
			empSocialData.NotionID = sa.AccountID
			empSocialData.NotionName = sa.Name
		case model.SocialAccountTypeLinkedIn:
			empSocialData.LinkedInName = sa.AccountID
		}
	}

	rs := &DiscordEmployeeData{
		ID:        employee.ID.String(),
		CreatedAt: employee.CreatedAt,
		UpdatedAt: employee.UpdatedAt,

		FullName:    employee.FullName,
		DisplayName: employee.DisplayName,
		TeamEmail:   employee.TeamEmail,
		Avatar:      employee.Avatar,

		Gender:      employee.Gender,
		Horoscope:   employee.Horoscope,
		DateOfBirth: employee.DateOfBirth,

		Username:      employee.Username,
		WorkingStatus: employee.WorkingStatus,
		Seniority:     employee.Seniority,
		Projects:      employeeProjects,

		GithubID: empSocialData.GithubID,

		Positions: ToEmployeePositions(employee.EmployeePositions),
		Stacks:    ToEmployeeStacks(employee.EmployeeStacks),
	}

	if employee.DiscordAccount != nil {
		rs.DiscordID = employee.DiscordAccount.DiscordID
		rs.DiscordName = employee.DiscordAccount.DiscordUsername
	}

	rs.NotionID = empSocialData.NotionID
	rs.NotionName = empSocialData.NotionName
	rs.LinkedInName = empSocialData.LinkedInName
	rs.PhoneNumber = employee.PhoneNumber
	rs.JoinedDate = employee.JoinedDate

	rs.MBTI = employee.MBTI
	rs.PersonalEmail = employee.PersonalEmail
	rs.Address = employee.Address
	rs.PlaceOfResidence = employee.PlaceOfResidence
	rs.City = employee.City
	rs.Country = employee.Country

	if employee.Seniority != nil {
		rs.Seniority = employee.Seniority
	}

	if len(employee.EmployeeMMAScores) > 0 {
		rs.MMAScore = &MMAScore{
			MasteryScore:  employee.EmployeeMMAScores[0].MasteryScore,
			AutonomyScore: employee.EmployeeMMAScores[0].AutonomyScore,
			MeaningScore:  employee.EmployeeMMAScores[0].MeaningScore,
			RatedAt:       employee.EmployeeMMAScores[0].RatedAt,
		}
	}

	return rs
}

type EmployeeMMAScore struct {
	EmployeeID    string          `json:"employeeID"`
	FullName      string          `json:"fullName"`
	MMAID         string          `json:"mmaID"`
	MasteryScore  decimal.Decimal `json:"masteryScore"`
	AutonomyScore decimal.Decimal `json:"autonomyScore"`
	MeaningScore  decimal.Decimal `json:"meaningScore"`
	RatedAt       *time.Time      `json:"ratedAt"`
} // @name EmployeeMMAScore

func ToEmployeesWithMMAScore(in []model.EmployeeMMAScoreData) []EmployeeMMAScore {
	rs := make([]EmployeeMMAScore, len(in))
	for i, v := range in {
		rs[i] = EmployeeMMAScore{
			EmployeeID:    v.EmployeeID.String(),
			FullName:      v.FullName,
			MMAID:         v.MMAID.String(),
			MasteryScore:  v.MasteryScore,
			AutonomyScore: v.AutonomyScore,
			MeaningScore:  v.MeaningScore,
			RatedAt:       v.RatedAt,
		}
	}

	return rs
}

type CheckInResponse struct {
	DiscordID       string  `json:"discordID"`
	IcyAmount       float64 `json:"icyAmount"`
	TransactionID   string  `json:"transactionID"`
	TransactionHash string  `json:"transactionHash"`
	Err             string  `json:"err"`
} // @name CheckInResponse

```

# pkg/view/earns.go

```go
package view

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/mochipay"
)

type MochiTransaction struct {
	ID                 string                 `json:"id"`
	FromProfileID      string                 `json:"fromProfileID"`
	OtherProfileID     string                 `json:"otherProfileID"`
	FromProfileSource  string                 `json:"fromProfileSource"`
	OtherProfileSource string                 `json:"otherProfileSource"`
	SourcePlatform     string                 `json:"sourcePlatform"`
	Amount             string                 `json:"amount"`
	TokenID            string                 `json:"tokenID"`
	ChainID            string                 `json:"chainID"`
	InternalID         int64                  `json:"internalID"`
	ExternalID         string                 `json:"externalID"`
	OnchainTxHash      string                 `json:"onchainTxHash"`
	Type               string                 `json:"type"`
	Action             string                 `json:"action"`
	Status             string                 `json:"status"`
	CreatedAt          time.Time              `json:"createdAt"`
	UpdatedAt          time.Time              `json:"updatedAt"`
	ExpiredAt          *time.Time             `json:"expiredAt"`
	SettledAt          *time.Time             `json:"settledAt"`
	Token              *Token                 `json:"token"`
	OriginalTxID       string                 `json:"originalTxID"`
	OtherProfile       *MochiProfile          `json:"otherProfile"`
	FromProfile        *MochiProfile          `json:"fromProfile"`
	OtherProfiles      []MochiProfile         `json:"otherProfiles"`
	AmountEachProfiles []AmountEachProfiles   `json:"amountEachProfiles"`
	USDAmount          float64                `json:"usdAmount"`
	Metadata           map[string]interface{} `json:"metadata"`
	OtherProfileIds    []string               `json:"otherProfileIds"`
	TotalAmount        string                 `json:"totalAmount"`
	FromTokenId        string                 `json:"fromTokenId"`
	ToTokenId          string                 `json:"toTokenId"`
	FromToken          *Token                 `json:"fromToken,omitempty"`
	ToToken            *Token                 `json:"toToken,omitempty"`
	FromAmount         string                 `json:"fromAmount"`
	ToAmount           string                 `json:"toAmount"`
} // @name MochiTransaction

type Token struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Symbol      string  `json:"symbol"`
	Decimal     int64   `json:"decimal"`
	ChainID     string  `json:"chainID"`
	Native      bool    `json:"native"`
	Address     string  `json:"address"`
	Icon        string  `json:"icon"`
	CoinGeckoID string  `json:"coinGeckoID"`
	Price       float64 `json:"price"`
	Chain       *Chain  `json:"chain"`
} // @name Token

type Chain struct {
	ID       string `json:"id"`
	ChainID  string `json:"chainID"`
	Name     string `json:"name"`
	Symbol   string `json:"symbol"`
	RPC      string `json:"rpc"`
	Explorer string `json:"explorer"`
	Icon     string `json:"icon"`
	Type     string `json:"type"`
} // @name Chain

type MochiProfile struct {
	ID                 string               `json:"id"`
	CreatedAt          string               `json:"createdAt"`
	UpdatedAt          string               `json:"updatedAt"`
	ProfileName        string               `json:"profileName"`
	Avatar             string               `json:"avatar"`
	AssociatedAccounts []AssociatedAccounts `json:"associatedAccounts"`
	Type               string               `json:"type"`
	Application        *Application         `json:"application"`
} // @name MochiProfile

type Application struct {
	ID                   int     `json:"id"`
	Name                 string  `json:"name"`
	OwnerProfileID       string  `json:"ownerProfileID"`
	ServiceFee           float64 `json:"serviceFee"`
	ApplicationProfileID string  `json:"applicationProfileID"`
	Active               bool    `json:"active"`
} // @name Application

type AssociatedAccounts struct {
	ID                 string      `json:"id"`
	ProfileID          string      `json:"profileID"`
	Platform           string      `json:"platform"`
	PlatformIdentifier string      `json:"platformIdentifier"`
	PlatformMetadata   interface{} `json:"platformMetadata"`
	IsGuildMember      bool        `json:"isGuildMember"`
	CreatedAt          string      `json:"createdAt"`
	UpdatedAt          string      `json:"updatedAt"`
} // @name AssociatedAccounts

type AmountEachProfiles struct {
	ProfileID string  `json:"profileID"`
	Amount    string  `json:"amount"`
	UsdAmount float64 `json:"usdAmount"`
} // @name AmountEachProfiles

func toMochiTransaction(data mochipay.TransactionData) MochiTransaction {
	return MochiTransaction{
		ID:                 data.Id,
		FromProfileID:      data.FromProfileId,
		OtherProfileID:     data.OtherProfileId,
		FromProfileSource:  data.FromProfileSource,
		OtherProfileSource: data.OtherProfileSource,
		SourcePlatform:     data.SourcePlatform,
		Amount:             data.Amount,
		TokenID:            data.TokenId,
		ChainID:            data.ChainId,
		InternalID:         data.InternalId,
		ExternalID:         data.ExternalId,
		OnchainTxHash:      data.OnchainTxHash,
		Type:               string(data.Type),
		Action:             string(data.Action),
		Status:             string(data.Status),
		CreatedAt:          data.CreatedAt,
		UpdatedAt:          data.UpdatedAt,
		ExpiredAt:          data.ExpiredAt,
		SettledAt:          data.SettledAt,
		Token:              toToken(data.Token),
		OriginalTxID:       data.OriginalTxId,
		OtherProfile:       toMochiProfile(data.OtherProfile),
		FromProfile:        toMochiProfile(data.FromProfile),
		OtherProfiles:      toMochiProfiles(data.OtherProfiles),
		AmountEachProfiles: toAmountEachProfiles(data.AmountEachProfiles),
		USDAmount:          data.UsdAmount,
		Metadata:           data.Metadata,
		OtherProfileIds:    data.OtherProfileIds,
		TotalAmount:        data.TotalAmount,
		FromTokenId:        data.FromTokenId,
		ToTokenId:          data.ToTokenId,
		FromToken:          toToken(data.FromToken),
		ToToken:            toToken(data.ToToken),
		FromAmount:         data.FromAmount,
		ToAmount:           data.ToAmount,
	}
}

func toToken(data *mochipay.Token) *Token {
	if data == nil {
		return nil
	}
	return &Token{
		ID:          data.Id,
		Name:        data.Name,
		Symbol:      data.Symbol,
		Decimal:     data.Decimal,
		ChainID:     data.ChainId,
		Native:      data.Native,
		Address:     data.Address,
		Icon:        data.Icon,
		CoinGeckoID: data.CoinGeckoId,
		Price:       data.Price,
		Chain:       toChain(data.Chain),
	}
}

func toChain(data *mochipay.Chain) *Chain {
	if data == nil {
		return nil
	}

	return &Chain{
		ID:       data.Id,
		ChainID:  data.ChainId,
		Name:     data.Name,
		Symbol:   data.Symbol,
		RPC:      data.Rpc,
		Explorer: data.Explorer,
		Icon:     data.Icon,
		Type:     data.Type,
	}
}

func toMochiProfile(data *mochipay.MochiProfile) *MochiProfile {
	if data == nil {
		return nil
	}

	return &MochiProfile{
		ID:                 data.Id,
		CreatedAt:          data.CreatedAt,
		UpdatedAt:          data.UpdatedAt,
		ProfileName:        data.ProfileName,
		Avatar:             data.Avatar,
		AssociatedAccounts: toAssociatedAccounts(data.AssociatedAccounts),
		Type:               data.Type,
		Application:        toApplication(data.Application),
	}
}

func toApplication(data *mochipay.Application) *Application {
	if data == nil {
		return nil
	}

	return &Application{
		ID:                   data.Id,
		Name:                 data.Name,
		OwnerProfileID:       data.OwnerProfileId,
		ServiceFee:           data.ServiceFee,
		ApplicationProfileID: data.ApplicationProfileId,
		Active:               data.Active,
	}
}

func toMochiProfiles(data []mochipay.MochiProfile) []MochiProfile {
	result := make([]MochiProfile, len(data))
	for _, item := range data {
		result = append(result, *toMochiProfile(&item))
	}
	return result
}

func toAssociatedAccounts(data []mochipay.AssociatedAccounts) []AssociatedAccounts {
	result := make([]AssociatedAccounts, len(data))
	for i, item := range data {
		result[i] = AssociatedAccounts{
			ID:                 item.Id,
			ProfileID:          item.ProfileId,
			Platform:           item.Platform,
			PlatformIdentifier: item.PlatformIdentifier,
			PlatformMetadata:   item.PlatformMetadata,
			IsGuildMember:      item.IsGuildMember,
			CreatedAt:          item.CreatedAt,
			UpdatedAt:          item.UpdatedAt,
		}
	}
	return result
}

func toAmountEachProfiles(data []mochipay.AmountEachProfiles) []AmountEachProfiles {
	result := make([]AmountEachProfiles, len(data))
	for i, item := range data {
		result[i] = AmountEachProfiles{
			ProfileID: item.ProfileId,
			Amount:    item.Amount,
			UsdAmount: item.UsdAmount,
		}
	}
	return result
}

func ToEmployeeEarnsTransactions(report model.EmployeeEarnTransactions) []MochiTransaction {
	var result []MochiTransaction
	for _, r := range report {
		result = append(result, toMochiTransaction(r))
	}
	return result
}

type GetEmployeeEarnTransactionsResponse struct {
	Pagination
	Total int64 `json:"total"`

	Data []MochiTransaction `json:"data"`
} // @name GetEmployeeEarnTransactionsResponse

type EmployeeTotalEarn struct {
	TotalEarnsICY string `json:"totalEarnsICY"`
	TotalEarnsUSD string `json:"totalEarnsUSD"`
} // @name EmployeeTotalEarn

type GetEmployeeTotalEarnResponse struct {
	Data EmployeeTotalEarn `json:"data"`
} // @name GetEmployeeTotalEarnResponse

```

# pkg/view/earn.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

// Earn represents memo earn
type Earn struct {
	Title    string   `json:"title"`
	Bounty   string   `json:"bounty"`
	Status   string   `json:"status"`
	PICs     []string `json:"pics"`
	Function string   `json:"function"`
	URL      string   `json:"url"`
} // @name Earn

type ListEarnResponse struct {
	Data []Earn `json:"earns"`
} // @name ListEarnResponse

func ToEarns(earns []model.Earn) []Earn {
	res := make([]Earn, 0)
	for _, earn := range earns {
		res = append(res, Earn{
			Title:    earn.Title,
			Bounty:   earn.Bounty,
			Status:   earn.Status,
			PICs:     earn.PICs,
			Function: earn.Function,
			URL:      earn.URL,
		})
	}

	return res
}

```

# pkg/view/discord_event.go

```go
package view

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

// Event struct
type DiscordEvent struct {
	ID               string     `json:"id"`
	Name             string     `json:"name"`
	Description      string     `json:"description"`
	Date             time.Time  `json:"date"`
	DiscordEventID   string     `json:"discord_event_id"`
	DiscordChannelID string     `json:"discord_channel_id"`
	DiscordMessageID string     `json:"discord_message_id"`
	DiscordCreatorID string     `json:"discord_creator_id"`
	EventType        string     `json:"type"`
	CreatedAt        time.Time  `json:"createdAt"`
	UpdatedAt        *time.Time `json:"updatedAt"`
}

func ToDiscordEvent(event model.Event) DiscordEvent {
	return DiscordEvent{
		ID:               event.ID.String(),
		Name:             event.Name,
		Description:      event.Description,
		Date:             event.Date,
		EventType:        event.EventType.String(),
		DiscordEventID:   event.DiscordEventID,
		DiscordChannelID: event.DiscordChannelID,
		DiscordMessageID: event.DiscordMessageID,
		DiscordCreatorID: event.DiscordCreatorID,
		CreatedAt:        event.CreatedAt,
		UpdatedAt:        event.UpdatedAt,
	}
}

```

# pkg/view/delivery_metric.go

```go
package view

import (
	"time"

	"github.com/shopspring/decimal"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type DeliveryMetricWeeklyReport struct {
	LastWeek    DeliveryMetricWeekReport `json:"lastWeek"`
	CurrentWeek DeliveryMetricWeekReport `json:"currentWeek"`

	TotalPointChangePercentage float32 `json:"totalPointChangePercentage"`
	EffortChangePercentage     float32 `json:"effortChangePercentage"`
	AvgPointChangePercentage   float32 `json:"avgPointChangePercentage"`
	AvgEffortChangePercentage  float32 `json:"avgEffortChangePercentage"`
}

type DeliveryMetricWeekReport struct {
	Date        *time.Time `json:"date"`
	TotalPoints float32    `json:"totalPoints"`
	Effort      float32    `json:"effort"`
	AvgPoint    float32    `json:"avgPoint"`
	AvgEffort   float32    `json:"avgEffort"`
}

type DeliveryLeaderBoardResponse struct {
	Data WeeklyLeaderBoard `json:"data"`
}

type WeeklyLeaderBoard struct {
	Date  *time.Time        `json:"date"`
	Items []LeaderBoardItem `json:"items"`
}

type LeaderBoardItem struct {
	EmployeeID      string          `json:"employeeID"`
	EmployeeName    string          `json:"employeeName"`
	Points          decimal.Decimal `json:"points"`
	Effectiveness   decimal.Decimal `json:"effectiveness"`
	DiscordID       string          `json:"discordID"`
	DiscordUsername string          `json:"discordUsername"`
	Rank            int             `json:"rank"`
}

func ToDeliveryMetricLeaderBoard(board *model.LeaderBoard) *WeeklyLeaderBoard {
	items := make([]LeaderBoardItem, 0, len(board.Items))
	// Get user info
	for _, m := range board.Items {
		items = append(items, LeaderBoardItem{
			EmployeeID:      m.EmployeeID,
			EmployeeName:    m.EmployeeName,
			Points:          m.Points,
			Effectiveness:   m.Effectiveness,
			DiscordID:       m.DiscordID,
			DiscordUsername: m.DiscordUsername,
			Rank:            m.Rank,
		})
	}

	return &WeeklyLeaderBoard{
		Date:  board.Date,
		Items: items,
	}
}

func ToDeliveryMetricWeeklyReport(in *model.WeeklyReport) *DeliveryMetricWeeklyReport {
	return &DeliveryMetricWeeklyReport{
		LastWeek: DeliveryMetricWeekReport{
			Date:        in.LastWeek.Date,
			TotalPoints: in.LastWeek.TotalPoints,
			Effort:      in.LastWeek.Effort,
			AvgPoint:    in.LastWeek.AvgPoint,
			AvgEffort:   in.LastWeek.AvgEffort,
		},
		CurrentWeek: DeliveryMetricWeekReport{
			Date:        in.CurrentWeek.Date,
			TotalPoints: in.CurrentWeek.TotalPoints,
			Effort:      in.CurrentWeek.Effort,
			AvgPoint:    in.CurrentWeek.AvgPoint,
			AvgEffort:   in.CurrentWeek.AvgEffort,
		},
		TotalPointChangePercentage: in.TotalPointChangePercentage,
		EffortChangePercentage:     in.EffortChangePercentage,
		AvgPointChangePercentage:   in.AvgPointChangePercentage,
		AvgEffortChangePercentage:  in.AvgEffortChangePercentage,
	}
}

func ToDeliveryMetricMonthlyReport(current model.MonthReport, prev model.MonthReport) *DeliveryMetricMonthlyReport {
	return &DeliveryMetricMonthlyReport{
		CurrentMonth: DeliveryMetricMonthlyReportItem{
			Month:           current.Month,
			TotalWeight:     current.TotalWeight,
			Effort:          current.Effort,
			AvgWeight:       current.AvgWeight,
			AvgEffort:       current.AvgEffort,
			AvgWeeklyWeight: current.AvgWeeklyWeight,
			AvgWeeklyEffort: current.AvgWeeklyEffort,
		},
		LastMonth: DeliveryMetricMonthlyReportItem{
			Month:           prev.Month,
			TotalWeight:     prev.TotalWeight,
			Effort:          prev.Effort,
			AvgWeight:       prev.AvgWeight,
			AvgEffort:       prev.AvgEffort,
			AvgWeeklyWeight: prev.AvgWeeklyWeight,
			AvgWeeklyEffort: prev.AvgWeeklyEffort,
		},

		TotalPointChangePercentage:      current.TotalPointChangePercentage,
		EffortChangePercentage:          current.EffortChangePercentage,
		AvgWeightChangePercentage:       current.AvgWeightChangePercentage,
		AvgEffortChangePercentage:       current.AvgEffortChangePercentage,
		AvgWeeklyPointChangePercentage:  current.AvgWeeklyPointChangePercentage,
		AvgWeeklyEffortChangePercentage: current.AvgWeeklyEffortChangePercentage,
	}
}

type DeliveryMetricMonthlyReport struct {
	CurrentMonth DeliveryMetricMonthlyReportItem `json:"currentMonth"`
	LastMonth    DeliveryMetricMonthlyReportItem `json:"lastMonth"`

	TotalPointChangePercentage      float32 `json:"totalPointChangePercentage"`
	EffortChangePercentage          float32 `json:"effortChangePercentage"`
	AvgWeightChangePercentage       float32 `json:"avgWeightChangePercentage"`
	AvgEffortChangePercentage       float32 `json:"avgEffortChangePercentage"`
	AvgWeeklyPointChangePercentage  float32 `json:"avgWeeklyPointChangePercentage"`
	AvgWeeklyEffortChangePercentage float32 `json:"avgWeeklyEffortChangePercentage"`
}

type DeliveryMetricMonthlyReportItem struct {
	Month       *time.Time `json:"date"`
	TotalWeight float32    `json:"totalWeight"`
	Effort      float32    `json:"effort"`

	AvgWeight       float32 `json:"avgWeight"`
	AvgEffort       float32 `json:"avgEffort"`
	AvgWeeklyWeight float32 `json:"avgWeeklyWeight"`
	AvgWeeklyEffort float32 `json:"avgWeeklyEffort"`
}

type MonthlyLeaderBoard struct {
	Date  *time.Time        `json:"date"`
	Items []LeaderBoardItem `json:"items"`
}

```

# pkg/view/dashboard.go

```go
package view

import (
	"math"
	"sort"
	"strings"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"golang.org/x/exp/slices"
)

type EngagementDashboardQuestionStat struct {
	Title     string     `json:"title"`
	StartDate *time.Time `json:"startDate"`
	Point     float64    `json:"point"`
} // @name EngagementDashboardQuestionStat
type EngagementDashboard struct {
	Content    string                            `json:"content"`
	QuestionID string                            `json:"questionID"`
	Stats      []EngagementDashboardQuestionStat `json:"stats"`
} // @name EngagementDashboard

type EngagementDashboardQuestionDetailStat struct {
	Field     string     `json:"field"`
	StartDate *time.Time `json:"startDate"`
	Point     float64    `json:"point"`
} // @name EngagementDashboardQuestionDetailStat

type EngagementDashboardDetail struct {
	QuestionID string                                  `json:"questionID"`
	Stats      []EngagementDashboardQuestionDetailStat `json:"stats"`
} // @name EngagementDashboardDetail

type ProjectSizeResponse struct {
	Data []*ProjectSize `json:"data"`
} // @name ProjectSizeResponse

type ProjectSize struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Code   string `json:"code"`
	Avatar string `json:"avatar"`
	Size   int64  `json:"size"`
} // @name ProjectSize

func ToProjectSizes(projects []*model.ProjectSize) []*ProjectSize {
	var rs []*ProjectSize
	for _, p := range projects {
		rs = append(rs, &ProjectSize{
			ID:     p.ID.String(),
			Name:   p.Name,
			Code:   p.Code,
			Avatar: p.Avatar,
			Size:   p.Size,
		})
	}

	return rs
}

type WorkSurveyResponse struct {
	Data WorkSurveysData `json:"data"`
} // @name WorkSurveyResponse

type Trend struct {
	Workload float64 `json:"workload"`
	Deadline float64 `json:"deadline"`
	Learning float64 `json:"learning"`
} // @name Trend

type WorkSurvey struct {
	EndDate  string  `json:"endDate"`
	Workload float64 `json:"workload"`
	Deadline float64 `json:"deadline"`
	Learning float64 `json:"learning"`
	Trend    Trend   `json:"trend"`
} // @name WorkSurvey

type ActionItemTrend struct {
	High   float64 `json:"high"`
	Medium float64 `json:"medium"`
	Low    float64 `json:"low"`
} // @name ActionItemTrend

type AuditActionItemReport struct {
	Quarter string          `json:"quarter"`
	High    int64           `json:"high"`
	Medium  int64           `json:"medium"`
	Low     int64           `json:"low"`
	Trend   ActionItemTrend `json:"trend"`
} // @name AuditActionItemReport

type WorkSurveysData struct {
	Project     *BasicProjectInfo `json:"project"`
	WorkSurveys []*WorkSurvey     `json:"workSurveys"`
} // @name WorkSurveysData

type ActionItemReportResponse struct {
	AuditActionItemReports []*AuditActionItemReport `json:"data"`
} // @name ActionItemReportResponse

func ToWorkSurveyData(project *model.Project, workSurveys []*model.WorkSurvey) *WorkSurveysData {
	rs := &WorkSurveysData{}

	for _, ws := range workSurveys {
		rs.WorkSurveys = append(rs.WorkSurveys, &WorkSurvey{
			EndDate:  ws.EndDate.Format("02/01"),
			Workload: ws.Workload,
			Deadline: ws.Deadline,
			Learning: ws.Learning,
		})
	}

	if project != nil {
		rs.Project = toBasicProjectInfo(*project)
	}

	if len(workSurveys) > 1 {
		for i := 1; i < len(workSurveys); i++ {
			rs.WorkSurveys[i].Trend = calculateTrend(workSurveys[i-1], workSurveys[i])
		}
	}

	return rs
}

func ToActionItemReportData(actionItemReports []*model.ActionItemReport) []*AuditActionItemReport {
	var rs []*AuditActionItemReport
	// reverse the order to correct timeline
	for i, j := 0, len(actionItemReports)-1; i < j; i, j = i+1, j-1 {
		actionItemReports[i], actionItemReports[j] = actionItemReports[j], actionItemReports[i]
	}
	for _, ws := range actionItemReports {
		rs = append(rs, &AuditActionItemReport{
			Quarter: strings.Split(ws.Quarter, "/")[1] + "/" + strings.Split(ws.Quarter, "/")[0],
			High:    ws.High,
			Medium:  ws.Medium,
			Low:     ws.Low,
		})
	}

	if len(actionItemReports) > 1 {
		for i := 1; i < len(actionItemReports); i++ {
			rs[i].Trend = calculateActionItemReportTrend(actionItemReports[i-1], actionItemReports[i])
		}
	}

	return rs
}

// calculateTrend calculate the trend for work survey
func calculateTrend(previous *model.WorkSurvey, current *model.WorkSurvey) Trend {
	rs := Trend{}

	// if previous or current value = 0 trend = 0
	if previous.Workload == 0 || current.Workload == 0 {
		rs.Workload = 0
	} else {
		rs.Workload = (current.Workload - previous.Workload) / previous.Workload * 100
	}

	if previous.Deadline == 0 || current.Deadline == 0 {
		rs.Deadline = 0
	} else {
		rs.Deadline = (current.Deadline - previous.Deadline) / previous.Deadline * 100
	}

	if previous.Learning == 0 || current.Learning == 0 {
		rs.Learning = 0
	} else {
		rs.Learning = (current.Learning - previous.Learning) / previous.Learning * 100
	}

	return rs
}

// calculateTrend calculate the trend for action item report
func calculateActionItemReportTrend(previous *model.ActionItemReport, current *model.ActionItemReport) ActionItemTrend {
	rs := ActionItemTrend{}

	// if previous or current value = 0 trend = 0
	if previous.High == 0 || current.High == 0 {
		rs.High = 0
	} else {
		rs.High = float64(current.High-previous.High) / float64(previous.High) * 100
	}

	if previous.Medium == 0 || current.Medium == 0 {
		rs.Medium = 0
	} else {
		rs.Medium = float64(current.Medium-previous.Medium) / float64(previous.Medium) * 100
	}

	if previous.Low == 0 || current.Low == 0 {
		rs.Low = 0
	} else {
		rs.Low = float64(current.Low-previous.Low) / float64(previous.Low) * 100
	}

	return rs
}

type EngineeringHealthResponse struct {
	Data EngineeringHealthData `json:"data"`
} // @name EngineeringHealthResponse

type EngineeringHealthData struct {
	Average []*EngineeringHealth      `json:"average"`
	Groups  []*GroupEngineeringHealth `json:"groups"`
} // @name EngineeringHealthData

type EngineeringHealth struct {
	Quarter string  `json:"quarter"`
	Value   float64 `json:"avg"`
	Trend   float64 `json:"trend"`
} // @name EngineeringHealth

type GroupEngineeringHealth struct {
	Quarter       string                 `json:"quarter"`
	Delivery      float64                `json:"delivery"`
	Quality       float64                `json:"quality"`
	Collaboration float64                `json:"collaboration"`
	Feedback      float64                `json:"feedback"`
	Trend         EngineeringHealthTrend `json:"trend"`
} // @name GroupEngineeringHealth

type EngineeringHealthTrend struct {
	Delivery      float64 `json:"delivery"`
	Quality       float64 `json:"quality"`
	Collaboration float64 `json:"collaboration"`
	Feedback      float64 `json:"feedback"`
} // @name EngineeringHealthTrend

func ToEngineeringHealthData(average []*model.AverageEngineeringHealth, groups []*model.GroupEngineeringHealth) *EngineeringHealthData {
	rs := &EngineeringHealthData{}

	// Reverse quarter order
	for i, j := 0, len(average)-1; i < j; i, j = i+1, j-1 {
		average[i], average[j] = average[j], average[i]
	}

	for i, j := 0, len(groups)-1; i < j; i, j = i+1, j-1 {
		groups[i], groups[j] = groups[j], groups[i]
	}

	for _, a := range average {
		rs.Average = append(rs.Average, &EngineeringHealth{
			Quarter: strings.Split(a.Quarter, "/")[1] + "/" + strings.Split(a.Quarter, "/")[0],
			Value:   a.Avg,
		})
	}

	calculateTrendForEngineeringHealthList(rs.Average)

	rs.Groups = toGroupEngineeringHealth(groups)
	calculateEngineeringHealthGroupTrend(rs.Groups)

	return rs
}

func toGroupEngineeringHealth(groups []*model.GroupEngineeringHealth) []*GroupEngineeringHealth {
	var rs []*GroupEngineeringHealth
	count := 0
	quarter := ""
	i := 0

	for i < len(groups) {
		if quarter != groups[i].Quarter {
			count++
			quarter = groups[i].Quarter

			if count > 4 {
				break
			}
		}

		rs = append(rs, &GroupEngineeringHealth{
			Quarter: strings.Split(groups[i].Quarter, "/")[1] + "/" + strings.Split(groups[i].Quarter, "/")[0],
		})

		for quarter == groups[i].Quarter {
			switch groups[i].Area {
			case model.AuditItemAreaDelivery:
				rs[count-1].Delivery = groups[i].Avg
			case model.AuditItemAreaQuality:
				rs[count-1].Quality = groups[i].Avg
			case model.AuditItemAreaCollaborating:
				rs[count-1].Collaboration = groups[i].Avg
			case model.AuditItemAreaFeedback:
				rs[count-1].Feedback = groups[i].Avg
			}

			i++
			if i >= len(groups) {
				break
			}
		}
	}

	return rs
}

func calculateTrendForEngineeringHealthList(healths []*EngineeringHealth) {
	for i := 1; i < len(healths); i++ {
		healths[i].Trend = calculateEngineeringHealthTrend(healths[i-1], healths[i])
	}
}

func calculateEngineeringHealthGroupTrend(groups []*GroupEngineeringHealth) {
	for i := 1; i < len(groups); i++ {
		groups[i].Trend.Delivery = calculateEngineeringHealthTrend(&EngineeringHealth{Value: groups[i-1].Delivery}, &EngineeringHealth{Value: groups[i].Delivery})
		groups[i].Trend.Quality = calculateEngineeringHealthTrend(&EngineeringHealth{Value: groups[i-1].Quality}, &EngineeringHealth{Value: groups[i].Quality})
		groups[i].Trend.Collaboration = calculateEngineeringHealthTrend(&EngineeringHealth{Value: groups[i-1].Collaboration}, &EngineeringHealth{Value: groups[i].Collaboration})
		groups[i].Trend.Feedback = calculateEngineeringHealthTrend(&EngineeringHealth{Value: groups[i-1].Feedback}, &EngineeringHealth{Value: groups[i].Feedback})
	}
}

func calculateEngineeringHealthTrend(previous *EngineeringHealth, current *EngineeringHealth) float64 {
	// if previous or current value = 0 trend = 0
	if previous.Value == 0 || current.Value == 0 {
		return 0
	}

	// return the value fixed 2 decimal places
	return math.Round((current.Value-previous.Value)/previous.Value*100*100) / 100
}

type AuditResponse struct {
	Data AuditData `json:"data"`
} // @name AuditResponse

type AuditData struct {
	Average []*Audit      `json:"average"`
	Groups  []*GroupAudit `json:"groups"`
} // @name AuditData

type Audit struct {
	Quarter string  `json:"quarter"`
	Value   float64 `json:"avg"`
	Trend   float64 `json:"trend"`
} // @name Audit

type GroupAudit struct {
	Quarter    string          `json:"quarter"`
	Frontend   float64         `json:"frontend"`
	Backend    float64         `json:"backend"`
	System     float64         `json:"system"`
	Process    float64         `json:"process"`
	Mobile     float64         `json:"mobile"`
	Blockchain float64         `json:"blockchain"`
	Trend      GroupAuditTrend `json:"trend"`
} // @name GroupAudit

type GroupAuditTrend struct {
	Frontend   float64 `json:"frontend"`
	Backend    float64 `json:"backend"`
	System     float64 `json:"system"`
	Process    float64 `json:"process"`
	Mobile     float64 `json:"mobile"`
	Blockchain float64 `json:"blockchain"`
} // @name GroupAuditTrend

func ToAuditData(average []*model.AverageAudit, groups []*model.GroupAudit) *AuditData {
	rs := &AuditData{}

	// Reverse quarter order
	for i, j := 0, len(average)-1; i < j; i, j = i+1, j-1 {
		average[i], average[j] = average[j], average[i]
	}

	for i, j := 0, len(groups)-1; i < j; i, j = i+1, j-1 {
		groups[i], groups[j] = groups[j], groups[i]
	}

	for _, a := range average {
		rs.Average = append(rs.Average, &Audit{
			Quarter: strings.Split(a.Quarter, "/")[1] + "/" + strings.Split(a.Quarter, "/")[0],
			Value:   a.Avg,
		})
	}

	calculateTrendForAuditList(rs.Average)

	rs.Groups = toGroupAudit(groups)
	calculateAuditGroupTrend(rs.Groups)

	return rs
}

func toGroupAudit(groups []*model.GroupAudit) []*GroupAudit {
	var rs []*GroupAudit

	for i := range groups {
		rs = append(rs, &GroupAudit{
			Quarter:    strings.Split(groups[i].Quarter, "/")[1] + "/" + strings.Split(groups[i].Quarter, "/")[0],
			Frontend:   groups[i].Frontend,
			Backend:    groups[i].Backend,
			System:     groups[i].System,
			Process:    groups[i].Process,
			Mobile:     groups[i].Mobile,
			Blockchain: groups[i].Blockchain,
		})
	}

	return rs
}

func calculateTrendForAuditList(healths []*Audit) {
	for i := 1; i < len(healths); i++ {
		healths[i].Trend = calculateAuditTrend(healths[i-1], healths[i])
	}
}

func calculateAuditGroupTrend(groups []*GroupAudit) {
	for i := 1; i < len(groups); i++ {
		groups[i].Trend.Frontend = calculateAuditTrend(&Audit{Value: groups[i-1].Frontend}, &Audit{Value: groups[i].Frontend})
		groups[i].Trend.Backend = calculateAuditTrend(&Audit{Value: groups[i-1].Backend}, &Audit{Value: groups[i].Backend})
		groups[i].Trend.System = calculateAuditTrend(&Audit{Value: groups[i-1].System}, &Audit{Value: groups[i].System})
		groups[i].Trend.Process = calculateAuditTrend(&Audit{Value: groups[i-1].Process}, &Audit{Value: groups[i].Process})
		groups[i].Trend.Mobile = calculateAuditTrend(&Audit{Value: groups[i-1].Mobile}, &Audit{Value: groups[i].Mobile})
		groups[i].Trend.Blockchain = calculateAuditTrend(&Audit{Value: groups[i-1].Blockchain}, &Audit{Value: groups[i].Blockchain})
	}
}

func calculateAuditTrend(previous *Audit, current *Audit) float64 {
	// if previous or current value = 0 trend = 0
	if previous.Value == 0 || current.Value == 0 {
		return 0
	}

	// return the value fixed 2 decimal places
	return math.Round((current.Value-previous.Value)/previous.Value*100*100) / 100
}

type ActionItemSquash struct {
	SnapDate string  `json:"snapDate"`
	Value    int64   `json:"value"`
	Trend    float64 `json:"trend"`
} // @name ActionItemSquash
type ActionItemSquashReport struct {
	All    []*ActionItemSquash `json:"all"`
	High   []*ActionItemSquash `json:"high"`
	Medium []*ActionItemSquash `json:"medium"`
	Low    []*ActionItemSquash `json:"low"`
} // @name ActionItemSquashReport

type ActionItemSquashReportResponse struct {
	Data *ActionItemSquashReport `json:"data"`
} // @name ActionItemSquashReportResponse

func ToActionItemSquashReportData(actionItemReports []*model.ActionItemSquashReport) *ActionItemSquashReport {
	rs := &ActionItemSquashReport{}
	// reverse the order to correct timeline
	for i, j := 0, len(actionItemReports)-1; i < j; i, j = i+1, j-1 {
		actionItemReports[i], actionItemReports[j] = actionItemReports[j], actionItemReports[i]
	}

	for _, item := range actionItemReports {
		date := item.SnapDate.Format("02/01")
		rs.All = append(rs.All, &ActionItemSquash{
			SnapDate: date,
			Value:    item.All,
		})
		rs.High = append(rs.High, &ActionItemSquash{
			SnapDate: date,
			Value:    item.High,
		})
		rs.Medium = append(rs.Medium, &ActionItemSquash{
			SnapDate: date,
			Value:    item.Medium,
		})
		rs.Low = append(rs.Low, &ActionItemSquash{
			SnapDate: date,
			Value:    item.Low,
		})
	}

	if len(actionItemReports) > 1 {
		calculateTrendForActionItemSquash(rs.All)
		calculateTrendForActionItemSquash(rs.High)
		calculateTrendForActionItemSquash(rs.Medium)
		calculateTrendForActionItemSquash(rs.Low)
	}

	return rs
}

func calculateTrendForActionItemSquash(items []*ActionItemSquash) {
	for i := 1; i < len(items); i++ {
		if items[i-1].Value == 0 || items[i].Value == 0 {
			items[i].Trend = 0
		}

		if float64(items[i-1].Value) != 0 {
			items[i].Trend = math.Floor(float64(items[i].Value-items[i-1].Value)/float64(items[i-1].Value)*100*100) / 100
		}
	}
}

type AuditValue struct {
	Value float64 `json:"value"`
	Trend float64 `json:"trend"`
} // @name AuditValue

type ItemValue struct {
	Value int64   `json:"value"`
	Trend float64 `json:"trend"`
} // @name ItemValue

type AuditSummary struct {
	ID           model.UUID `json:"id"`
	Name         string     `json:"name"`
	Code         string     `json:"code"`
	Avatar       string     `json:"avatar"`
	Size         ItemValue  `json:"size"`
	Health       AuditValue `json:"health"`
	Audit        AuditValue `json:"audit"`
	NewItem      ItemValue  `json:"newItem"`
	ResolvedItem ItemValue  `json:"resolvedItem"`
} // @name AuditSummary

type AuditSummaries struct {
	Summary []*AuditSummary `json:"summary"`
} // @name AuditSummaries

type AuditSummariesResponse struct {
	Data *AuditSummaries `json:"data"`
} // @name AuditSummariesResponse

func ToAuditSummary(summary []*model.AuditSummary, previousSize int) *AuditSummary {
	rs := &AuditSummary{
		ID:     summary[0].ID,
		Name:   summary[0].Name,
		Code:   summary[0].Code,
		Avatar: summary[0].Avatar,
	}

	// Size
	rs.Size.Value = summary[0].Size
	if previousSize != 0 {
		rs.Size.Trend = math.Round((float64(rs.Size.Value)-float64(previousSize))/float64(previousSize)*100*100) / 100
	}

	// Health and Audit value
	rs.Health.Value = summary[0].Health
	rs.Audit.Value = summary[0].Audit

	if len(summary) > 1 && summary[1].Audit != 0 && summary[0].Audit != 0 && summary[1].Health != 0 && summary[0].Health != 0 {
		rs.Health.Trend = math.Round((summary[0].Health-summary[1].Health)/summary[1].Health*100*100) / 100
		rs.Audit.Trend = math.Round((summary[0].Audit-summary[1].Audit)/summary[1].Audit*100*100) / 100
	}

	// New and Resolved item
	if summary[0].Size != 0 {
		rs.NewItem.Value = (summary[0].High + summary[0].Medium + summary[0].Low) / summary[0].Size
	}

	if len(summary) > 1 {
		var currentItem int64
		if summary[0].Size != 0 {
			currentItem = (summary[1].High + summary[1].Medium + summary[1].Low) / summary[0].Size
		}

		if currentItem != 0 {
			rs.NewItem.Trend = math.Round((float64(rs.NewItem.Value)-float64(currentItem))/float64(currentItem)*100*100) / 100
		}

		rs.ResolvedItem.Value = summary[1].Done
		if len(summary) > 2 && summary[2].Done != 0 {
			rs.ResolvedItem.Trend = math.Round((float64(summary[1].Done)-float64(summary[2].Done))/float64(summary[2].Done)*100*100) / 100
		}
	}

	return rs
}

func ToAuditSummaries(summaryMap map[model.UUID][]*model.AuditSummary, previousQuarterMap map[model.UUID]int64, allProjectsMap map[model.UUID]*model.ProjectSize) *AuditSummaries {
	rs := &AuditSummaries{}
	for _, summaries := range summaryMap {
		previouSize := 0

		delete(allProjectsMap, summaries[0].ID)
		if size, ok := previousQuarterMap[summaries[0].ID]; ok {
			previouSize = int(size)
		}

		rs.Summary = append(rs.Summary, ToAuditSummary(summaries, previouSize))
	}

	for projectID, project := range allProjectsMap {
		newAuditSummary := &AuditSummary{
			ID:     project.ID,
			Name:   project.Name,
			Code:   project.Code,
			Avatar: project.Avatar,
			Size:   ItemValue{Value: project.Size},
		}

		if size, ok := previousQuarterMap[projectID]; ok {
			previouSize := int(size)

			if previouSize != 0 && newAuditSummary.Size.Trend != 0 {
				newAuditSummary.Size.Trend = math.Round((float64(newAuditSummary.Size.Value)-float64(previouSize))/float64(previouSize)*100*100) / 100
			}
		}

		rs.Summary = append(rs.Summary, newAuditSummary)
	}

	sort.Slice(rs.Summary, func(i, j int) bool {
		return rs.Summary[i].Name < rs.Summary[j].Name
	})

	return rs
}

type AvailableSlot struct {
	ID        string           `json:"id"`
	Type      string           `json:"type"`
	Note      string           `json:"note"`
	CreatedAt string           `json:"createdAt"`
	Seniority Seniority        `json:"seniority"`
	Project   BasicProjectInfo `json:"project"`
	Positions []Position       `json:"positions"`
} // @name AvailableSlot

type AvailableEmployee struct {
	ID          string             `json:"id"`
	FullName    string             `json:"fullName"`
	DisplayName string             `json:"displayName"`
	Username    string             `json:"username"`
	Avatar      string             `json:"avatar"`
	Seniority   Seniority          `json:"seniority"`
	Positions   []Position         `json:"positions"`
	Stacks      []Stack            `json:"stacks"`
	Projects    []BasicProjectInfo `json:"projects"`
} // @name AvailableEmployee

type ResourceAvailability struct {
	Slots     []AvailableSlot     `json:"slots"`
	Employees []AvailableEmployee `json:"employees"`
} // @name ResourceAvailability

type ResourceAvailabilityResponse struct {
	Data ResourceAvailability `json:"data"`
} // @name ResourceAvailabilityResponse

func ToResourceAvailability(slots []*model.ProjectSlot, employees []*model.Employee) ResourceAvailability {
	var res ResourceAvailability

	for _, v := range slots {
		res.Slots = append(res.Slots, AvailableSlot{
			ID:        v.ID.String(),
			Type:      v.DeploymentType.String(),
			Note:      v.Note,
			CreatedAt: v.CreatedAt.String(),
			Seniority: ToSeniority(v.Seniority),
			Project:   *toBasicProjectInfo(v.Project),
			Positions: ToProjectSlotPositions(v.ProjectSlotPositions),
		})
	}

	for _, v := range employees {
		employee := AvailableEmployee{
			ID:          v.ID.String(),
			FullName:    v.FullName,
			DisplayName: v.DisplayName,
			Username:    v.Username,
			Avatar:      v.Avatar,
			Seniority:   ToSeniority(*v.Seniority),
			Positions:   ToEmployeePositions(v.EmployeePositions),
			Stacks:      ToEmployeeStacks(v.EmployeeStacks),
		}

		for _, pm := range v.ProjectMembers {
			project := toBasicProjectInfo(pm.Project)
			employee.Projects = append(employee.Projects, *project)
		}

		res.Employees = append(res.Employees, employee)
	}

	return res
}

func ToEngagementDashboard(statistic []*model.StatisticEngagementDashboard) []EngagementDashboard {
	questionMapper := make(map[string][]EngagementDashboardQuestionStat)
	questionIDMapper := make(map[string]string)
	for _, s := range statistic {
		questionMapper[s.Content] = append(questionMapper[s.Content], EngagementDashboardQuestionStat{
			Title:     strings.Replace(s.Title, ", ", "/", -1),
			StartDate: &s.StartDate,
			Point:     math.Floor(s.Point*100) / 100,
		})
		questionIDMapper[s.Content] = s.QuestionID.String()
	}

	dashboard := make([]EngagementDashboard, 0)

	for k, v := range questionMapper {
		sort.Slice(v, func(i, j int) bool {
			return v[i].StartDate.After(*v[j].StartDate)
		})
		dashboard = append(dashboard, EngagementDashboard{
			Content:    k,
			Stats:      v,
			QuestionID: questionIDMapper[k],
		})
	}

	sort.Slice(dashboard, func(i, j int) bool {
		return dashboard[i].Content < dashboard[j].Content
	})
	return dashboard
}

func ToEngagementDashboardDetails(statistic []*model.StatisticEngagementDashboard) []EngagementDashboardDetail {
	questionMapper := make(map[string][]EngagementDashboardQuestionDetailStat)
	for _, s := range statistic {
		questionMapper[s.QuestionID.String()] = append(questionMapper[s.QuestionID.String()], EngagementDashboardQuestionDetailStat{
			Field:     s.Name,
			StartDate: &s.StartDate,
			Point:     math.Floor(s.Point*100) / 100,
		})
	}

	dashboard := make([]EngagementDashboardDetail, 0)

	for k, v := range questionMapper {
		sort.Slice(v, func(i, j int) bool {
			return v[i].Point < v[j].Point
		})
		dashboard = append(dashboard, EngagementDashboardDetail{
			QuestionID: k,
			Stats:      v,
		})
	}

	sort.Slice(dashboard, func(i, j int) bool {
		return dashboard[i].QuestionID < dashboard[j].QuestionID
	})

	return dashboard
}

type GetEngagementDashboardResponse struct {
	Data []EngagementDashboard `json:"data"`
} // @name GetEngagementDashboardResponse

type GetEngagementDashboardDetailResponse struct {
	Data []EngagementDashboardDetail `json:"data"`
} // @name GetEngagementDashboardDetailResponse

type GetDashboardResourceUtilizationResponse struct {
	Data []ResourceUtilization `json:"data"`
} // @name GetDashboardResourceUtilizationResponse

type WorkUnitDistribution struct {
	Employee    BasicEmployeeInfo               `json:"employee"`
	Learning    WorkUnitDistributionLearning    `json:"learning"`
	Development WorkUnitDistributionDevelopment `json:"development"`
	Management  WorkUnitDistributionManagement  `json:"management"`
	Training    WorkUnitDistributionTraining    `json:"training"`
} // @name WorkUnitDistribution

func ManagementInfoToProjectHead(managementInfo *model.ManagementInfo) *WorkUnitDistributionWUProjectHead {
	return &WorkUnitDistributionWUProjectHead{
		Project: BasicProjectInfo{
			ID:     managementInfo.ID.String(),
			Name:   managementInfo.Name,
			Type:   managementInfo.Type.String(),
			Status: managementInfo.Status.String(),
			Avatar: managementInfo.Avatar,
			Code:   managementInfo.Code,
		},
		Position: managementInfo.Position.String(),
	}
}

func ToWorkUnitDistributionWU(workUnit *model.WorkUnit) *WorkUnitDistributionWU {
	return &WorkUnitDistributionWU{
		Project:      *toBasicProjectInfo(*workUnit.Project),
		WorkUnitName: workUnit.Name,
	}
}

type WorkUnitDistributionLearning struct {
	Total     int                       `json:"total"`
	WorkUnits []*WorkUnitDistributionWU `json:"workUnits"`
} // @name WorkUnitDistributionLearning

type WorkUnitDistributionDevelopment struct {
	Total     int                       `json:"total"`
	WorkUnits []*WorkUnitDistributionWU `json:"workUnits"`
} // @name WorkUnitDistributionDevelopment

type WorkUnitDistributionManagement struct {
	Total        int                                  `json:"total"`
	WorkUnits    []*WorkUnitDistributionWU            `json:"workUnits"`
	ProjectHeads []*WorkUnitDistributionWUProjectHead `json:"projectHeads"`
} // @name WorkUnitDistributionManagement

type WorkUnitDistributionTraining struct {
	Total     int                       `json:"total"`
	WorkUnits []*WorkUnitDistributionWU `json:"workUnits"`
	Mentees   []BasicEmployeeInfo       `json:"mentees"`
} // @name WorkUnitDistributionTraining

type WorkUnitDistributionWU struct {
	Project      BasicProjectInfo `json:"project"`
	WorkUnitName string           `json:"workUnitName"`
} // @name WorkUnitDistributionWU

type WorkUnitDistributionWUProjectHead struct {
	Project  BasicProjectInfo `json:"project"`
	Position string           `json:"position"`
} // @name WorkUnitDistributionWUProjectHead

type WorkUnitDistributionData struct {
	WorkUnitDistributions []*WorkUnitDistribution `json:"workUnitDistributions"`
} // @name WorkUnitDistributionData

func toWorkUnitDistributionWUProjectHeads(projectHeads []model.ProjectHead) []*WorkUnitDistributionWUProjectHead {
	rs := make([]*WorkUnitDistributionWUProjectHead, 0)

	for _, projectHead := range projectHeads {
		rs = append(rs, &WorkUnitDistributionWUProjectHead{
			Project:  *toBasicProjectInfo(projectHead.Project),
			Position: projectHead.Position.String(),
		})
	}

	return rs
}

func SortWorkUnitDistributionData(wudd *WorkUnitDistributionData, sortRequired model.SortOrder) *WorkUnitDistributionData {
	if sortRequired != "" {
		if sortRequired == model.SortOrderASC {
			sort.Slice(wudd.WorkUnitDistributions, func(i, j int) bool {
				return wudd.WorkUnitDistributions[i].Learning.Total+wudd.WorkUnitDistributions[i].Development.Total+wudd.WorkUnitDistributions[i].Management.Total+wudd.WorkUnitDistributions[i].Training.Total <
					wudd.WorkUnitDistributions[j].Learning.Total+wudd.WorkUnitDistributions[j].Development.Total+wudd.WorkUnitDistributions[j].Management.Total+wudd.WorkUnitDistributions[j].Training.Total
			})
		} else {
			sort.Slice(wudd.WorkUnitDistributions, func(i, j int) bool {
				return wudd.WorkUnitDistributions[i].Learning.Total+wudd.WorkUnitDistributions[i].Development.Total+wudd.WorkUnitDistributions[i].Management.Total+wudd.WorkUnitDistributions[i].Training.Total >
					wudd.WorkUnitDistributions[j].Learning.Total+wudd.WorkUnitDistributions[j].Development.Total+wudd.WorkUnitDistributions[j].Management.Total+wudd.WorkUnitDistributions[j].Training.Total
			})
		}
	}

	return wudd
}

func ToWorkUnitDistributionData(employees []*model.Employee, sort string) WorkUnitDistributionData {
	wuds := make([]*WorkUnitDistribution, 0)

	for _, employee := range employees {
		wud := &WorkUnitDistribution{
			Employee: *toBasicEmployeeInfo(*employee),
			Management: WorkUnitDistributionManagement{
				ProjectHeads: toWorkUnitDistributionWUProjectHeads(employee.Heads),
				Total:        len(employee.Heads),
			},
			Training: WorkUnitDistributionTraining{
				Mentees: ToBasicEmployees(employee.Mentees),
				Total:   len(employee.Mentees),
			},
		}

		for _, wum := range employee.WorkUnitMembers {
			switch wum.WorkUnit.Type {
			case model.WorkUnitTypeLearning:
				wud.Learning.WorkUnits = append(wud.Learning.WorkUnits, ToWorkUnitDistributionWU(&wum.WorkUnit))
				wud.Learning.Total++
			case model.WorkUnitTypeDevelopment:
				wud.Development.WorkUnits = append(wud.Development.WorkUnits, ToWorkUnitDistributionWU(&wum.WorkUnit))
				wud.Development.Total++
			case model.WorkUnitTypeManagement:
				wud.Management.WorkUnits = append(wud.Management.WorkUnits, ToWorkUnitDistributionWU(&wum.WorkUnit))
				wud.Management.Total++
			case model.WorkUnitTypeTraining:
				wud.Training.WorkUnits = append(wud.Training.WorkUnits, ToWorkUnitDistributionWU(&wum.WorkUnit))
				wud.Training.Total++
			}
		}
		wuds = append(wuds, wud)
	}

	return *SortWorkUnitDistributionData(&WorkUnitDistributionData{
		WorkUnitDistributions: wuds,
	}, model.SortOrder(sort))
}

type SummaryWorkUnitDistributionData struct {
	Learning    float64 `json:"learning"`
	Development float64 `json:"development"`
	Management  float64 `json:"management"`
	Training    float64 `json:"training"`
} // @name SummaryWorkUnitDistributionData

type SummaryWorkUnitDistributionResponse struct {
	Data *SummaryWorkUnitDistributionData `json:"data"`
} // @name SummaryWorkUnitDistributionResponse

func ToSummaryWorkUnitDistributionData(data *model.TotalWorkUnitDistribution) *SummaryWorkUnitDistributionData {
	total := data.TotalLineManagerCount + data.TotalProjectHead + data.TotalLearning + data.TotalDevelopment + data.TotalManagement + data.TotalTraining
	rs := &SummaryWorkUnitDistributionData{}

	rs.Learning = math.Round(float64(data.TotalLearning+data.TotalLineManagerCount)/float64(total)*100*100) / 100
	rs.Development = math.Round(float64(data.TotalDevelopment)/float64(total)*100*100) / 100
	rs.Management = math.Round(float64(data.TotalManagement+data.TotalProjectHead)/float64(total)*100*100) / 100
	rs.Training = math.Round(float64(data.TotalTraining)/float64(total)*100*100) / 100

	return rs
}

type WorkUnitDistributionsResponse struct {
	Data *WorkUnitDistributionData `json:"data"`
} // @name WorkUnitDistributionsResponse

type WorkSurveySummaryAnswer struct {
	Answer  string           `json:"answer"`
	Project BasicProjectInfo `json:"project"`
} // @name WorkSurveySummaryAnswer

type WorkSurveySummaryListAnswer struct {
	Date    string                    `json:"date"`
	Answers []WorkSurveySummaryAnswer `json:"answers"`
} // @name WorkSurveySummaryListAnswer

type WorkSurveySummaryEmployee struct {
	Reviewer    BasicEmployeeInfo             `json:"reviewer"`
	ListAnswers []WorkSurveySummaryListAnswer `json:"listAnswers"`
} // @name WorkSurveySummaryEmployee

type WorkSurveySummary struct {
	Type  string                      `json:"type"`
	Dates []string                    `json:"dates"`
	Data  []WorkSurveySummaryEmployee `json:"data"`
} // @name WorkSurveySummary

type WorkSurveySummaryResponse struct {
	PaginationResponse
	Data []WorkSurveySummary `json:"data"`
} // @name WorkSurveySummaryResponse

func ToWorkSummaries(eers []*model.EmployeeEventReviewer) []WorkSurveySummary {
	rs := []WorkSurveySummary{
		{
			Type: model.QuestionDomainWorkload.String(),
		},
		{
			Type: model.QuestionDomainDeadline.String(),
		},
		{
			Type: model.QuestionDomainLearning.String(),
		},
	}

	domainMap := map[model.QuestionDomain]*WorkSurveySummary{
		model.QuestionDomainWorkload: &rs[0],
		model.QuestionDomainDeadline: &rs[1],
		model.QuestionDomainLearning: &rs[2],
	}

	answerMap := map[model.QuestionDomain]map[model.UUID]map[string][]WorkSurveySummaryAnswer{
		model.QuestionDomainWorkload: make(map[model.UUID]map[string][]WorkSurveySummaryAnswer),
		model.QuestionDomainDeadline: make(map[model.UUID]map[string][]WorkSurveySummaryAnswer),
		model.QuestionDomainLearning: make(map[model.UUID]map[string][]WorkSurveySummaryAnswer),
	}

	employeeMap := make(map[model.UUID]model.Employee)

	listDate := make([]string, 0)
	for _, eer := range eers {
		employeeMap[eer.ReviewerID] = *eer.Reviewer

		// to order date
		date := eer.Event.EndDate.Format("02/01/2006")
		if !slices.Contains(listDate, date) {
			listDate = append(listDate, date)
		}

		for _, eeq := range eer.EmployeeEventQuestions {
			answer := WorkSurveySummaryAnswer{
				Answer:  model.AgreementLevelValueMap[eeq.Answer].String(),
				Project: *toBasicProjectInfo(*eer.EmployeeEventTopic.Project),
			}

			if answerMap[eeq.Domain][eer.ReviewerID] == nil {
				answerMap[eeq.Domain][eer.ReviewerID] = make(map[string][]WorkSurveySummaryAnswer)
			}
			answerMap[eeq.Domain][eer.ReviewerID][date] = append(answerMap[eeq.Domain][eer.ReviewerID][date], answer)
		}
	}

	for domain, eIDMap := range answerMap {
		domainMap[domain].Dates = listDate

		for eID, dateMap := range eIDMap {
			listAnswers := make([]WorkSurveySummaryListAnswer, 0)

			for _, date := range listDate {
				if dateMap[date] != nil && len(dateMap[date]) > 0 {
					listAnswers = append(listAnswers, WorkSurveySummaryListAnswer{
						Date:    date,
						Answers: dateMap[date],
					})
				}
			}

			employee := WorkSurveySummaryEmployee{
				Reviewer:    *toBasicEmployeeInfo(employeeMap[eID]),
				ListAnswers: listAnswers,
			}

			domainMap[domain].Data = append(domainMap[domain].Data, employee)
		}
	}

	return rs
}

type ResourceUtilization struct {
	Date      time.Time `json:"date"`
	Staffed   int       `json:"staffed"`
	Internal  int       `json:"internal"`
	Available int       `json:"available"`
} // @name ResourceUtilization

func ToReSourceUtilizations(data []*model.ResourceUtilization) []ResourceUtilization {
	rs := make([]ResourceUtilization, 0, len(data))

	for _, v := range data {
		rs = append(rs, ResourceUtilization{
			Date:      v.Date,
			Staffed:   v.Staffed,
			Internal:  v.Internal,
			Available: v.Available,
		})
	}

	return rs
}

```

# pkg/view/currency.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type Currency struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Symbol string `json:"symbol"`
	Locale string `json:"locale"`
	Type   string `json:"type"`
} // @name Currency

func toCurrency(c *model.Currency) *Currency {
	if c == nil {
		return nil
	}
	return &Currency{
		ID:     c.ID.String(),
		Name:   c.Name,
		Symbol: c.Symbol,
		Locale: c.Locale,
		Type:   c.Type,
	}
}

func ToCurrencies(c []model.Currency) []Currency {
	rs := make([]Currency, 0)
	for i := range c {
		rs = append(rs, *toCurrency(&c[i]))
	}
	return rs
}

type GetCurrenciesResponse struct {
	Data []Currency `json:"data"`
} // @name GetCurrenciesResponse

```

# pkg/view/company_info.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

func ToCompanyInfos(companies []*model.CompanyInfo) []CompanyInfo {
	rs := make([]CompanyInfo, 0, len(companies))
	for _, com := range companies {
		c := ToCompanyInfo(com)
		if c != nil {
			rs = append(rs, *c)
		}
	}

	return rs
}

type GetListCompanyInfoResponse struct {
	Data []*CompanyInfo `json:"data"`
} // @name GetListCompanyInfoResponse

```

# pkg/view/communitynft.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type GetNftMetadataResponse struct {
	Data *NftMetadata `json:"data"`
} // @name GetNftMetadataResponse

type NftMetadata struct {
	Name            string      `json:"name"`
	Description     string      `json:"description"`
	Image           string      `json:"image"`
	BackgroundColor string      `json:"background_color"`
	Attributes      []Attribute `json:"attributes"`
} // @name NftInfo

type Attribute struct {
	TraitType string `json:"trait_type"`
	Value     string `json:"value"`
} // @name Attribute

func ToNftMetadata(nft *model.NftMetadata) *NftMetadata {
	attributes := make([]Attribute, 0)
	for _, attr := range nft.Attributes {
		attributes = append(attributes, Attribute{
			TraitType: attr.TraitType,
			Value:     attr.Value,
		})
	}
	return &NftMetadata{
		Name:            nft.Name,
		Description:     nft.Description,
		Image:           nft.Image,
		BackgroundColor: nft.BackgroundColor,
		Attributes:      attributes,
	}
}

```

# pkg/view/client_contact.go

```go
package view

import (
	"encoding/json"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type ClientContact struct {
	ID            string   `json:"id"`
	Name          string   `json:"name"`
	Role          string   `json:"role"`
	Emails        []string `json:"emails"`
	IsMainContact bool     `json:"isMainContact"`
} // @name ClientContact

func toClientContact(cc *model.ClientContact) *ClientContact {
	emails := []string{}
	if err := json.Unmarshal(cc.Emails, &emails); err != nil {
		logger.L.Error(err, "failed to scan emails")
	}

	return &ClientContact{
		ID:            cc.ID.String(),
		Name:          cc.Name,
		Role:          cc.Role,
		Emails:        emails,
		IsMainContact: cc.IsMainContact,
	}
}

```

# pkg/view/client.go

```go
package view

import (
	"strings"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type CreateClientResponse struct {
	Data *Client `json:"data"`
} // @name CreateClientResponse

type GetListClientResponse struct {
	Data []*Client `json:"data"`
} // @name GetListClientResponse

type GetDetailClientResponse struct {
	Data *Client `json:"data"`
} // @name GetDetailClientResponse

type Client struct {
	ID                 string     `json:"id"`
	CreatedAt          time.Time  `json:"createdAt"`
	UpdatedAt          *time.Time `json:"updatedAt"`
	Name               string     `json:"name"`
	Description        string     `json:"description"`
	RegistrationNumber string     `json:"registrationNumber"`
	Avatar             string     `json:"avatar"`
	Address            string     `json:"address"`
	Country            string     `json:"country"`
	City               string     `json:"city"`
	Industry           string     `json:"industry"`
	Website            string     `json:"website"`
	IsPublic           bool       `json:"isPublic"`
	Lat                string     `json:"lat"`
	Long               string     `json:"long"`
	CompanySize        string     `json:"companySize"`
	SolutionType       string     `json:"solutionType"`

	Contacts []ClientContact `json:"contacts"`
	Projects []Project       `json:"projects"`
} // @name Client

func ToClients(clients []*model.Client) []Client {
	rs := make([]Client, 0, len(clients))
	for _, client := range clients {
		c := ToClient(client)
		if c != nil {
			rs = append(rs, *c)
		}
	}

	return rs
}

func ToClient(client *model.Client) *Client {
	contacts := make([]ClientContact, 0)
	for _, contact := range client.Contacts {
		contacts = append(contacts, *toClientContact(&contact))
	}

	return &Client{
		ID:                 client.ID.String(),
		CreatedAt:          client.CreatedAt,
		UpdatedAt:          client.UpdatedAt,
		Name:               client.Name,
		Description:        client.Description,
		RegistrationNumber: client.RegistrationNumber,
		Avatar:             client.Avatar,
		Address:            client.Address,
		Country:            client.Country,
		City:               client.City,
		Industry:           client.Industry,
		Website:            client.Website,
		IsPublic:           client.IsPublic,
		Lat:                client.Lat,
		Long:               client.Long,
		CompanySize:        client.CompanySize,
		SolutionType:       client.SolutionType,
		Contacts:           contacts,
		Projects:           ToProjects(client.Projects),
	}
}

type Address struct {
	Address string `json:"address"`
	Country string `json:"country"`
	City    string `json:"city"`
	Lat     string `json:"lat"`
	Long    string `json:"long"`
} // @name Address

type PublicClient struct {
	ID           string   `json:"id"`
	Name         string   `json:"name"`
	Avatar       string   `json:"avatar"`
	Address      Address  `json:"address"`
	Stack        []string `json:"stacks"`
	Industry     string   `json:"industry"`
	CompanySize  string   `json:"companySize"`
	SolutionType string   `json:"solutionType"`
} // @name PublicClient

type PublicClientListResponse struct {
	Data []PublicClient `json:"data"`
} // @name PublicClientListResponse

func ToPublicClientListResponse(clients []*model.Client) []PublicClient {
	rs := make([]PublicClient, 0, len(clients))
	for _, client := range clients {
		stacks := make([]string, 0)

		for _, p := range client.Projects {
			for _, s := range p.ProjectStacks {
				stacks = append(stacks, s.Stack.Name)
			}
		}

		clientAddress := client.Country
		if strings.TrimSpace(client.City) != "" {
			clientAddress = client.City + ", " + clientAddress
		}

		rs = append(rs, PublicClient{
			ID:     client.ID.String(),
			Name:   client.Name,
			Avatar: client.Avatar,
			Address: Address{
				Address: clientAddress,
				City:    client.City,
				Country: client.Country,
				Lat:     client.Lat,
				Long:    client.Long,
			},
			Stack:        stacks,
			Industry:     client.Industry,
			CompanySize:  client.CompanySize,
			SolutionType: client.SolutionType,
		})
	}

	return rs
}

```

# pkg/view/chapter.go

```go
package view

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type Chapter struct {
	ID     string `json:"id"`
	Code   string `json:"code"`
	Name   string `json:"name"`
	LeadID string `json:"leadID"`
} // @name Chapter

func ToChapters(employeeChapters []model.EmployeeChapter) []Chapter {
	rs := make([]Chapter, 0, len(employeeChapters))
	for _, v := range employeeChapters {
		r := Chapter{
			ID:   v.Chapter.ID.String(),
			Code: v.Chapter.Code,
			Name: v.Chapter.Name,
		}

		if v.Chapter.LeadID != nil {
			r.LeadID = v.Chapter.LeadID.String()
		}

		rs = append(rs, r)
	}

	return rs
}

```

# pkg/view/brainery_metric.go

```go
package view

import (
	"sort"
	"time"

	"github.com/shopspring/decimal"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type Post struct {
	Title       string          `json:"title"`
	URL         string          `json:"url"`
	Reward      decimal.Decimal `json:"reward"`
	PublishedAt string          `json:"publishedAt"`
	DiscordID   string          `json:"discordID"`
} // @name Post

type BraineryMetric struct {
	LatestPosts     []Post           `json:"latestPosts"`
	Tags            []string         `json:"tags"`
	Contributors    []Post           `json:"contributors"`
	NewContributors []Post           `json:"newContributors"`
	TopContributors []TopContributor `json:"topContributors"`
} // @name BraineryMetric

type TopContributor struct {
	Count     int
	Ranking   int
	DiscordID string
} // @name TopContributor

// ToPost parse BraineryLog model to Post
func ToPost(l model.BraineryLog) Post {
	return Post{
		Title:       l.Title,
		URL:         l.URL,
		Reward:      l.Reward,
		PublishedAt: l.PublishedAt.Format(time.RFC3339Nano),
		DiscordID:   l.DiscordID,
	}
}

type BraineryMetricResponse struct {
	Data BraineryMetric `json:"data"`
} // @name BraineryMetricResponse

// ToBraineryMetric parse BraineryLog logs to BraineryMetric
func ToBraineryMetric(latestPosts, logs []*model.BraineryLog, ncids []string, queryView string) BraineryMetric {
	metric := BraineryMetric{}

	// latest posts
	for _, post := range latestPosts {
		metric.LatestPosts = append(metric.LatestPosts, ToPost(*post))
	}

	// tags
	tagMap := make(map[string]int)
	for _, log := range logs {
		for _, tag := range log.Tags {
			if _, ok := tagMap[tag]; !ok {
				tagMap[tag] = 0
			}
			tagMap[tag]++
		}
	}

	// get 10 top tags
	l := len(tagMap)
	if len(tagMap) > 10 {
		l = 10
	}
	for i := 0; i < l; i++ {
		var topCount int
		var topTag string
		for tag, count := range tagMap {
			if count > topCount {
				topCount = count
				topTag = tag
			}
		}
		metric.Tags = append(metric.Tags, topTag)
		delete(tagMap, topTag)
	}

	ncidsMap := make(map[string]struct{}, len(ncids))
	for _, id := range ncids {
		ncidsMap[id] = struct{}{}
	}

	// contributors
	for _, log := range logs {
		if _, ok := ncidsMap[log.DiscordID]; !ok {
			metric.Contributors = append(metric.Contributors, ToPost(*log))
		}
	}

	// new contributors
	for _, log := range logs {
		if _, ok := ncidsMap[log.DiscordID]; ok {
			metric.NewContributors = append(metric.NewContributors, ToPost(*log))
		}
	}

	// top contributors
	if queryView == "monthly" {
		logMap := make(map[string]int)
		for _, log := range logs {
			if _, ok := logMap[log.DiscordID]; !ok {
				logMap[log.DiscordID] = 0
			}
			logMap[log.DiscordID]++
		}

		for discordID, count := range logMap {
			metric.TopContributors = append(metric.TopContributors, TopContributor{
				Count:     count,
				DiscordID: discordID,
			})
		}

		sort.Slice(metric.TopContributors, func(i, j int) bool {
			return metric.TopContributors[i].Count > metric.TopContributors[j].Count
		})

		if len(metric.TopContributors) > 0 {
			metric.TopContributors[0].Ranking = 1
			for i := 1; i < len(metric.TopContributors); i++ {
				if metric.TopContributors[i].Count == metric.TopContributors[i-1].Count {
					metric.TopContributors[i].Ranking = metric.TopContributors[i-1].Ranking
				} else {
					metric.TopContributors[i].Ranking = metric.TopContributors[i-1].Ranking + 1
				}
			}
		}
	}

	return metric
}

```

# pkg/view/bank_account.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type ListBankAccountResponse struct {
	Data []BankAccount `json:"data"`
} // @name ListBankAccountResponse

type BankAccount struct {
	ID                      string   `json:"id"`
	AccountNumber           string   `json:"accountNumber"`
	BankName                string   `json:"bankName"`
	OwnerName               string   `json:"ownerName"`
	Address                 *string  `json:"address"`
	SwiftCode               string   `json:"swiftCode"`
	IntermediaryBankAddress string   `json:"intermediaryBankAddress"`
	IntermediaryBankName    string   `json:"intermediaryBankName"`
	RoutingNumber           string   `json:"routingNumber"`
	Name                    string   `json:"name"`
	UKSortCode              string   `json:"ukSortCode"`
	CurrencyID              string   `json:"currencyID"`
	Currency                Currency `json:"currency"`
} // @name BankAccount

func ToBankAccount(account *model.BankAccount) *BankAccount {
	return &BankAccount{
		ID:                      account.ID.String(),
		AccountNumber:           account.AccountNumber,
		BankName:                account.BankName,
		OwnerName:               account.OwnerName,
		Address:                 account.Address,
		SwiftCode:               account.SwiftCode,
		RoutingNumber:           account.RoutingNumber,
		Name:                    account.Name,
		UKSortCode:              account.UKSortCode,
		IntermediaryBankName:    account.IntermediaryBankName,
		IntermediaryBankAddress: account.IntermediaryBankAddress,
		CurrencyID:              account.CurrencyID.String(),
		Currency:                *toCurrency(account.Currency),
	}
}

func ToListBankAccount(accounts []*model.BankAccount) []BankAccount {
	res := make([]BankAccount, 0)

	for _, acc := range accounts {
		res = append(res, BankAccount{
			ID:                      acc.ID.String(),
			AccountNumber:           acc.AccountNumber,
			BankName:                acc.BankName,
			OwnerName:               acc.OwnerName,
			Address:                 acc.Address,
			SwiftCode:               acc.SwiftCode,
			RoutingNumber:           acc.RoutingNumber,
			Name:                    acc.Name,
			UKSortCode:              acc.UKSortCode,
			IntermediaryBankName:    acc.IntermediaryBankName,
			IntermediaryBankAddress: acc.IntermediaryBankAddress,
			CurrencyID:              acc.CurrencyID.String(),
			Currency:                *toCurrency(acc.Currency),
		})
	}

	return res
}

```

# pkg/view/bank.go

```go
package view

import "github.com/dwarvesf/fortress-api/pkg/model"

type ListBankResponse struct {
	Data []Bank `json:"data"`
} // @name ListBankResponse

type Bank struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Code      string `json:"code"`
	Bin       string `json:"bin"`
	ShortName string `json:"shortName"`
	Logo      string `json:"logo"`
	SwiftCode string `json:"swiftCode"`
} // @name Bank

func ToBank(in *model.Bank) *Bank {
	return &Bank{
		ID:        in.ID.String(),
		Name:      in.Name,
		Code:      in.Code,
		Bin:       in.Bin,
		ShortName: in.ShortName,
		Logo:      in.Logo,
		SwiftCode: in.SwiftCode,
	}
}

func ToListBank(banks []*model.Bank) []Bank {
	res := make([]Bank, 0)
	for _, bank := range banks {
		b := ToBank(bank)
		res = append(res, *b)
	}

	return res
}

```

# pkg/view/auth_test.go

```go
package view

import (
	"reflect"
	"testing"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

func TestToAuthData(t *testing.T) {
	id := model.NewUUID()
	type args struct {
		accessToken string
		employee    *model.Employee
	}
	tests := []struct {
		name string
		args args
		want *AuthData
	}{
		{
			name: "happy case",
			args: args{
				accessToken: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjQ4MjM0MDc0NzYsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiIiwiZW1haWwiOiIifQ.RJhl4O1PDMzIFO3pR13vyO07Z4gd90ewq5PKOao1MtY",
				employee: &model.Employee{
					BaseModel: model.BaseModel{
						ID: id,
					},
				},
			},
			want: &AuthData{
				Employee: EmployeeData{
					ID:        id.String(),
					Projects:  []EmployeeProjectData{},
					Positions: []Position{},
				},
				AccessToken: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjQ4MjM0MDc0NzYsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiIiwiZW1haWwiOiIifQ.RJhl4O1PDMzIFO3pR13vyO07Z4gd90ewq5PKOao1MtY",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ToAuthData(tt.args.accessToken, tt.args.employee); !reflect.DeepEqual(got.Employee.ID, tt.want.Employee.ID) {
				t.Errorf("ToAuthData() = %v, want %v", *got, *tt.want)
			}
		})
	}
}

```

# pkg/view/auth.go

```go
package view

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type AuthData struct {
	Employee    EmployeeData `json:"employee"`
	AccessToken string       `json:"accessToken"`
} // @name AuthData

type APIKeyData struct {
	Key string `json:"key"`
} // @name APIKeyData

func ToAuthData(accessToken string, employee *model.Employee) *AuthData {
	return &AuthData{
		Employee:    *ToEmployeeData(employee),
		AccessToken: accessToken,
	}
}

type LoggedInUserData struct {
	ID          model.UUID `json:"id"`
	FullName    string     `json:"fullName"`
	DisplayName string     `json:"displayName"`
	Avatar      string     `json:"avatar"`
	TeamEmail   string     `json:"teamEmail"`
	Role        string     `json:"role"`
	Permissions []string   `json:"permissions"`
} // @name LoggedInUserData

func ToAuthorizedUserData(employee *model.Employee, perms []*model.Permission) *LoggedInUserData {
	permissions := make([]string, len(perms))
	for i, p := range perms {
		permissions[i] = p.Code
	}

	return &LoggedInUserData{
		ID:          employee.ID,
		FullName:    employee.FullName,
		DisplayName: employee.DisplayName,
		Avatar:      employee.Avatar,
		TeamEmail:   employee.TeamEmail,
		Role:        employee.EmployeeRoles[0].Role.Name,
		Permissions: permissions,
	}
}

type AuthUserResponse struct {
	Data LoggedInUserData `json:"data"`
} // @name AuthUserResponse

type APIKeyResponse struct {
	Data APIKeyData `json:"data"`
} // @name APIKeyResponse

```

# pkg/view/asset.go

```go
package view

type ContentData struct {
	Url string `json:"url"`
} // @name ContentData

// ContentDataResponse represent the content data
type ContentDataResponse struct {
	Data *ContentData `json:"data"`
} // @name ContentDataResponse

func ToContentData(url string) *ContentData {
	return &ContentData{
		Url: url,
	}
}

```

# pkg/service/service.go

```go
package service

import (
	"time"

	"github.com/patrickmn/go-cache"
	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
	admin "google.golang.org/api/admin/directory/v1"
	"google.golang.org/api/gmail/v1"
	"google.golang.org/api/sheets/v4"
	"google.golang.org/api/youtube/v3"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/service/communitynft"
	"github.com/dwarvesf/fortress-api/pkg/service/currency"
	"github.com/dwarvesf/fortress-api/pkg/service/discord"
	"github.com/dwarvesf/fortress-api/pkg/service/evm"
	"github.com/dwarvesf/fortress-api/pkg/service/github"
	googleauth "github.com/dwarvesf/fortress-api/pkg/service/google"
	"github.com/dwarvesf/fortress-api/pkg/service/googleadmin"
	"github.com/dwarvesf/fortress-api/pkg/service/googledrive"
	"github.com/dwarvesf/fortress-api/pkg/service/googlemail"
	"github.com/dwarvesf/fortress-api/pkg/service/googlesheet"
	"github.com/dwarvesf/fortress-api/pkg/service/googlestorage"
	"github.com/dwarvesf/fortress-api/pkg/service/icyswap"
	"github.com/dwarvesf/fortress-api/pkg/service/improvmx"
	"github.com/dwarvesf/fortress-api/pkg/service/lobsters"
	"github.com/dwarvesf/fortress-api/pkg/service/mochi"
	"github.com/dwarvesf/fortress-api/pkg/service/mochipay"
	"github.com/dwarvesf/fortress-api/pkg/service/mochiprofile"
	"github.com/dwarvesf/fortress-api/pkg/service/notion"
	"github.com/dwarvesf/fortress-api/pkg/service/ogifmemosummarizer"
	"github.com/dwarvesf/fortress-api/pkg/service/reddit"
	"github.com/dwarvesf/fortress-api/pkg/service/sendgrid"
	"github.com/dwarvesf/fortress-api/pkg/service/tono"
	"github.com/dwarvesf/fortress-api/pkg/service/wise"
	yt "github.com/dwarvesf/fortress-api/pkg/service/youtube"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type Service struct {
	Basecamp      *basecamp.Service
	Cache         *cache.Cache
	Currency      currency.IService
	Discord       discord.IService
	Github        github.IService
	Google        googleauth.IService
	GoogleStorage googlestorage.IService
	GoogleAdmin   googleadmin.IService
	GoogleDrive   googledrive.IService
	GoogleMail    googlemail.IService
	GoogleSheet   googlesheet.IService
	ImprovMX      improvmx.IService
	Mochi         mochi.IService
	MochiPay      mochipay.IService
	MochiProfile  mochiprofile.IService
	Notion        notion.IService
	Sendgrid      sendgrid.IService
	Wise          wise.IService
	BaseClient    evm.IService
	IcySwap       icyswap.IService
	CommunityNft  communitynft.IService
	Tono          tono.IService
	Reddit        reddit.IService
	Lobsters      lobsters.IService
	Youtube       yt.IService
	Dify          ogifmemosummarizer.IService
}

func New(cfg *config.Config, store *store.Store, repo store.DBRepo) *Service {
	cch := cache.New(5*time.Minute, 10*time.Minute)

	googleAuthSvc, err := googleauth.New(
		&oauth2.Config{
			ClientID:     cfg.Google.ClientID,
			ClientSecret: cfg.Google.ClientSecret,
			Endpoint:     google.Endpoint,
			Scopes:       []string{"email", "profile"},
		},
	)
	if err != nil {
		logger.L.Error(err, "failed to init google auth")
	}

	gcsSvc, err := googlestorage.New(
		cfg.Google.GCSBucketName,
		cfg.Google.GCSProjectID,
		cfg.Google.GCSCredentials,
	)
	if err != nil {
		logger.L.Error(err, "failed to init gcs")
	}

	driveConfig := &oauth2.Config{
		ClientID:     cfg.Google.ClientID,
		ClientSecret: cfg.Google.ClientSecret,
		Endpoint:     google.Endpoint,
		Scopes:       []string{googledrive.FullDriveAccessScope},
	}

	googleDriveSvc := googledrive.New(driveConfig, cfg)

	googleAdminConfig := &oauth2.Config{
		ClientID:     cfg.Google.ClientID,
		ClientSecret: cfg.Google.ClientSecret,
		Endpoint:     google.Endpoint,
		Scopes: []string{admin.AdminDirectoryUserScope,
			admin.AdminDirectoryGroupScope,
		},
	}
	googleAdminSvc := googleadmin.New(googleAdminConfig, cfg)

	mailConfig := &oauth2.Config{
		ClientID:     cfg.Google.ClientID,
		ClientSecret: cfg.Google.ClientSecret,
		Endpoint:     google.Endpoint,
		Scopes:       []string{gmail.MailGoogleComScope},
	}

	googleMailSvc := googlemail.New(
		mailConfig,
		cfg,
	)

	youtubeSvc := yt.New(&oauth2.Config{
		ClientID:     cfg.Youtube.ClientID,
		ClientSecret: cfg.Youtube.ClientSecret,
		Endpoint:     google.Endpoint,
		Scopes:       []string{youtube.YoutubeForceSslScope},
	}, cfg)

	gSheetConfig := &oauth2.Config{
		ClientID:     cfg.Google.ClientID,
		ClientSecret: cfg.Google.ClientSecret,
		Endpoint:     google.Endpoint,
		Scopes: []string{
			sheets.DriveScope,
			sheets.DriveFileScope,
			sheets.DriveReadonlyScope,
			sheets.SpreadsheetsScope,
			sheets.SpreadsheetsReadonlyScope,
		},
	}

	gSheetSvc := googlesheet.New(
		gSheetConfig,
		cfg,
	)

	bc := model.Basecamp{
		ClientID:     cfg.Basecamp.ClientID,
		ClientSecret: cfg.Basecamp.ClientSecret,
	}

	Currency := currency.New(cfg)

	baseClient, err := evm.New(evm.DefaultBASEClient, cfg, logger.L)
	if err != nil {
		logger.L.Error(err, "failed to init base client service")
	}
	icySwap, err := icyswap.New(baseClient, cfg, logger.L)
	if err != nil {
		logger.L.Error(err, "failed to init icyswap service")
	}

	communityNft, err := communitynft.New(baseClient, cfg, logger.L)
	if err != nil {
		logger.L.Error(err, "failed to init community nft service")
	}

	reddit, err := reddit.New(cfg, logger.L)
	if err != nil {
		logger.L.Error(err, "failed to init reddit service")
	}

	difySvc := ogifmemosummarizer.New(cfg)

	return &Service{
		Basecamp:      basecamp.New(store, repo, cfg, &bc, logger.L),
		Cache:         cch,
		Currency:      Currency,
		Discord:       discord.New(cfg),
		Github:        github.New(cfg, logger.L),
		Google:        googleAuthSvc,
		GoogleStorage: gcsSvc,
		GoogleAdmin:   googleAdminSvc,
		GoogleDrive:   googleDriveSvc,
		GoogleMail:    googleMailSvc,
		GoogleSheet:   gSheetSvc,
		ImprovMX:      improvmx.New(cfg.ImprovMX.Token),
		Mochi:         mochi.New(cfg, logger.L),
		MochiPay:      mochipay.New(cfg, logger.L),
		MochiProfile:  mochiprofile.New(cfg, logger.L),
		Notion:        notion.New(cfg.Notion.Secret, cfg.Notion.Databases.Project, logger.L),
		Sendgrid:      sendgrid.New(cfg.Sendgrid.APIKey, cfg, logger.L),
		Wise:          wise.New(cfg, logger.L),
		BaseClient:    baseClient,
		IcySwap:       icySwap,
		CommunityNft:  communityNft,
		Tono:          tono.New(cfg, logger.L),
		Reddit:        reddit,
		Lobsters:      lobsters.New(),
		Youtube:       youtubeSvc,
		Dify:          difySvc,
	}
}

```

# pkg/routes/v1_test.go

```go
package routes

import (
	"fmt"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/stretchr/testify/require"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler"
	"github.com/dwarvesf/fortress-api/pkg/logger"
)

// Test_loadV1Routes simply test we load route and handler correctly
func Test_loadV1Routes(t *testing.T) {
	expectedRoutes := map[string]map[string]gin.RouteInfo{
		"/api/v1/employees": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.Create-fm",
			},
		},
		"/api/v1/employees/search": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.List-fm",
			},
		},
		"/api/v1/employees/:id": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.Details-fm",
			},
		},
		"/api/v1/employees/:id/upload-avatar": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.UploadAvatar-fm",
			},
		},
		"/api/v1/employees/:id/general-info": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.UpdateGeneralInfo-fm",
			},
		},
		"/api/v1/employees/:id/personal-info": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.UpdatePersonalInfo-fm",
			},
		},
		"/api/v1/employees/:id/skills": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.UpdateSkills-fm",
			},
		},
		"/api/v1/employees/:id/base-salary": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.UpdateBaseSalary-fm",
			},
		},
		"/api/v1/line-managers": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.GetLineManagers-fm",
			},
		},
		"/api/v1/metadata/banks": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.Banks-fm",
			},
		},
		"/api/v1/metadata/working-status": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.WorkingStatuses-fm",
			},
		},
		"/api/v1/metadata/seniorities": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.Seniorities-fm",
			},
		},
		"/api/v1/metadata/chapters": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.Chapters-fm",
			},
		},
		"/api/v1/metadata/organizations": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.Organizations-fm",
			},
		},
		"/api/v1/metadata/roles": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.GetRoles-fm",
			},
		},
		"/api/v1/metadata/positions": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.Positions-fm",
			},
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.CreatePosition-fm",
			},
		},
		"/api/v1/metadata/positions/:id": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.UpdatePosition-fm",
			},
			"DELETE": {
				Method:  "DELETE",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.DeletePosition-fm",
			},
		},
		"/api/v1/auth": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/auth.IHandler.Auth-fm",
			},
		},
		"/api/v1/auth/me": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/auth.IHandler.Me-fm",
			},
		},
		"/api/v1/auth/api-key": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/auth.IHandler.CreateAPIKey-fm",
			},
		},
		"/api/v1/metadata/countries": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.GetCountries-fm",
			},
		},
		"/api/v1/metadata/project-statuses": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.ProjectStatuses-fm",
			},
		},
		"/api/v1/metadata/stacks": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.Stacks-fm",
			},
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.CreateStack-fm",
			},
		},
		"/api/v1/metadata/stacks/:id": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.UpdateStack-fm",
			},
			"DELETE": {
				Method:  "DELETE",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.DeleteStack-fm",
			},
		},
		"/api/v1/metadata/countries/:country_id/cities": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.GetCities-fm",
			},
		},
		"/api/v1/employees/:id/employee-status": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.UpdateEmployeeStatus-fm",
			},
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.Create-fm",
			},
		},
		"/api/v1/profile": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/profile.IHandler.GetProfile-fm",
			},
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/profile.IHandler.UpdateInfo-fm",
			},
		},
		"/api/v1/invite": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/profile.IHandler.GetInvitation-fm",
			},
		},
		"/api/v1/invite/submit": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/profile.IHandler.SubmitOnboardingForm-fm",
			},
		},
		"/api/v1/projects": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.List-fm",
			},
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.Create-fm",
			},
		},
		"/api/v1/projects/icy-distribution/weekly": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.IcyWeeklyDistribution-fm",
			},
		},
		"/api/v1/projects/:id": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.Details-fm",
			},
		},
		"/api/v1/projects/:id/upload-avatar": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.UploadAvatar-fm",
			},
		},
		"/api/v1/projects/:id/sending-survey-state": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.UpdateSendingSurveyState-fm",
			},
		},
		"/api/v1/projects/:id/status": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.UpdateProjectStatus-fm",
			},
		},
		"/api/v1/projects/:id/members": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.AssignMember-fm",
			},
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.GetMembers-fm",
			},
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.UpdateMember-fm",
			},
		},
		"/api/v1/projects/:id/members/:memberID": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.UnassignMember-fm",
			},
			"DELETE": {
				Method:  "DELETE",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.DeleteMember-fm",
			},
		},
		"/api/v1/projects/:id/slots/:slotID": {
			"DELETE": {
				Method:  "DELETE",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.DeleteSlot-fm",
			},
		},
		"/api/v1/projects/:id/general-info": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.UpdateGeneralInfo-fm",
			},
		},
		"/api/v1/projects/:id/contact-info": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.UpdateContactInfo-fm",
			},
		},
		"/api/v1/profile/upload-avatar": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/profile.IHandler.UploadAvatar-fm",
			},
		},
		"/api/v1/profile/upload": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/profile.IHandler.Upload-fm",
			},
		},
		"/api/v1/projects/:id/work-units": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.GetWorkUnits-fm",
			},
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.CreateWorkUnit-fm",
			},
		},
		"/api/v1/projects/:id/work-units/:workUnitID": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.UpdateWorkUnit-fm",
			},
		},
		"/api/v1/projects/:id/work-units/:workUnitID/archive": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.ArchiveWorkUnit-fm",
			},
		},
		"/api/v1/projects/:id/work-units/:workUnitID/unarchive": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.UnarchiveWorkUnit-fm",
			},
		},
		"/api/v1/metadata/questions": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.GetQuestions-fm",
			},
		},
		"/api/v1/metadata/currencies": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/metadata.IHandler.GetCurrencies-fm",
			},
		},
		"/api/v1/feedbacks": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/feedback.IHandler.List-fm",
			},
		},
		"/api/v1/feedbacks/:id/topics/:topicID": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/feedback.IHandler.Detail-fm",
			},
		},
		"/api/v1/feedbacks/unreads": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/feedback.IHandler.CountUnreadFeedback-fm",
			},
		},
		"/api/v1/feedbacks/:id/topics/:topicID/submit": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/feedback.IHandler.Submit-fm",
			},
		},
		"/api/v1/surveys": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.CreateSurvey-fm",
			},
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.ListSurvey-fm",
			},
		},
		"/api/v1/surveys/:id/send": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.SendSurvey-fm",
			},
		},
		"/api/v1/surveys/:id": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.GetSurveyDetail-fm",
			},
			"DELETE": {
				Method:  "DELETE",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.DeleteSurvey-fm",
			},
		},
		"/api/v1/surveys/:id/topics/:topicID/reviews/:reviewID": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.GetSurveyReviewDetail-fm",
			},
		},
		"/api/v1/surveys/:id/topics/:topicID/employees": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.UpdateTopicReviewers-fm",
			},
			"DELETE": {
				Method:  "DELETE",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.DeleteTopicReviewers-fm",
			},
		},
		"/api/v1/surveys/:id/done": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.MarkDone-fm",
			},
		},
		"/api/v1/surveys/:id/topics/:topicID": {
			"DELETE": {
				Method:  "DELETE",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.DeleteSurveyTopic-fm",
			},
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/survey.IHandler.GetSurveyTopicDetail-fm",
			},
		},
		"/api/v1/employees/:id/roles": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.UpdateRole-fm",
			},
		},
		"/api/v1/valuation/:year": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/valuation.IHandler.One-fm",
			},
		},
		"/api/v1/dashboards/projects/sizes": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetProjectSizes-fm",
			},
		},
		"/api/v1/dashboards/projects/work-surveys": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetWorkSurveys-fm",
			},
		},
		"/api/v1/dashboards/projects/action-items": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetActionItemReports-fm",
			},
		},
		"/api/v1/dashboards/projects/engineering-healths": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetEngineeringHealth-fm",
			},
		},
		"/api/v1/dashboards/projects/audits": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetAudits-fm",
			},
		},
		"/api/v1/assets/upload": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/asset.IHandler.Upload-fm",
			},
		},
		"/api/v1/notion/earn": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListEarns-fm",
			},
		},
		"/api/v1/notion/tech-radar": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListTechRadars-fm",
			},
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.CreateTechRadar-fm",
			},
		},
		"/api/v1/notion/audiences": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListAudiences-fm",
			},
		},
		"/api/v1/notion/events": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListEvents-fm",
			},
		},
		"/api/v1/notion/digests": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListDigests-fm",
			},
		},
		"/api/v1/notion/issues": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListIssues-fm",
			},
		},
		"/api/v1/notion/updates": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListUpdates-fm",
			},
		},
		"/api/v1/notion/memos": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListMemos-fm",
			},
		},
		"/api/v1/notion/hiring-positions": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListHiringPositions-fm",
			},
		},
		"/api/v1/notion/staffing-demands": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListStaffingDemands-fm",
			},
		},
		"/api/v1/notion/projects/milestones": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.ListProjectMilestones-fm",
			},
		},
		"/api/v1/dashboards/projects/action-item-squash": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetActionItemSquashReports-fm",
			},
		},
		"/api/v1/dashboards/projects/summary": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetSummary-fm",
			},
		},
		"/api/v1/dashboards/resources/availabilities": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetResourcesAvailability-fm",
			},
		},
		"/api/v1/dashboards/engagement/info": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetEngagementInfo-fm",
			},
		},
		"/api/v1/dashboards/engagement/detail": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetEngagementInfoDetail-fm",
			},
		},
		"/api/v1/dashboards/resources/utilization": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetResourceUtilization-fm",
			},
		},
		"/api/v1/dashboards/resources/work-unit-distribution": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetWorkUnitDistribution-fm",
			},
		},
		"/api/v1/dashboards/resources/work-unit-distribution-summary": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetWorkUnitDistributionSummary-fm",
			},
		},
		"/api/v1/dashboards/resources/work-survey-summaries": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/dashboard.IHandler.GetResourceWorkSurveySummaries-fm",
			},
		},
		"/cronjobs/birthday": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.BirthdayDailyMessage-fm",
			},
		},
		"/cronjobs/on-leaves": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.OnLeaveMessage-fm",
			},
		},
		"/cronjobs/audits": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/audit.IHandler.Sync-fm",
			},
		},
		"/cronjobs/sync-discord-info": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.SyncDiscordInfo-fm",
			},
		},
		"/cronjobs/sync-monthly-accounting-todo": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/accounting.IHandler.CreateAccountingTodo-fm",
			},
		},
		"/cronjobs/sync-project-member-status": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/project.IHandler.SyncProjectMemberStatus-fm",
			},
		},
		"/cronjobs/store-vault-transaction": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/vault.IHandler.StoreVaultTransaction-fm",
			},
		},
		"/cronjobs/index-engagement-messages": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/engagement.IHandler.IndexMessages-fm",
			},
		},
		"/cronjobs/brainery-reports": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.ReportBraineryMetrics-fm",
			},
		},
		"/cronjobs/delivery-metric-reports": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.DeliveryMetricsReport-fm",
			},
		},
		"/cronjobs/sync-delivery-metrics": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/deliverymetric.IHandler.Sync-fm",
			},
		},
		"/cronjobs/sync-conversion-rates": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/conversionrate.IHandler.Sync-fm",
			},
		},
		"/cronjobs/sync-memo": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.SyncMemo-fm",
			},
		},
		"/cronjobs/notify-weekly-memos": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.NotifyWeeklyMemos-fm",
			},
		},
		"/cronjobs/transcribe-youtube-broadcast": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/youtube.IHandler.TranscribeBroadcast-fm",
			},
		},
		"/cronjobs/golang-news": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.PostGolangNews-fm",
			},
		},
		"/webhooks/n8n": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/webhook.IHandler.N8n-fm",
			},
		},
		"/webhooks/basecamp/expense/validate": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/webhook.IHandler.ValidateBasecampExpense-fm",
			},
		},
		"/webhooks/basecamp/expense": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/webhook.IHandler.CreateBasecampExpense-fm",
			},
			"DELETE": {
				Method:  "DELETE",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/webhook.IHandler.UncheckBasecampExpense-fm",
			},
		},
		"/webhooks/basecamp/operation/accounting-transaction": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/webhook.IHandler.StoreAccountingTransaction-fm",
			},
		},
		"/webhooks/basecamp/operation/invoice": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/webhook.IHandler.MarkInvoiceAsPaidViaBasecamp-fm",
			},
		},
		"/webhooks/basecamp/onleave": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/webhook.IHandler.ApproveOnLeaveRequest-fm",
			},
		},
		"/webhooks/basecamp/onleave/validate": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/webhook.IHandler.ValidateOnLeaveRequest-fm",
			},
		},
		"/api/v1/bank-accounts": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/bankaccount.IHandler.List-fm",
			},
		},
		"/api/v1/invoices/send": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/invoice.IHandler.Send-fm",
			},
		},
		"/api/v1/invoices/:id/status": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/invoice.IHandler.UpdateStatus-fm",
			},
		},
		"/api/v1/invoices": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/invoice.IHandler.List-fm",
			},
		},
		"/api/v1/invoices/template": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/invoice.IHandler.GetTemplate-fm",
			},
		},
		"/api/v1/clients": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/client.IHandler.List-fm",
			},
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/client.IHandler.Create-fm",
			},
		},
		"/api/v1/company-infos": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/companyinfo.IHandler.List-fm",
			},
		},
		"/api/v1/clients/:id": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/client.IHandler.Detail-fm",
			},
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/client.IHandler.Update-fm",
			},
			"DELETE": {
				Method:  "DELETE",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/client.IHandler.Delete-fm",
			},
		},
		"/api/v1/notion/changelogs/projects/available": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.GetAvailableProjectsChangelog-fm",
			},
		},
		"/api/v1/notion/changelogs/project": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.SendProjectChangelog-fm",
			},
		},
		"/api/v1/notion/df-updates/:id/send": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/notion.IHandler.SendNewsLetter-fm",
			},
		},
		"/api/v1/payrolls": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/payroll.IHandler.MarkPayrollAsPaid-fm",
			},
		},
		"/api/v1/payrolls/detail": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/payroll.IHandler.GetPayrollsByMonth-fm",
			},
		},
		"/api/v1/payrolls/bhxh": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/payroll.IHandler.GetPayrollsBHXH-fm",
			},
		},
		"/api/v1/payrolls/commit": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/payroll.IHandler.CommitPayroll-fm",
			},
		},
		"/api/v1/engagements/rollup": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/engagement.IHandler.UpsertRollup-fm",
			},
		},
		"/api/v1/engagements/channels/:channel-id/last-message-id": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/engagement.IHandler.GetLastMessageID-fm",
			},
		},
		"/api/v1/brainery-logs": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs.IHandler.Create-fm",
			},
		},
		"/api/v1/brainery-logs/metrics": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs.IHandler.GetMetrics-fm",
			},
		},
		"/api/v1/brainery-logs/sync": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs.IHandler.Sync-fm",
			},
		},
		"/api/v1/public/employees": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.PublicList-fm",
			},
		},
		"/api/v1/delivery-metrics/report/sync": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/deliverymetric.IHandler.Sync-fm",
			},
		},
		"/api/v1/delivery-metrics/report/weekly": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/deliverymetric.IHandler.GetWeeklyReport-fm",
			},
		},
		"/api/v1/delivery-metrics/report/monthly": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/deliverymetric.IHandler.GetMonthlyReport-fm",
			},
		},
		"/api/v1/delivery-metrics/leader-board/weekly": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/deliverymetric.IHandler.GetWeeklyLeaderBoard-fm",
			},
		},
		"/api/v1/delivery-metrics/leader-board/monthly": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/deliverymetric.IHandler.GetMonthlyLeaderBoard-fm",
			},
		},
		"/api/v1/delivery-metrics/report/weekly/discord-msg": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/deliverymetric.IHandler.GetWeeklyReportDiscordMsg-fm",
			},
		},
		"/api/v1/delivery-metrics/report/monthly/discord-msg": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/deliverymetric.IHandler.GetMonthlyReportDiscordMsg-fm",
			},
		},

		"/api/v1/public/clients": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/client.IHandler.PublicList-fm",
			},
		},
		"/api/v1/discords": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.ListByDiscordRequest-fm",
			},
		},
		"/api/v1/discords/mma-scores": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.ListWithMMAScore-fm",
			},
		},
		"/api/v1/conversion-rates": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/conversionrate.IHandler.List-fm",
			},
		},
		"/api/v1/discords/advance-salary": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.SalaryAdvance-fm",
			},
		},
		"/api/v1/discords/check-advance-salary": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.CheckSalaryAdvance-fm",
			},
		},
		"/api/v1/discords/salary-advance-report": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.SalaryAdvanceReport-fm",
			},
		},
		"/api/v1/discords/:discord_id/earns/transactions": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.GetEmployeeEarnTransactions-fm",
			},
		},
		"/api/v1/discords/:discord_id/earns/total": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.GetEmployeeTotalEarn-fm",
			},
		},
		"/api/v1/discords/icy-accounting": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/icy.IHandler.Accounting-fm",
			},
		},
		"/api/v1/discords/earns/total": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.GetTotalEarn-fm",
			},
		},
		"/api/v1/discords/office-checkin": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/employee.IHandler.OfficeCheckIn-fm",
			},
		},
		"/api/v1/discords/scheduled-events": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.ListScheduledEvent-fm",
			},
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.CreateScheduledEvent-fm",
			},
		},
		"/api/v1/discords/scheduled-events/:id/speakers": {
			"PUT": {
				Method:  "PUT",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.SetScheduledEventSpeakers-fm",
			},
		},
		"/api/v1/memos": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/memologs.IHandler.Create-fm",
			},
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/memologs.IHandler.List-fm",
			},
		},
		"/api/v1/memos/sync": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/memologs.IHandler.Sync-fm",
			},
		},
		"/api/v1/memos/prs": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/memologs.IHandler.ListOpenPullRequest-fm",
			},
		},
		"/api/v1/memos/discords": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/memologs.IHandler.ListByDiscordID-fm",
			},
		},
		"/api/v1/memos/top-authors": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/memologs.IHandler.GetTopAuthors-fm",
			},
		},
		"/api/v1/public/community-nfts/:id": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/communitynft.IHandler.GetNftMetadata-fm",
			},
		},
		"/api/v1/earns": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/earn.IHandler.ListEarn-fm",
			},
		},
		"/api/v1/discords/research-topics": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.ListDiscordResearchTopics-fm",
			},
		},
		"/api/v1/news": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/news.IHandler.Fetch-fm",
			},
		},
		"/api/v1/public/youtube/broadcast": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/youtube.IHandler.LatestBroadcast-fm",
			},
		},
		"/api/v1/ogif": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.UserOgifStats-fm",
			},
		},
		"/cronjobs/sweep-memo": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.SweepMemo-fm",
			},
		},
		"/api/v1/ogif/leaderboard": {
			"GET": {
				Method:  "GET",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.OgifLeaderboard-fm",
			},
		},
		"/cronjobs/sweep-ogif-event": {
			"POST": {
				Method:  "POST",
				Handler: "github.com/dwarvesf/fortress-api/pkg/handler/discord.IHandler.SweepOgifEvent-fm",
			},
		},
	}

	l := logger.NewLogrusLogger()
	cfg := config.LoadConfig(config.DefaultConfigLoaders())
	h := handler.New(nil, nil, nil, nil, nil, l, cfg)

	router := gin.New()
	loadV1Routes(router, h, nil, nil, nil)

	routeInfo := router.Routes()

	for _, r := range routeInfo {
		require.NotNil(t, r.HandlerFunc)
		expected, ok := expectedRoutes[r.Path][r.Method]
		require.True(t, ok, fmt.Sprintf("unexpected path: %s", r.Path))
		ignoreFields := cmpopts.IgnoreFields(gin.RouteInfo{}, "HandlerFunc", "Path")
		if !cmp.Equal(expected, r, ignoreFields) {
			t.Errorf("route mismatched. \n route path: %v \n diff: %+v", r.Path,
				cmp.Diff(expected, r, ignoreFields))
			t.FailNow()
		}
	}
}

```

# pkg/routes/v1.go

```go
package routes

import (
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/mw"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

func loadV1Routes(r *gin.Engine, h *handler.Handler, repo store.DBRepo, s *store.Store, cfg *config.Config) {
	pmw := mw.NewPermissionMiddleware(s, repo, cfg)
	amw := mw.NewAuthMiddleware(cfg, s, repo)

	/////////////////
	// Cronjob GROUP
	/////////////////
	cronjob := r.Group("/cronjobs")
	{
		cronjob.POST("/audits", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Audit.Sync)
		cronjob.POST("/birthday", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.BirthdayDailyMessage)
		cronjob.POST("/on-leaves", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.OnLeaveMessage)
		cronjob.POST("/sync-discord-info", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.SyncDiscordInfo)
		cronjob.POST("/sync-monthly-accounting-todo", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Accounting.CreateAccountingTodo)
		cronjob.POST("/sync-project-member-status", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Project.SyncProjectMemberStatus)
		cronjob.POST("/store-vault-transaction", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Vault.StoreVaultTransaction)
		cronjob.POST("/index-engagement-messages", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Engagement.IndexMessages)
		cronjob.POST("/brainery-reports", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.ReportBraineryMetrics)
		cronjob.POST("/delivery-metric-reports", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.DeliveryMetricsReport)
		cronjob.POST("/sync-delivery-metrics", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.DeliveryMetric.Sync)
		cronjob.POST("/sync-conversion-rates", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.ConversionRate.Sync)
		cronjob.POST("/sync-memo", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.SyncMemo)
		cronjob.POST("/sweep-memo", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.SweepMemo)
		cronjob.POST("/notify-weekly-memos", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.NotifyWeeklyMemos)
		cronjob.POST("/transcribe-youtube-broadcast", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Youtube.TranscribeBroadcast)
		cronjob.POST("/sweep-ogif-event", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.SweepOgifEvent)
	}

	/////////////////
	// Webhook GROUP
	/////////////////
	webhook := r.Group("/webhooks")
	{
		webhook.POST("/n8n", h.Webhook.N8n)

		basecampGroup := webhook.Group("/basecamp")
		{
			expenseGroup := basecampGroup.Group("/expense")
			{
				expenseGroup.POST("/validate", h.Webhook.ValidateBasecampExpense)
				expenseGroup.POST("", h.Webhook.CreateBasecampExpense)
				expenseGroup.DELETE("", h.Webhook.UncheckBasecampExpense)
			}
			operationGroup := basecampGroup.Group("/operation")
			{
				operationGroup.POST("/accounting-transaction", h.Webhook.StoreAccountingTransaction)
				operationGroup.PUT("/invoice", h.Webhook.MarkInvoiceAsPaidViaBasecamp)
			}
			onLeaveGroup := basecampGroup.Group("/onleave")
			{
				onLeaveGroup.POST("/validate", h.Webhook.ValidateOnLeaveRequest)
				onLeaveGroup.POST("", h.Webhook.ApproveOnLeaveRequest)
			}
		}
	}

	/////////////////
	// API GROUP
	/////////////////
	v1 := r.Group("/api/v1")

	// assets
	assetGroup := v1.Group("/assets")
	{
		assetGroup.POST("/upload", amw.WithAuth, h.Asset.Upload)
	}

	lineManagerGroup := v1.Group("/line-managers")
	{
		lineManagerGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesRead), h.Employee.GetLineManagers)
	}

	// auth
	authRoute := v1.Group("/auth")
	{
		authRoute.POST("", h.Auth.Auth)
		authRoute.GET("/me", amw.WithAuth, pmw.WithPerm(model.PermissionAuthRead), h.Auth.Me)
		authRoute.POST("/api-key", amw.WithAuth, pmw.WithPerm(model.PermissionAuthCreate), h.Auth.CreateAPIKey)
	}

	// user profile
	profileGroup := v1.Group("/profile")
	{
		profileGroup.GET("", amw.WithAuth, h.Profile.GetProfile)
		profileGroup.PUT("", amw.WithAuth, h.Profile.UpdateInfo)
		profileGroup.POST("/upload-avatar", amw.WithAuth, h.Profile.UploadAvatar)
		profileGroup.POST("/upload", amw.WithAuth, h.Profile.Upload)
	}

	// employees
	employeeRoute := v1.Group("/employees")
	{
		employeeRoute.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesCreate), h.Employee.Create)
		employeeRoute.POST("/search", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesRead), h.Employee.List)
		employeeRoute.GET("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesRead), h.Employee.Details)
		employeeRoute.PUT("/:id/general-info", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesEdit), h.Employee.UpdateGeneralInfo)
		employeeRoute.PUT("/:id/personal-info", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesEdit), h.Employee.UpdatePersonalInfo)
		employeeRoute.PUT("/:id/skills", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesEdit), h.Employee.UpdateSkills)
		employeeRoute.PUT("/:id/employee-status", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesEdit), h.Employee.UpdateEmployeeStatus)
		employeeRoute.POST("/:id/upload-avatar", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesEdit), h.Employee.UploadAvatar)
		employeeRoute.PUT("/:id/roles", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeeRolesEdit), h.Employee.UpdateRole)
		employeeRoute.PUT("/:id/base-salary", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesBaseSalaryEdit), h.Employee.UpdateBaseSalary)
	}

	// metadata
	metadataRoute := v1.Group("/metadata")
	{
		metadataRoute.GET("/working-status", h.Metadata.WorkingStatuses)
		metadataRoute.GET("/banks", h.Metadata.Banks)
		metadataRoute.GET("/stacks", h.Metadata.Stacks)
		metadataRoute.GET("/seniorities", h.Metadata.Seniorities)
		metadataRoute.GET("/chapters", h.Metadata.Chapters)
		metadataRoute.GET("/organizations", h.Metadata.Organizations)
		metadataRoute.GET("/roles", h.Metadata.GetRoles)
		metadataRoute.GET("/positions", h.Metadata.Positions)
		metadataRoute.GET("/countries", h.Metadata.GetCountries)
		metadataRoute.GET("/currencies", h.Metadata.GetCurrencies)
		metadataRoute.GET("/countries/:country_id/cities", h.Metadata.GetCities)
		metadataRoute.GET("/project-statuses", h.Metadata.ProjectStatuses)
		metadataRoute.GET("/questions", h.Metadata.GetQuestions)
		metadataRoute.PUT("/stacks/:id", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataEdit), h.Metadata.UpdateStack)
		metadataRoute.POST("/stacks", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataCreate), h.Metadata.CreateStack)
		metadataRoute.DELETE("/stacks/:id", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataDelete), h.Metadata.DeleteStack)
		metadataRoute.PUT("/positions/:id", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataEdit), h.Metadata.UpdatePosition)
		metadataRoute.POST("/positions", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataCreate), h.Metadata.CreatePosition)
		metadataRoute.DELETE("/positions/:id", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataDelete), h.Metadata.DeletePosition)
	}

	// projects
	projectGroup := v1.Group("projects")
	{
		projectGroup.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsCreate), h.Project.Create)
		projectGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsRead), h.Project.List)
		projectGroup.GET("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsRead), h.Project.Details)
		projectGroup.PUT("/:id/sending-survey-state", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsEdit), h.Project.UpdateSendingSurveyState)
		projectGroup.POST("/:id/upload-avatar", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsEdit), h.Project.UploadAvatar)
		projectGroup.PUT("/:id/status", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsEdit), h.Project.UpdateProjectStatus)
		projectGroup.POST("/:id/members", amw.WithAuth, pmw.WithPerm(model.PermissionProjectMembersCreate), h.Project.AssignMember)
		projectGroup.GET("/:id/members", amw.WithAuth, pmw.WithPerm(model.PermissionProjectMembersRead), h.Project.GetMembers)
		projectGroup.PUT("/:id/members", amw.WithAuth, pmw.WithPerm(model.PermissionProjectMembersEdit), h.Project.UpdateMember)
		projectGroup.DELETE("/:id/members/:memberID", amw.WithAuth, pmw.WithPerm(model.PermissionProjectMembersDelete), h.Project.DeleteMember)
		projectGroup.DELETE("/:id/slots/:slotID", amw.WithAuth, pmw.WithPerm(model.PermissionProjectMembersDelete), h.Project.DeleteSlot)
		projectGroup.PUT("/:id/general-info", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsEdit), h.Project.UpdateGeneralInfo)
		projectGroup.PUT("/:id/contact-info", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsEdit), h.Project.UpdateContactInfo)
		projectGroup.GET("/:id/work-units", amw.WithAuth, pmw.WithPerm(model.PermissionProjectWorkUnitsRead), h.Project.GetWorkUnits)
		projectGroup.POST("/:id/work-units", amw.WithAuth, pmw.WithPerm(model.PermissionProjectWorkUnitsCreate), h.Project.CreateWorkUnit)
		projectGroup.PUT("/:id/work-units/:workUnitID", amw.WithAuth, pmw.WithPerm(model.PermissionProjectWorkUnitsEdit), h.Project.UpdateWorkUnit)
		projectGroup.PUT("/:id/work-units/:workUnitID/archive", amw.WithAuth, pmw.WithPerm(model.PermissionProjectWorkUnitsEdit), h.Project.ArchiveWorkUnit)
		projectGroup.PUT("/:id/work-units/:workUnitID/unarchive", amw.WithAuth, pmw.WithPerm(model.PermissionProjectWorkUnitsEdit), h.Project.UnarchiveWorkUnit)
		projectGroup.GET("/icy-distribution/weekly", amw.WithAuth, pmw.WithPerm(model.PermissionIcyDistributionRead), h.Project.IcyWeeklyDistribution)
	}

	clientGroup := v1.Group("/clients")
	{
		clientGroup.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionClientCreate), h.Client.Create)
		clientGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionClientRead), h.Client.List)
		clientGroup.GET("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionClientEdit), h.Client.Detail)
		clientGroup.PUT("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionClientRead), h.Client.Update)
		clientGroup.DELETE("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionClientDelete), h.Client.Delete)
	}

	feedbackGroup := v1.Group("/feedbacks")
	{
		feedbackGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionFeedbacksRead), h.Feedback.List)
		feedbackGroup.GET("/:id/topics/:topicID", amw.WithAuth, pmw.WithPerm(model.PermissionFeedbacksRead), h.Feedback.Detail)
		feedbackGroup.POST("/:id/topics/:topicID/submit", amw.WithAuth, pmw.WithPerm(model.PermissionFeedbacksCreate), h.Feedback.Submit)
		feedbackGroup.GET("/unreads", amw.WithAuth, pmw.WithPerm(model.PermissionFeedbacksRead), h.Feedback.CountUnreadFeedback)
	}

	surveyGroup := v1.Group("/surveys")
	{
		surveyGroup.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysCreate), h.Survey.CreateSurvey)
		surveyGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysRead), h.Survey.ListSurvey)
		surveyGroup.GET("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysRead), h.Survey.GetSurveyDetail)
		surveyGroup.DELETE("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysDelete), h.Survey.DeleteSurvey)
		surveyGroup.POST("/:id/send", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysCreate), h.Survey.SendSurvey)
		surveyGroup.GET("/:id/topics/:topicID/reviews/:reviewID", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeeEventQuestionsRead), h.Survey.GetSurveyReviewDetail)
		surveyGroup.DELETE("/:id/topics/:topicID", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysDelete), h.Survey.DeleteSurveyTopic)
		surveyGroup.GET("/:id/topics/:topicID", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysRead), h.Survey.GetSurveyTopicDetail)
		surveyGroup.PUT("/:id/topics/:topicID/employees", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysEdit), h.Survey.UpdateTopicReviewers)
		surveyGroup.PUT("/:id/done", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysEdit), h.Survey.MarkDone)
		surveyGroup.DELETE("/:id/topics/:topicID/employees", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysEdit), h.Survey.DeleteTopicReviewers)
	}

	bankGroup := v1.Group("/bank-accounts")
	{
		bankGroup.GET("", pmw.WithPerm(model.PermissionBankAccountRead), h.BankAccount.List)
	}

	companyInfoGroup := v1.Group("/company-infos")
	{
		companyInfoGroup.GET("", pmw.WithPerm(model.PermissionCompanyInfoRead), h.CompanyInfo.List)
	}

	invoiceGroup := v1.Group("/invoices")
	{
		invoiceGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionInvoiceRead), h.Invoice.List)
		invoiceGroup.PUT("/:id/status", amw.WithAuth, pmw.WithPerm(model.PermissionInvoiceEdit), h.Invoice.UpdateStatus)
		invoiceGroup.GET("/template", amw.WithAuth, pmw.WithPerm(model.PermissionInvoiceRead), h.Invoice.GetTemplate)
		invoiceGroup.POST("/send", amw.WithAuth, pmw.WithPerm(model.PermissionInvoiceRead), h.Invoice.Send)
	}

	valuation := v1.Group("/valuation")
	{
		valuation.GET("/:year", pmw.WithPerm(model.PermissionValuationRead), h.Valuation.One)
	}

	notion := v1.Group("/notion")
	{
		earn := notion.Group("/earn")
		{
			earn.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListEarns)
		}
		techRadar := notion.Group("/tech-radar")
		{
			techRadar.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListTechRadars)
			techRadar.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionCreate), h.Notion.CreateTechRadar)
		}
		audience := notion.Group("/audiences")
		{
			audience.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListAudiences)
		}
		event := notion.Group("/events")
		{
			event.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListEvents)
		}
		digest := notion.Group("/digests")
		{
			digest.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListDigests)
		}
		update := notion.Group("/updates")
		{
			update.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListUpdates)
		}
		memo := notion.Group("/memos")
		{
			memo.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListMemos)
		}
		issue := notion.Group("/issues")
		{
			issue.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListIssues)
		}
		staffingDemand := notion.Group("/staffing-demands")
		{
			staffingDemand.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListStaffingDemands)
		}
		hiring := notion.Group("/hiring-positions")
		{
			hiring.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListHiringPositions)
		}

		projectNotion := notion.Group("/projects")
		{
			projectNotion.GET("/milestones", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListProjectMilestones)
		}

		dfUpdates := notion.Group("df-updates")
		{
			dfUpdates.POST("/:id/send", amw.WithAuth, pmw.WithPerm(model.PermissionNotionSend), h.Notion.SendNewsLetter)
		}

		notionChangelog := notion.Group("changelogs")
		{
			notionChangelog.GET("/projects/available", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.GetAvailableProjectsChangelog)
			notionChangelog.POST("/project", amw.WithAuth, pmw.WithPerm(model.PermissionNotionSend), h.Notion.SendProjectChangelog)
		}
	}

	dashboard := v1.Group("/dashboards")
	{
		engagementDashboardGroup := dashboard.Group("/engagement", amw.WithAuth, pmw.WithPerm(model.PermissionDashBoardEngagementRead))
		{
			engagementDashboardGroup.GET("/info", h.Dashboard.GetEngagementInfo)
			engagementDashboardGroup.GET("/detail", h.Dashboard.GetEngagementInfoDetail)
		}

		projectDashboardGroup := dashboard.Group("/projects", amw.WithAuth, pmw.WithPerm(model.PermissionDashBoardProjectsRead))
		{
			projectDashboardGroup.GET("/sizes", h.Dashboard.GetProjectSizes)
			projectDashboardGroup.GET("/work-surveys", h.Dashboard.GetWorkSurveys)
			projectDashboardGroup.GET("/action-items", h.Dashboard.GetActionItemReports)
			projectDashboardGroup.GET("/engineering-healths", h.Dashboard.GetEngineeringHealth)
			projectDashboardGroup.GET("/audits", h.Dashboard.GetAudits)
			projectDashboardGroup.GET("/action-item-squash", h.Dashboard.GetActionItemSquashReports)
			projectDashboardGroup.GET("/summary", h.Dashboard.GetSummary)
		}

		resourceDashboardGroup := dashboard.Group("/resources", amw.WithAuth, pmw.WithPerm(model.PermissionDashBoardResourcesRead))
		{
			resourceDashboardGroup.GET("/availabilities", h.Dashboard.GetResourcesAvailability)
			resourceDashboardGroup.GET("/utilization", h.Dashboard.GetResourceUtilization)
			resourceDashboardGroup.GET("/work-unit-distribution", h.Dashboard.GetWorkUnitDistribution)
			resourceDashboardGroup.GET("/work-unit-distribution-summary", h.Dashboard.GetWorkUnitDistributionSummary)
			resourceDashboardGroup.GET("/work-survey-summaries", h.Dashboard.GetResourceWorkSurveySummaries)
		}
	}

	payroll := v1.Group("payrolls")
	{
		payroll.PUT("", amw.WithAuth, pmw.WithPerm(model.PermissionPayrollsEdit), h.Payroll.MarkPayrollAsPaid)
		payroll.GET("/detail", amw.WithAuth, pmw.WithPerm(model.PermissionPayrollsRead), h.Payroll.GetPayrollsByMonth)
		payroll.GET("/bhxh", amw.WithAuth, pmw.WithPerm(model.PermissionPayrollsRead), h.Payroll.GetPayrollsBHXH)
		payroll.POST("/commit", amw.WithAuth, pmw.WithPerm(model.PermissionPayrollsCreate), h.Payroll.CommitPayroll)
	}

	invitationGroup := v1.Group("/invite")
	{
		invitationGroup.GET("", amw.WithAuth, h.Profile.GetInvitation)
		invitationGroup.PUT("/submit", amw.WithAuth, h.Profile.SubmitOnboardingForm)
	}

	engagementsGroup := v1.Group("/engagements")
	{
		engagementsGroup.POST(
			"/rollup",
			amw.WithAuth,
			pmw.WithPerm(model.PermissionEngagementMetricsWrite),
			h.Engagement.UpsertRollup,
		)
		engagementsGroup.GET(
			"/channels/:channel-id/last-message-id",
			amw.WithAuth,
			pmw.WithPerm(model.PermissionEngagementMetricsRead),
			h.Engagement.GetLastMessageID,
		)
	}

	braineryGroup := v1.Group("/brainery-logs")
	{
		braineryGroup.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionBraineryLogsWrite), h.BraineryLog.Create)
		braineryGroup.GET("/metrics", amw.WithAuth, pmw.WithPerm(model.PermissionBraineryLogsRead), h.BraineryLog.GetMetrics)
		braineryGroup.POST("/sync", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.BraineryLog.Sync)
	}

	memoGroup := v1.Group("/memos")
	{
		memoGroup.POST("", amw.WithAuth, h.MemoLog.Create)
		memoGroup.POST("/sync", amw.WithAuth, h.MemoLog.Sync)
		memoGroup.GET("", amw.WithAuth, h.MemoLog.List)
		memoGroup.GET("/discords", amw.WithAuth, h.MemoLog.ListByDiscordID)
		memoGroup.GET("/prs", amw.WithAuth, h.MemoLog.ListOpenPullRequest)
		memoGroup.GET("/top-authors", amw.WithAuth, h.MemoLog.GetTopAuthors)
	}

	earnGroup := v1.Group("/earns")
	{
		earnGroup.GET("", amw.WithAuth, h.Earn.ListEarn)
	}

	// Delivery metrics
	{
		deliveryGroup := v1.Group("/delivery-metrics")
		deliveryGroup.POST("/report/sync", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsSync), h.DeliveryMetric.Sync)

		deliveryGroup.GET("/report/weekly", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsRead), h.DeliveryMetric.GetWeeklyReport)
		deliveryGroup.GET("/report/monthly", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsRead), h.DeliveryMetric.GetMonthlyReport)
		deliveryGroup.GET("/leader-board/weekly", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsLeaderBoardRead), h.DeliveryMetric.GetWeeklyLeaderBoard)
		deliveryGroup.GET("/leader-board/monthly", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsLeaderBoardRead), h.DeliveryMetric.GetMonthlyLeaderBoard)

		// API for fortress-discord
		deliveryGroup.GET("/report/weekly/discord-msg", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsRead), h.DeliveryMetric.GetWeeklyReportDiscordMsg)
		deliveryGroup.GET("/report/monthly/discord-msg", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsRead), h.DeliveryMetric.GetMonthlyReportDiscordMsg)
	}

	discordGroup := v1.Group("/discords")
	{
		discordGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.ListByDiscordRequest)
		discordGroup.GET("/mma-scores", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.ListWithMMAScore)
		discordGroup.POST("/advance-salary", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.SalaryAdvance)
		discordGroup.POST("/check-advance-salary", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.CheckSalaryAdvance)

		discordGroup.GET("/salary-advance-report", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.SalaryAdvanceReport)
		discordGroup.GET("/:discord_id/earns/transactions", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.GetEmployeeEarnTransactions)
		discordGroup.GET("/:discord_id/earns/total", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.GetEmployeeTotalEarn)
		discordGroup.GET("/earns/total", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.GetTotalEarn)
		discordGroup.POST("/office-checkin", amw.WithAuth, pmw.WithPerm(model.PermissionTransferCheckinIcy), h.Employee.OfficeCheckIn)

		discordGroup.GET("/icy-accounting", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Icy.Accounting)

		scheduledEventGroup := discordGroup.Group("/scheduled-events")
		{
			scheduledEventGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Discord.ListScheduledEvent)
			scheduledEventGroup.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordCreate), h.Discord.CreateScheduledEvent)
			scheduledEventGroup.PUT("/:id/speakers", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordEdit), h.Discord.SetScheduledEventSpeakers)
		}

		discordGroup.GET("/research-topics", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Discord.ListDiscordResearchTopics)
	}

	conversionRateGroup := v1.Group("/conversion-rates")
	{
		conversionRateGroup.GET("", amw.WithAuth, h.ConversionRate.List)
	}

	newsGroup := v1.Group("/news")
	{
		newsGroup.GET("", amw.WithAuth, h.News.Fetch)
	}

	ogifGroup := v1.Group("/ogif")
	{
		ogifGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Discord.UserOgifStats)
		ogifGroup.GET("/leaderboard", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Discord.OgifLeaderboard)
	}

	/////////////////
	// PUBLIC API GROUP
	/////////////////

	// assets
	publicGroup := v1.Group("/public")
	{
		publicGroup.GET("/employees", h.Employee.PublicList)
		publicGroup.GET("/clients", h.Client.PublicList)
		publicGroup.GET("/community-nfts/:id", h.CommunityNft.GetNftMetadata)
		publicGroup.GET("/youtube/broadcast", h.Youtube.LatestBroadcast)
	}
}

```

# pkg/routes/routes.go

```go
package routes

import (
	"strings"

	"github.com/gin-contrib/cors"
	"github.com/gin-contrib/pprof"
	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"     // swagger embed files
	ginSwagger "github.com/swaggo/gin-swagger" // gin-swagger middleware

	"github.com/dwarvesf/fortress-api/docs"
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/handler"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/worker"
)

func setupCORS(r *gin.Engine, cfg *config.Config) {
	corsOrigins := strings.Split(cfg.ApiServer.AllowedOrigins, ";")
	r.Use(func(c *gin.Context) {
		cors.New(
			cors.Config{
				AllowOrigins: corsOrigins,
				AllowMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD"},
				AllowHeaders: []string{
					"Origin", "Host", "Content-Type", "Content-Length", "Accept-Encoding", "Accept-Language", "Accept",
					"X-CSRF-Token", "Authorization", "X-Requested-With", "X-Access-Token",
				},
				AllowCredentials: true,
			},
		)(c)
	})
}

func NewRoutes(cfg *config.Config, svc *service.Service, s *store.Store, repo store.DBRepo, worker *worker.Worker, logger logger.Logger) *gin.Engine {
	// programmatically set swagger info
	docs.SwaggerInfo.Title = "Swagger API"
	docs.SwaggerInfo.Description = "This is a swagger for API."
	docs.SwaggerInfo.Version = "1.0"
	docs.SwaggerInfo.Schemes = []string{"https", "http"}
	r := gin.New()
	pprof.Register(r)

	ctrl := controller.New(s, repo, svc, worker, logger, cfg)
	h := handler.New(s, repo, svc, ctrl, worker, logger, cfg)

	r.Use(
		gin.LoggerWithWriter(gin.DefaultWriter, "/healthz"),
		gin.Recovery(),
	)
	// config CORS
	setupCORS(r, cfg)

	r.GET("/healthz", h.Healthcheck.Healthz)

	// use ginSwagger middleware to serve the API docs
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	// load API here
	loadV1Routes(r, h, repo, s, cfg)

	return r
}

```

# pkg/request/validator.go

```go
package request

import (
	"reflect"
	"strconv"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/binding"
	"github.com/go-playground/validator/v10"

	"github.com/dwarvesf/fortress-api/pkg/logger"
)

func RegisCustomValidators(engine *gin.Engine) {
	if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
		regisCrossFieldGte(v)
	}
}

func regisCrossFieldGte(v *validator.Validate) {
	err := v.RegisterValidation("fieldgte", func(fl validator.FieldLevel) bool {
		field := fl.Field()
		kind := field.Kind()
		params := strings.Split(fl.Param(), " ")

		currentField, currentKind, _, found := fl.GetStructFieldOKAdvanced2(fl.Parent(), params[0])

		if !found || currentKind != kind {
			return false
		}

		gteValue, err := strconv.ParseInt(params[1], 10, 64)
		if err != nil {
			return false
		}

		switch kind {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			return field.Int()-currentField.Int() >= gteValue
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			return field.Uint()-currentField.Uint() >= uint64(gteValue)
		case reflect.Float32, reflect.Float64:
			return field.Float()-currentField.Float() >= float64(gteValue)
		}

		return len(field.String())-len(currentField.String()) >= int(gteValue)
	})
	if err != nil {
		logger.L.Error(err, "failed to register validation")
	}
}

```

# pkg/store/test_repo.go

```go
package store

import (
	"gorm.io/gorm"
)

// testRepo is implementation of repository
type testRepo struct {
	Database *gorm.DB
}

// DB database connection
func (s *testRepo) DB() *gorm.DB {
	return s.Database
}

func NewTestRepo(db *gorm.DB) DBRepo {
	return &testRepo{Database: db}
}

// NewTransaction for database connection
func (s *testRepo) NewTransaction() (newRepo DBRepo, finallyFn FinallyFunc) {
	finallyFn = func(err error) error {
		return err
	}

	return &testRepo{Database: s.DB()}, finallyFn
}

func (s *testRepo) SetNewDB(db *gorm.DB) {
	s.Database = db
}

```

# pkg/store/store_util.go

```go
package store

import (
	"database/sql"
	"fmt"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	gormlogger "gorm.io/gorm/logger"
)

// NewPostgresStore postgres init by gorm
func NewPostgresStore(cfg *config.Config) DBRepo {
	ds := fmt.Sprintf(
		"postgres://%s:%s@%s:%s/%s?sslmode=disable",
		cfg.Postgres.User, cfg.Postgres.Pass,
		cfg.Postgres.Host, cfg.Postgres.Port, cfg.Postgres.Name,
	)

	conn, err := sql.Open("postgres", ds)
	if err != nil {
		logger.L.Fatalf(err, "failed to open database connection")
	}

	db, err := gorm.Open(postgres.New(
		postgres.Config{Conn: conn}),
		&gorm.Config{
			NamingStrategy: schema.NamingStrategy{
				SingularTable: false,
			},
		})
	if err != nil {
		logger.L.Fatalf(err, "failed to open database connection")
	}

	logger.L.Info("database connected")

	if cfg.Debug {
		db.Logger = gormlogger.Default.LogMode(gormlogger.Info)
	}

	return &repo{Database: db}
}

```

# pkg/store/store.go

```go
package store

import (
	"github.com/dwarvesf/fortress-api/pkg/store/accounting"
	"github.com/dwarvesf/fortress-api/pkg/store/actionitem"
	"github.com/dwarvesf/fortress-api/pkg/store/actionitemsnapshot"
	"github.com/dwarvesf/fortress-api/pkg/store/apikey"
	"github.com/dwarvesf/fortress-api/pkg/store/apikeyrole"
	"github.com/dwarvesf/fortress-api/pkg/store/audit"
	"github.com/dwarvesf/fortress-api/pkg/store/auditactionitem"
	"github.com/dwarvesf/fortress-api/pkg/store/auditcycle"
	"github.com/dwarvesf/fortress-api/pkg/store/audititem"
	"github.com/dwarvesf/fortress-api/pkg/store/auditparticipant"
	"github.com/dwarvesf/fortress-api/pkg/store/bank"
	"github.com/dwarvesf/fortress-api/pkg/store/bankaccount"
	"github.com/dwarvesf/fortress-api/pkg/store/basesalary"
	"github.com/dwarvesf/fortress-api/pkg/store/brainerylog"
	"github.com/dwarvesf/fortress-api/pkg/store/cachedpayroll"
	"github.com/dwarvesf/fortress-api/pkg/store/chapter"
	"github.com/dwarvesf/fortress-api/pkg/store/client"
	"github.com/dwarvesf/fortress-api/pkg/store/clientcontact"
	"github.com/dwarvesf/fortress-api/pkg/store/companyinfo"
	"github.com/dwarvesf/fortress-api/pkg/store/config"
	"github.com/dwarvesf/fortress-api/pkg/store/content"
	"github.com/dwarvesf/fortress-api/pkg/store/conversionrate"
	"github.com/dwarvesf/fortress-api/pkg/store/country"
	"github.com/dwarvesf/fortress-api/pkg/store/currency"
	"github.com/dwarvesf/fortress-api/pkg/store/dashboard"
	"github.com/dwarvesf/fortress-api/pkg/store/deliverymetric"
	"github.com/dwarvesf/fortress-api/pkg/store/deliverymetricmonthly"
	"github.com/dwarvesf/fortress-api/pkg/store/deliverymetricweekly"
	"github.com/dwarvesf/fortress-api/pkg/store/discordaccount"
	"github.com/dwarvesf/fortress-api/pkg/store/discordevent"
	"github.com/dwarvesf/fortress-api/pkg/store/discordtemplate"
	"github.com/dwarvesf/fortress-api/pkg/store/employee"
	"github.com/dwarvesf/fortress-api/pkg/store/employeebonus"
	"github.com/dwarvesf/fortress-api/pkg/store/employeechapter"
	"github.com/dwarvesf/fortress-api/pkg/store/employeecommission"
	"github.com/dwarvesf/fortress-api/pkg/store/employeeeventquestion"
	"github.com/dwarvesf/fortress-api/pkg/store/employeeeventreviewer"
	"github.com/dwarvesf/fortress-api/pkg/store/employeeeventtopic"
	"github.com/dwarvesf/fortress-api/pkg/store/employeeinvitation"
	"github.com/dwarvesf/fortress-api/pkg/store/employeeorganization"
	"github.com/dwarvesf/fortress-api/pkg/store/employeeposition"
	"github.com/dwarvesf/fortress-api/pkg/store/employeerole"
	"github.com/dwarvesf/fortress-api/pkg/store/employeestack"
	"github.com/dwarvesf/fortress-api/pkg/store/engagementsrollup"
	"github.com/dwarvesf/fortress-api/pkg/store/eventspeaker"
	"github.com/dwarvesf/fortress-api/pkg/store/expense"
	"github.com/dwarvesf/fortress-api/pkg/store/feedbackevent"
	"github.com/dwarvesf/fortress-api/pkg/store/icydistribution"
	"github.com/dwarvesf/fortress-api/pkg/store/icytransaction"
	"github.com/dwarvesf/fortress-api/pkg/store/invoice"
	"github.com/dwarvesf/fortress-api/pkg/store/invoicenumbercaching"
	"github.com/dwarvesf/fortress-api/pkg/store/memolog"
	"github.com/dwarvesf/fortress-api/pkg/store/onleaverequest"
	"github.com/dwarvesf/fortress-api/pkg/store/operationalservice"
	"github.com/dwarvesf/fortress-api/pkg/store/organization"
	"github.com/dwarvesf/fortress-api/pkg/store/payroll"
	"github.com/dwarvesf/fortress-api/pkg/store/permission"
	"github.com/dwarvesf/fortress-api/pkg/store/physicalcheckin"
	"github.com/dwarvesf/fortress-api/pkg/store/position"
	"github.com/dwarvesf/fortress-api/pkg/store/project"
	"github.com/dwarvesf/fortress-api/pkg/store/projectcommissionconfig"
	"github.com/dwarvesf/fortress-api/pkg/store/projecthead"
	"github.com/dwarvesf/fortress-api/pkg/store/projectmember"
	"github.com/dwarvesf/fortress-api/pkg/store/projectmemberposition"
	"github.com/dwarvesf/fortress-api/pkg/store/projectnotion"
	"github.com/dwarvesf/fortress-api/pkg/store/projectslot"
	"github.com/dwarvesf/fortress-api/pkg/store/projectslotposition"
	"github.com/dwarvesf/fortress-api/pkg/store/projectstack"
	"github.com/dwarvesf/fortress-api/pkg/store/question"
	"github.com/dwarvesf/fortress-api/pkg/store/recruitment"
	"github.com/dwarvesf/fortress-api/pkg/store/role"
	"github.com/dwarvesf/fortress-api/pkg/store/salaryadvance"
	"github.com/dwarvesf/fortress-api/pkg/store/schedule"
	"github.com/dwarvesf/fortress-api/pkg/store/seniority"
	"github.com/dwarvesf/fortress-api/pkg/store/socialaccount"
	"github.com/dwarvesf/fortress-api/pkg/store/stack"
	"github.com/dwarvesf/fortress-api/pkg/store/valuation"
	"github.com/dwarvesf/fortress-api/pkg/store/workunit"
	"github.com/dwarvesf/fortress-api/pkg/store/workunitmember"
	"github.com/dwarvesf/fortress-api/pkg/store/workunitstack"
)

type Store struct {
	Accounting              accounting.IStore
	ActionItem              actionitem.IStore
	ActionItemSnapshot      actionitemsnapshot.IStore
	APIKey                  apikey.IStore
	APIKeyRole              apikeyrole.IStore
	Audit                   audit.IStore
	AuditActionItem         auditactionitem.IStore
	AuditCycle              auditcycle.IStore
	AuditItem               audititem.IStore
	AuditParticipant        auditparticipant.IStore
	SalaryAdvance           salaryadvance.IStore
	Bank                    bank.IStore
	BankAccount             bankaccount.IStore
	BaseSalary              basesalary.IStore
	Bonus                   employeebonus.IStore
	BraineryLog             brainerylog.IStore
	CachedPayroll           cachedpayroll.IStore
	Chapter                 chapter.IStore
	Client                  client.IStore
	ClientContact           clientcontact.IStore
	CompanyInfo             companyinfo.IStore
	Content                 content.IStore
	ConversionRate          conversionrate.IStore
	Country                 country.IStore
	Currency                currency.IStore
	Config                  config.IStore
	Dashboard               dashboard.IStore
	DeliveryMetric          deliverymetric.IStore
	DiscordAccount          discordaccount.IStore
	DiscordEvent            discordevent.IStore
	DiscordLogTemplate      discordtemplate.IStore
	Employee                employee.IStore
	EmployeeChapter         employeechapter.IStore
	EmployeeCommission      employeecommission.IStore
	EmployeeEventQuestion   employeeeventquestion.IStore
	EmployeeEventReviewer   employeeeventreviewer.IStore
	EmployeeEventTopic      employeeeventtopic.IStore
	EmployeeInvitation      employeeinvitation.IStore
	EmployeeOrganization    employeeorganization.IStore
	EmployeePosition        employeeposition.IStore
	EmployeeRole            employeerole.IStore
	EmployeeStack           employeestack.IStore
	EventSpeaker            eventspeaker.IStore
	EngagementsRollup       engagementsrollup.IStore
	Expense                 expense.IStore
	FeedbackEvent           feedbackevent.IStore
	IcyDistribution         icydistribution.IStore
	IcyTransaction          icytransaction.IStore
	Invoice                 invoice.IStore
	InvoiceNumberCaching    invoicenumbercaching.IStore
	MemoLog                 memolog.IStore
	MonthlyDeliveryMetric   deliverymetricmonthly.IStore
	OnLeaveRequest          onleaverequest.IStore
	OperationalService      operationalservice.IStore
	Organization            organization.IStore
	Payroll                 payroll.IStore
	Permission              permission.IStore
	Position                position.IStore
	Project                 project.IStore
	ProjectCommissionConfig projectcommissionconfig.IStore
	ProjectHead             projecthead.IStore
	ProjectMember           projectmember.IStore
	ProjectMemberPosition   projectmemberposition.IStore
	ProjectNotion           projectnotion.IStore
	ProjectSlot             projectslot.IStore
	ProjectSlotPosition     projectslotposition.IStore
	ProjectStack            projectstack.IStore
	PhysicalCheckin         physicalcheckin.IStore
	Question                question.IStore
	Recruitment             recruitment.IStore
	Role                    role.IStore
	Schedule                schedule.IStore
	Seniority               seniority.IStore
	SocialAccount           socialaccount.IStore
	Stack                   stack.IStore
	Valuation               valuation.IStore
	WeeklyDeliveryMetric    deliverymetricweekly.IStore
	WorkUnit                workunit.IStore
	WorkUnitMember          workunitmember.IStore
	WorkUnitStack           workunitstack.IStore
}

func New() *Store {
	return &Store{
		Accounting:              accounting.New(),
		ActionItem:              actionitem.New(),
		ActionItemSnapshot:      actionitemsnapshot.New(),
		APIKey:                  apikey.New(),
		APIKeyRole:              apikeyrole.New(),
		Audit:                   audit.New(),
		AuditActionItem:         auditactionitem.New(),
		AuditCycle:              auditcycle.New(),
		AuditItem:               audititem.New(),
		AuditParticipant:        auditparticipant.New(),
		SalaryAdvance:           salaryadvance.New(),
		Bank:                    bank.New(),
		BankAccount:             bankaccount.New(),
		BaseSalary:              basesalary.New(),
		Bonus:                   employeebonus.New(),
		BraineryLog:             brainerylog.New(),
		CachedPayroll:           cachedpayroll.New(),
		Chapter:                 chapter.New(),
		Client:                  client.New(),
		ClientContact:           clientcontact.New(),
		CompanyInfo:             companyinfo.New(),
		Content:                 content.New(),
		ConversionRate:          conversionrate.New(),
		Country:                 country.New(),
		Currency:                currency.New(),
		Config:                  config.New(),
		Dashboard:               dashboard.New(),
		DeliveryMetric:          deliverymetric.New(),
		DiscordAccount:          discordaccount.New(),
		DiscordEvent:            discordevent.New(),
		DiscordLogTemplate:      discordtemplate.New(),
		Employee:                employee.New(),
		EmployeeChapter:         employeechapter.New(),
		EmployeeCommission:      employeecommission.New(),
		EmployeeEventQuestion:   employeeeventquestion.New(),
		EmployeeEventReviewer:   employeeeventreviewer.New(),
		EmployeeEventTopic:      employeeeventtopic.New(),
		EmployeeInvitation:      employeeinvitation.New(),
		EmployeeOrganization:    employeeorganization.New(),
		EmployeePosition:        employeeposition.New(),
		EmployeeRole:            employeerole.New(),
		EmployeeStack:           employeestack.New(),
		EngagementsRollup:       engagementsrollup.New(),
		EventSpeaker:            eventspeaker.New(),
		Expense:                 expense.New(),
		FeedbackEvent:           feedbackevent.New(),
		IcyDistribution:         icydistribution.New(),
		IcyTransaction:          icytransaction.New(),
		Invoice:                 invoice.New(),
		InvoiceNumberCaching:    invoicenumbercaching.New(),
		MemoLog:                 memolog.New(),
		MonthlyDeliveryMetric:   deliverymetricmonthly.New(),
		OnLeaveRequest:          onleaverequest.New(),
		OperationalService:      operationalservice.New(),
		Organization:            organization.New(),
		Payroll:                 payroll.New(),
		Permission:              permission.New(),
		Position:                position.New(),
		Project:                 project.New(),
		ProjectCommissionConfig: projectcommissionconfig.New(),
		ProjectHead:             projecthead.New(),
		ProjectMember:           projectmember.New(),
		ProjectMemberPosition:   projectmemberposition.New(),
		ProjectNotion:           projectnotion.New(),
		ProjectSlot:             projectslot.New(),
		ProjectSlotPosition:     projectslotposition.New(),
		ProjectStack:            projectstack.New(),
		PhysicalCheckin:         physicalcheckin.New(),
		Question:                question.New(),
		Recruitment:             recruitment.New(),
		Role:                    role.New(),
		Schedule:                schedule.New(),
		Seniority:               seniority.New(),
		SocialAccount:           socialaccount.New(),
		Stack:                   stack.New(),
		Valuation:               valuation.New(),
		WeeklyDeliveryMetric:    deliverymetricweekly.New(),
		WorkUnit:                workunit.New(),
		WorkUnitMember:          workunitmember.New(),
		WorkUnitStack:           workunitstack.New(),
	}
}

```

# pkg/store/repo.go

```go
package store

import (
	"errors"

	"gorm.io/gorm"
)

// FinallyFunc function to finish a transaction
type FinallyFunc = func(error) error

// DBRepo ..
type DBRepo interface {
	DB() *gorm.DB
	NewTransaction() (DBRepo, FinallyFunc)
	SetNewDB(*gorm.DB)
}

// repo is implementation of repository
type repo struct {
	Database *gorm.DB
}

// DB database connection
func (s *repo) DB() *gorm.DB {
	return s.Database
}

func NewRepo(db *gorm.DB) DBRepo {
	return &repo{Database: db}
}

// NewTransaction for database connection
func (s *repo) NewTransaction() (newRepo DBRepo, finallyFn FinallyFunc) {
	newDB := s.Database.Begin()

	finallyFn = func(err error) error {
		if err != nil {
			nErr := newDB.Rollback().Error
			if nErr != nil {
				return errors.New(nErr.Error())
			}
			return err
		}

		cErr := newDB.Commit().Error
		if cErr != nil {
			return errors.New(cErr.Error())
		}
		return nil
	}

	return &repo{Database: newDB}, finallyFn
}

func (s *repo) SetNewDB(db *gorm.DB) {
	s.Database = db
}

```

# pkg/mw/mw_test.go

```go
package mw

import (
	"errors"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/require"
)

func TestWithAuth(t *testing.T) {
	type args struct {
		testURL          string
		testTokenType    string
		testAccessToken  string
		expectedHTTPCode int
		expectedError    error
	}
	tcs := map[string]args{
		"authorization header valid": {
			testURL:          "/sample-routes",
			expectedHTTPCode: http.StatusOK,
			testTokenType:    "Bearer",
			testAccessToken:  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MzA4OTAyNjIsIlVzZXJJRCI6IjI2NTU4MzJlLWYwMDktNGI3My1hNTM1LTY0YzNhMjJlNTU4ZiIsImF2YXRhciI6Imh0dHBzOi8vczMtYXAtc291dGhlYXN0LTEuYW1hem9uYXdzLmNvbS9mb3J0cmVzcy1pbWFnZXMvNTE1MzU3NDY5NTY2Mzk1NTk0NC5wbmciLCJlbWFpbCI6InRoYW5oQGQuZm91bmRhdGlvbiIsInBlcm1pc3Npb25zIjpbImVtcGxveWVlcy5yZWFkIl0sInVzZXJfaW5mbyI6bnVsbH0.MDHMPBJC8BPY4ZJNg5j0xn2jUvVDg-05M6AKqrTwdSM",
		},
		"authorization header invalid": {
			testURL:          "/sample-routes",
			testTokenType:    "",
			testAccessToken:  "",
			expectedHTTPCode: http.StatusUnauthorized,
			expectedError:    ErrAuthenticationTypeHeaderInvalid,
		},
		"authorization header invalid - missing token type": {
			testURL:          "/sample-routes",
			testTokenType:    "",
			testAccessToken:  "access_token",
			expectedHTTPCode: http.StatusUnauthorized,
			expectedError:    ErrAuthenticationTypeHeaderInvalid,
		},
		"authorization header invalid - none token type": {
			testURL:          "/sample-routes",
			testTokenType:    "Bearerr",
			testAccessToken:  "access_token",
			expectedHTTPCode: http.StatusUnauthorized,
			expectedError:    ErrAuthenticationTypeHeaderInvalid,
		},
		"invalid access token - invalid length of segments": {
			testURL:          "/sample-routes",
			testTokenType:    "Bearer",
			testAccessToken:  "access_token",
			expectedHTTPCode: http.StatusUnauthorized,
			expectedError:    errors.New("token contains an invalid number of segments"),
		},
		"invalid access token - invalid signature": {
			testURL:          "/sample-routes",
			testTokenType:    "Bearer",
			testAccessToken:  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTkzNTM4OTcsIlVzZXJJRCI6IjI2NTU4MzJlLWYwMDktNGI3My1hNTM1LTY0YzNhMjJlNTU4ZiIsImF2YXRhciI6Imh0dHBzOi8vczMtYXAtc291dGhlYXN0LTEuYW1hem9uYXdzLmNvbS9mb3J0cmVzcy1pbWFnZXMvNTE1MzU3NDY5NTY2Mzk1NTk0NC5wbmciLCJlbWFpbCI6InRoYW5oQGQuZm91bmRhdGlvbiIsInBlcm1pc3Npb25zIjpbImVtcGxveWVlcy5yZWFkIl0sInVzZXJfaW5mbyI6bnVsbH0.WoIAHchh9H6tEClULpJBPB0zmkZEOgtoWBEVlTzHZbc",
			expectedHTTPCode: http.StatusUnauthorized,
			expectedError:    errors.New("signature is invalid"),
		},
		"invalid access token - expired": {
			testURL:          "/sample-routes",
			expectedHTTPCode: http.StatusUnauthorized,
			testTokenType:    "Bearer",
			testAccessToken:  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njc4MTc4MzEsIlVzZXJJRCI6IjI2NTU4MzJlLWYwMDktNGI3My1hNTM1LTY0YzNhMjJlNTU4ZiIsImF2YXRhciI6Imh0dHBzOi8vczMtYXAtc291dGhlYXN0LTEuYW1hem9uYXdzLmNvbS9mb3J0cmVzcy1pbWFnZXMvNTE1MzU3NDY5NTY2Mzk1NTk0NC5wbmciLCJlbWFpbCI6InRoYW5oQGQuZm91bmRhdGlvbiIsInBlcm1pc3Npb25zIjpbImVtcGxveWVlcy5yZWFkIl0sInVzZXJfaW5mbyI6bnVsbH0.GLzCC6dcHRjPFGm_CQHzrD3nmSsKrqsN6Yq6BYzNRbk",
			expectedError:    errors.New("token is expired"),
		},
	}
	for desc, tc := range tcs {
		t.Run(desc, func(t *testing.T) {
			r := prepareTestDefaultRoutes()
			req, _ := http.NewRequest("GET", tc.testURL, nil)
			req.Header.Set("Authorization", fmt.Sprintf("%s %s", tc.testTokenType, tc.testAccessToken))

			// Create a response recorder
			w := httptest.NewRecorder()

			// Create the service and process the above request.
			r.ServeHTTP(w, req)
			if tc.expectedError != nil {
				require.Contains(t, w.Body.String(), tc.expectedError.Error())
			}
			require.Equal(t, tc.expectedHTTPCode, w.Code)
		})
	}
}

func prepareTestDefaultRoutes() *gin.Engine {
	cfg := config.LoadTestConfig()
	storeMock := store.New()
	amw := NewAuthMiddleware(&cfg, storeMock, nil)

	r := gin.Default()
	r.GET("/sample-routes", amw.WithAuth)

	return r
}

```

# pkg/mw/mw.go

```go
package mw

import (
	"errors"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v4"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
)

var noAuthPath = []string{
	"/healthz",
}

type AuthMiddleware struct {
	cfg   *config.Config
	store *store.Store
	repo  store.DBRepo
}

func NewAuthMiddleware(cfg *config.Config, s *store.Store, r store.DBRepo) *AuthMiddleware {
	return &AuthMiddleware{
		cfg:   cfg,
		store: s,
		repo:  r,
	}
}

// WithAuth a middleware to check the access token
func (amw *AuthMiddleware) WithAuth(c *gin.Context) {
	if !authRequired(c) {
		c.Next()
		return
	}

	err := amw.authenticate(c)
	if err != nil {
		c.AbortWithStatusJSON(401, map[string]string{"message": err.Error()})
		return
	}

	c.Next()
}

func authRequired(c *gin.Context) bool {
	requestURL := c.Request.URL.Path
	for _, v := range noAuthPath {
		if strings.Contains(requestURL, v) {
			return false
		}
	}

	return true
}

func (amw *AuthMiddleware) authenticate(c *gin.Context) error {
	headers := strings.Split(c.Request.Header.Get("Authorization"), " ")
	if len(headers) != 2 {
		return ErrUnexpectedAuthorizationHeader
	}
	switch headers[0] {
	case "Bearer":
		return amw.validateToken(headers[1])
	case "ApiKey":
		return amw.validateAPIKey(headers[1])
	default:
		return ErrAuthenticationTypeHeaderInvalid
	}
}

// validateToken a func help validate the access token we got
func (amw *AuthMiddleware) validateToken(accessToken string) error {
	claims := &jwt.RegisteredClaims{}

	_, err := jwt.ParseWithClaims(accessToken, claims, func(token *jwt.Token) (interface{}, error) {
		return []byte(amw.cfg.JWTSecretKey), nil
	})
	if err != nil {
		return err
	}

	return claims.Valid()
}
func NewPermissionMiddleware(s *store.Store, r store.DBRepo, cfg *config.Config) *PermMiddleware {
	return &PermMiddleware{
		store:  s,
		repo:   r,
		config: cfg,
	}
}

func (amw *AuthMiddleware) validateAPIKey(apiKey string) error {
	clientID, key, err := authutils.ExtractAPIKey(apiKey)
	if err != nil {
		return ErrInvalidAPIKey
	}

	rec, err := amw.store.APIKey.GetByClientID(amw.repo.DB(), clientID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return ErrInvalidAPIKey
		}
		return err
	}
	if rec.Status != model.ApikeyStatusValid {
		return ErrInvalidAPIKey
	}

	return authutils.ValidateHashedKey(rec.SecretKey, key)
}

type PermMiddleware struct {
	store  *store.Store
	repo   store.DBRepo
	config *config.Config
}

// WithPerm a middleware to check the permission
func (m *PermMiddleware) WithPerm(perm model.PermissionCode) func(c *gin.Context) {
	return func(c *gin.Context) {
		accessToken, err := authutils.GetTokenFromRequest(c)
		if err != nil {
			c.AbortWithStatusJSON(401, map[string]string{"message": err.Error()})
			return
		}
		tokenType := model.TokenTypeJWT
		if authutils.IsAPIKey(c) {
			tokenType = model.TokenTypeAPIKey
		}

		err = m.ensurePerm(m.store, m.repo.DB(), accessToken, perm.String(), tokenType.String())
		if err != nil {
			c.AbortWithStatusJSON(401, map[string]string{"message": err.Error()})
			return
		}

		c.Next()
	}
}

func (m *PermMiddleware) ensurePerm(storeDB *store.Store, db *gorm.DB, accessToken string, requiredPerm string, tokenType string) error {
	var perms []*model.Permission

	if tokenType == model.TokenTypeAPIKey.String() {
		clientID, key, err := authutils.ExtractAPIKey(accessToken)
		if err != nil {
			return ErrInvalidAPIKey
		}

		apikey, err := storeDB.APIKey.GetByClientID(db, clientID)
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return ErrInvalidAPIKey
			}
			return err
		}

		if apikey.Status != model.ApikeyStatusValid {
			return ErrInvalidAPIKey
		}

		err = authutils.ValidateHashedKey(apikey.SecretKey, key)
		if err != nil {
			return err
		}

		perms, err = storeDB.Permission.GetByApiKeyID(db, apikey.ID.String())
		if err != nil {
			return err
		}
	}

	if tokenType == model.TokenTypeJWT.String() {
		token, err := jwt.Parse(accessToken, func(token *jwt.Token) (interface{}, error) {
			return []byte(m.config.JWTSecretKey), nil
		})
		if err != nil {
			return err
		}

		claims, ok := token.Claims.(jwt.MapClaims)
		if !ok || !token.Valid {
			return ErrUnauthorized
		}

		userID, ok := claims["id"].(string)
		if !ok {
			return ErrInvalidUserID
		}

		perms, err = storeDB.Permission.GetByEmployeeID(db, userID)
		if err != nil {
			return err
		}
	}

	ok := false
	for _, v := range perms {
		if v.Code == requiredPerm {
			ok = true
			break
		}
	}

	if !ok {
		return errUnauthorized(requiredPerm)
	}

	return nil
}

```

# pkg/mw/errors.go

```go
package mw

import (
	"errors"
	"fmt"
)

var (
	ErrUnauthorized                    = errors.New("unauthorized")
	ErrInvalidUserID                   = errors.New("invalid user id")
	ErrAuthenticationTypeHeaderInvalid = errors.New("authentication type header is invalid")
	ErrUnexpectedAuthorizationHeader   = errors.New("unexpected authorization headers")
	ErrInvalidAPIKey                   = errors.New("invalid API key")
)

// errUnauthorized returns unauthorized custom error
func errUnauthorized(description string) error {
	return fmt.Errorf("unauthorized permission required: %v", description)
}

```

# pkg/logger/logrus.go

```go
package logger

import (
	"os"

	"github.com/sirupsen/logrus"
)

type LogrusLogger struct {
	logger *logrus.Logger
	fields Fields
}

var L Logger

func NewLogrusLogger() Logger {
	l := logrus.New()
	l.SetFormatter(&logrus.JSONFormatter{})

	hostname, err := os.Hostname()
	if err != nil {
		hostname = "unknown"
	}
	defaultFields := Fields{
		"service":  "fortress-api",
		"hostname": hostname,
	}

	L = &LogrusLogger{
		logger: l,
		fields: defaultFields,
	}

	return L
}

func (l *LogrusLogger) Fields(data Fields) Logger {
	return &LogrusLogger{
		logger: l.logger,
		fields: data,
	}
}

func (l *LogrusLogger) Field(key, value string) Logger {
	return &LogrusLogger{
		logger: l.logger,
		fields: Fields{key: value},
	}
}

func (l LogrusLogger) AddField(key string, value any) Logger {
	l.fields[key] = value
	return &LogrusLogger{
		logger: l.logger,
		fields: l.fields,
	}
}

func (l *LogrusLogger) Debug(msg string) {
	l.logger.WithFields(logrus.Fields(l.fields)).Debug(msg)
}

func (l *LogrusLogger) Debugf(msg string, args ...interface{}) {
	l.logger.WithFields(logrus.Fields(l.fields)).Debugf(msg, args...)
}

func (l *LogrusLogger) Info(msg string) {
	l.logger.WithFields(logrus.Fields(l.fields)).Info(msg)
}

func (l *LogrusLogger) Infof(msg string, args ...interface{}) {
	l.logger.WithFields(logrus.Fields(l.fields)).Infof(msg, args...)
}

func (l *LogrusLogger) Warn(msg string) {
	l.logger.WithFields(logrus.Fields(l.fields)).Warn(msg)
}

func (l *LogrusLogger) Warnf(msg string, args ...interface{}) {
	l.logger.WithFields(logrus.Fields(l.fields)).Warnf(msg, args...)
}

func (l *LogrusLogger) Error(err error, msg string) {
	l.logger.WithFields(logrus.Fields(l.fields)).WithError(err).Error(msg)
}

func (l *LogrusLogger) Errorf(err error, msg string, args ...interface{}) {
	l.logger.WithFields(logrus.Fields(l.fields)).WithError(err).Errorf(msg, args...)
}

func (l *LogrusLogger) Fatal(err error, msg string) {
	l.logger.WithFields(logrus.Fields(l.fields)).WithError(err).Fatal(msg)
}

func (l *LogrusLogger) Fatalf(err error, msg string, args ...interface{}) {
	l.logger.WithFields(logrus.Fields(l.fields)).WithError(err).Fatalf(msg, args...)
}

```

# pkg/logger/logger.go

```go
package logger

type Fields map[string]interface{}

type Logger interface {
	Fields(data Fields) Logger
	Field(key, value string) Logger
	AddField(key string, value any) Logger
	Debug(msg string)
	Debugf(msg string, args ...interface{})
	Info(msg string)
	Infof(msg string, args ...interface{})
	Warn(msg string)
	Warnf(msg string, args ...interface{})
	Error(err error, msg string)
	Errorf(err error, msg string, args ...interface{})
	Fatal(err error, msg string)
	Fatalf(err error, msg string, args ...interface{})
}

```

# pkg/model/worker_message.go

```go
package model

type Action uint8

type WorkerMessage struct {
	Type    string
	Payload interface{}
}

```

# pkg/model/work_units.go

```go
package model

import (
	"gorm.io/datatypes"
)

type WorkUnit struct {
	BaseModel

	Name           string
	SourceURL      string
	Status         WorkUnitStatus
	Type           WorkUnitType
	SourceMetadata datatypes.JSON
	ProjectID      UUID

	WorkUnitMembers []*WorkUnitMember
	WorkUnitStacks  []*WorkUnitStack
	Project         *Project
}

type WorkUnitStatus string

const (
	WorkUnitStatusActive   WorkUnitStatus = "active"
	WorkUnitStatusArchived WorkUnitStatus = "archived"
)

func (e WorkUnitStatus) IsValid() bool {
	switch e {
	case
		WorkUnitStatusActive,
		WorkUnitStatusArchived:
		return true
	}
	return false
}

func (e WorkUnitStatus) String() string {
	return string(e)
}

type WorkUnitType string

const (
	WorkUnitTypeDevelopment WorkUnitType = "development"
	WorkUnitTypeManagement  WorkUnitType = "management"
	WorkUnitTypeTraining    WorkUnitType = "training"
	WorkUnitTypeLearning    WorkUnitType = "learning"
)

func (e WorkUnitType) IsValid() bool {
	switch e {
	case
		WorkUnitTypeDevelopment,
		WorkUnitTypeManagement,
		WorkUnitTypeTraining,
		WorkUnitTypeLearning:
		return true
	}
	return false
}

func (e WorkUnitType) String() string {
	return string(e)
}

```

# pkg/model/work_unit_stacks.go

```go
package model

type WorkUnitStack struct {
	BaseModel

	StackID    UUID
	WorkUnitID UUID

	Stack Stack
}

```

# pkg/model/work_unit_members.go

```go
package model

import (
	"time"
)

type WorkUnitMember struct {
	BaseModel

	Status     string
	StartDate  time.Time
	EndDate    *time.Time
	EmployeeID UUID
	WorkUnitID UUID
	ProjectID  UUID

	Employee Employee
	WorkUnit WorkUnit
}

type WorkUnitPeer struct {
	EmployeeID UUID
	ReviewerID UUID
}

type WorkUnitMemberStatus string

const (
	WorkUnitMemberStatusActive   WorkUnitMemberStatus = "active"
	WorkUnitMemberStatusInactive WorkUnitMemberStatus = "inactive"
)

func (e WorkUnitMemberStatus) IsValid() bool {
	switch e {
	case
		WorkUnitMemberStatusActive,
		WorkUnitMemberStatusInactive:
		return true
	}
	return false
}

func (e WorkUnitMemberStatus) String() string {
	return string(e)
}

```

# pkg/model/wise.go

```go
package model

type WiseConversionRate struct {
	Rate   float64 `json:"rate"`
	Source string  `json:"source"`
	Target string  `json:"target"`
}

```

# pkg/model/weekly_delivery_metric.go

```go
package model

import (
	"time"

	"github.com/shopspring/decimal"
)

type WeeklyDeliveryMetric struct {
	Date      *time.Time
	SumWeight decimal.Decimal
	SumEffort decimal.Decimal
}

type AvgWeeklyDeliveryMetric struct {
	Weight decimal.Decimal
	Effort decimal.Decimal
}

type AvgMonthWeeklyDeliveryMetric struct {
	Date   *time.Time
	Weight decimal.Decimal
	Effort decimal.Decimal
}

```

# pkg/model/webhook.go

```go
package model

import (
	"encoding/json"
	"io"
	"strings"
)

// BasecampWebhookMessage is a structure display basecamp webhook message
type BasecampWebhookMessage struct {
	Kind      string            `json:"kind,omitempty"`
	Recording BasecampRecording `json:"recording,omitempty"`
	Creator   BasecampUser      `json:"creator,omitempty"`
}

func (msg *BasecampWebhookMessage) Decode(body []byte) error {
	return json.Unmarshal(body, &msg)
}

func (msg *BasecampWebhookMessage) Read(rc io.ReadCloser) []byte {
	defer rc.Close()
	body, _ := io.ReadAll(rc)
	return body
}

// IsOperationComplete true when parent (Todolist) title contain "Operations" example title ("Operations | July 2019")
func (msg *BasecampWebhookMessage) IsOperationComplete() bool {
	split := strings.Split(strings.Replace(msg.Recording.Parent.Title, " ", "", -1), "|")
	if len(split) < 2 {
		return false
	}
	if strings.ToLower(split[0]) != "operations" {
		return false
	}

	return true
}

func (msg *BasecampWebhookMessage) IsExpenseComplete() bool {
	pt := msg.Recording.Parent.Title
	if len(pt) < 8 || strings.ToLower(pt[:8]) != "expenses" {
		return false
	}

	return true
}

```

# pkg/model/valuation.go

```go
// please edit this file only with approval from hnh
package model

type Valuation struct {
	// basic info
	Year     string  `json:"year"`
	Rate     float64 `json:"rate"`
	Currency string  `json:"currency"`

	// valuation info
	Assets float64 `json:"assets"`

	// money that company will receive in the future
	AccountReceivable struct {
		Total float64          `json:"total"`
		Items []AccountingItem `json:"items"`
	} `json:"accountReceivable"`

	// money that company will pay in the future
	Liabilities struct {
		Total float64          `json:"total"`
		Items []AccountingItem `json:"items"`
	} `json:"liabilities"`

	// Total paid invoice, investment & bank interest
	Income struct {
		Total  float64 `json:"total"`
		Detail struct {
			ConsultantService float64 `json:"consultantService"`
			Investment        float64 `json:"investment"`
			Interest          float64 `json:"interest"`
		} `json:"detail"`
	} `json:"income"`

	// Sum of Expenses and payroll
	Outcome struct {
		Total  float64 `json:"total"`
		Detail struct {
			Payroll    float64 `json:"payroll"`
			Expense    float64 `json:"expense"`
			Investment float64 `json:"investment"`
		} `json:"detail"`
	} `json:"outcome"`
}

type AccountingItem struct {
	Name   string  `json:"name"`
	Amount float64 `json:"amount"`
}

type CurrencyView struct {
	USD float64
	VND float64
	EUR float64
	GBP float64
	SGD float64
}

```

# pkg/model/uuid_test.go

```go
package model

import (
	"database/sql/driver"
	"errors"
	"reflect"
	"testing"

	uuid "github.com/satori/go.uuid"
)

func TestUUIDFromString(t *testing.T) {
	type args struct {
		s string
	}
	tests := []struct {
		name    string
		args    args
		want    UUID
		wantErr error
	}{
		{
			name:    "correct uuid",
			args:    args{"a98484cb-cc66-4687-8e66-837e5997c427"},
			want:    UUID(uuid.Must(uuid.FromString("a98484cb-cc66-4687-8e66-837e5997c427"))),
			wantErr: nil,
		},
		{
			name:    "correct uuid zero value",
			args:    args{"00000000-0000-0000-0000-000000000000"},
			want:    UUID(uuid.Must(uuid.FromString("00000000-0000-0000-0000-000000000000"))),
			wantErr: nil,
		},
		{
			name:    "incorrect uuid by wrong character",
			args:    args{"a98484cb-cc66-4687-8e66-837e5997c42l"},
			wantErr: errors.New("encoding/hex: invalid byte: U+006C 'l'"),
		},
		{
			name:    "incorrect uuid by invalid length",
			args:    args{"a98484cb-cc66-4687-8e66-837e5997c42"},
			wantErr: errors.New("uuid: incorrect UUID length: a98484cb-cc66-4687-8e66-837e5997c42"),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := UUIDFromString(tt.args.s)
			if err != nil {
				if tt.wantErr == nil {
					t.Errorf("UUIDFromString() error = %v, wantErr %v", err, tt.wantErr)
					return
				}

				if tt.wantErr.Error() != err.Error() {
					t.Errorf("UUIDFromString() error = %v, wantErr %v", err, tt.wantErr)
					return
				}

				return
			}

			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UUIDFromString() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUUID_IsZero(t *testing.T) {
	tests := []struct {
		name string
		u    UUID
		want bool
	}{
		{
			name: "zero uuid",
			u:    UUID(uuid.Must(uuid.FromString("00000000-0000-0000-0000-000000000000"))),
			want: true,
		},
		{
			name: "normal uuid",
			u:    UUID(uuid.Must(uuid.FromString("c2186152-0e6e-437f-bf16-d0b291e98100"))),
			want: false,
		},
		{
			name: "nil uuid",
			u:    UUID{},
			want: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := (&tt.u).IsZero(); got != tt.want {
				t.Errorf("UUID.IsZero() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUUID_MarshalJSON(t *testing.T) {
	tests := []struct {
		name    string
		u       UUID
		want    []byte
		wantErr bool
	}{
		{
			name:    "success marshal json",
			u:       UUID(uuid.Must(uuid.FromString("c2186152-0e6e-437f-bf16-d0b291e98100"))),
			want:    []byte("\"c2186152-0e6e-437f-bf16-d0b291e98100\""),
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.u.MarshalJSON()
			if (err != nil) != tt.wantErr {
				t.Errorf("UUID.MarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UUID.MarshalJSON() = %v, want %v", string(got), string(tt.want))
			}
		})
	}
}

func TestUUID_UnmarshalJSON(t *testing.T) {
	type args struct {
		data []byte
	}
	tests := []struct {
		name    string
		u       UUID
		args    args
		wantErr bool
	}{
		{
			name:    "success unmarshal json",
			u:       UUID{},
			args:    args{[]byte("\"c2186152-0e6e-437f-bf16-d0b291e98100\"")},
			wantErr: false,
		},
		{
			name:    "fail unmarshal json by length",
			u:       UUID{},
			args:    args{[]byte("\"c2186152-0e6e-437f-bf16-d0b291e9810\"")},
			wantErr: true,
		},
		{
			name:    "fail unmarshal json by wrong character",
			u:       UUID{},
			args:    args{[]byte("\"c2186152-0e6e-437f-bf16-d0b291e981l\"")},
			wantErr: true,
		},
		{
			name:    "fail unmarshal json by missing double quote character",
			u:       UUID{},
			args:    args{[]byte("c2186152-0e6e-437f-bf16-d0b291e9810")},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := (&tt.u).UnmarshalJSON(tt.args.data); (err != nil) != tt.wantErr {
				t.Errorf("UUID.UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestUUID_Value(t *testing.T) {
	tests := []struct {
		name    string
		u       UUID
		want    driver.Value
		wantErr bool
	}{
		{
			name:    "correct uuid",
			u:       UUID(uuid.Must(uuid.FromString("c2186152-0e6e-437f-bf16-d0b291e98100"))),
			want:    driver.Value("c2186152-0e6e-437f-bf16-d0b291e98100"),
			wantErr: false,
		},
		{
			name:    "zero uuid",
			u:       UUID(uuid.Must(uuid.FromString("00000000-0000-0000-0000-000000000000"))),
			want:    nil,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.u.Value()
			if (err != nil) != tt.wantErr {
				t.Errorf("UUID.Value() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UUID.Value() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUUID_Scan(t *testing.T) {
	type args struct {
		b interface{}
	}
	tests := []struct {
		name    string
		u       *UUID
		args    args
		wantErr bool
	}{
		{
			name:    "success scan uuid",
			u:       &UUID{},
			args:    args{[]byte("5d38884d-2d3c-4662-8e1a-a91464a0d248")},
			wantErr: false,
		},
		{
			name:    "failed scan uuid by length",
			u:       &UUID{},
			args:    args{[]byte("5d38884d-2d3c-4662-8e1a-a91464a0d24")},
			wantErr: true,
		},
		{
			name:    "failed scan uuid by invalid character",
			u:       &UUID{},
			args:    args{[]byte("5d38884d-2d3c-4662-8e1a-a91464a0d24l")},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := tt.u.Scan(tt.args.b); (err != nil) != tt.wantErr {
				t.Errorf("UUID.Scan() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestNewUUIDFromString(t *testing.T) {
	type args struct {
		s string
	}
	tests := []struct {
		name    string
		args    args
		want    UUID
		wantErr error
	}{
		{
			name:    "correct uuid",
			args:    args{"a98484cb-cc66-4687-8e66-837e5997c427"},
			want:    UUID(uuid.Must(uuid.FromString("a98484cb-cc66-4687-8e66-837e5997c427"))),
			wantErr: nil,
		},
		{
			name:    "correct uuid zero value",
			args:    args{"00000000-0000-0000-0000-000000000000"},
			want:    UUID(uuid.Must(uuid.FromString("00000000-0000-0000-0000-000000000000"))),
			wantErr: nil,
		},
		{
			name:    "incorrect uuid by wrong character",
			args:    args{"a98484cb-cc66-4687-8e66-837e5997c42l"},
			wantErr: errors.New("encoding/hex: invalid byte: U+006C 'l'"),
		},
		{
			name:    "incorrect uuid by invalid length",
			args:    args{"a98484cb-cc66-4687-8e66-837e5997c42"},
			wantErr: errors.New("uuid: incorrect UUID length: a98484cb-cc66-4687-8e66-837e5997c42"),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := NewUUIDFromString(tt.args.s)
			if err != nil {
				if tt.wantErr == nil {
					t.Errorf("NewUUIDFromString() error = %v, wantErr %v", err, tt.wantErr)
					return
				}

				if tt.wantErr.Error() != err.Error() {
					t.Errorf("NewUUIDFromString() error = %v, wantErr %v", err, tt.wantErr)
					return
				}

				return
			}

			if !reflect.DeepEqual(got, &tt.want) {
				t.Errorf("NewUUIDFromString() = %v, want %v", got, tt.want)
			}
		})
	}
}

```

# pkg/model/uuid.go

```go
package model

import (
	"database/sql/driver"
	"errors"

	uuid "github.com/satori/go.uuid"
)

// UUID implement for go-pg convert uuid
type UUID [16]byte

// NewUUID create new UUID with V4
func NewUUID() UUID {
	return UUID(uuid.NewV4())
}

// UUIDFromString convert string to UUID
func UUIDFromString(s string) (UUID, error) {
	id, err := uuid.FromString(s)
	return UUID(id), err
}

// IsZero check uuid is zero
func (u *UUID) IsZero() bool {
	if u == nil {
		return true
	}
	for _, c := range u {
		if c != 0 {
			return false
		}
	}
	return true
}

func (u UUID) String() string {
	if u.IsZero() {
		return ""
	}
	return uuid.UUID(u).String()
}

// MarshalJSON implement for json encoding
func (u UUID) MarshalJSON() ([]byte, error) {
	if len(u) == 0 {
		return []byte(`""`), nil
	}
	return []byte(`"` + u.String() + `"`), nil
}

// UnmarshalJSON implement for json decoding
func (u *UUID) UnmarshalJSON(data []byte) error {
	if len(data) == 0 || string(data) == `""` {
		return nil
	}

	if len(data) < 2 || data[0] != '"' || data[len(data)-1] != '"' {
		return errors.New("invalid UUID format")
	}
	data = data[1 : len(data)-1]
	uu, err := uuid.FromString(string(data))
	if err != nil {
		return errors.New("invalid UUID format")
	}
	*u = UUID(uu)
	return nil
}

// Value .
func (u UUID) Value() (driver.Value, error) {
	if u.IsZero() {
		return nil, nil
	}
	return uuid.UUID(u).String(), nil
}

// Scan .
func (u *UUID) Scan(b interface{}) error {
	if b == nil {
		for i := range u {
			u[i] = 0
		}
		return nil
	}

	// postgres store DB as a string
	id, err := uuid.FromString(string(b.([]byte)))
	if err != nil {
		return err
	}

	copy(u[:], id[:])

	return nil
}

func NewUUIDFromString(s string) (*UUID, error) {
	uuid, err := uuid.FromString(s)
	if err != nil {
		return nil, err
	}

	id := &UUID{}
	copy(id[:], uuid[:])

	return id, nil
}

func IsUUIDFromString(s string) bool {
	_, err := uuid.FromString(s)
	return err == nil
}

// MustGetUUIDFromString get uuid from string if failed throw panic,
// CAUTION: IT ONLY USE FOR TESTING
func MustGetUUIDFromString(s string) UUID {
	id, err := uuid.FromString(s)
	if err != nil {
		panic(err)
	}
	return UUID(id)
}

type UUIDStruct struct {
	ID UUID
}

```

# pkg/model/user_bank_accounts.go

```go
package model

type UserBankAccount struct {
	BaseModel

	EmployerID       UUID
	DiscordAccountID UUID
	BankID           UUID
	AccountNumber    string
	Branch           string
}

```

# pkg/model/transferwise.go

```go
package model

// TWQuote defines a structure for quote request in transferwise
type TWQuote struct {
	SourceAmount float64 `json:"sourceAmount"`
	Fee          float64 `json:"fee"`
	Rate         float64 `json:"rate"`
}

type TWRate struct {
	Rate   float64 `json:"rate"`
	Source string  `json:"source"`
	Target string  `json:"target"`
}

```

# pkg/model/stacks.go

```go
package model

type Stack struct {
	BaseModel

	Name   string `json:"name"`
	Code   string `json:"code"`
	Avatar string `json:"avatar"`
}

// ToStackMap create map from stacks
func ToStackMap(stacks []*Stack) map[UUID]string {
	rs := map[UUID]string{}
	for _, s := range stacks {
		rs[s.ID] = s.Name
	}

	return rs
}

```

# pkg/model/social_account.go

```go
package model

type SocialAccount struct {
	BaseModel

	EmployeeID UUID
	Type       SocialAccountType
	AccountID  string
	Email      string
	Name       string
}

// SocialAccountType social type for social_account table
type SocialAccountType string

// values for working_status
const (
	SocialAccountTypeGitHub   SocialAccountType = "github"
	SocialAccountTypeGitLab   SocialAccountType = "gitlab"
	SocialAccountTypeNotion   SocialAccountType = "notion"
	SocialAccountTypeLinkedIn SocialAccountType = "linkedin"
	SocialAccountTypeTwitter  SocialAccountType = "twitter"
)

// IsValid validation for SocialAccountType
func (e SocialAccountType) IsValid() bool {
	switch e {
	case
		SocialAccountTypeGitHub,
		SocialAccountTypeGitLab,
		SocialAccountTypeNotion,
		SocialAccountTypeLinkedIn,
		SocialAccountTypeTwitter:
		return true
	}
	return false
}

// String returns the string type from the SocialAccountType type
func (e SocialAccountType) String() string {
	return string(e)
}

type SocialAccounts []SocialAccount

func (e SocialAccounts) GetGithub() *SocialAccount {
	for _, account := range e {
		if account.Type == SocialAccountTypeGitHub {
			return &account
		}
	}
	return nil
}

func (e SocialAccounts) ToMap() (map[string]string, map[string]string) {
	m := make(map[string]string)
	rm := make(map[string]string)
	for _, account := range e {
		if account.AccountID != "" {
			m[account.AccountID] = account.EmployeeID.String()
		}
		rm[account.EmployeeID.String()] = account.AccountID
	}

	return m, rm
}

type SocialAccountInput struct {
	GithubID     string
	NotionID     string
	NotionName   string
	NotionEmail  string
	LinkedInName string
}

```

# pkg/model/senitorities.go

```go
package model

type Seniority struct {
	BaseModel

	Name  string `json:"name"`
	Code  string `json:"code"`
	Level int    `json:"level"`
}

```

# pkg/model/schedule.go

```go
package model

import "time"

type Schedule struct {
	BaseModel

	Name         string
	Description  string
	ScheduleType string
	SyncedAt     *time.Time

	StartTime *time.Time
	EndTime   *time.Time

	GoogleCalendar *ScheduleGoogleCalendar
	DiscordEvent   *ScheduleDiscordEvent
	NotionPage     *ScheduleNotionPage
}

type ScheduleGoogleCalendar struct {
	BaseModel

	ScheduleID       UUID
	GoogleCalendarID string
	Description      string
	HangoutLink      string
}

type ScheduleDiscordEvent struct {
	BaseModel
	ScheduleID     UUID
	DiscordEventID string
	Description    string
	VoiceChannelID string
}

type ScheduleNotionPage struct {
	BaseModel
	ScheduleID   UUID
	NotionPageID string
	Description  string
}

```

# pkg/model/salary_advance.go

```go
package model

import "time"

type SalaryAdvance struct {
	BaseModel `json:"base_model"`

	EmployeeID UUID      `json:"employee_id"`
	Employee   *Employee `json:"employee"`

	CurrencyID UUID      `json:"currency_id"`
	Currency   *Currency `json:"currency"`

	AmountIcy      int64      `json:"amount_icy"`
	AmountUSD      float64    `json:"amount_usd"`
	BaseAmount     float64    `json:"base_amount"`
	ConversionRate float64    `json:"conversion_rate"`
	IsPaidBack     bool       `json:"is_paid_back"`
	PaidAt         *time.Time `json:"paid_at"`
}

func (SalaryAdvance) TableName() string { return "salary_advance_histories" }

type AggregatedSalaryAdvance struct {
	EmployeeID string
	Employee   *Employee

	AmountICY int64
	AmountUSD float64
}

type SalaryAdvanceReport struct {
	SalaryAdvances []AggregatedSalaryAdvance
	TotalICY       int64
	TotalUSD       float64
	Count          int64
}

```

# pkg/model/roles.go

```go
package model

const (
	RoleFullTimeCode    = "full-time"
	RoleProjectLeadCode = "project-lead"
)

type Role struct {
	BaseModel

	Name   string `json:"name"`
	Code   string `json:"code"`
	Level  int64  `json:"level"`
	Color  string `json:"color"`
	IsShow bool   `json:"isShow"`

	Employees []Employee `gorm:"many2many:employee_roles;"`
}

```

# pkg/model/research_topic.go

```go
package model

import "time"

// DiscordResearchTopic represents discord research topic
type DiscordResearchTopic struct {
	Name              string
	URL               string
	MsgCount          int64
	SortedActiveUsers []DiscordTopicActiveUser
	LastActiveTime    time.Time
}

// DiscordTopicActiveUser represents active users who send most messages in topic
type DiscordTopicActiveUser struct {
	UserID   string
	MsgCount int64
}

```

# pkg/model/questions.go

```go
package model

// QuestionType type of question
type QuestionType string

// valid values for QuestionType
const (
	QuestionTypeScale   QuestionType = "likert-scale"
	QuestionTypeGeneral QuestionType = "general"
)

// IsValid validation for QuestionType
func (e QuestionType) IsValid() bool {
	switch e {
	case
		QuestionTypeScale,
		QuestionTypeGeneral:
		return true
	}
	return false
}

// String returns a string representation of QuestionType
func (e QuestionType) String() string {
	return string(e)
}

// Question model for questions table
type Question struct {
	BaseModel

	Type        QuestionType
	Category    EventType
	Subcategory EventSubtype
	Content     string
	Order       int64
	Domain      QuestionDomain
	EventID     UUID
}

// LikertScaleAnswer type of question
type LikertScaleAnswer string

// valid values for LikertScaleAnswer
const (
	LikertScaleAnswerStronglyDisagree LikertScaleAnswer = "strongly-disagree"
	LikertScaleAnswerDisagree         LikertScaleAnswer = "disagree"
	LikertScaleAnswerMixed            LikertScaleAnswer = "mixed"
	LikertScaleAnswerAgree            LikertScaleAnswer = "agree"
	LikertScaleAnswerStronglyAgree    LikertScaleAnswer = "strongly-agree"
)

// IsValid validation for LikertScaleAnswer
func (e LikertScaleAnswer) IsValid() bool {
	switch e {
	case
		LikertScaleAnswerStronglyDisagree,
		LikertScaleAnswerDisagree,
		LikertScaleAnswerMixed,
		LikertScaleAnswerAgree,
		LikertScaleAnswerStronglyAgree:
		return true
	}
	return false
}

// String returns a string representation of LikertScaleAnswer
func (e LikertScaleAnswer) String() string {
	return string(e)
}

// QuestionDomain type for domain of questions table
type QuestionDomain string

// QuestionDomain values
const (
	QuestionDomainEngagement QuestionDomain = "engagement"
	QuestionDomainWorkload   QuestionDomain = "workload"
	QuestionDomainDeadline   QuestionDomain = "deadline"
	QuestionDomainLearning   QuestionDomain = "learning"
)

// IsValid validation for QuestionDomain
func (e QuestionDomain) IsValid() bool {
	switch e {
	case
		QuestionDomainWorkload,
		QuestionDomainDeadline,
		QuestionDomainLearning:
		return true
	}
	return false
}

// String returns the string type from the QuestionDomain type
func (e QuestionDomain) String() string {
	return string(e)
}

// LikertScaleCount represent for counted likert-scale answer model
type LikertScaleCount struct {
	StronglyDisagree int `json:"stronglyDisagree" gorm:"column:strongly_disagree"`
	Disagree         int `json:"disagree" gorm:"column:disagree"`
	Mixed            int `json:"mixed" gorm:"column:mixed"`
	Agree            int `json:"agree" gorm:"column:agree"`
	StronglyAgree    int `json:"stronglyAgree" gorm:"column:strongly_agree"`
}

type QuestionDomainCount struct {
	Domain QuestionDomain
	LikertScaleCount
}

// AgreementLevel type for work survey answer
type AgreementLevel string

// AgreementLevel values
const (
	AgreementLevelStronglyDisagree AgreementLevel = "strongly-disagree"
	AgreementLevelDisagree         AgreementLevel = "disagree"
	AgreementLevelMixed            AgreementLevel = "mixed"
	AgreementLevelAgree            AgreementLevel = "agree"
	AgreementLevelStronglyAgree    AgreementLevel = "strongly-agree"
)

// IsValid validation for AgreementLevel
func (e AgreementLevel) IsValid() bool {
	switch e {
	case
		AgreementLevelStronglyDisagree,
		AgreementLevelDisagree,
		AgreementLevelMixed,
		AgreementLevelAgree,
		AgreementLevelStronglyAgree:
		return true
	}
	return false
}

// String returns the string type of AgreementLevel
func (e AgreementLevel) String() string {
	return string(e)
}

var AgreementLevelMap = map[AgreementLevel]string{
	AgreementLevelStronglyDisagree: "1",
	AgreementLevelDisagree:         "2",
	AgreementLevelMixed:            "3",
	AgreementLevelAgree:            "4",
	AgreementLevelStronglyAgree:    "5",
}

var AgreementLevelValueMap = map[string]AgreementLevel{
	"1": AgreementLevelStronglyDisagree,
	"2": AgreementLevelDisagree,
	"3": AgreementLevelMixed,
	"4": AgreementLevelAgree,
	"5": AgreementLevelStronglyAgree,
}

```

# pkg/model/projects.go

```go
package model

import (
	"database/sql/driver"
	"encoding/json"
	"time"

	"github.com/shopspring/decimal"
)

type Project struct {
	BaseModel

	Name                string          `gorm:"default:null"`
	CountryID           UUID            `gorm:"default:null"`
	Type                ProjectType     `gorm:"default:null"`
	StartDate           *time.Time      `gorm:"default:null"`
	EndDate             *time.Time      `gorm:"default:null"`
	Status              ProjectStatus   `gorm:"default:null"`
	ProjectEmail        string          `gorm:"default:null"`
	ClientEmail         string          `gorm:"default:null"`
	Avatar              string          `gorm:"default:null"`
	AllowsSendingSurvey bool            `gorm:"default:null"`
	Code                string          `gorm:"default:null"`
	Function            ProjectFunction `gorm:"default:null"`
	BankAccountID       UUID            `gorm:"default:null"`
	CompanyInfoID       UUID            `gorm:"default:null"`
	ClientID            UUID            `gorm:"default:null"`
	OrganizationID      UUID            `gorm:"default:null"`
	AccountRating       int
	DeliveryRating      int
	LeadRating          int
	ImportantLevel      ProjectImportantLevel

	ProjectNotion     *ProjectNotion `gorm:"foreignKey:project_id"`
	Organization      *Organization
	BankAccount       *BankAccount
	Country           *Country
	Client            *Client
	CompanyInfo       *CompanyInfo
	Slots             []ProjectSlot
	Heads             []*ProjectHead
	ProjectMembers    []ProjectMember
	ProjectStacks     []ProjectStack
	CommissionConfigs ProjectCommissionConfigs

	ProjectInfo *ProjectInfo `json:"-" gorm:"foreignkey:ProjectID;association_foreignkey:ID"`
}

type ProjectType string

const (
	ProjectTypeDwarves      ProjectType = "dwarves"
	ProjectTypeFixedCost    ProjectType = "fixed-cost"
	ProjectTypeTimeMaterial ProjectType = "time-material"
)

func (e ProjectType) IsValid() bool {
	switch e {
	case
		ProjectTypeDwarves,
		ProjectTypeFixedCost,
		ProjectTypeTimeMaterial:
		return true
	}
	return false
}

func (e ProjectType) String() string {
	return string(e)
}

type ProjectStatus string

const (
	ProjectStatusOnBoarding ProjectStatus = "on-boarding"
	ProjectStatusActive     ProjectStatus = "active"
	ProjectStatusPaused     ProjectStatus = "paused"
	ProjectStatusClosed     ProjectStatus = "closed"
)

func (e ProjectStatus) IsValid() bool {
	switch e {
	case
		ProjectStatusOnBoarding,
		ProjectStatusActive,
		ProjectStatusPaused,
		ProjectStatusClosed:
		return true
	}
	return false
}

func (e ProjectStatus) String() string {
	return string(e)
}

type DeploymentType string

const (
	MemberDeploymentTypeOfficial DeploymentType = "official"
	MemberDeploymentTypeShadow   DeploymentType = "shadow"
	MemberDeploymentTypePartTime DeploymentType = "part-time"
)

func (e DeploymentType) IsValid() bool {
	switch e {
	case
		MemberDeploymentTypeOfficial,
		MemberDeploymentTypeShadow,
		MemberDeploymentTypePartTime:
		return true
	}
	return false
}

func (e DeploymentType) String() string {
	return string(e)
}

type ProjectMemberStatus string

const (
	ProjectMemberStatusPending    ProjectMemberStatus = "pending"
	ProjectMemberStatusOnBoarding ProjectMemberStatus = "on-boarding"
	ProjectMemberStatusActive     ProjectMemberStatus = "active"
	ProjectMemberStatusInactive   ProjectMemberStatus = "inactive"
)

func (e ProjectMemberStatus) IsValid() bool {
	switch e {
	case
		ProjectMemberStatusOnBoarding,
		ProjectMemberStatusActive,
		ProjectMemberStatusInactive,
		ProjectMemberStatusPending:
		return true
	}
	return false
}

func (e ProjectMemberStatus) String() string {
	return string(e)
}

type ProjectImportantLevel string

const (
	ProjectImportantLevelLow        ProjectImportantLevel = "low"
	ProjectImportantLevelMediumLow  ProjectImportantLevel = "medium-"
	ProjectImportantLevelMedium     ProjectImportantLevel = "medium"
	ProjectImportantLevelMediumHigh ProjectImportantLevel = "medium+"
	ProjectImportantLevelHigh       ProjectImportantLevel = "high"
)

func (e ProjectImportantLevel) IsValid() bool {
	switch e {
	case
		ProjectImportantLevelLow,
		ProjectImportantLevelMediumLow,
		ProjectImportantLevelMedium,
		ProjectImportantLevelMediumHigh,
		ProjectImportantLevelHigh:
		return true
	}

	return false
}

func (e ProjectImportantLevel) String() string {
	return string(e)
}

type ProjectSlot struct {
	BaseModel

	ProjectID      UUID
	SeniorityID    UUID
	UpsellPersonID UUID
	DeploymentType DeploymentType
	Status         ProjectMemberStatus
	Rate           decimal.Decimal
	Discount       decimal.Decimal
	Note           string

	Seniority            Seniority
	Project              Project
	ProjectMember        ProjectMember
	ProjectSlotPositions []ProjectSlotPosition
	UpsellPerson         *Employee
}

type ProjectMember struct {
	BaseModel

	ProjectID            UUID
	EmployeeID           UUID
	ProjectSlotID        UUID
	StartDate            *time.Time
	EndDate              *time.Time
	Status               ProjectMemberStatus
	Rate                 decimal.Decimal
	Discount             decimal.Decimal
	DeploymentType       DeploymentType
	UpsellPersonID       UUID
	UpsellCommissionRate decimal.Decimal
	SeniorityID          UUID
	Note                 string

	IsLead bool `gorm:"-"`

	Employee               Employee  `gorm:"foreignKey:EmployeeID"`
	UpsellPerson           *Employee `gorm:"foreignKey:UpsellPersonID"`
	Project                Project
	Seniority              *Seniority
	ProjectMemberPositions []ProjectMemberPosition
	Positions              []Position   `gorm:"-"`
	Head                   *ProjectHead `gorm:"-"`
}

type HeadPosition string

const (
	HeadPositionTechnicalLead   HeadPosition = "technical-lead"
	HeadPositionDeliveryManager HeadPosition = "delivery-manager"
	HeadPositionAccountManager  HeadPosition = "account-manager"
	HeadPositionSalePerson      HeadPosition = "sale-person"
)

func (e HeadPosition) IsValid() bool {
	switch e {
	case
		HeadPositionTechnicalLead,
		HeadPositionDeliveryManager,
		HeadPositionAccountManager,
		HeadPositionSalePerson:
		return true
	}
	return false
}

func (e HeadPosition) String() string {
	return string(e)
}

type ProjectHead struct {
	BaseModel

	ProjectID      UUID
	EmployeeID     UUID
	StartDate      time.Time
	EndDate        *time.Time
	CommissionRate decimal.Decimal
	Position       HeadPosition

	Employee Employee
	Project  Project
}

func (p ProjectHead) IsLead() bool {
	return p.Position == HeadPositionTechnicalLead
}

func (p ProjectHead) IsAccountManager() bool {
	return p.Position == HeadPositionAccountManager
}

func (p ProjectHead) IsSalePerson() bool {
	return p.Position == HeadPositionSalePerson
}

func (p ProjectHead) IsDeliveryManager() bool {
	return p.Position == HeadPositionDeliveryManager
}

type ProjectStack struct {
	BaseModel

	ProjectID UUID
	StackID   UUID

	Stack Stack
}

type ProjectFunction string

const (
	ProjectFunctionDevelopment ProjectFunction = "development"
	ProjectFunctionLearning    ProjectFunction = "learning"
	ProjectFunctionTraining    ProjectFunction = "training"
	ProjectFunctionManagement  ProjectFunction = "management"
)

func (e ProjectFunction) IsValid() bool {
	switch e {
	case
		ProjectFunctionDevelopment,
		ProjectFunctionLearning,
		ProjectFunctionTraining,
		ProjectFunctionManagement:
		return true
	}
	return false
}

func (e ProjectFunction) String() string {
	return string(e)
}

func IsUserActiveInProject(userID string, pm []ProjectMember) bool {
	for _, p := range pm {
		if p.EmployeeID.String() == userID && p.Status == ProjectMemberStatusActive {
			return true
		}
	}

	return false
}

func (pm *ProjectMember) IsActive() bool {
	if pm.StartDate != nil &&
		!pm.StartDate.After(time.Now()) && // start_date <= now()
		(pm.EndDate == nil || pm.EndDate.After(time.Now())) { // end_date > now()
		return true
	}

	return false
}

var priority = []string{"us", "eu", "vn"}

func (p Project) GetCompanyContactInfo() (*CompanyContactInfo, error) {
	res := CompanyContactInfo{}
	if p.CompanyInfo == nil {
		return &res, nil
	}
	m := map[string]*CompanyContactInfo{}
	v, err := p.CompanyInfo.Info.Value()
	if err != nil {
		return nil, err
	}

	if !driver.IsValue(v) || v == nil {
		return &res, nil
	}

	if err = json.Unmarshal(v.([]byte), &m); err != nil {
		return nil, err
	}

	for _, v := range priority {
		if m[v] != nil {
			return m[v], nil
		}
	}

	return &res, nil
}

type Projects []Project

func (p Projects) ToNameIDMap() map[string]UUID {
	rs := map[string]UUID{}
	for _, itm := range p {
		rs[itm.Name] = itm.ID
	}
	return rs
}

```

# pkg/model/project_slot_positions.go

```go
package model

type ProjectSlotPosition struct {
	BaseModel

	ProjectSlotID UUID
	PositionID    UUID

	Position Position
}

```

# pkg/model/project_notion.go

```go
package model

type ProjectNotion struct {
	BaseModel

	ProjectID     UUID
	AuditNotionID UUID

	Project *Project `gorm:"foreignKey:project_id"`
}

```

# pkg/model/project_member_positions.go

```go
package model

type ProjectMemberPosition struct {
	BaseModel

	ProjectMemberID UUID
	PositionID      UUID

	Position Position
}

```

# pkg/model/project_issue.go

```go
package model

type ProjectIssue struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
	Link string `json:"link"`
}

```

# pkg/model/project_info.go

```go
package model

type ProjectInfo struct {
	BaseModel

	ProjectID              *UUID `json:"project_id"`
	BasecampBucketID       int64 `json:"basecamp_bucket_id"`
	BasecampScheduleID     int64 `json:"basecamp_schedule_id"`
	BasecampCampfireID     int64 `json:"basecamp_campfire_id"`
	BasecampTodolistID     int64 `json:"basecamp_todolist_id"`
	BasecampMessageBoardID int64 `json:"basecamp_message_board_id"`
	BasecampSentryID       int64 `json:"basecamp_sentry_id"`
	GitlabID               int64 `json:"gitlab_id"`
	Repositories           JSON  `json:"repositories"`

	Project *Project `json:"project"`
}

```

# pkg/model/project_commission_configs.go

```go
package model

import "github.com/shopspring/decimal"

type ProjectCommissionConfig struct {
	BaseModel

	ProjectID      UUID
	Position       HeadPosition
	CommissionRate decimal.Decimal
}

type ProjectCommissionConfigs []ProjectCommissionConfig

func (m *ProjectCommissionConfigs) ToMap() map[string]decimal.Decimal {
	rs := make(map[string]decimal.Decimal)
	for _, itm := range *m {
		rs[itm.Position.String()] = itm.CommissionRate
	}
	return rs
}

```

# pkg/model/positions.go

```go
package model

type Position struct {
	BaseModel

	Name string `json:"name"`
	Code string `json:"code"`
}

// ToPositionMap create map from position
func ToPositionMap(positions []*Position) map[UUID]Position {
	rs := map[UUID]Position{}
	for _, s := range positions {
		rs[s.ID] = *s
	}

	return rs
}

type Positions []Position

func (p Positions) IsSales() bool {
	for _, position := range p {
		if position.Code == "sales" {
			return true
		}
	}
	return false
}

```

# pkg/model/physical_checkin_transactions.go

```go
package model

import "time"

type PhysicalCheckinTransaction struct {
	ID         UUID
	EmployeeID UUID
	Date       time.Time
	IcyAmount  float64
	MochiTxID  int64
}

func (PhysicalCheckinTransaction) TableName() string { return "physical_checkin_transactions" }

```

# pkg/model/permissions.go

```go
package model

type Permission struct {
	BaseModel

	Code string
	Name string
}

func ToPermissionMap(perms []*Permission) map[string]string {
	m := make(map[string]string)
	for _, v := range perms {
		m[v.Code] = v.Name
	}

	return m
}

type PermissionCode string

const (
	PermissionAssetUpload                         PermissionCode = "assets.upload"
	PermissionAuthCreate                          PermissionCode = "auth.create"
	PermissionAuthRead                            PermissionCode = "auth.read"
	PermissionBankAccountRead                     PermissionCode = "bankAccounts.read"
	PermissionClientCreate                        PermissionCode = "clients.create"
	PermissionClientDelete                        PermissionCode = "clients.delete"
	PermissionClientEdit                          PermissionCode = "clients.edit"
	PermissionClientRead                          PermissionCode = "clients.read"
	PermissionCompanyInfoRead                     PermissionCode = "companyInfos.read"
	PermissionCronjobExecute                      PermissionCode = "cronjobs.execute"
	PermissionDashBoardEngagementRead             PermissionCode = "dashboards.engagement.read"
	PermissionDashBoardProjectsRead               PermissionCode = "dashboards.projects.read"
	PermissionDashBoardRead                       PermissionCode = "dashboards.read"
	PermissionDashBoardResourcesRead              PermissionCode = "dashboards.resources.read"
	PermissionEarnRead                            PermissionCode = "earns.read"
	PermissionEmployeeEventQuestionsCreate        PermissionCode = "employeeEventQuestions.create"
	PermissionEmployeeEventQuestionsDelete        PermissionCode = "employeeEventQuestions.delete"
	PermissionEmployeeEventQuestionsEdit          PermissionCode = "employeeEventQuestions.edit"
	PermissionEmployeeEventQuestionsRead          PermissionCode = "employeeEventQuestions.read"
	PermissionEmployeeMenteesCreate               PermissionCode = "employeeMentees.create"
	PermissionEmployeeMenteesDelete               PermissionCode = "employeeMentees.delete"
	PermissionEmployeeMenteesEdit                 PermissionCode = "employeeMentees.edit"
	PermissionEmployeeMenteesRead                 PermissionCode = "employeeMentees.read"
	PermissionEmployeeRolesCreate                 PermissionCode = "employeeRoles.create"
	PermissionEmployeeRolesDelete                 PermissionCode = "employeeRoles.delete"
	PermissionEmployeeRolesEdit                   PermissionCode = "employeeRoles.edit"
	PermissionEmployeeRolesRead                   PermissionCode = "employeeRoles.read"
	PermissionEmployeesBaseSalaryEdit             PermissionCode = "employees.baseSalary.edit"
	PermissionEmployeesBaseSalaryRead             PermissionCode = "employees.baseSalary.read"
	PermissionEmployeesCreate                     PermissionCode = "employees.create"
	PermissionEmployeesDiscordRead                PermissionCode = "employees.discord.read"
	PermissionEmployeesDiscordEdit                PermissionCode = "employees.discord.edit"
	PermissionEmployeesDiscordCreate              PermissionCode = "employees.discord.create"
	PermissionEmployeesDelete                     PermissionCode = "employees.delete"
	PermissionEmployeesEdit                       PermissionCode = "employees.edit"
	PermissionEmployeesRead                       PermissionCode = "employees.read"
	PermissionEmployeesReadFilterByAllStatuses    PermissionCode = "employees.read.filterByAllStatuses"
	PermissionEmployeesReadFilterByProject        PermissionCode = "employees.read.filterByProject"
	PermissionEmployeesReadFullAccess             PermissionCode = "employees.read.fullAccess"
	PermissionEmployeesReadGeneralInfoFullAccess  PermissionCode = "employees.read.generalInfo.fullAccess"
	PermissionEmployeesReadLineManagerFullAccess  PermissionCode = "employees.read.lineManager.fullAccess"
	PermissionEmployeesReadPersonalInfoFullAccess PermissionCode = "employees.read.personalInfo.fullAccess"
	PermissionEmployeesReadProjectsFullAccess     PermissionCode = "employees.read.projects.fullAccess"
	PermissionEmployeesReadProjectsReadActive     PermissionCode = "employees.read.projects.readActive"
	PermissionEmployeesReadReadActive             PermissionCode = "employees.read.readActive"
	PermissionFeedbacksCreate                     PermissionCode = "feedbacks.create"
	PermissionFeedbacksDelete                     PermissionCode = "feedbacks.delete"
	PermissionFeedbacksEdit                       PermissionCode = "feedbacks.edit"
	PermissionFeedbacksRead                       PermissionCode = "feedbacks.read"
	PermissionInvoiceCreate                       PermissionCode = "invoices.create"
	PermissionInvoiceDelete                       PermissionCode = "invoices.delete"
	PermissionInvoiceEdit                         PermissionCode = "invoices.edit"
	PermissionInvoiceRead                         PermissionCode = "invoices.read"
	PermissionMetadataCreate                      PermissionCode = "metadata.create"
	PermissionMetadataDelete                      PermissionCode = "metadata.delete"
	PermissionMetadataEdit                        PermissionCode = "metadata.edit"
	PermissionMetadataRead                        PermissionCode = "metadata.read"
	PermissionNotionCreate                        PermissionCode = "notion.create"
	PermissionNotionRead                          PermissionCode = "notion.read"
	PermissionNotionSend                          PermissionCode = "notion.send"
	PermissionPayrollsCreate                      PermissionCode = "payrolls.create"
	PermissionPayrollsEdit                        PermissionCode = "payrolls.edit"
	PermissionPayrollsRead                        PermissionCode = "payrolls.read"
	PermissionProjectMembersCreate                PermissionCode = "projectMembers.create"
	PermissionProjectMembersDelete                PermissionCode = "projectMembers.delete"
	PermissionProjectMembersEdit                  PermissionCode = "projectMembers.edit"
	PermissionProjectMembersRateEdit              PermissionCode = "projectMembers.rate.edit"
	PermissionProjectMembersRateRead              PermissionCode = "projectMembers.rate.read"
	PermissionProjectMembersRead                  PermissionCode = "projectMembers.read"
	PermissionProjectWorkUnitsCreate              PermissionCode = "projectWorkUnits.create"
	PermissionProjectWorkUnitsCreateFullAccess    PermissionCode = "projectWorkUnits.create.fullAccess"
	PermissionProjectWorkUnitsDelete              PermissionCode = "projectWorkUnits.delete"
	PermissionProjectWorkUnitsDeleteFullAccess    PermissionCode = "projectWorkUnits.delete.fullAccess"
	PermissionProjectWorkUnitsEdit                PermissionCode = "projectWorkUnits.edit"
	PermissionProjectWorkUnitsEditFullAccess      PermissionCode = "projectWorkUnits.edit.fullAccess"
	PermissionProjectWorkUnitsRead                PermissionCode = "projectWorkUnits.read"
	PermissionProjectWorkUnitsReadFullAccess      PermissionCode = "projectWorkUnits.read.fullAccess"
	PermissionProjectsCommissionRateEdit          PermissionCode = "projects.commissionRate.edit"
	PermissionProjectsCommissionRateRead          PermissionCode = "projects.commissionRate.read"
	PermissionProjectsCreate                      PermissionCode = "projects.create"
	PermissionProjectsEdit                        PermissionCode = "projects.edit"
	PermissionProjectsRead                        PermissionCode = "projects.read"
	PermissionProjectsReadFullAccess              PermissionCode = "projects.read.fullAccess"
	PermissionProjectsReadMonthlyRevenue          PermissionCode = "projects.read.monthlyRevenue"
	PermissionProjectsReadReadActive              PermissionCode = "projects.read.readActive"
	PermissionSurveysCreate                       PermissionCode = "surveys.create"
	PermissionSurveysDelete                       PermissionCode = "surveys.delete"
	PermissionSurveysEdit                         PermissionCode = "surveys.edit"
	PermissionSurveysRead                         PermissionCode = "surveys.read"
	PermissionValuationRead                       PermissionCode = "valuations.read"
	PermissionEngagementMetricsWrite              PermissionCode = "engagementMetrics.write"
	PermissionEngagementMetricsRead               PermissionCode = "engagementMetrics.read"
	PermissionIcyDistributionRead                 PermissionCode = "icyDistribution.read"
	PermissionBraineryLogsWrite                   PermissionCode = "braineryLogs.write"
	PermissionBraineryLogsRead                    PermissionCode = "braineryLogs.read"
	PermissionDeliveryMetricsRead                 PermissionCode = "deliveryMetrics.read"
	PermissionDeliveryMetricsLeaderBoardRead      PermissionCode = "deliveryMetrics.leaderBoard.read"
	PermissionDeliveryMetricsSync                 PermissionCode = "deliveryMetrics.sync"
	PermissionTransferCheckinIcy                  PermissionCode = "employees.transferCheckinIcy.fullAccess"
)

func (p PermissionCode) String() string {
	return string(p)
}

```

# pkg/model/payroll.go

```go
package model

import (
	"time"

	"gorm.io/datatypes"
	"gorm.io/gorm"
	// "git.d.foundation/fortress/ragnarok/src/service/vault"
)

type Payroll struct {
	ID                  UUID           `sql:",type:uuid" json:"id"`
	EmployeeID          UUID           `json:"employee_id"`
	BaseSalaryAmount    int64          `json:"base_salary_amount"`
	ContractAmount      int64          `json:"contract_amount"`
	Total               VietnamDong    `json:"total"`
	ConversionAmount    VietnamDong    `json:"conversion_amount"`
	Month               int64          `json:"month"`
	Year                int64          `json:"year"`
	CommissionAmount    VietnamDong    `json:"commission_amount"`
	CommissionExplain   datatypes.JSON `json:"commission_explain"`
	UserRankSnapshot    datatypes.JSON `json:"user_rank_snapshot"`
	TotalExplain        datatypes.JSON `json:"total_explain"`
	ProjectBonusAmount  VietnamDong    `json:"project_bonus"`
	ProjectBonusExplain datatypes.JSON `json:"project_bonus_explain"`
	DueDate             *time.Time     `json:"due_date"`
	IsPaid              bool           `json:"is_paid"`
	SalaryAdvanceAmount float64        `json:"salary_advance_amount"`

	Employee Employee `json:"employee"`

	TotalAllowance       float64               `json:"total_allowance" gorm:"-"`        // TotalAllowance is amount of allowance in email template
	CommissionExplains   []CommissionExplain   `json:"commission_explains" gorm:"-"`    // CommissionExplains is commission explains in email template
	ProjectBonusExplains []ProjectBonusExplain `json:"project_bonus_explains" gorm:"-"` // ProjectBonusExplains is project bonus explains in email template
	TWAmount             float64               `json:"twAmount" gorm:"-"`               // TotalAllowance is amount of allowance in email template
	TWRate               float64               `json:"twRate" gorm:"-"`                 // TWRate is rate of allowance in email template
	TWFee                float64               `json:"twFee" gorm:"-"`
}

func (p *Payroll) BeforeCreate(tx *gorm.DB) error {
	p.ID = NewUUID()
	return nil
}

func (Payroll) TableName() string { return "payrolls" }

// ProjectBonusExplain  explain where and when
// the project bonus come from
// in each row of table payroll
type ProjectBonusExplain struct {
	Name             string      `json:"name"`
	Month            int         `json:"month"`
	Year             int         `json:"year"`
	Amount           VietnamDong `json:"amount"`
	FormattedAmount  string      `json:"formatted_amount"`
	Description      string      `json:"description"`
	BasecampTodoID   int         `json:"todo_id"`
	BasecampBucketID int         `json:"bucket_id"`
}

// CommissionExplain  explain where and when
// the commission come from
// in each row of table payroll
type CommissionExplain struct {
	ID               UUID        `json:"id"`
	Name             string      `json:"name"`
	Month            int         `json:"month"`
	Year             int         `json:"year"`
	Amount           VietnamDong `json:"amount"`
	FormattedAmount  string      `json:"formatted_amount"`
	BasecampTodoID   int         `json:"todo_id"`
	BasecampBucketID int         `json:"bucket_id"`
}

// Batch enumeration
type Batch int

const (
	// FirstBatch represent payroll batch that due date in date: 1st of a month
	FirstBatch Batch = 1

	// SecondBatch represent payroll batch that due date in date: 15th of a month
	SecondBatch Batch = 15
)

```

# pkg/model/pagination_test.go

```go
package model

import "testing"

func Test_StandardizeSortQuery(t *testing.T) {
	type args struct {
		sortQ string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			name: "empty",
			args: args{
				sortQ: "",
			},
			want: "",
		},
		{
			name: "no sort operator",
			args: args{
				sortQ: "chain_id",
			},
			want: "chain_id ASC",
		},
		{
			name: "multiple empty sort",
			args: args{
				sortQ: ",,,",
			},
			want: "",
		},
		{
			name: "multiple sort",
			args: args{
				sortQ: "-token_id,name",
			},
			want: "token_id DESC,name ASC",
		},
		{
			name: "invalid sort_operator/field",
			args: args{
				sortQ: "token_id?",
			},
			want: "token_id ASC",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := standardizeSortQuery(tt.args.sortQ); got != tt.want {
				t.Errorf("StandardizeUri() = %v, want %v", got, tt.want)
			}
		})
	}
}

```

# pkg/model/pagination.go

```go
package model

import (
	"fmt"
	"regexp"
	"strings"
)

var maxPageSize int64 = 999

type SortOrder string

// @name SortOrder

type Pagination struct {
	Page         int64  `json:"page" form:"page,default=0"`            // page index
	Size         int64  `json:"size" form:"size"`                      // page size
	Sort         string `json:"sort" form:"sort" swaggerignore:"true"` // sort by field
	Standardized bool   `json:"-" form:"-" swaggerignore:"true"`
} // @name Pagination

const (
	SortOrderASC  SortOrder = "asc"
	SortOrderDESC SortOrder = "desc"
)

func (e SortOrder) IsValid() bool {
	switch e {
	case
		SortOrderASC,
		SortOrderDESC:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (p *Pagination) Standardize() {
	if p.Standardized {
		return
	}

	if p.Page < 0 {
		p.Page = 0
	}

	if p.Size <= 0 || p.Size >= maxPageSize {
		p.Size = maxPageSize
	}

	if p.Sort == "" {
		return
	}

	p.Sort = standardizeSortQuery(p.Sort)
	p.Standardized = true
}

func (p *Pagination) ToLimitOffset() (limit int, offset int) {
	limit = int(p.Size)
	offset = limit * (int(p.Page) - 1)
	if offset < 0 {
		offset = 0
	}

	return limit, offset
}

func standardizeSortQuery(sortQ string) string {
	if sortQ == "" {
		return sortQ
	}

	f := func(c rune) bool {
		return c == ','
	}
	sorts := strings.FieldsFunc(sortQ, f)

	re, err := regexp.Compile(`[^\w|-]`)
	if err != nil {
		return ""
	}

	for i := range sorts {
		sort := re.ReplaceAllString(sorts[i], "")
		operator := "ASC"
		if sort[0] == '-' {
			operator = "DESC"
			sort = strings.Replace(sort, "-", "", 1)
		}
		sorts[i] = fmt.Sprintf("%s %s", sort, operator)
	}

	return strings.Join(sorts, ",")
}

```

# pkg/model/organization.go

```go
package model

const (
	OrganizationCodeDwarves = "dwarves-foundation"
	OrganizationNameDwarves = "Dwarves Foundation"
)

type Organization struct {
	BaseModel

	Name   string `json:"name"`
	Code   string `json:"code"`
	Avatar string `json:"avatar"`
}

// ToOrganizationMap create map from organizations
func ToOrganizationMap(organizations []*Organization) map[UUID]string {
	rs := map[UUID]string{}
	for _, s := range organizations {
		rs[s.ID] = s.Name
	}

	return rs
}

```

# pkg/model/operational_service.go

```go
package model

import "time"

type OperationalService struct {
	BaseModel

	Name         string
	Amount       int
	Note         string
	RegisterDate time.Time
	StartAt      time.Time
	EndAt        time.Time
	IsActive     bool
	CurrencyID   UUID
	Currency     *Currency `gorm:"foreignKey:CurrencyID;references:ID"`
}

```

# pkg/model/onleave_request.go

```go
package model

import (
	"time"
)

type OnLeaveRequest struct {
	BaseModel

	Type        string
	StartDate   *time.Time
	EndDate     *time.Time
	Shift       string
	Title       string
	Description string
	CreatorID   UUID
	ApproverID  UUID
	AssigneeIDs JSONArrayString

	Creator  *Employee
	Approver *Employee
}

```

# pkg/model/notion_event.go

```go
package model

import (
	"time"
)

type NotionEvent struct {
	ID           string    `json:"id"`
	Name         string    `json:"name"`
	Date         DateTime  `json:"date"`
	ActivityType string    `json:"activity_type"`
	CreatedAt    time.Time `json:"created_at"`
}

```

# pkg/model/notion.go

```go
package model

import "time"

// ProjectChangelogPage -- notion project changelog page
type ProjectChangelogPage struct {
	RowID        string `json:"row_id"`
	Name         string `json:"name"`
	Title        string `json:"title"`
	ChangelogURL string `json:"changelog_url"`
}

type NotionMemo struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	Tags      []string  `json:"tags"`
	Author    string    `json:"author"`
	CreatedAt time.Time `json:"created_at"`
}

type NotionUpdate struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	Audience  string    `json:"audience"`
	CreatedAt time.Time `json:"created_at"`
}

type NotionEarn struct {
	ID       string       `json:"id"`
	Name     string       `json:"name"`
	Reward   int          `json:"reward"`
	Priority string       `json:"priority"`
	Tags     []string     `json:"tags"`
	PICs     []Employee   `json:"pics"`
	Status   string       `json:"status"`
	Function []string     `json:"function"`
	SubItems []NotionEarn `json:"sub_items"`
	ParentID string       `json:"-"`
	DueDate  *time.Time   `json:"due_date"`
}

type NotionAudience struct {
	ID        string    `json:"id"`
	FullName  string    `json:"full_name"`
	Email     string    `json:"email"`
	Sources   []string  `json:"source"`
	CreatedAt time.Time `json:"created_at"`
}

type NotionTechRadar struct {
	ID         string   `json:"id"`
	Name       string   `json:"name"`
	Assign     string   `json:"assign"`
	Categories []string `json:"categories"`
	Tags       []string `json:"tags"`
	Quadrant   string   `json:"quadrant"`
	Ring       string   `json:"ring"`
} // @name NotionTechRadar

type NotionDigest struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	CreatedAt time.Time `json:"created_at"`
}

type NotionStaffingDemand struct {
	ID      string `json:"id"`
	Name    string `json:"name"`
	Request string `json:"request"`
}

type NotionIssue struct {
	ID           string     `json:"id"`
	Name         string     `json:"name"`
	RootCause    string     `json:"rootcause"`
	Resolution   string     `json:"resolution"`
	Scope        string     `json:"scope"`
	Priority     string     `json:"priority"`
	Severity     string     `json:"severity"`
	IncidentDate *time.Time `json:"incident_date"`
	SolvedDate   *time.Time `json:"solve_date"`
	PIC          string     `json:"pic"`
	Projects     []string   `json:"projects"`
	Status       string     `json:"status"`
	Source       string     `json:"source"`
	Profile      string     `json:"profile"`
}

type HiringType string

const (
	HiringTypeDirect     HiringType = "direct"
	HiringTypeReferral   HiringType = "referral"
	HiringTypeInternship HiringType = "internship"
)

type NotionHiringRelationship struct {
	BaseModel

	UserID     UUID       `json:"user_id"`
	SupplierID UUID       `json:"supplier_id"`
	HiringType HiringType `json:"hiring_type"`

	Employee Employee `json:"user"`
}

type NotionHiringPosition struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	Projects  []string  `json:"project"`
	Status    string    `json:"status"`
	CreatedAt time.Time `json:"created_at"`
}

type NotionProjectMilestone struct {
	ID            string                    `json:"id"`
	Project       string                    `json:"-"`
	Name          string                    `json:"name"`
	StartDate     time.Time                 `json:"start_date"`
	EndDate       time.Time                 `json:"end_date"`
	SubMilestones []*NotionProjectMilestone `json:"sub_milestones"`
}

func (o *NotionProjectMilestone) GetSubMilestones() []*NotionProjectMilestone {
	return o.SubMilestones
}

```

# pkg/model/news.go

```go
package model

import "time"

const (
	RedditPlatform   = "reddit"
	LobstersPlatform = "lobsters"
)

type News struct {
	Title        string
	URL          string
	Popularity   int64
	CommentCount int64
	Flag         int64
	Description  string
	Tags         []string
	CreatedAt    time.Time
}

```

# pkg/model/monthly_delivery_metric.go

```go
package model

import (
	"time"

	"github.com/shopspring/decimal"
)

type MonthlyDeliveryMetric struct {
	Month     *time.Time
	SumWeight decimal.Decimal
	SumEffort decimal.Decimal
}

type AvgMonthlyDeliveryMetric struct {
	Weight decimal.Decimal
	Effort decimal.Decimal
}

```

# pkg/model/mochi.go

```go
package model

type VaultTransaction struct {
	ID          int64
	GuildID     string
	VaultID     int64
	VaultName   string
	Action      string
	FromAddress string
	ToAddress   string
	Target      string
	Sender      string
	Amount      string
	Token       string
	Threshold   string
	CreatedAt   string
	UpdatedAt   string
}

```

# pkg/model/memopr.go

```go
package model

import (
	"time"
)

type MemoPullRequest struct {
	Number         int       `json:"number"`
	Title          string    `json:"title"`
	DiscordId      string    `json:"discord_id"`
	GithubUserName string    `json:"github_user_name"`
	Url            string    `json:"url"`
	Timestamp      time.Time `json:"timestamp"`
}

```

# pkg/model/memo_log.go

```go
package model

import (
	"time"

	"github.com/lib/pq"
	"github.com/shopspring/decimal"
	"gorm.io/gorm"
)

type MemoLog struct {
	BaseModel

	Title       string
	URL         string
	Tags        JSONArrayString
	Description string
	PublishedAt *time.Time
	Reward      decimal.Decimal
	Category    pq.StringArray `json:"value" gorm:"type:text[]"`

	Authors []DiscordAccount `json:"authors" gorm:"many2many:memo_authors;"`

	// This field is used to make sure response always contains authors
	AuthorMemoUsernames []string `json:"-" gorm:"-"`
}

type DiscordAccountMemoRank struct {
	DiscordID       string
	DiscordUsername string
	MemoUsername    string
	TotalMemos      int
	Rank            int
}

func (MemoLog) BeforeCreate(db *gorm.DB) error {
	return db.SetupJoinTable(&MemoLog{}, "Authors", &MemoAuthor{})
}

```

# pkg/model/memo_author.go

```go
package model

import (
	"time"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

// MemoAuthor is the join table for memo log and discord account
type MemoAuthor struct {
	MemoLogID        UUID `gorm:"primaryKey"`
	DiscordAccountID UUID `gorm:"primaryKey"`
	CreatedAt        time.Time
}

func (b *MemoAuthor) BeforeCreate(tx *gorm.DB) (err error) {
	cols := []clause.Column{}
	for _, field := range tx.Statement.Schema.PrimaryFields {
		cols = append(cols, clause.Column{Name: field.DBName})
	}
	tx.Statement.AddClause(clause.OnConflict{
		Columns:   cols,
		DoNothing: true,
	})

	return nil
}

```

# pkg/model/liability.go

```go
package model

import "time"

type Liability struct {
	BaseModel

	PaidAt     *time.Time `json:"paidAt"`
	Name       string     `json:"name"`
	Total      float64    `json:"total"`
	CurrencyID UUID       `json:"currencyID"`
}

```

# pkg/model/json.go

```go
package model

import (
	"bytes"
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"strings"
)

// JSONArrayString custom type for handling string array in postgreSQL
type JSONArrayString []string

func (j JSONArrayString) Value() (driver.Value, error) {
	return strings.ReplaceAll(fmt.Sprintf("%q", j), " ", ","), nil
}

func (j *JSONArrayString) Scan(value interface{}) error {
	if value == nil {
		*j = nil
		return nil
	}

	switch t := value.(type) {
	case []uint8:
		return json.Unmarshal(value.([]uint8), j)
	default:
		return fmt.Errorf("could not scan type %T into JSONArrayString", t)
	}
}

// JSON custom type for storing db & responding API req purpose only
type JSON []byte

func (j JSON) Value() (driver.Value, error) {
	if j == nil {
		return "null", nil
	}
	return string(j), nil
}

func (j *JSON) Scan(value interface{}) error {
	if value == nil {
		*j = nil
		return nil
	}

	switch t := value.(type) {
	case []uint8:
		jsonData := value.([]uint8)
		if string(jsonData) == "null" {
			return nil
		}
		*j = JSON(jsonData)
		return nil
	default:
		return fmt.Errorf("could not scan type %T into json", t)
	}
}

func (j JSON) MarshalJSON() ([]byte, error) {
	switch true {
	case j == nil, len(j) == 0:
		return []byte("null"), nil
	case len(j) <= 2:
		if (j[0]) == '[' {
			return []byte("[]"), nil
		}
		return []byte("null"), nil
	default:
		return []byte(j), nil
	}
}

func (j *JSON) UnmarshalJSON(raw []byte) error {
	if string(raw) == "null" {
		*j = nil
		return nil
	}

	var out bytes.Buffer
	err := json.Compact(&out, raw)
	if err == nil {
		*j = JSON(out.Bytes())
		return nil
	}
	*j = JSON(raw)
	return nil
}

type JSONNullString struct {
	sql.NullString
}

func (v JSONNullString) MarshalJSON() ([]byte, error) {
	if v.Valid {
		return json.Marshal(v.String)
	} else {
		return json.Marshal(nil)
	}
}

func (v *JSONNullString) UnmarshalJSON(raw []byte) error {
	err := json.Unmarshal(raw, &v.NullString.String)

	v.NullString.Valid = err == nil
	return err
}

type JSONNullInt64 struct {
	sql.NullInt64
}

func (v JSONNullInt64) MarshalJSON() ([]byte, error) {
	if v.Valid {
		return json.Marshal(v.Int64)
	} else {
		return json.Marshal(nil)
	}
}

func (v *JSONNullInt64) UnmarshalJSON(raw []byte) error {
	err := json.Unmarshal(raw, &v.NullInt64.Int64)

	v.NullInt64.Valid = err == nil
	return err
}

```

# pkg/model/invoice_number_caching.go

```go
package model

type InvoiceNumberCaching struct {
	BaseModel

	Key    string `json:"key"`
	Number int    `json:"number"`
}

func (InvoiceNumberCaching) TableName() string { return "invoice_number_caching" }

type InvoiceCachingKeyStr struct {
	YearInvoiceNumberPrefix     string
	ProjectInvoiceNumberPrefix  string
	ProjectTemplateNumberPrefix string
	TplNumberPrefix             string
}

// InvoiceCachingKey present current keys of max numbers
var InvoiceCachingKey = InvoiceCachingKeyStr{
	YearInvoiceNumberPrefix:     "year_invoice",
	ProjectInvoiceNumberPrefix:  "project_invoice",
	ProjectTemplateNumberPrefix: "Project_Template_Number",
	TplNumberPrefix:             "Tpl",
}

```

# pkg/model/invoice.go

```go
package model

import (
	"encoding/json"
	"errors"
	"strings"
	"time"
)

type InvoiceStatus string

const (
	InvoiceStatusDraft     InvoiceStatus = "draft"
	InvoiceStatusSent      InvoiceStatus = "sent"
	InvoiceStatusOverdue   InvoiceStatus = "overdue"
	InvoiceStatusPaid      InvoiceStatus = "paid"
	InvoiceStatusError     InvoiceStatus = "error"
	InvoiceStatusScheduled InvoiceStatus = "scheduled"
)

func (i InvoiceStatus) IsValid() bool {
	switch i {
	case InvoiceStatusDraft,
		InvoiceStatusSent,
		InvoiceStatusOverdue,
		InvoiceStatusPaid,
		InvoiceStatusError,
		InvoiceStatusScheduled:
		return true
	}
	return false
}

func (i InvoiceStatus) String() string {
	return string(i)
}

// Invoice contain company information
type Invoice struct {
	BaseModel

	Number            string
	InvoicedAt        *time.Time
	DueAt             *time.Time
	PaidAt            *time.Time
	FailedAt          *time.Time
	Status            InvoiceStatus
	Email             string
	CC                JSON
	Description       string
	Note              string
	SubTotal          float64
	Tax               float64
	Discount          float64
	Total             float64
	ConversionAmount  float64
	InvoiceFileURL    string
	ErrorInvoiceID    *UUID
	LineItems         JSON
	Month             int
	Year              int
	SentBy            *UUID
	Sender            *Employee `gorm:"foreignKey:sent_by;"`
	ThreadID          string
	ScheduledDate     *time.Time
	ConversionRate    float64
	Bonus             float64
	TotalWithoutBonus float64

	BankID UUID
	Bank   *BankAccount

	ProjectID UUID
	Project   *Project

	InvoiceFileContent []byte `gorm:"-"` // we not store this in db
	MessageID          string `gorm:"-"`
	References         string `gorm:"-"`
	TodoAttachment     string `gorm:"-"`
}

func (i *Invoice) Validate() error {
	if i == nil {
		return errors.New("nil structure")
	}
	if i.Project == nil {
		return errors.New("missing project")
	}
	if i.Bank.Currency.Name == "" {
		return errors.New("missing bank info")
	}
	return nil
}

func GatherAddresses(CCs JSON) (string, error) {
	if CCs == nil {
		return "", nil
	}
	var ccList []string
	if err := json.Unmarshal(CCs, &ccList); err != nil {
		return "", err
	}
	for _, v := range ccList {
		if v == "" {
			continue
		}
	}
	return strings.Join(ccList, ", "), nil
}

type InvoiceItem struct {
	Quantity    float64 `json:"quantity"`
	UnitCost    float64 `json:"unit_cost"`
	Discount    float64 `json:"discount"`
	Cost        float64 `json:"cost"`
	Description string  `json:"description"`
	IsExternal  bool    `json:"is_external"`
}

func GetInfoItems(lineItems JSON) ([]InvoiceItem, error) {
	var items []InvoiceItem

	if len(lineItems) == 0 || string(lineItems) == "null" {
		return items, nil
	}

	if err := json.Unmarshal(lineItems, &items); err != nil {
		return nil, err
	}
	return items, nil
}

```

# pkg/model/icy_transaction.go

```go
package model

import (
	"time"
)

type IcyTransaction struct {
	BaseModel

	Category       string
	TxnTime        time.Time
	Amount         string
	Note           string
	SrcEmployeeID  UUID
	DestEmployeeID UUID
	Sender         string
	Target         string
}

```

# pkg/model/icy_distribution.go

```go
package model

// IcyDistribution is a model for icy_distribution table
type IcyDistribution struct {
	BaseModel
	Team   string `json:"team"`
	Period string `json:"period"`
	Amount string `json:"amount"`
}

```

# pkg/model/icy.go

```go
package model

type IcyAccounting struct {
	ICY     *TokenInfo    `json:"icy"`
	USDT    *TokenInfo    `json:"usdt"`
	IcySwap *ContractInfo `json:"icy_swap"`

	ConversionRate     float32 `json:"conversion_rate"`
	CirculatingICY     string  `json:"circulating_icy"`
	ContractFundInUSDT string  `json:"contract_fund_in_usdt"`
	OffsetUSDT         string  `json:"offset_usdt"` // how many usdt left need to be issued
}

type TokenInfo struct {
	Name        string `json:"name"`
	Symbol      string `json:"symbol"`
	Address     string `json:"address"`
	Decimals    int    `json:"decimals"`
	Chain       string `json:"chain"`
	ChainID     string `json:"chain_id"`
	TotalSupply string `json:"total_supply"`
}

type ContractInfo struct {
	Name    string `json:"name"`
	Address string `json:"address"`
	Chain   string `json:"chain"`
}

```

# pkg/model/google_mail.go

```go
package model

// GoogleMailThread --
type GoogleMailThread struct {
	ID       string              `json:"id"`
	Messages []GoogleMailMessage `json:"messages"`
}

// GoogleMailMessage --
type GoogleMailMessage struct {
	ID       string   `json:"id"`
	ThreadID string   `json:"threadId"`
	Payload  *Payload `json:"payload"`
}

type Payload struct {
	Headers []Header `json:"headers"`
}

type Header struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

```

# pkg/model/feedback_events.go

```go
package model

import (
	"time"
)

// EventType event_type for table feedback events
type EventType string
type EventStatus string

// values for EventType
const (
	EventTypeFeedback EventType = "feedback"
	EventTypeSurvey   EventType = "survey"
)

const (
	EventStatusDraft      EventStatus = "draft"
	EventStatusDone       EventStatus = "done"
	EventStatusInProgress EventStatus = "in-progress"
)

// IsValid validation for EventStatus
func (e EventStatus) IsValid() bool {
	switch e {
	case
		EventStatusDraft,
		EventStatusDone,
		EventStatusInProgress:
		return true
	}
	return false
}

// IsValid validation for EventType
func (e EventType) IsValid() bool {
	switch e {
	case
		EventTypeFeedback,
		EventTypeSurvey:
		return true
	}
	return false
}

// String returns the string type from the EventStatus type
func (e EventStatus) String() string {
	return string(e)
}

// String returns the string type from the EventType type
func (e EventType) String() string {
	return string(e)
}

// EventSubtype event_subtype for table feedback events
type EventSubtype string

// values for EventSubtype
const (
	EventSubtypePeerReview   EventSubtype = "peer-review"
	EventSubtypeEngagement   EventSubtype = "engagement"
	EventSubtypeWork         EventSubtype = "work"
	EventSubtypeAppreciation EventSubtype = "appreciation"
	EventSubtypeComment      EventSubtype = "comment"
)

// IsValid validation for EventSubtype
func (e EventSubtype) IsValid() bool {
	switch e {
	case
		EventSubtypePeerReview,
		EventSubtypeEngagement,
		EventSubtypeWork,
		EventSubtypeAppreciation,
		EventSubtypeComment:
		return true
	}
	return false
}

// IsSurveyValid validation for subtype of survey
func (e EventSubtype) IsSurveyValid() bool {
	switch e {
	case
		EventSubtypePeerReview,
		EventSubtypeEngagement,
		EventSubtypeWork:
		return true
	}
	return false
}

// String returns the string type from the EventSubtype type
func (e EventSubtype) String() string {
	return string(e)
}

// IsValidSurvey validation for EventSubType
func (e EventSubtype) IsValidSurvey() bool {
	switch e {
	case
		EventSubtypePeerReview,
		EventSubtypeEngagement,
		EventSubtypeWork:
		return true
	}
	return false
}

// FeedbackEvent model for feedback_events table
type FeedbackEvent struct {
	BaseModel

	Title     string
	Type      EventType
	Subtype   EventSubtype
	Status    EventStatus
	CreatedBy UUID
	StartDate *time.Time
	EndDate   *time.Time

	Employee             Employee              `gorm:"foreignKey:CreatedBy"`
	Topics               []*EmployeeEventTopic `gorm:"foreignKey:EventID"`
	QuestionDomainCounts []QuestionDomainCount `gorm:"-"`
}

```

# pkg/model/expense.go

```go
package model

import (
	"time"

	"gorm.io/datatypes"
)

// Expense for slack command
type Expense struct {
	BaseModel

	EmployeeID              UUID           `json:"employee_id"`
	CurrencyID              UUID           `json:"currency_id"`
	Amount                  int            `json:"amount"`
	IssuedDate              time.Time      `sql:"default: now()" json:"issued_date"`
	Reason                  string         `json:"reason"`
	InvoiceImageURL         string         `json:"invoice_image_url"`
	Metadata                datatypes.JSON `json:"metadata"`
	BasecampID              int            `json:"basecamp_id"`
	AccountingTransactionID *UUID          `json:"accounting_transaction_id"`
}

```

# pkg/model/event.go

```go
package model

import (
	"time"
)

// Event struct
type Event struct {
	BaseModel
	Name             string                    `json:"name"`
	Description      string                    `json:"description"`
	Date             time.Time                 `json:"date"`
	Image            string                    `json:"image" gorm:"-"`
	DiscordEventID   string                    `json:"discordEventId"`
	DiscordChannelID string                    `json:"discordChannelId"`
	DiscordMessageID string                    `json:"discordMessageId"`
	DiscordCreatorID string                    `json:"discordCreatorId"`
	EventType        DiscordScheduledEventType `json:"type"`
	EventSpeakers    []EventSpeaker            `json:"eventSpeakers"`
	IsOver           bool                      `json:"isOver" gorm:"-"`
}

// EventSpeaker struct
type EventSpeaker struct {
	EventID          UUID   `json:"eventId"`
	DiscordAccountID UUID   `json:"discordAccountId"`
	Topic            string `json:"topic,omitempty"`

	Event *Event `json:"event"`
}

type DiscordScheduledEventType string

const (
	DiscordScheduledEventTypeOGIF DiscordScheduledEventType = "OGIF"
	DiscordScheduledEventTypeDemo DiscordScheduledEventType = "DEMO"
)

// IsValid validation for DiscordScheduledEventType
func (e DiscordScheduledEventType) IsValid() bool {
	switch e {
	case
		DiscordScheduledEventTypeOGIF,
		DiscordScheduledEventTypeDemo:
		return true
	}
	return false
}

// String returns the string type from the DiscordScheduledEventType type
func (e DiscordScheduledEventType) String() string {
	return string(e)
}

// OgifLeaderboardRecord represents an element in the OGIF leaderboard
type OgifLeaderboardRecord struct {
	DiscordID  string `json:"discordID"`
	SpeakCount int64  `json:"speakCount"`
}

```

# pkg/model/engagement_rollup.go

```go
package model

type EngagementsRollup struct {
	BaseModel

	DiscordUserID   int64  `gorm:"default:null"`
	LastMessageID   int64  `gorm:"default:null"`
	DiscordUsername string `gorm:"default:null"`
	ChannelID       int64  `gorm:"default:null"`
	CategoryID      int64  `gorm:"default:null"`
	MessageCount    int    `gorm:"default:null"`
	ReactionCount   int    `gorm:"default:null"`
}

```

# pkg/model/employees.go

```go
package model

import (
	"strings"
	"time"
)

// WorkingStatus working_status type for employee table
type WorkingStatus string

// values for working_status
const (
	WorkingStatusOnBoarding WorkingStatus = "on-boarding"
	WorkingStatusLeft       WorkingStatus = "left"
	WorkingStatusProbation  WorkingStatus = "probation"
	WorkingStatusFullTime   WorkingStatus = "full-time"
	WorkingStatusContractor WorkingStatus = "contractor"
)

// IsValid validation for WorkingStatus
func (e WorkingStatus) IsValid() bool {
	switch e {
	case
		WorkingStatusOnBoarding,
		WorkingStatusContractor,
		WorkingStatusLeft,
		WorkingStatusProbation,
		WorkingStatusFullTime:
		return true
	}
	return false
}

// String returns the string type from the WorkingStatus type
func (e WorkingStatus) String() string {
	return string(e)
}

// AccountRole account_role type for employee table
type AccountRole string

// values for account_role
const (
	AccountRoleAdmin  AccountRole = "admin"
	AccountRoleMember AccountRole = "member"
)

// IsValid validation for AccountRole
func (e AccountRole) IsValid() bool {
	switch e {
	case
		AccountRoleAdmin,
		AccountRoleMember:
		return true
	}
	return false
}

// String returns the string representation
func (e AccountRole) String() string {
	return string(e)
}

// Employee define the model for table employees
type Employee struct {
	BaseModel

	// basic info
	FullName               string     `gorm:"default:null"`
	DisplayName            string     `gorm:"default:null"`
	Username               string     `gorm:"default:null"`
	TeamEmail              string     `gorm:"default:null"`
	PersonalEmail          string     `gorm:"default:null"`
	Avatar                 string     `gorm:"default:null"`
	PhoneNumber            string     `gorm:"default:null"`
	Address                string     `gorm:"default:null"`
	PlaceOfResidence       string     `gorm:"default:null"`
	MBTI                   string     `gorm:"default:null"`
	Gender                 string     `gorm:"default:null"`
	Horoscope              string     `gorm:"default:null"`
	PassportPhotoFront     string     `gorm:"default:null"`
	PassportPhotoBack      string     `gorm:"default:null"`
	IdentityCardPhotoFront string     `gorm:"default:null"`
	IdentityCardPhotoBack  string     `gorm:"default:null"`
	DateOfBirth            *time.Time `gorm:"default:null"`
	Country                string     `gorm:"default:null"`
	City                   string     `gorm:"default:null"`
	Lat                    string     `gorm:"default:null"`
	Long                   string     `gorm:"default:null"`

	// working info
	WorkingStatus WorkingStatus `gorm:"default:null"`
	JoinedDate    *time.Time    `gorm:"default:null"`
	LeftDate      *time.Time    `gorm:"default:null"`
	SeniorityID   UUID          `gorm:"default:null"`
	LineManagerID UUID          `gorm:"default:null"`
	ReferredBy    UUID          `gorm:"default:null"`

	// social services
	BasecampID             int    `gorm:"default:null"`
	BasecampAttachableSGID string `gorm:"column:basecamp_attachable_sgid;default:null"`
	DiscordAccountID       UUID   `gorm:"default:null"`

	// payroll info
	WiseRecipientEmail string `gorm:"default:null"`
	WiseRecipientID    string `gorm:"default:null"`
	WiseRecipientName  string `gorm:"default:null"`
	WiseAccountNumber  string `gorm:"default:null"`
	WiseCurrency       string `gorm:"default:null"`

	LocalBankBranch        string `gorm:"default:null"`
	LocalBankNumber        string `gorm:"default:null"`
	LocalBankCurrency      string `gorm:"default:null"`
	LocalBranchName        string `gorm:"default:null"`
	LocalBankRecipientName string `gorm:"default:null"`

	BeneficiaryBankName      string `gorm:"default:null"`
	BeneficiaryBankPostcode  string `gorm:"default:null"`
	BeneficiaryBankAddress   string `gorm:"default:null"`
	BeneficiaryBankCity      string `gorm:"default:null"`
	BeneficiaryRoutingNumber string `gorm:"default:null"`

	Seniority             *Seniority
	LineManager           *Employee
	Referrer              *Employee `gorm:"foreignKey:referred_by;"`
	ProjectMembers        []ProjectMember
	Organizations         []Organization `gorm:"many2many:employee_organizations;"`
	Roles                 []Role         `gorm:"many2many:employee_roles;"`
	Positions             []Position     `gorm:"many2many:employee_positions;"`
	EmployeeRoles         []EmployeeRole
	EmployeePositions     []EmployeePosition
	EmployeeOrganizations []EmployeeOrganization
	EmployeeStacks        []EmployeeStack
	EmployeeChapters      []EmployeeChapter
	EmployeeMMAScores     []EmployeeMMAScore
	SocialAccounts        []SocialAccount
	Mentees               []*Employee `gorm:"references:ID;foreignKey:LineManagerID"`
	WorkUnitMembers       []WorkUnitMember
	Heads                 []ProjectHead

	EmployeeSalary *EmployeeSalary `json:"employee_salary"`
	BaseSalary     BaseSalary      `json:"base_salary"`

	DiscordAccount *DiscordAccount
}

// ToEmployeeMap create map from employees
func ToEmployeeMap(employees []*Employee) map[UUID]Employee {
	rs := map[UUID]Employee{}
	for _, e := range employees {
		rs[e.ID] = *e
	}

	return rs
}

func (e Employee) GetFirstNameFromFullName() string {
	if e.FullName == "" {
		return ""
	}
	s := strings.Split(e.FullName, " ")
	return s[len(s)-1]
}

type Employees []Employee

func (e Employees) ToTeamEmailIDMap() map[string]UUID {
	rs := map[string]UUID{}
	for _, e := range e {
		rs[e.TeamEmail] = e.ID
	}

	return rs
}

```

# pkg/model/employee_stacks.go

```go
package model

type EmployeeStack struct {
	BaseModel

	EmployeeID UUID
	StackID    UUID

	Stack Stack
}

```

# pkg/model/employee_salary.go

```go
package model

import "gorm.io/datatypes"

// const (
// 	rateUSD = 22500
// )

type EmployeeSalary struct {
	ID UUID `json:"-"`

	EmployeeID UUID      `json:"employee_id"`
	Employee   *Employee `json:"-"`

	CommissionAmount    int64          `json:"commission_amount"`
	CommissionDetail    datatypes.JSON `json:"commission_detail"`
	ReimbursementAmount int64          `json:"reimbursement_amount"`
	ReimbursementDetail datatypes.JSON `json:"reimbursement_detail"`
	BonusAmount         int64          `json:"bonus_amount"`
	BonusDetail         datatypes.JSON `json:"bonus_detail"`
	TotalAmount         int64          `json:"total_amount"`

	Month        uint8 `json:"month"`
	Year         int32 `json:"year"`
	ActualPayDay int8  `json:"actual_pay_day"`
	PlanPayDay   int8  `json:"plan_pay_day"`
	IsDone       bool  `json:"is_done"`
}

```

# pkg/model/employee_roles.go

```go
package model

type EmployeeRole struct {
	BaseModel

	EmployeeID UUID
	RoleID     UUID

	Role Role
}

```

# pkg/model/employee_positions.go

```go
package model

type EmployeePosition struct {
	BaseModel

	EmployeeID UUID
	PositionID UUID

	Position Position
}

```

# pkg/model/employee_organizations.go

```go
package model

type EmployeeOrganization struct {
	BaseModel

	EmployeeID     UUID
	OrganizationID UUID

	Organization Organization
}

```

# pkg/model/employee_mma_score.go

```go
package model

import (
	"time"

	"github.com/shopspring/decimal"
)

// EmployeeMMAScore define the model for table employee_mma_scores
type EmployeeMMAScore struct {
	BaseModel

	EmployeeID    UUID
	MasteryScore  decimal.Decimal
	AutonomyScore decimal.Decimal
	MeaningScore  decimal.Decimal
	RatedAt       *time.Time
}

type EmployeeMMAScoreData struct {
	EmployeeID    UUID
	FullName      string
	MMAID         UUID
	MasteryScore  decimal.Decimal
	AutonomyScore decimal.Decimal
	MeaningScore  decimal.Decimal
	RatedAt       *time.Time
}

```

# pkg/model/employee_mentees.go

```go
package model

// EmployeeMentee define the model for table employee_mentees
type EmployeeMentee struct {
	BaseModel

	MenteeID UUID
	MentorID UUID

	Mentee *Employee `gorm:"foreignKey:MenteeID"`
}

```

# pkg/model/employee_invitations.go

```go
package model

type EmployeeInvitation struct {
	BaseModel

	EmployeeID               UUID
	InvitedBy                UUID
	InvitationCode           string
	IsCompleted              bool
	IsInfoUpdated            bool
	IsDiscordRoleAssigned    bool
	IsBasecampAccountCreated bool
	IsTeamEmailCreated       bool
	Employee                 *Employee
}

type InvitationEmail struct {
	Name    string `json:"name"`
	Email   string `json:"email"`
	Link    string `json:"link"`
	Inviter string `json:"inviter"`
}

```

# pkg/model/employee_event_topic.go

```go
package model

// Relationship relationships for table employee_event_topics
type Relationship string

// values for Relationship
const (
	RelationshipPeer        Relationship = "peer"
	RelationshipLineManager Relationship = "line-manager"
	RelationshipChapterLead Relationship = "chapter-lead"
	RelationshipSelf        Relationship = "self"
)

// IsValid validation for Relationship
func (e Relationship) IsValid() bool {
	switch e {
	case
		RelationshipPeer,
		RelationshipLineManager,
		RelationshipChapterLead,
		RelationshipSelf:
		return true
	}
	return false
}

// IsValid validation for Relationship
func (e Relationship) String() string {
	return string(e)
}

// EmployeeEventTopic model for table employee_event_topics
type EmployeeEventTopic struct {
	BaseModel

	Title      string
	EventID    UUID
	EmployeeID UUID
	ProjectID  UUID

	Event                  FeedbackEvent
	Employee               *Employee
	Project                *Project
	EmployeeEventReviewers []EmployeeEventReviewer
}

```

# pkg/model/employee_event_reviewer.go

```go
package model

// EmployeeEventReviewer model for table employee_event_reviewer
type EmployeeEventReviewer struct {
	BaseModel

	EmployeeEventTopicID UUID
	ReviewerID           UUID
	ReviewerStatus       EventReviewerStatus
	AuthorStatus         EventAuthorStatus
	Relationship         Relationship
	IsShared             bool
	IsRead               bool
	IsForcedDone         bool
	EventID              UUID

	Event                  FeedbackEvent
	EmployeeEventTopic     EmployeeEventTopic
	Reviewer               *Employee
	EmployeeEventQuestions []EmployeeEventQuestion
}

// EventReviewerStatus event_reviewer_status for table employee event reviewer
type EventReviewerStatus string // @name EventReviewerStatus

// EventReviewerStatus values
const (
	EventReviewerStatusNone  EventReviewerStatus = "none"
	EventReviewerStatusNew   EventReviewerStatus = "new"
	EventReviewerStatusDraft EventReviewerStatus = "draft"
	EventReviewerStatusDone  EventReviewerStatus = "done"
)

// IsValid validation for EventReviewerStatus
func (e EventReviewerStatus) IsValid() bool {
	switch e {
	case
		EventReviewerStatusNone,
		EventReviewerStatusDraft,
		EventReviewerStatusDone,
		EventReviewerStatusNew:
		return true
	}
	return false
}

// String returns the string type from the EventReviewerStatus type
func (e EventReviewerStatus) String() string {
	return string(e)
}

// EventAuthorStatus event_reviewer_status for table employee event reviewer
type EventAuthorStatus string

// EventAuthorStatus values
const (
	EventAuthorStatusDraft EventAuthorStatus = "draft"
	EventAuthorStatusSent  EventAuthorStatus = "sent"
	EventAuthorStatusDone  EventAuthorStatus = "done"
)

// IsValid validation for EventAuthorStatus
func (e EventAuthorStatus) IsValid() bool {
	switch e {
	case
		EventAuthorStatusDraft,
		EventAuthorStatusSent,
		EventAuthorStatusDone:
		return true
	}
	return false
}

// String returns the string type from the EventReviewerStatus type
func (e EventAuthorStatus) String() string {
	return string(e)
}

```

# pkg/model/employee_event_questions.go

```go
package model

import "time"

// EmployeeEventQuestion model for employee_event_questions table
type EmployeeEventQuestion struct {
	BaseModel

	EmployeeEventReviewerID UUID
	QuestionID              UUID
	EventID                 UUID
	Content                 string
	Answer                  string
	Note                    string
	Type                    string
	Order                   int64
	Domain                  QuestionDomain
}

type StatisticEngagementDashboard struct {
	Name       string
	Content    string
	Title      string
	Point      float64
	QuestionID UUID
	StartDate  time.Time
}

type EngagementDashboardFilter string

const (
	EngagementDashboardFilterDepartment EngagementDashboardFilter = "department"
	EngagementDashboardFilterChapter    EngagementDashboardFilter = "chapter"
	EngagementDashboardFilterSeniority  EngagementDashboardFilter = "seniority"
	EngagementDashboardFilterProject    EngagementDashboardFilter = "project"
)

// String returns the string type from the EngagementDashboardFilter type
func (e EngagementDashboardFilter) String() string {
	return string(e)
}

func (e EngagementDashboardFilter) IsValid() bool {
	switch e {
	case
		EngagementDashboardFilterDepartment,
		EngagementDashboardFilterChapter,
		EngagementDashboardFilterSeniority,
		EngagementDashboardFilterProject:
		return true
	}
	return false
}

// ToQuestionMap create map from EmployeeEventQuestion
func ToQuestionMap(questionList []*EmployeeEventQuestion) map[UUID]string {
	rs := map[UUID]string{}
	for _, q := range questionList {
		rs[q.ID] = q.Answer
	}

	return rs
}

// ToQuestionMapType create map from Question to type
func ToQuestionMapType(questionList []*EmployeeEventQuestion) map[UUID]string {
	rs := map[UUID]string{}
	for _, q := range questionList {
		rs[q.ID] = q.Type
	}

	return rs
}

```

# pkg/model/employee_earns.go

```go
package model

import "github.com/dwarvesf/fortress-api/pkg/service/mochipay"

type EmployeeEarnTransactions []mochipay.TransactionData

```

# pkg/model/employee_commissions.go

```go
package model

import "time"

// EmployeeCommission represents EmployeeCommission table
// save the commission when invoice is paid for an Employee
type EmployeeCommission struct {
	BaseModel

	EmployeeID     UUID
	InvoiceID      UUID
	Project        string
	IsPaid         bool
	Amount         VietnamDong
	ConversionRate float64
	Formula        string
	Note           string
	PaidAt         *time.Time

	Employee *Employee
	Invoice  *Invoice
}

// New create new Employee commission
func New(employeeID, invoiceID UUID, project string, amount VietnamDong, rate float64) EmployeeCommission {
	return EmployeeCommission{
		EmployeeID:     employeeID,
		InvoiceID:      invoiceID,
		Amount:         amount,
		Project:        project,
		ConversionRate: rate,
	}
}

```

# pkg/model/employee_chapters.go

```go
package model

type EmployeeChapter struct {
	BaseModel

	EmployeeID UUID
	ChapterID  UUID

	Chapter Chapter
}

```

# pkg/model/employee_bonus.go

```go
package model

// EmployeeBonus represents employeeBonus table
// save the commission when invoice is paid for an employee
type EmployeeBonus struct {
	ID         UUID        `json:"id"`
	EmployeeID UUID        `json:"employee_id"`
	Amount     VietnamDong `json:"amount"`
	IsActive   bool        `json:"is_active"`
	Name       string      `json:"name"`
}

func (EmployeeBonus) TableName() string { return "employee_bonuses" }

```

# pkg/model/email.go

```go
package model

import "github.com/sendgrid/sendgrid-go/helpers/mail"

type Email struct {
	HTMLContent string
	Subject     string
	From        *mail.Email
	To          []*mail.Email
	Bcc         []*mail.Email
	Categories  []string
}

```

# pkg/model/earn.go

```go
package model

type Earn struct {
	Title    string
	Bounty   string
	Status   string
	PICs     []string
	Function string
	URL      string
}

```

# pkg/model/discord_message.go

```go
package model

import "github.com/bwmarrin/discordgo"

type DiscordMessage struct {
	AvatarURL  string                     `json:"avatar_url"`
	Content    string                     `json:"content"`
	Embeds     []DiscordMessageEmbed      `json:"embeds"`
	Components []DiscordMessageComponents `json:"components"`
}

type DiscordMessageEmbed struct {
	Author      DiscordMessageAuthor  `json:"author"`
	Title       string                `json:"title"`
	URL         string                `json:"url"`
	Description string                `json:"description"`
	Color       int64                 `json:"color"`
	Fields      []DiscordMessageField `json:"fields"`
	Thumbnail   DiscordMessageImage   `json:"thumbnail"`
	Image       DiscordMessageImage   `json:"image"`
	Footer      DiscordMessageFooter  `json:"footer"`
	Timestamp   string                `json:"timestamp"`
}

type DiscordMessageAuthor struct {
	Name    string `json:"name"`
	URL     string `json:"url"`
	IconURL string `json:"icon_url"`
}

type DiscordMessageField struct {
	Name   string `json:"name"`
	Value  string `json:"value"`
	Inline *bool  `json:"inline,omitempty"`
}

type DiscordMessageFooter struct {
	Text    string `json:"text"`
	IconURL string `json:"icon_url"`
}

type DiscordMessageImage struct {
	URL string `json:"url"`
}

type DiscordMessageComponents struct {
	Components []DiscordMessageComponent `json:"components"`
	Type       int64                     `json:"type"`
}

type DiscordMessageComponent struct {
	CustomID string      `json:"custom_id"`
	Disabled bool        `json:"disabled"`
	Emoji    interface{} `json:"emoji"`
	Label    string      `json:"label"`
	Style    int64       `json:"style"`
	Type     int64       `json:"type"`
	URL      interface{} `json:"url"`
}

type OriginalDiscordMessage struct {
	RawContent  string
	ContentArgs []string
	ChannelId   string
	GuildId     string
	Author      *discordgo.User
	Roles       []string
}

```

# pkg/model/discord_account.go

```go
package model

import "github.com/lib/pq"

type DiscordAccount struct {
	BaseModel

	DiscordID       string
	DiscordUsername string         `json:"discord_username"`
	MemoUsername    string         `json:"memo_username"`
	Roles           pq.StringArray `json:"role" gorm:"type:text[]"`
	GithubUsername  string         `json:"github_username"`
	PersonalEmail   string         `json:"personal_email"`

	Employee *Employee `json:"employee"`
}

```

# pkg/model/discord.go

```go
package model

type LogDiscordInput struct {
	Type string
	Data interface{}
}

type DiscordLogTemplate struct {
	ID          string `json:"id"`
	Description string
	Content     string
}

type DiscordRole string

func (r DiscordRole) String() string {
	return string(r)
}

const (
	DiscordRolePeeps DiscordRole = "peeps"
)

```

# pkg/model/delivery_metric.go

```go
package model

import (
	"time"

	"github.com/shopspring/decimal"
)

type DeliveryMetric struct {
	BaseModel

	Weight        decimal.Decimal
	Effort        decimal.Decimal
	Effectiveness decimal.Decimal
	EmployeeID    UUID
	ProjectID     UUID
	Date          *time.Time
	Ref           int
}

type TopWeightMetric struct {
	EmployeeID UUID
	SumWeight  decimal.Decimal
	SumEffort  decimal.Decimal
}

type DeliveryMetrics []DeliveryMetric

type LeaderBoard struct {
	Date  *time.Time
	Items []LeaderBoardItem
}

type MonthlyLeaderBoard struct {
	Date  *time.Time
	Items []LeaderBoardItem
}

type LeaderBoardItem struct {
	EmployeeID      string
	EmployeeName    string
	Points          decimal.Decimal
	Effectiveness   decimal.Decimal
	DiscordID       string
	DiscordUsername string
	Rank            int
}

type WeeklyReport struct {
	LastWeek    WeekReport `json:"last_week"`
	CurrentWeek WeekReport `json:"current_week"`

	TotalPointChangePercentage float32 `json:"total_point_change_percentage"`
	EffortChangePercentage     float32 `json:"effort_change_percentage"`
	AvgPointChangePercentage   float32 `json:"avg_point_change_percentage"`
	AvgEffortChangePercentage  float32 `json:"avg_effort_change_percentage"`
}

type WeekReport struct {
	Date        *time.Time `json:"date"`
	TotalPoints float32    `json:"total_points"`
	Effort      float32    `json:"effort"`
	AvgPoint    float32    `json:"avg_point"`
	AvgEffort   float32    `json:"avg_effort"`
}

type MonthlyReport struct {
	Reports []MonthReport `json:"reports"`
}

type MonthReport struct {
	Month       *time.Time `json:"date"`
	TotalWeight float32    `json:"total_weight"`
	Effort      float32    `json:"effort"`

	AvgWeight       float32 `json:"avg_weight"`
	AvgEffort       float32 `json:"avg_effort"`
	AvgWeeklyWeight float32 `json:"avg_weekly_weight"`
	AvgWeeklyEffort float32 `json:"avg_weekly_effort"`

	TotalPointChangePercentage      float32 `json:"total_point_change_percentage"`
	EffortChangePercentage          float32 `json:"effort_change_percentage"`
	AvgWeightChangePercentage       float32 `json:"avg_weight_change_percentage"`
	AvgEffortChangePercentage       float32 `json:"avg_effort_change_percentage"`
	AvgWeeklyPointChangePercentage  float32 `json:"avg_weekly_point_change_percentage"`
	AvgWeeklyEffortChangePercentage float32 `json:"avg_weekly_effort_change_percentage"`
}

```

# pkg/model/date_time.go

```go
package model

import "time"

type DateTime struct {
	Time    time.Time `json:"time"`
	HasTime bool      `json:"has_time"`
}

```

# pkg/model/dashboard.go

```go
package model

import "time"

type ProjectSize struct {
	ID     UUID   `json:"id"`
	Name   string `json:"name"`
	Code   string `json:"code"`
	Avatar string `json:"avatar"`
	Size   int64  `json:"size"`
}

type WorkSurvey struct {
	EndDate  time.Time `json:"endDate"`
	Workload float64   `json:"workload"`
	Deadline float64   `json:"deadline"`
	Learning float64   `json:"learning"`
}

type ActionItemReport struct {
	Quarter string `json:"quarter"`
	High    int64  `json:"high"`
	Medium  int64  `json:"medium"`
	Low     int64  `json:"low"`
}

type AverageEngineeringHealth struct {
	Quarter string  `json:"quarter"`
	Avg     float64 `json:"avg"`
}

type GroupEngineeringHealth struct {
	Quarter string  `json:"quarter"`
	Avg     float64 `json:"avg"`
	Area    string  `json:"area"`
}

type GroupAudit struct {
	Quarter    string  `json:"quarter"`
	Frontend   float64 `json:"frontend"`
	Backend    float64 `json:"backend"`
	System     float64 `json:"system"`
	Process    float64 `json:"process"`
	Blockchain float64 `json:"blockchain"`
	Mobile     float64 `json:"mobile"`
}

type AverageAudit struct {
	Quarter string  `json:"quarter"`
	Avg     float64 `json:"avg"`
}

type ActionItemSquashReport struct {
	SnapDate time.Time `json:"snapDate"`
	All      int64     `json:"all"`
	High     int64     `json:"high"`
	Medium   int64     `json:"medium"`
	Low      int64     `json:"low"`
}

type ResolvedActionItem struct {
	ID      UUID   `json:"id"`
	Quarter string `json:"quarter"`
	Count   int64  `json:"count"`
}

type AuditSummary struct {
	Quarter string  `json:"quarter"`
	ID      UUID    `json:"id"`
	Name    string  `json:"name"`
	Avatar  string  `json:"avatar"`
	Size    int64   `json:"size"`
	Code    string  `json:"code"`
	High    int64   `json:"high"`
	Medium  int64   `json:"medium"`
	Low     int64   `json:"low"`
	Done    int64   `json:"done"`
	Health  float64 `json:"health"`
	Audit   float64 `json:"audit"`
}

type ResourceUtilization struct {
	Date      time.Time `json:"date"`
	Staffed   int       `json:"staffed"`
	Internal  int       `json:"internal"`
	Available int       `json:"available"`
}

type TotalWorkUnitDistribution struct {
	TotalLineManagerCount int64
	TotalProjectHead      int64
	TotalLearning         int64
	TotalDevelopment      int64
	TotalManagement       int64
	TotalTraining         int64
}

type ManagementInfo struct {
	ID       UUID          `json:"id"`
	Name     string        `json:"name"`
	Code     string        `json:"code"`
	Avatar   string        `json:"avatar"`
	Type     ProjectType   `json:"type"`
	Status   ProjectStatus `json:"status"`
	Position HeadPosition  `json:"position"`
}

```

# pkg/model/currency.go

```go
package model

import "github.com/dwarvesf/fortress-api/pkg/utils"

type Currency struct {
	BaseModel

	Name   string
	Symbol string
	Locale string
	Type   string
}

type VietnamDong int64

func (vnd *VietnamDong) Scan(b interface{}) error {
	if b == nil {
		return nil
	}
	*vnd = VietnamDong(b.(int64))
	vnd.format()
	return nil
}

func NewVietnamDong(i int64) VietnamDong {
	return VietnamDong(i)
}

func (vnd VietnamDong) String() string {
	return utils.FormatNumber(int64(vnd))
}

func (vnd *VietnamDong) format() {
	*vnd = NewVietnamDong(int64(*vnd) / 1000 * 1000)
}

func (vnd *VietnamDong) Format() VietnamDong {
	vnd.format()
	return *vnd
}

```

# pkg/model/country.go

```go
package model

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
)

type Country struct {
	BaseModel

	Name   string `json:"name"`
	Code   string `json:"code"`
	Cities Cities `json:"cities"`
}

type City struct {
	Name string `json:"name"`
	Lat  string `json:"lat"`
	Long string `json:"long"`
}

type Cities []City

func (j Cities) Value() (driver.Value, error) {
	return json.Marshal(j)
}

func (j *Cities) Scan(value interface{}) error {
	if value == nil {
		*j = nil
		return nil
	}
	switch t := value.(type) {
	case []uint8:
		jsonData := value.([]uint8)
		if string(jsonData) == "null" {
			return nil
		}
		return json.Unmarshal(jsonData, j)
	default:
		return fmt.Errorf("could not scan type %T into json", t)
	}
}

func (j Cities) GetCity(city string) *City {
	for _, itm := range j {
		if itm.Name == city {
			return &itm
		}
	}

	return nil
}

```

# pkg/model/conversion_rate.go

```go
package model

import "github.com/shopspring/decimal"

type ConversionRate struct {
	BaseModel

	CurrencyID UUID
	Currency   Currency
	ToUSD      decimal.Decimal
	ToVND      decimal.Decimal
}

```

# pkg/model/content.go

```go
package model

import (
	"time"

	uuid "github.com/satori/go.uuid"
	"gorm.io/gorm"
)

type Content struct {
	ID        UUID       `sql:",type:uuid" json:"id"`
	CreatedAt time.Time  `sql:"default:now()" json:"createdAt"`
	UpdatedAt *time.Time `sql:"default:now()" json:"updatedAt"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	Type       string `json:"type"`
	Extension  string `json:"extension"`
	Path       string `json:"path"`
	UploadBy   UUID   `json:"uploadBy"`
	TargetID   UUID   `json:"target_id"`
	TargetType string `json:"target_type"`
	AuthType   string `json:"auth_type"`
}

// BeforeCreate prepare data before create data
func (m *Content) BeforeCreate(tx *gorm.DB) error {
	m.ID = UUID(uuid.NewV4())
	return nil
}

type ContentExtension string

const (
	ContentExtensionJpg ContentExtension = ".jpg"
	ContentExtensionPng ContentExtension = ".png"
	ContentExtensionPdf ContentExtension = ".pdf"
)

type ContentTargetType string

const (
	ContentTargetTypeEmployee  ContentTargetType = "employees"
	ContentTargetTypeProject   ContentTargetType = "projects"
	ContentTargetTypeChangeLog ContentTargetType = "change-logs"
	ContentTargetTypeInvoice   ContentTargetType = "invoices"
)

type ContentType string

const (
	ContentTypeImage ContentType = "image"
	ContentTypeDoc   ContentType = "doc"
)

const (
	MaxFileSizeImage = 2202099
	MaxFileSizePdf   = 5347737
)

func (e ContentExtension) Valid() bool {
	switch e {
	case
		ContentExtensionJpg,
		ContentExtensionPng,
		ContentExtensionPdf:
		return true
	}
	return false
}
func (e ContentExtension) ImageValid() bool {
	switch e {
	case
		ContentExtensionJpg,
		ContentExtensionPng:
		return true
	}
	return false
}

func (e ContentExtension) String() string {
	return string(e)
}

func (e ContentTargetType) Valid() bool {
	switch e {
	case
		ContentTargetTypeEmployee,
		ContentTargetTypeProject,
		ContentTargetTypeInvoice,
		ContentTargetTypeChangeLog:
		return true
	}
	return false
}

func (e ContentTargetType) String() string {
	return string(e)
}

func (e ContentType) Valid() bool {
	switch e {
	case
		ContentTypeImage,
		ContentTypeDoc:
		return true
	}
	return false
}

func (e ContentType) String() string {
	return string(e)
}

type DocumentType string

const (
	DocumentTypeAvatar       DocumentType = "avatar"
	DocumentTypeIDPhotoFront DocumentType = "id_photo_front"
	DocumentTypeIDPhotoBack  DocumentType = "id_photo_back"
)

func (e DocumentType) Valid() bool {
	switch e {
	case
		DocumentTypeAvatar,
		DocumentTypeIDPhotoFront,
		DocumentTypeIDPhotoBack:
		return true
	}
	return false
}

func (e DocumentType) String() string {
	return string(e)
}

```

# pkg/model/config.go

```go
package model

const (
	ConfigKeySalaryAdvanceMaxCap = "salary-advance-max-cap"
	ConfigKeyIcyUSDRate          = "icy-usd-rate"
)

type Config struct {
	BaseModel `json:"base_model"`

	Key   string `json:"key"`
	Value string `json:"value"`
}

func (Config) TableName() string { return "configs" }

```

# pkg/model/company_info.go

```go
package model

import "github.com/jackc/pgtype"

// CompanyInfo contain company information
type CompanyInfo struct {
	BaseModel

	Name               string       `json:"name"`
	Description        string       `json:"description"`
	RegistrationNumber string       `json:"registrationNumber"`
	Info               pgtype.JSONB `json:"info"`
}

type CompanyContactInfo struct {
	Address string `json:"address"`
	Phone   string `json:"phone"`
}

```

# pkg/model/communitynft.go

```go
package model

// Client store information of a Client
type NftMetadata struct {
	Name            string
	Description     string
	Image           string
	BackgroundColor string
	Attributes      []NftAttribute
}

type NftAttribute struct {
	TraitType string
	Value     string
}

```

# pkg/model/client_contact.go

```go
package model

import (
	"gorm.io/datatypes"
)

// ClientContact is the model for the client_contact table
type ClientContact struct {
	BaseModel

	Name          string
	ClientID      UUID
	Role          string
	Emails        datatypes.JSON
	IsMainContact bool
}

type ClientEmail struct {
	Emails []string `json:"emails"`
}

```

# pkg/model/client.go

```go
package model

// Client store information of a Client
type Client struct {
	BaseModel

	Name               string
	Description        string
	RegistrationNumber string
	Avatar             string
	Address            string
	Country            string
	City               string
	Industry           string
	Website            string
	IsPublic           bool
	Lat                string
	Long               string
	CompanySize        string
	SolutionType       string

	Contacts []ClientContact
	Projects []Project
}

```

# pkg/model/chapters.go

```go
package model

type Chapter struct {
	BaseModel

	Name   string `json:"name"`
	Code   string `json:"code"`
	LeadID *UUID  `json:"lead_id"`
}

// ToChapterMap create map from chapters
func ToChapterMap(chapters []*Chapter) map[UUID]string {
	rs := map[UUID]string{}
	for _, s := range chapters {
		rs[s.ID] = s.Name
	}

	return rs
}

```

# pkg/model/candidate.go

```go
package model

import (
	"strings"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
)

type CandidateStatus string

const (
	ApproachCandidateStatus CandidateStatus = "approach"
	OfferedCandidateStatus  CandidateStatus = "offered"
	FailedCandidateStatus   CandidateStatus = "failed"
	HiredCandidateStatus    CandidateStatus = "hired"
	RejectCandidateStatus   CandidateStatus = "reject"
)

type Candidate struct {
	BaseModel

	Name              string          `json:"name"`
	Email             string          `json:"email"`
	Detail            string          `json:"detail"`
	Note              string          `json:"-" gorm:"-"`
	CVUrl             string          `json:"cv_url"`
	Role              string          `json:"role"`
	Source            string          `json:"source"`
	Type              HiringType      `json:"type"`
	Status            CandidateStatus `json:"status"`
	Phone             string          `json:"phone"`
	CCAT              int             `gorm:"column:CCAT" json:"CCAT"`
	EPP               int             `gorm:"column:EPP" json:"EPP"`
	IsReferral        bool            `json:"is_referral"`
	ReferralInfo      JSON            `json:"referral_info"`
	BasecampTodoID    int             `json:"basecamp_todo_id"`
	OfferSalary       int             `json:"offer_salary"`
	OfferStartDate    *time.Time      `json:"offer_start_date"`
	ProbationDuration int             `json:"probation_duration"`
	IsEmailSent       bool            `json:"is_email_sent"`
	OnboardTodoID     int             `json:"onboard_todo_id"`

	PdfFile          []byte `json:"-" gorm:"-"`
	GroupRole        string `json:"-" gorm:"-"`
	DisplayName      string `json:"-" gorm:"-"`
	DisplayStartDate string `json:"-" gorm:"-"`
	DisplaySalary    string `json:"-" gorm:"-"`
}

type ReferralInfo struct {
	Name        string `json:"name"`
	Email       string `json:"email"`
	PhoneNumber string `json:"phone_number"`
}

func (r Candidate) FindHiringInCharge() int {
	switch r.Role {
	case "Backend":
		return consts.HuyNguyenBasecampID
	case "Frontend":
		return consts.HuyGiangBasecampID
	case "QA/QC":
		return consts.PhuongTruongBasecampID
	case "iOs", "MacOS":
		return consts.TrungPhanBasecampID
	case "Android":
		return consts.ThanhNguyenBasecampID
	case "Sales", "Client Partner":
		return consts.NamTranBasecampID
	case "Designer", "Ventures Designer", "Visual Designer":
		return consts.KhaiLeBasecampID
	}
	return consts.HuyNguyenBasecampID
}

func GroupRole(role string) string {
	switch role {
	case "Golang":
		return "Backend"
	case "React", "Vue":
		return "Frontend"
	case "undefined":
		return "Other"
	default:
		return role
	}
}
func DisplayRole(role string) string {
	switch role {
	case "Golang", "Backend":
		return "Back-end Engineer"
	case "React", "Vue", "Frontend":
		return "Front-end Engineer"
	default:
		return role
	}
}

func DisplayName(name string) string {
	parts := strings.Split(name, " ")
	return parts[len(parts)-1]
}

```

# pkg/model/cached_payroll.go

```go
package model

import (
	"gorm.io/datatypes"
	"gorm.io/gorm"
)

type CachedPayroll struct {
	ID       UUID           `sql:",type:uuid" json:"id"`
	Month    int            `json:"month"`
	Year     int            `json:"year"`
	Batch    int            `json:"batch"`
	Payrolls datatypes.JSON `json:"payrolls"`
}

func (p *CachedPayroll) BeforeCreate(scope *gorm.DB) error {
	p.ID = NewUUID()
	return nil
}

func (CachedPayroll) TableName() string { return "cached_payrolls" }

```

# pkg/model/brainery_log.go

```go
package model

import (
	"time"

	"github.com/shopspring/decimal"
)

type BraineryLog struct {
	BaseModel

	Title       string
	URL         string
	GithubID    string
	DiscordID   string
	EmployeeID  UUID
	Tags        JSONArrayString
	PublishedAt *time.Time
	Reward      decimal.Decimal
}

```

# pkg/model/basecamp.go

```go
package model

import "time"

// BasecampRecording is a data structure define basecamp todo
type BasecampRecording struct {
	ID        int            `json:"id,omitempty"`
	Status    string         `json:"status,omitempty"`
	CreatedAt time.Time      `json:"created_at,omitempty"`
	UpdatedAt time.Time      `json:"updated_at,omitempty"`
	Title     string         `json:"title,omitempty"`
	URL       string         `json:"url,omitempty"`
	Parent    BasecampParent `json:"parent,omitempty"`
	Creator   BasecampUser   `json:"creator,omitempty"`
	Bucket    BasecampBucket `json:"bucket,omitempty"`
	Content   string         `json:"content,omitempty"`
}

type BasecampParent struct {
	ID    int64  `json:"id,omitempty"`
	Title string `json:"title,omitempty"`
	URL   string `json:"url,omitempty"`
}

type BasecampUser struct {
	ID    int    `json:"id,omitempty"`
	Email string `json:"email_address,omitempty"`
	Name  string `json:"name,omitempty"`
}

// BasecampBucket is
type BasecampBucket struct {
	ID   int    `json:"id,omitempty"`
	Name string `json:"name,omitempty"`
	Type string `json:"type,omitempty"`
}

```

# pkg/model/base_salary.go

```go
package model

import "time"

type BaseSalary struct {
	BaseModel

	EmployeeID UUID `json:"employee_id"`
	Employee   *Employee

	ContractAmount        int64       `json:"contract_amount"`
	CompanyAccountAmount  int64       `json:"company_account_amount"`
	PersonalAccountAmount int64       `json:"personal_account_amount"`
	InsuranceAmount       VietnamDong `json:"insurance_amount"`
	Type                  string      `json:"type"`
	Category              string      `json:"category"`

	CurrencyID UUID `json:"currency_id"`
	Currency   *Currency
	Batch      int

	EffectiveDate *time.Time `json:"effective_date"`
}

func (BaseSalary) TableName() string { return "base_salaries" }

```

# pkg/model/base.go

```go
package model

import (
	"time"

	"gorm.io/gorm"
)

// BaseModel base model for domain type
type BaseModel struct {
	ID        UUID            `sql:",type:uuid" json:"id" gorm:"default:uuid()"`
	CreatedAt time.Time       `sql:"default:now()" json:"createdAt"`
	UpdatedAt *time.Time      `sql:"default:now()" json:"updatedAt"`
	DeletedAt *gorm.DeletedAt `json:"deletedAt,omitempty"`
}

// BeforeCreate prepare data before create data
// func (m *BaseModel) BeforeCreate(tx *gorm.DB) (err error) {
// 	m.ID = NewUUID()
// 	m.CreatedAt = time.Now()
// 	return
// }

// BeforeUpdate prepare data before create data
func (m *BaseModel) BeforeUpdate(tx *gorm.DB) (err error) {
	tx.Statement.SetColumn("updated_at", time.Now())
	return
}

```

# pkg/model/banks.go

```go
package model

type Bank struct {
	BaseModel

	Name      string
	Code      string
	Bin       string
	ShortName string
	Logo      string
	SwiftCode string
}

```

# pkg/model/bank_account.go

```go
package model

// BankAccount contain company information
type BankAccount struct {
	BaseModel

	AccountNumber           string
	BankName                string
	OwnerName               string
	Address                 *string
	SwiftCode               string
	RoutingNumber           string
	Name                    string
	UKSortCode              string
	IntermediaryBankName    string
	IntermediaryBankAddress string

	CurrencyID UUID
	Currency   *Currency
}

```

# pkg/model/auth.go

```go
package model

import (
	"github.com/golang-jwt/jwt/v4"
)

// AuthenticationInfo ..
type AuthenticationInfo struct {
	jwt.StandardClaims

	UserID string `json:"id"`
	Avatar string `json:"avatar"`
	Email  string `json:"email"`
}

type CurrentLoggedUserInfo struct {
	UserID      string
	Permissions map[string]string
	Projects    map[UUID]*Project
	Role        string
}

```

# pkg/model/audits.go

```go
package model

import (
	"strings"
	"time"

	"github.com/dstotijn/go-notion"
)

type AuditType string

// values for audit_type
const (
	AuditTypeHealth     AuditType = "engineering-health"
	AuditTypeProcess    AuditType = "engineering-process"
	AuditTypeFrontend   AuditType = "frontend"
	AuditTypeBackend    AuditType = "backend"
	AuditTypeSystem     AuditType = "system"
	AuditTypeMobile     AuditType = "mobile"
	AuditTypeBlockchain AuditType = "blockchain"
)

// IsValid validation for AuditType
func (e AuditType) IsValid() bool {
	switch e {
	case
		AuditTypeHealth,
		AuditTypeProcess,
		AuditTypeFrontend,
		AuditTypeBackend,
		AuditTypeSystem,
		AuditTypeMobile,
		AuditTypeBlockchain:
		return true
	}
	return false
}

// String returns the string representation
func (e AuditType) String() string {
	return string(e)
}

type Audit struct {
	BaseModel

	ProjectID  UUID
	NotionDBID UUID
	AuditorID  UUID
	Name       string
	Type       AuditType
	Score      float64
	Status     AuditStatus
	Flag       AuditFlag
	ActionItem int64
	Duration   float64
	AuditedAt  *time.Time
	SyncAt     *time.Time
}

func NewAuditFromNotionPage(page notion.Page, projectID string, auditorID UUID, flag AuditFlag, notionDBID string) *Audit {
	properties := page.Properties.(notion.DatabasePageProperties)
	now := time.Now()

	rs := &Audit{
		BaseModel:  BaseModel{ID: MustGetUUIDFromString(page.ID)},
		NotionDBID: MustGetUUIDFromString(notionDBID),
		Name:       properties["Name"].Title[0].PlainText,
		SyncAt:     &now,
		Flag:       flag,
	}

	if !auditorID.IsZero() {
		rs.AuditorID = auditorID
	}

	if properties["Score"].Number != nil {
		rs.Score = *properties["Score"].Number
		rs.Status = AuditStatusAudited
	} else {
		rs.Status = AuditStatusPending
	}

	if properties["Duration (hours)"].Number != nil {
		rs.Duration = *properties["Duration (hours)"].Number
	}

	if properties["Date"].Date != nil {
		rs.AuditedAt = &properties["Date"].Date.Start.Time
	}

	if len(properties["Name"].Title) > 0 {
		if MappingAuditType(properties["Name"].Title[0].PlainText) != "" {
			rs.Type = MappingAuditType(properties["Name"].Title[0].PlainText)
		} else {
			return nil
		}
	} else {
		return nil
	}

	if projectID != "" {
		rs.ProjectID = MustGetUUIDFromString(projectID)
	}

	return rs
}

func MappingAuditType(auditType string) AuditType {
	switch strings.ToLower(auditType) {
	case "engineering health checklist":
		return AuditTypeHealth
	case "engineering process checklist":
		return AuditTypeProcess
	case "frontend checklist":
		return AuditTypeFrontend
	case "backend checklist":
		return AuditTypeBackend
	case "system checklist":
		return AuditTypeSystem
	case "mobile checklist":
		return AuditTypeMobile
	case "blockchain checklist":
		return AuditTypeBlockchain
	}

	return ""
}

func CompareAudit(currAudit Audit, newAudit Audit) bool {
	return ((currAudit.AuditedAt == nil && newAudit.AuditedAt == nil) ||
		(currAudit.AuditedAt != nil && newAudit.AuditedAt != nil && currAudit.AuditedAt.Equal(*newAudit.AuditedAt))) &&
		currAudit.ProjectID == newAudit.ProjectID &&
		currAudit.NotionDBID == newAudit.NotionDBID && currAudit.AuditorID == newAudit.AuditorID &&
		currAudit.Name == newAudit.Name && currAudit.Type == newAudit.Type &&
		currAudit.Score == newAudit.Score && currAudit.Status == newAudit.Status &&
		currAudit.Flag == newAudit.Flag && currAudit.Duration == newAudit.Duration
}

```

# pkg/model/audit_participants.go

```go
package model

type AuditParticipant struct {
	BaseModel

	AuditID    UUID
	EmployeeID UUID
}

func AuditParticipantToMap(auditParticipant []*AuditParticipant) map[UUID]AuditParticipant {
	rs := make(map[UUID]AuditParticipant)
	for _, ap := range auditParticipant {
		rs[ap.EmployeeID] = *ap
	}

	return rs
}

```

# pkg/model/audit_item.go

```go
package model

import (
	"strings"

	"github.com/dstotijn/go-notion"
)

type AuditItemSeverity string

// values for audit_item_severity
const (
	AuditItemSeverityHigh   AuditItemSeverity = "high"
	AuditItemSeverityLow    AuditItemSeverity = "low"
	AuditItemSeverityMedium AuditItemSeverity = "medium"
)

// IsValid validation for AuditItemSeverity
func (e AuditItemSeverity) IsValid() bool {
	switch e {
	case
		AuditItemSeverityHigh,
		AuditItemSeverityLow,
		AuditItemSeverityMedium:
		return true
	}
	return false
}

// String returns the string representation
func (e AuditItemSeverity) String() string {
	return string(e)
}

// values for audit_area field
const (
	AuditItemAreaDelivery      string = "Delivery performance"
	AuditItemAreaQuality       string = "Quality assurance"
	AuditItemAreaCollaborating string = "Collaborating"
	AuditItemAreaFeedback      string = "Engineering feedback"
)

type AuditItem struct {
	BaseModel

	AuditID      UUID
	NotionDBID   UUID
	Name         string
	Area         string
	Requirements string
	Grade        int64
	Severity     *AuditItemSeverity
	Notes        string
	ActionItemID *UUID
}

func NewAuditItemFromNotionPage(page notion.Page, auditID string, notionDBID string) *AuditItem {
	properties := page.Properties.(notion.DatabasePageProperties)
	rs := &AuditItem{
		BaseModel:  BaseModel{ID: MustGetUUIDFromString(page.ID)},
		AuditID:    MustGetUUIDFromString(auditID),
		Name:       properties["Name"].Title[0].PlainText,
		NotionDBID: MustGetUUIDFromString(notionDBID),
	}

	if properties["Area"].Select != nil {
		rs.Area = properties["Area"].Select.Name
	}

	if properties["Grade"].Select != nil {
		rs.Grade = MappingAuditItemGrade(properties["Grade"].Select.Name)
	}

	if properties["Severity"].Select != nil {
		severity := AuditItemSeverity(strings.ToLower(properties["Severity"].Select.Name))
		if severity.IsValid() {
			rs.Severity = &severity
		}
	}

	if len(properties["Requirements"].RichText) > 0 {
		rs.Requirements = properties["Requirements"].RichText[0].PlainText
	}

	if len(properties["Notes"].RichText) > 0 {
		rs.Notes = properties["Notes"].RichText[0].PlainText
	}

	return rs
}

func MappingAuditItemGrade(auditGrade string) int64 {
	switch auditGrade {
	case "Very Good":
		return 5
	case "Good":
		return 4
	case "Acceptable":
		return 3
	case "Poor":
		return 2
	case "Very Poor":
		return 1
	default:
		return 0
	}
}

func CompareAuditItem(currAuditItem *AuditItem, newAuditItem *AuditItem) bool {
	return ((currAuditItem.Severity == nil && newAuditItem.Severity == nil) ||
		(currAuditItem.Severity != nil && newAuditItem.Severity != nil && *currAuditItem.Severity == *newAuditItem.Severity)) &&
		currAuditItem.Name == newAuditItem.Name && currAuditItem.Area == newAuditItem.Area &&
		currAuditItem.Requirements == newAuditItem.Requirements && currAuditItem.Grade == newAuditItem.Grade &&
		currAuditItem.Notes == newAuditItem.Notes && currAuditItem.AuditID == newAuditItem.AuditID && currAuditItem.NotionDBID == newAuditItem.NotionDBID
}

func AuditItemToMap(ai []*AuditItem) map[UUID]AuditItem {
	rs := make(map[UUID]AuditItem)
	for _, item := range ai {
		rs[item.ID] = *item
	}
	return rs
}

```

# pkg/model/audit_cycles.go

```go
package model

import (
	"fmt"
	"strings"
	"time"

	"github.com/dstotijn/go-notion"
)

type AuditStatus string

// values for audit_status
const (
	AuditStatusPending AuditStatus = "pending"
	AuditStatusAudited AuditStatus = "audited"
)

// IsValid validation for AuditStatus
func (e AuditStatus) IsValid() bool {
	switch e {
	case
		AuditStatusPending,
		AuditStatusAudited:
		return true
	}
	return false
}

// String returns the string representation
func (e AuditStatus) String() string {
	return string(e)
}

type AuditFlag string

// values for audit_flag
const (
	AuditFlagRed    AuditFlag = "red"
	AuditFlagYellow AuditFlag = "yellow"
	AuditFlagGreen  AuditFlag = "green"
	AuditFlagNone   AuditFlag = "none"
)

// IsValid validation for AuditFlag
func (e AuditFlag) IsValid() bool {
	switch e {
	case
		AuditFlagRed,
		AuditFlagYellow,
		AuditFlagGreen,
		AuditFlagNone:
		return true
	}
	return false
}

// String returns the string representation
func (e AuditFlag) String() string {
	return string(e)
}

type AuditCycle struct {
	BaseModel

	ProjectID         UUID
	NotionDBID        UUID
	HealthAuditID     *UUID
	ProcessAuditID    *UUID
	BackendAuditID    *UUID
	FrontendAuditID   *UUID
	SystemAuditID     *UUID
	MobileAuditID     *UUID
	BlockchainAuditID *UUID
	Cycle             int64
	AverageScore      float64
	Status            AuditStatus
	Flag              AuditFlag
	Quarter           string
	ActionItemHigh    int64
	ActionItemMedium  int64
	ActionItemLow     int64
	SyncAt            *time.Time

	Project *Project
}

func AuditCycleToMap(auditCycles []*AuditCycle) map[UUID]*AuditCycle {
	rs := map[UUID]*AuditCycle{}
	for _, s := range auditCycles {
		rs[s.ID] = s
	}

	return rs
}

func NewAuditCycleFromNotionPage(page *notion.Page, notionDBID string) *AuditCycle {
	properties := page.Properties.(notion.DatabasePageProperties)
	now := time.Now()

	rs := &AuditCycle{
		BaseModel:  BaseModel{ID: MustGetUUIDFromString(page.ID)},
		NotionDBID: MustGetUUIDFromString(notionDBID),
		Status:     AuditStatusPending,
		Flag:       AuditFlag(strings.ToLower(properties["Flag"].Status.Name)),
		SyncAt:     &now,
	}

	if properties["Score"].Number != nil {
		rs.AverageScore = *properties["Score"].Number
	}

	if properties["Cycle"].Number != nil {
		rs.Cycle = int64(*properties["Cycle"].Number)
	}

	if properties["Date"].Date != nil {
		date := properties["Date"].Date.Start.Time
		rs.Quarter = fmt.Sprintf("%d/Q%d", date.Year(), (date.Month()-1)/3+1)
	} else {
		date := time.Now()
		rs.Quarter = fmt.Sprintf("%d/Q%d", date.Year(), (date.Month()-1)/3+1)
	}

	if properties["Project"].Relation != nil && len(properties["Project"].Relation) > 0 {
		rs.ProjectID = MustGetUUIDFromString(properties["Project"].Relation[0].ID)
	}

	return rs
}

func AuditMap(ac AuditCycle) map[UUID]AuditType {
	rs := make(map[UUID]AuditType)

	if !ac.HealthAuditID.IsZero() {
		rs[*ac.HealthAuditID] = AuditTypeHealth
	}

	if !ac.ProcessAuditID.IsZero() {
		rs[*ac.ProcessAuditID] = AuditTypeProcess
	}

	if !ac.BackendAuditID.IsZero() {
		rs[*ac.BackendAuditID] = AuditTypeBackend
	}

	if !ac.FrontendAuditID.IsZero() {
		rs[*ac.FrontendAuditID] = AuditTypeFrontend
	}

	if !ac.SystemAuditID.IsZero() {
		rs[*ac.SystemAuditID] = AuditTypeSystem
	}

	if !ac.MobileAuditID.IsZero() {
		rs[*ac.MobileAuditID] = AuditTypeMobile
	}

	if !ac.BlockchainAuditID.IsZero() {
		rs[*ac.BlockchainAuditID] = AuditTypeBlockchain
	}

	return rs
}

func CheckTypeExists(auditMap map[UUID]AuditType, auditType AuditType) UUID {
	for k, v := range auditMap {
		if v == auditType {
			return k
		}
	}

	return UUID{}
}

func CompareAuditCycle(currAC *AuditCycle, newAC *AuditCycle) bool {
	return currAC.ProjectID == newAC.ProjectID && currAC.NotionDBID == newAC.NotionDBID &&
		currAC.Cycle == newAC.Cycle && currAC.AverageScore == newAC.AverageScore &&
		currAC.Flag == newAC.Flag && currAC.Quarter == newAC.Quarter
}

```

# pkg/model/audit_action_item.go

```go
package model

type AuditActionItem struct {
	BaseModel

	AuditID      UUID
	ActionItemID UUID
}

type AuditAction struct {
	AuditID      UUID
	ActionItemID UUID
}

func AuditActionItemToMap(aais []*AuditActionItem) map[AuditAction]AuditActionItem {
	rs := make(map[AuditAction]AuditActionItem)
	for _, aai := range aais {
		rs[AuditAction{AuditID: aai.AuditID, ActionItemID: aai.ActionItemID}] = *aai
	}

	return rs
}

```

# pkg/model/asset.go

```go
package model

import "time"

type Asset struct {
	BaseModel

	Name         string
	Price        int64
	Quantity     string
	Note         string
	Location     string
	PurchaseDate *time.Time
}

```

# pkg/model/api_key_roles.go

```go
package model

type APIKeyRole struct {
	BaseModel

	APIKeyID UUID `gorm:"column:api_key_id;default:null"`
	RoleID   UUID

	ApiKey APIKey
	Role   Role
}

```

# pkg/model/api_key.go

```go
package model

type APIKey struct {
	BaseModel

	ClientID  string
	SecretKey string
	Status    APIKeyStatus

	ApikeyRoles []APIKeyRole
	Roles       []Role `gorm:"many2many:api_key_roles;"`
}

type APIKeyStatus string

// values for working_status
const (
	ApikeyStatusValid   APIKeyStatus = "valid"
	ApikeyStatusInvalid APIKeyStatus = "invalid"
)

// IsValid validation for APIKeyStatus
func (e APIKeyStatus) IsValid() bool {
	switch e {
	case
		ApikeyStatusValid,
		ApikeyStatusInvalid:
		return true
	}
	return false
}

type TokenType string

const (
	TokenTypeJWT    TokenType = "JWT"
	TokenTypeAPIKey TokenType = "ApiKey"
)

func (t TokenType) String() string {
	return string(t)
}

```

# pkg/model/answer_drafts.go

```go
package model

// AnswerDraft model for answer_drafts table
type AnswerDraft struct {
	BaseModel

	QuestionID UUID
	AnswerBy   UUID
	Answer     string
	Note       string
}

```

# pkg/model/answer.go

```go
package model

// Answer model for answers table
type Answer struct {
	BaseModel

	QuestionID UUID
	AnswerBy   UUID
	Answer     string
	Note       string
}

```

# pkg/model/action_items.go

```go
package model

import (
	"strings"

	"github.com/dstotijn/go-notion"
)

type ActionItemStatus string

// values for action_item_status
const (
	ActionItemStatusPending   ActionItemStatus = "pending"
	ActionItemStatusInProgess ActionItemStatus = "in-progress"
	ActionItemStatusDone      ActionItemStatus = "done"
)

// IsValid validation for ActionItemStatus
func (e ActionItemStatus) IsValid() bool {
	switch e {
	case
		ActionItemStatusPending,
		ActionItemStatusInProgess,
		ActionItemStatusDone:
		return true
	}
	return false
}

// String returns the string representation
func (e ActionItemStatus) String() string {
	return string(e)
}

type ActionItemPriority string

// values for action_item_priority
const (
	ActionItemPriorityHigh   ActionItemPriority = "high"
	ActionItemPriorityLow    ActionItemPriority = "low"
	ActionItemPriorityMedium ActionItemPriority = "medium"
)

// IsValid validation for ActionItemPriority
func (e ActionItemPriority) IsValid() bool {
	switch e {
	case
		ActionItemPriorityHigh,
		ActionItemPriorityLow,
		ActionItemPriorityMedium:
		return true
	}
	return false
}

// String returns the string representation
func (e ActionItemPriority) String() string {
	return string(e)
}

type ActionItem struct {
	BaseModel

	ProjectID    UUID
	NotionDBID   UUID
	PICID        UUID
	AuditCycleID *UUID
	Name         string
	Description  string
	NeedHelp     bool
	Priority     *ActionItemPriority
	Status       ActionItemStatus
}

func ActionItemToMap(actionItems []*ActionItem) map[UUID]*ActionItem {
	rs := map[UUID]*ActionItem{}
	for _, s := range actionItems {
		rs[s.ID] = s
	}

	return rs
}

func NewActionItemFromNotionPage(page notion.Page, picID UUID, notionDB string) *ActionItem {
	properties := page.Properties.(notion.DatabasePageProperties)

	rs := &ActionItem{
		BaseModel:  BaseModel{ID: MustGetUUIDFromString(page.ID)},
		NotionDBID: MustGetUUIDFromString(notionDB),
		Status:     ActionItemStatus(strings.ReplaceAll(strings.ToLower(properties["Status"].Status.Name), " ", "-")),
		// TODO:Description:
	}

	if properties["Project"].Relation != nil && len(properties["Project"].Relation) > 0 {
		rs.ProjectID = MustGetUUIDFromString(properties["Project"].Relation[0].ID)
	}

	if !picID.IsZero() {
		rs.PICID = picID
	}

	if properties["NEED HELP???"].Checkbox != nil {
		rs.NeedHelp = *properties["NEED HELP???"].Checkbox
	}

	if properties["Name"].Title != nil && len(properties["Name"].Title) > 0 {
		rs.Name = properties["Name"].Title[0].PlainText
	}

	if properties["Priority"].Select != nil {
		priority := MappingAuditActionPriority(properties["Priority"].Select.Name)
		if priority.IsValid() {
			rs.Priority = &priority
		}
	}

	if len(properties["👏 Audit Changelog"].Relation) > 0 {
		auditCycleID := MustGetUUIDFromString(properties["👏 Audit Changelog"].Relation[0].ID)
		rs.AuditCycleID = &auditCycleID
	}

	return rs
}

func MappingAuditActionPriority(auditGrade string) ActionItemPriority {
	switch auditGrade {
	case "High":
		return ActionItemPriorityHigh
	case "Medium":
		return ActionItemPriorityMedium
	case "Low":
		return ActionItemPriorityLow
	default:
		return ""
	}
}

func CompareActionItem(old, new *ActionItem) bool {
	return ((old.Priority == nil && new.Priority == nil) ||
		(old.Priority != nil && new.Priority != nil && *old.Priority == *new.Priority)) &&
		((old.AuditCycleID == nil && new.AuditCycleID == nil) ||
			(old.AuditCycleID != nil && new.AuditCycleID != nil && *old.AuditCycleID == *new.AuditCycleID)) &&
		old.ProjectID == new.ProjectID && old.NotionDBID == new.NotionDBID &&
		old.PICID == new.PICID && old.Name == new.Name && old.Description == new.Description &&
		old.NeedHelp == new.NeedHelp && old.Status == new.Status
}

```

# pkg/model/action_item_snapshot.go

```go
package model

type ActionItemSnapshot struct {
	BaseModel

	ProjectID    UUID
	AuditCycleID UUID
	High         int64
	Medium       int64
	Low          int64
}

func CompareActionItemSnapshot(old, new *ActionItemSnapshot) bool {
	return old.High == new.High &&
		old.Medium == new.Medium &&
		old.Low == new.Low
}

```

# pkg/model/accounting.go

```go
package model

import (
	"time"

	"gorm.io/datatypes"
)

const (
	AccountingSE     = "SE"
	AccountingOP     = "OP"
	AccountingOV     = "OV"
	AccountingCA     = "CA"
	AccountingIncome = "In"

	AccountingOfficeSupply   = "Office Supply"
	AccountingOfficeServices = "Office Services"
	AccountingOfficeSpace    = "Office Space"
	AccountingIn             = "In"
	AccountingTools          = "Tools"
	AccountingAssets         = "Assets"

	AccountingOps         = "Payroll for Operation"
	AccountingRec         = "Payroll for Recruit"
	AccountingEng         = "Payroll for Engineer"
	AccountingMar         = "Payroll for Marketing"
	AccountingVen         = "Payroll for Venture"
	AccountingMng         = "Payroll for Middle Mngr"
	AccountingSal         = "Payroll for Sales"
	AccountingDsg         = "Payroll for Design"
	AccountingCommLead    = "Commission for Lead"
	AccountingCommSales   = "Commission for Sales"
	AccountingCommAccount = "Commission for Account"
	AccountingCommHiring  = "Commission for Hiring"
)

// AccountingTransaction --
type AccountingTransaction struct {
	BaseModel

	Name             string         `json:"name"`
	Date             *time.Time     `json:"date"`
	Amount           float64        `json:"amount"`
	ConversionAmount VietnamDong    `json:"conversion_amount"`
	Organization     string         `json:"organization"`
	Category         string         `json:"category_name"`
	Type             string         `json:"type"`
	Currency         string         `json:"currency_name"`
	CurrencyID       *UUID          `json:"-"`
	ConversionRate   float64        `json:"conversion_rate"`
	Metadata         datatypes.JSON `json:"metadata"`

	CurrencyInfo       *Currency           `json:"currency" gorm:"foreignkey:ID;association_foreignkey:CurrencyID"`
	AccountingCategory *AccountingCategory `json:"category" gorm:"foreignkey:Type;association_foreignkey:Type"`
}

type AccountingCategory struct {
	BaseModel
	Name string `json:"name"`
	Type string `json:"type"`
}

type SheetExpense struct {
	Name     string `json:"name"`
	Amount   string `json:"amount"`
	Category string `json:"category"`
	Currency string `json:"currency"`
	Date     string `json:"date"`
}

type AccountingMetadata struct {
	Source string `json:"source"`
	ID     string `json:"id"`
}

```

# pkg/handler/handler.go

```go
package handler

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/handler/accounting"
	"github.com/dwarvesf/fortress-api/pkg/handler/asset"
	"github.com/dwarvesf/fortress-api/pkg/handler/audit"
	"github.com/dwarvesf/fortress-api/pkg/handler/auth"
	"github.com/dwarvesf/fortress-api/pkg/handler/bankaccount"
	"github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs"
	"github.com/dwarvesf/fortress-api/pkg/handler/client"
	"github.com/dwarvesf/fortress-api/pkg/handler/communitynft"
	"github.com/dwarvesf/fortress-api/pkg/handler/companyinfo"
	"github.com/dwarvesf/fortress-api/pkg/handler/conversionrate"
	"github.com/dwarvesf/fortress-api/pkg/handler/dashboard"
	"github.com/dwarvesf/fortress-api/pkg/handler/dashboard/util"
	"github.com/dwarvesf/fortress-api/pkg/handler/deliverymetric"
	"github.com/dwarvesf/fortress-api/pkg/handler/discord"
	"github.com/dwarvesf/fortress-api/pkg/handler/earn"
	"github.com/dwarvesf/fortress-api/pkg/handler/employee"
	"github.com/dwarvesf/fortress-api/pkg/handler/engagement"
	"github.com/dwarvesf/fortress-api/pkg/handler/feedback"
	"github.com/dwarvesf/fortress-api/pkg/handler/healthz"
	"github.com/dwarvesf/fortress-api/pkg/handler/icy"
	"github.com/dwarvesf/fortress-api/pkg/handler/invoice"
	"github.com/dwarvesf/fortress-api/pkg/handler/memologs"
	"github.com/dwarvesf/fortress-api/pkg/handler/metadata"
	"github.com/dwarvesf/fortress-api/pkg/handler/news"
	"github.com/dwarvesf/fortress-api/pkg/handler/notion"
	"github.com/dwarvesf/fortress-api/pkg/handler/payroll"
	"github.com/dwarvesf/fortress-api/pkg/handler/profile"
	"github.com/dwarvesf/fortress-api/pkg/handler/project"
	"github.com/dwarvesf/fortress-api/pkg/handler/survey"
	"github.com/dwarvesf/fortress-api/pkg/handler/valuation"
	"github.com/dwarvesf/fortress-api/pkg/handler/vault"
	"github.com/dwarvesf/fortress-api/pkg/handler/webhook"
	yt "github.com/dwarvesf/fortress-api/pkg/handler/youtube"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/worker"
)

type Handler struct {
	Accounting     accounting.IHandler
	Asset          asset.IHandler
	Audit          audit.IHandler
	Auth           auth.IHandler
	BankAccount    bankaccount.IHandler
	BraineryLog    brainerylogs.IHandler
	Client         client.IHandler
	CompanyInfo    companyinfo.IHandler
	ConversionRate conversionrate.IHandler
	Dashboard      dashboard.IHandler
	DeliveryMetric deliverymetric.IHandler
	Discord        discord.IHandler
	Employee       employee.IHandler
	Engagement     engagement.IHandler
	Feedback       feedback.IHandler
	Healthcheck    healthz.IHandler
	Invoice        invoice.IHandler
	MemoLog        memologs.IHandler
	Metadata       metadata.IHandler
	Notion         notion.IHandler
	Payroll        payroll.IHandler
	Profile        profile.IHandler
	Project        project.IHandler
	Survey         survey.IHandler
	Valuation      valuation.IHandler
	Webhook        webhook.IHandler
	Vault          vault.IHandler
	Icy            icy.IHandler
	CommunityNft   communitynft.IHandler
	Earn           earn.IHandler
	News           news.IHandler
	Youtube        yt.IHandler
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, ctrl *controller.Controller, worker *worker.Worker, logger logger.Logger, cfg *config.Config) *Handler {
	return &Handler{
		Accounting:     accounting.New(store, repo, service, logger, cfg),
		Asset:          asset.New(store, repo, service, logger, cfg),
		Audit:          audit.New(store, repo, service, logger, cfg),
		Auth:           auth.New(ctrl, logger, cfg),
		BankAccount:    bankaccount.New(store, repo, service, logger, cfg),
		BraineryLog:    brainerylogs.New(ctrl, store, repo, service, logger, cfg),
		Client:         client.New(ctrl, store, repo, service, logger, cfg),
		CompanyInfo:    companyinfo.New(ctrl, store, repo, service, logger, cfg),
		ConversionRate: conversionrate.New(ctrl, store, repo, service, logger, cfg),
		Dashboard:      dashboard.New(store, repo, service, logger, cfg, util.New()),
		DeliveryMetric: deliverymetric.New(ctrl, store, repo, service, logger, cfg),
		Discord:        discord.New(ctrl, store, repo, service, logger, cfg),
		Employee:       employee.New(ctrl, store, repo, service, logger, cfg),
		Engagement:     engagement.New(ctrl, store, repo, service, logger, cfg),
		Feedback:       feedback.New(store, repo, service, logger, cfg),
		Healthcheck:    healthz.New(),
		Invoice:        invoice.New(ctrl, store, repo, service, worker, logger, cfg),
		MemoLog:        memologs.New(ctrl, store, repo, service, logger, cfg),
		Metadata:       metadata.New(store, repo, service, logger, cfg),
		Notion:         notion.New(store, repo, service, logger, cfg),
		Payroll:        payroll.New(ctrl, store, repo, service, worker, logger, cfg),
		Profile:        profile.New(ctrl, store, repo, service, logger, cfg),
		Project:        project.New(ctrl, store, repo, service, logger, cfg),
		Survey:         survey.New(store, repo, service, logger, cfg),
		Valuation:      valuation.New(store, repo, service, logger, cfg),
		Webhook:        webhook.New(ctrl, store, repo, service, logger, cfg, worker),
		Vault:          vault.New(store, repo, service, logger, cfg),
		Icy:            icy.New(ctrl, logger),
		CommunityNft:   communitynft.New(ctrl, store, repo, service, logger, cfg),
		Earn:           earn.New(ctrl, store, repo, service, logger, cfg),
		News:           news.New(store, repo, ctrl, logger, cfg),
		Youtube:        yt.New(ctrl, store, repo, service, logger, cfg),
	}
}

```

# pkg/constant/constant.go

```go
package constant

const (
	RegexPatternDiscordChannelID = `<#(\d+)>`
	RegexPatternDiscordID        = `<@(\d+)>`
	RegexPatternEmail            = `\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]+\b`
	RegexPatternIcyReward        = ` (\d+)`
	RegexPatternNumber           = `\d{18,}`
	RegexPatternUrl              = `((?:https?://)[^\s]+)`
	RegexPatternGithub           = `gh:(\w+)`
	RegexPatternDescription      = `d:"(.*?)"`
	RegexPatternTime             = `t:(\w+)`
)

```

# pkg/config/file_reader.go

```go
package config

import (
	"fmt"

	"github.com/joho/godotenv"
	"github.com/spf13/viper"
)

// FileReader read config from file
type FileReader struct {
	filename string
	dirname  string
}

// NewFileLoader create new file loader with filename and dirname
func NewFileLoader(filename, dirname string) Loader {
	return &FileReader{filename, dirname}
}

// Load from yml file
func (r *FileReader) Load(v viper.Viper) (*viper.Viper, error) {
	filePath := fmt.Sprintf("%s/%s", r.dirname, r.filename)
	err := godotenv.Load(filePath)
	if err != nil {
		return nil, err
	}
	v.AutomaticEnv()
	return &v, nil
}

```

# pkg/config/env_reader.go

```go
package config

import (
	"github.com/spf13/viper"
)

// ENVReader load config from env
type ENVReader struct {
}

// NewENVLoader create new env loader
func NewENVLoader() Loader {
	return &ENVReader{}
}

// Load env into viper
func (r *ENVReader) Load(v viper.Viper) (*viper.Viper, error) {
	v.AutomaticEnv()
	return &v, nil
}

```

# pkg/config/config.go

```go
package config

import (
	"strings"

	"github.com/spf13/viper"
)

// Loader load config from reader into Viper
type Loader interface {
	Load(viper.Viper) (*viper.Viper, error)
}

type Config struct {
	// db
	Postgres DBConnection

	// server
	ApiServer ApiServer

	// service
	Google        Google
	Vault         Vault
	Notion        Notion
	Wise          Wise
	Discord       Discord
	Basecamp      Basecamp
	CurrencyLayer CurrencyLayer
	Mochi         Mochi
	MochiPay      MochiPay
	MochiProfile  MochiProfile
	Tono          Tono
	ImprovMX      ImprovMX
	CommunityNft  CommunityNft
	Reddit        Reddit
	Youtube       Youtube
	Dify          Dify

	Invoice  Invoice
	Sendgrid Sendgrid
	Github   Github

	APIKey       string
	Debug        bool
	Env          string
	JWTSecretKey string
	FortressURL  string
}

type DBConnection struct {
	Host string
	Port string
	User string
	Name string
	Pass string

	SSLMode string
}

type ApiServer struct {
	Port           string
	AllowedOrigins string
}

type Google struct {
	ClientSecret                 string
	ClientID                     string
	AppName                      string
	GCSProjectID                 string
	GCSBucketName                string
	GCSCredentials               string
	GCPProjectID                 string
	AccountingGoogleRefreshToken string
	AdminGoogleRefreshToken      string
	AccountingEmailID            string
	TeamGoogleRefreshToken       string
	TeamEmailID                  string
}

type Youtube struct {
	ClientSecret string
	ClientID     string
	RefreshToken string
}

type Dify struct {
	URL   string
	Token string
}

type Wise struct {
	APIKey  string
	Profile string
	Url     string
}

type CurrencyLayer struct {
	APIKey string
}

type Vault struct {
	Address string
	Token   string
	Path    string
}

type ImprovMX struct {
	Token string
}

type Mochi struct {
	BaseURL         string
	ApplicationID   string
	ApplicationName string
	APIKey          string
}

type MochiPay struct {
	BaseURL string
}

type MochiProfile struct {
	BaseURL string
}

type Tono struct {
	BaseURL string
}

type CommunityNft struct {
	ContractAddress string
}

type Notion struct {
	Secret    string
	Databases NotionDatabase
}

type Github struct {
	Token             string
	BraineryReviewers []string
}

type NotionDatabase struct {
	AuditCycle      string
	AuditActionItem string
	Earn            string
	TechRadar       string
	Audience        string
	Event           string
	Hiring          string
	StaffingDemand  string
	Project         string
	Delivery        string
	Digest          string
	Updates         string
	Memo            string
	Issue           string
}

type Discord struct {
	SecretToken string
	Webhooks    DiscordWebhook
	IDs         DiscordID
}

type DiscordWebhook struct {
	Campfire     string
	AuditLog     string
	ICYPublicLog string
}

type DiscordID struct {
	DwarvesGuild    string
	EventsChannel   string
	GolangChannel   string
	ResearchChannel string
}

type Invoice struct {
	TemplatePath string
	DirID        string
	TestEmail    string
}

type Sendgrid struct {
	APIKey string
}

type Basecamp struct {
	BotKey            string
	ClientID          string
	ClientSecret      string
	OAuthRefreshToken string
}

type ENV interface {
	GetBool(string) bool
	GetString(string) string
}

type Reddit struct {
	ClientID     string
	ClientSecret string
	Username     string
	Password     string
}

func Generate(v ENV) *Config {
	return &Config{
		Debug:        v.GetBool("DEBUG"),
		APIKey:       v.GetString("API_KEY"),
		Env:          v.GetString("ENV"),
		JWTSecretKey: v.GetString("JWT_SECRET_KEY"),
		FortressURL:  v.GetString("FORTRESS_URL"),

		ApiServer: ApiServer{
			Port:           v.GetString("PORT"),
			AllowedOrigins: v.GetString("ALLOWED_ORIGINS"),
		},

		Postgres: DBConnection{
			Host:    v.GetString("DB_HOST"),
			Port:    v.GetString("DB_PORT"),
			User:    v.GetString("DB_USER"),
			Name:    v.GetString("DB_NAME"),
			Pass:    v.GetString("DB_PASS"),
			SSLMode: v.GetString("DB_SSL_MODE"),
		},
		Github: Github{
			Token:             v.GetString("GITHUB_ACCESS_TOKEN"),
			BraineryReviewers: strings.Split(v.GetString("BRAINERY_REVIEWERS"), ","),
		},
		Google: Google{
			AccountingEmailID:            v.GetString("ACCOUNTING_EMAIL_ID"),
			AccountingGoogleRefreshToken: v.GetString("ACCOUNTING_GOOGLE_REFRESH_TOKEN"),
			AdminGoogleRefreshToken:      v.GetString("ADMIN_GOOGLE_REFRESH_TOKEN"),
			AppName:                      v.GetString("GOOGLE_API_APP_NAME"),
			ClientID:                     v.GetString("GOOGLE_API_CLIENT_ID"),
			ClientSecret:                 v.GetString("GOOGLE_API_CLIENT_SECRET"),
			GCPProjectID:                 v.GetString("GCP_PROJECT_ID"),
			GCSBucketName:                v.GetString("GCS_BUCKET_NAME"),
			GCSCredentials:               v.GetString("GCS_CREDENTIALS"),
			GCSProjectID:                 v.GetString("GCS_PROJECT_ID"),
			TeamEmailID:                  v.GetString("TEAM_EMAIL_ID"),
			TeamGoogleRefreshToken:       v.GetString("TEAM_GOOGLE_REFRESH_TOKEN"),
		},
		Youtube: Youtube{
			ClientID:     v.GetString("YOUTUBE_API_CLIENT_ID"),
			ClientSecret: v.GetString("YOUTUBE_API_CLIENT_SECRET"),
			RefreshToken: v.GetString("YOUTUBE_REFRESH_TOKEN"),
		},

		Wise: Wise{
			APIKey:  v.GetString("WISE_API_KEY"),
			Profile: v.GetString("WISE_PROFILE"),
			Url:     v.GetString("WISE_URL"),
		},
		CurrencyLayer: CurrencyLayer{
			APIKey: v.GetString("CURRENCY_LAYER_API_KEY"),
		},
		Vault: Vault{
			Address: v.GetString("VAULT_ADDR"),
			Token:   v.GetString("VAULT_TOKEN"),
			Path:    v.GetString("VAULT_PATH"),
		},
		Notion: Notion{
			Secret: v.GetString("NOTION_SECRET"),
			Databases: NotionDatabase{
				AuditCycle:      v.GetString("NOTION_AUDIT_CYCLE_DB_ID"),
				AuditActionItem: v.GetString("NOTION_AUDIT_ACTION_ITEM_DB_ID"),
				Earn:            v.GetString("NOTION_EARN_DB_ID"),
				TechRadar:       v.GetString("NOTION_TECH_RADAR_DB_ID"),
				Audience:        v.GetString("NOTION_AUDIENCE_DB_ID"),
				Event:           v.GetString("NOTION_EVENT_DB_ID"),
				Hiring:          v.GetString("NOTION_HIRING_DB_ID"),
				StaffingDemand:  v.GetString("NOTION_STAFFING_DEMAND_DB_ID"),
				Project:         v.GetString("NOTION_PROJECT_DB_ID"),
				Delivery:        v.GetString("NOTION_DELIVERY_DB_ID"),
				Digest:          v.GetString("NOTION_DIGEST_DB_ID"),
				Updates:         v.GetString("NOTION_UPDATES_DB_ID"),
				Memo:            v.GetString("NOTION_MEMO_DB_ID"),
				Issue:           v.GetString("NOTION_ISSUE_DB_ID"),
			},
		},
		Discord: Discord{
			Webhooks: DiscordWebhook{
				Campfire:     v.GetString("DISCORD_WEBHOOK_CAMPFIRE"),
				AuditLog:     v.GetString("DISCORD_WEBHOOK_AUDIT"),
				ICYPublicLog: v.GetString("DISCORD_WEBHOOK_ICY_PUBLIC_LOG"),
			},
			SecretToken: v.GetString("DISCORD_SECRET_TOKEN"),
			IDs: DiscordID{
				DwarvesGuild:    v.GetString("DISCORD_DWARVES_GUILD_ID"),
				GolangChannel:   v.GetString("DISCORD_GOLANG_CHANNEL_ID"),
				ResearchChannel: v.GetString("DISCORD_RESEARCH_CHANNEL_ID"),
			},
		},
		Basecamp: Basecamp{
			BotKey:            v.GetString("BASECAMP_BOT_KEY"),
			ClientID:          v.GetString("BASECAMP_CLIENT_ID"),
			ClientSecret:      v.GetString("BASECAMP_CLIENT_SECRET"),
			OAuthRefreshToken: v.GetString("BASECAMP_OAUTH_REFRESH_TOKEN"),
		},
		Invoice: Invoice{
			TemplatePath: v.GetString("INVOICE_TEMPLATE_PATH"),
			DirID:        v.GetString("INVOICE_DIR_ID"),
			TestEmail:    v.GetString("INVOICE_TEST_EMAIL"),
		},

		Sendgrid: Sendgrid{
			APIKey: v.GetString("SENDGRID_API_KEY"),
		},
		Mochi: Mochi{
			BaseURL:         v.GetString("MOCHI_BASE_URL"),
			ApplicationID:   v.GetString("MOCHI_APPLICATION_ID"),
			ApplicationName: v.GetString("MOCHI_APPLICATION_NAME"),
			APIKey:          v.GetString("MOCHI_API_KEY"),
		},
		MochiPay: MochiPay{
			BaseURL: v.GetString("MOCHI_PAY_BASE_URL"),
		},
		MochiProfile: MochiProfile{
			BaseURL: v.GetString("MOCHI_PROFILE_BASE_URL"),
		},
		Tono: Tono{
			BaseURL: v.GetString("TONO_BASE_URL"),
		},
		ImprovMX: ImprovMX{
			Token: v.GetString("IMPROVMX_API_TOKEN"),
		},
		CommunityNft: CommunityNft{
			ContractAddress: v.GetString("COMMUNITY_NFT_CONTRACT_ADDRESS"),
		},
		Reddit: Reddit{
			ClientID:     v.GetString("REDDIT_CLIENT_ID"),
			ClientSecret: v.GetString("REDDIT_CLIENT_SECRET"),
			Username:     v.GetString("REDDIT_USERNAME"),
			Password:     v.GetString("REDDIT_PASSWORD"),
		},
		Dify: Dify{
			URL:   v.GetString("DIFY_URL"),
			Token: v.GetString("DIFY_TOKEN"),
		},
	}
}

func DefaultConfigLoaders() []Loader {
	var loaders []Loader
	fileLoader := NewFileLoader(".env", ".")
	loaders = append(loaders, fileLoader)
	loaders = append(loaders, NewENVLoader())

	return loaders
}

// LoadConfig load config from loader list
func LoadConfig(loaders []Loader) *Config {
	v := viper.New()
	v.SetDefault("PORT", "8080")
	v.SetDefault("ENV", "local")
	v.SetDefault("ALLOWED_ORIGINS", "*")

	for idx := range loaders {
		newV, err := loaders[idx].Load(*v)

		if err == nil {
			v = newV
		}
	}
	return Generate(v)
}

func LoadTestConfig() Config {
	return Config{
		Debug: true,
		ApiServer: ApiServer{
			Port: "8080",
		},
		JWTSecretKey: "JWTSecretKey",
		Postgres: DBConnection{
			Host:    "127.0.0.1",
			Port:    "35432",
			User:    "postgres",
			Pass:    "postgres",
			Name:    "fortress_local_test",
			SSLMode: "disable",
		},
	}
}

```

# pkg/controller/controller.go

```go
package controller

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller/auth"
	"github.com/dwarvesf/fortress-api/pkg/controller/brainerylogs"
	"github.com/dwarvesf/fortress-api/pkg/controller/client"
	"github.com/dwarvesf/fortress-api/pkg/controller/communitynft"
	"github.com/dwarvesf/fortress-api/pkg/controller/companyinfo"
	"github.com/dwarvesf/fortress-api/pkg/controller/conversionrate"
	"github.com/dwarvesf/fortress-api/pkg/controller/deliverymetrics"
	"github.com/dwarvesf/fortress-api/pkg/controller/discord"
	"github.com/dwarvesf/fortress-api/pkg/controller/earn"
	"github.com/dwarvesf/fortress-api/pkg/controller/employee"
	"github.com/dwarvesf/fortress-api/pkg/controller/event"
	"github.com/dwarvesf/fortress-api/pkg/controller/icy"
	"github.com/dwarvesf/fortress-api/pkg/controller/invoice"
	"github.com/dwarvesf/fortress-api/pkg/controller/memologs"
	"github.com/dwarvesf/fortress-api/pkg/controller/news"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/worker"
)

type Controller struct {
	Auth           auth.IController
	BraineryLog    brainerylogs.IController
	Client         client.IController
	CompanyInfo    companyinfo.IController
	ConversionRate conversionrate.IController
	DeliveryMetric deliverymetrics.IController
	Employee       employee.IController
	Invoice        invoice.IController
	Discord        discord.IController
	Icy            icy.IController
	MemoLog        memologs.IController
	CommunityNft   communitynft.IController
	Earn           earn.IController
	News           news.IController
	Event          event.IController
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, worker *worker.Worker, logger logger.Logger, cfg *config.Config) *Controller {
	return &Controller{
		Auth:           auth.New(store, repo, service, logger, cfg),
		BraineryLog:    brainerylogs.New(store, repo, service, logger, cfg),
		Client:         client.New(store, repo, service, logger, cfg),
		CompanyInfo:    companyinfo.New(store, repo, service, logger, cfg),
		ConversionRate: conversionrate.New(store, repo, service, logger, cfg),
		DeliveryMetric: deliverymetrics.New(store, repo, service, logger, cfg),
		Employee:       employee.New(store, repo, service, logger, cfg),
		Invoice:        invoice.New(store, repo, service, worker, logger, cfg),
		Discord:        discord.New(store, repo, service, logger, cfg),
		Icy:            icy.New(service, logger, cfg),
		MemoLog:        memologs.New(store, repo, service, logger, cfg),
		CommunityNft:   communitynft.New(store, repo, service, logger, cfg),
		Earn:           earn.New(store, repo, service, logger, cfg),
		News:           news.New(store, service, logger, cfg),
		Event:          event.New(store, repo, service, logger, cfg),
	}
}

```

# cmd/server/main.go

```go
package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"

	_ "github.com/lib/pq"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/request"
	"github.com/dwarvesf/fortress-api/pkg/routes"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/service/vault"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/worker"
)

// @title           FORTRESS API DOCUMENT
// @version         v0.1.39
// @description     This is api document for fortress project.
// @termsOfService  http://swagger.io/terms/

// @contact.name   Nam Nguyen
// @contact.url    https://d.foundation
// @contact.email  benjamin@d.foundation

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @BasePath  /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
func main() {
	cfg := config.LoadConfig(config.DefaultConfigLoaders())
	log := logger.NewLogrusLogger()
	log.Infof("Server starting")

	v, err := vault.New(cfg)
	if err != nil {
		log.Error(err, "failed to init vault")
	}

	if v != nil {
		cfg = config.Generate(v)
	}

	s := store.New()
	repo := store.NewPostgresStore(cfg)

	ctx, cancel := context.WithCancel(context.Background())
	svc := service.New(cfg, s, repo)

	queue := make(chan model.WorkerMessage, 1000)
	w := worker.New(ctx, queue, svc, log)

	go func() {
		err := w.ProcessMessage()
		if err != nil {
			log.Error(err, "failed to process message")
		}
	}()

	router := routes.NewRoutes(cfg, svc, s, repo, w, log)
	request.RegisCustomValidators(router)

	srv := &http.Server{
		Addr:    fmt.Sprintf(":%s", cfg.ApiServer.Port),
		Handler: router,
	}

	// serve http server
	go func() {
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatal(err, "failed to listen and serve")
		}
	}()

	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt)

	<-quit

	cancel()

	shutdownServer(srv, log)
}

func shutdownServer(srv *http.Server, l logger.Logger) {
	l.Info("Server Shutting Down")
	if err := srv.Shutdown(context.Background()); err != nil {
		l.Error(err, "failed to shutdown server")
	}

	l.Info("Server Exit")
}

```

# .github/workflows/golangci-lint.yaml

```yaml
name: golangci-lint

on:
  pull_request:
permissions:
  contents: read
  # Optional: allow read access to pull request. Use with `only-new-issues` option.
  # pull-requests: read

jobs:
  golangci:
    name: lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-go@v3
        with:
          go-version: '1.21'
      - uses: actions/checkout@v3
      - name: build
        run: go mod download
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          # Optional: version of golangci-lint to use in form of v1.2 or v1.2.3 or `latest` to use the latest version
          version: v1.55.2

          # Optional: working directory, useful for monorepos
          # working-directory: somedir

          # Optional: golangci-lint command line arguments.
          # args: --issues-exit-code=0

          # Optional: show only new issues if it's a pull request. The default value is `false`.
          # only-new-issues: true

          # Optional: if set to true then the all caching functionality will be complete disabled,
          #           takes precedence over all other caching options.
          # skip-cache: true

          # Optional: if set to true then the action don't cache or restore ~/go/pkg.
          skip-pkg-cache: true

          # Optional: if set to true then the action don't cache or restore ~/.cache/go-build.
          # skip-build-cache: true

```

# .github/workflows/gke-prod.yml

```yml
name: Build and Deploy to GKE Prod

on:
  push:
    tags:
      - "v*"

# Environment variables available to all jobs and steps in this workflow
env:
  REGISTRY_HOSTNAME: gcr.io
  GKE_PROJECT: df-infrastructure
  IMAGE: fortress/api
  K8S_ENVIRONMENT: prod

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - id: "auth"
        name: "Authenticate to Google Cloud"
        uses: "google-github-actions/auth@v0"
        with:
          credentials_json: "${{ secrets.GCP_CREDENTIALS }}"

      - name: "Set up Cloud SDK"
        uses: "google-github-actions/setup-gcloud@v0"

      - name: Setup Docker
        run: |
          gcloud auth configure-docker gcr.io

      # Build & Push the Docker image
      - name: Build & Push
        run: |
          docker build -t $REGISTRY_HOSTNAME/$GKE_PROJECT/$IMAGE:${GITHUB_REF_NAME} .   
          docker push $REGISTRY_HOSTNAME/$GKE_PROJECT/$IMAGE:${GITHUB_REF_NAME}
      # Setup kustomize
      - name: Setup kustomize
        run: |
          curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
          chmod u+x ./kustomize
          mv kustomize /tmp
      - name: Checkout dwarvesf/infrastructure
        uses: actions/checkout@master
        with:
          repository: dwarvesf/infrastructure
          token: ${{ secrets.GH_PAT }}
          path: ./infrastructure
          ref: main
      - name: Update api version
        run: |
          cd ./infrastructure/fortress/fortress-api/$K8S_ENVIRONMENT
          git config user.name lmquang
          git config user.email quanglm.ops@gmail.com
          /tmp/kustomize edit set image $REGISTRY_HOSTNAME/$GKE_PROJECT/$IMAGE=$REGISTRY_HOSTNAME/$GKE_PROJECT/$IMAGE:${GITHUB_REF_NAME}
          git commit -am "[skip ci] fortress-api ${K8S_ENVIRONMENT} image update"
          git push origin main

```

# .github/workflows/gke-dev.yml

```yml
name: Build and Deploy to GKE Dev

on:
  push:
    branches:
      - cicd
      - develop

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}
  REGISTRY_HOSTNAME: gcr.io
  GKE_PROJECT: df-infrastructure
  IMAGE: fortress/api
  K8S_ENVIRONMENT: dev

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - id: "auth"
        name: "Authenticate to Google Cloud"
        uses: "google-github-actions/auth@v0"
        with:
          credentials_json: "${{ secrets.GCP_CREDENTIALS }}"

      - name: "Set up Cloud SDK"
        uses: "google-github-actions/setup-gcloud@v0"

      - name: Setup Docker
        run: |
          gcloud auth configure-docker gcr.io

      # Build & Push the Docker image
      - name: Build & Push
        run: |
          docker build -t $REGISTRY_HOSTNAME/$GKE_PROJECT/$IMAGE:${GITHUB_SHA} .   
          docker push $REGISTRY_HOSTNAME/$GKE_PROJECT/$IMAGE:${GITHUB_SHA}
      # Setup kustomize
      - name: Setup kustomize
        run: |
          curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
          chmod u+x ./kustomize
          mv kustomize /tmp
      - name: Checkout dwarvesf/infrastructure
        uses: actions/checkout@master
        with:
          repository: dwarvesf/infrastructure
          token: ${{ secrets.GH_PAT }}
          path: ./infrastructure
          ref: main
      - name: Update api version
        run: |
          cd ./infrastructure/fortress/fortress-api/$K8S_ENVIRONMENT
          git config user.name lmquang
          git config user.email quanglm.ops@gmail.com
          /tmp/kustomize edit set image $REGISTRY_HOSTNAME/$GKE_PROJECT/$IMAGE=$REGISTRY_HOSTNAME/$GKE_PROJECT/$IMAGE:${GITHUB_SHA}
          git commit -am "[skip ci] fortress-api ${K8S_ENVIRONMENT} image update"
          git push origin main

```

# .github/workflows/commitlint.yml

```yml
name: Lint Commit Messages
on: [pull_request]

jobs:
  commitlint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - uses: wagoid/commitlint-github-action@v2
```

# .github/workflows/ci-test.yml

```yml
on: [pull_request]

jobs:
  ci-test:
    runs-on: ubuntu-latest
    name: CI testing
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v3
        with:
          go-version: "^1.21"

      - name: Run Test
        run: make ci

```

# .github/workflows/build-tools.yaml

```yaml
name: Build tools image

on:
  push:
    branches:
      - develop
    paths:
      - tools.Dockerfile
      - go.mod

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}
  PROJECT: dwarvesv
  IMAGE: fortress-tools

jobs:
  setup-build-publish:
    name: Build tools image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Build & Push the Docker image
      - name: Build & Push
        run: |
          docker build -f tools.Dockerfile -t $PROJECT/${IMAGE}:${GITHUB_SHA} .
          docker push $PROJECT/${IMAGE}:${GITHUB_SHA}

          docker tag $PROJECT/${IMAGE}:${GITHUB_SHA} $PROJECT/${IMAGE}:latest
          docker push $PROJECT/${IMAGE}:latest

```

# migrations/schemas/20240919023432-alter_table_checkins_update_id_type.sql

```sql

-- +migrate Up
ALTER TABLE physical_checkins DROP CONSTRAINT physical_checkins_pkey;
ALTER TABLE physical_checkins DROP COLUMN id;
ALTER TABLE physical_checkins ADD COLUMN id uuid PRIMARY KEY DEFAULT (uuid());
ALTER TABLE discord_checkins DROP CONSTRAINT discord_checkins_pkey;
ALTER TABLE discord_checkins DROP COLUMN id;
ALTER TABLE discord_checkins ADD COLUMN id uuid PRIMARY KEY DEFAULT (uuid());

-- +migrate Down
ALTER TABLE physical_checkins DROP CONSTRAINT physical_checkins_pkey;
ALTER TABLE physical_checkins ADD COLUMN id SERIAL PRIMARY KEY;
ALTER TABLE discord_checkins DROP CONSTRAINT discord_checkins_pkey;
ALTER TABLE discord_checkins ADD COLUMN id SERIAL PRIMARY KEY;
```

# migrations/schemas/20240918064436-add_table_physical_checkin_transactions.sql

```sql

-- +migrate Up
CREATE TABLE physical_checkin_transactions (
    id uuid PRIMARY KEY DEFAULT (uuid()),
    employee_id UUID REFERENCES employees(id) NOT NULL,
    date DATE NOT NULL,
    icy_amount FLOAT8 DEFAULT 0.0,
    mochi_tx_id INTEGER
);
-- add unique constraint
CREATE UNIQUE INDEX physical_checkin_transactions_employee_id_date_idx ON physical_checkin_transactions(employee_id, date);


-- +migrate Down
DROP TABLE physical_checkin_transactions;



```

# migrations/schemas/20240918064435-add_employee_bank_columns.sql

```sql
-- +migrate Up
ALTER TABLE employees ADD COLUMN beneficiary_bank_name TEXT DEFAULT NULL;
ALTER TABLE employees ADD COLUMN beneficiary_bank_postcode TEXT DEFAULT NULL;
ALTER TABLE employees ADD COLUMN beneficiary_bank_address TEXT DEFAULT NULL;
ALTER TABLE employees ADD COLUMN beneficiary_bank_city TEXT DEFAULT NULL;
ALTER TABLE employees ADD COLUMN beneficiary_routing_number TEXT DEFAULT NULL;

-- +migrate Down
ALTER TABLE employees DROP COLUMN beneficiary_bank_name;
ALTER TABLE employees DROP COLUMN beneficiary_bank_postcode;
ALTER TABLE employees DROP COLUMN beneficiary_bank_address;
ALTER TABLE employees DROP COLUMN beneficiary_bank_city;
ALTER TABLE employees DROP COLUMN beneficiary_routing_number;

```

# migrations/schemas/20240912134356-add_table_checkins.sql

```sql
-- +migrate Up
-- Create physical_checkins table
CREATE TABLE physical_checkins (
    id SERIAL PRIMARY KEY,
    employee_id UUID REFERENCES employees(id),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    date DATE
);

-- Create discord_checkins table
CREATE TABLE discord_checkins (
    id SERIAL PRIMARY KEY,
    employee_id UUID REFERENCES employees(id),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    date DATE
);

-- Create index on date
CREATE INDEX idx_physical_checkins_date ON physical_checkins (date);
CREATE INDEX idx_discord_checkins_date ON discord_checkins (date);

-- +migrate Down
-- Drop physical_checkins table
DROP TABLE physical_checkins;
-- Drop discord_checkins table
DROP TABLE discord_checkins;

```

# migrations/schemas/20240906073841-dropevent_speakers_event_id_discord_account_id_key.sql

```sql

-- +migrate Up
ALTER TABLE event_speakers
    DROP CONSTRAINT IF EXISTS event_speakers_event_id_discord_account_id_key;

ALTER TABLE event_speakers
    ADD CONSTRAINT event_speakers_topic_key UNIQUE (topic);



-- +migrate Down
ALTER TABLE event_speakers
    DROP CONSTRAINT IF EXISTS event_speakers_topic_key;

ALTER TABLE event_speakers ADD CONSTRAINT event_speakers_event_id_discord_account_id_key UNIQUE (event_id, discord_account_id);

```

# migrations/schemas/20240627064435-add_memo_log_category.sql

```sql

-- +migrate Up
ALTER TABLE memo_logs ADD COLUMN "category" TEXT[] default '{}'::TEXT[];

-- +migrate Down
ALTER TABLE memo_logs DROP COLUMN "category";

```

# migrations/schemas/20240513164949-remove_column_memo_logs_authors.sql

```sql

-- +migrate Up
ALTER TABLE memo_logs DROP COLUMN IF EXISTS authors;
-- +migrate Down
ALTER TABLE memo_logs ADD COLUMN authors JSONB;

```

# migrations/schemas/20240513105259-add_table_memo_authors_and_unique_memo_link.sql

```sql

-- +migrate Up
CREATE TABLE IF NOT EXISTS memo_authors  (
  memo_log_id UUID NOT NULL REFERENCES memo_logs(id),
  discord_account_id UUID NOT NULL REFERENCES discord_accounts(id),
  created_at    TIMESTAMP(6)     DEFAULT (now()),
  PRIMARY KEY (memo_log_id, discord_account_id)
);

ALTER TABLE memo_logs ADD UNIQUE ("url");
-- +migrate Down
ALTER TABLE memo_logs DROP CONSTRAINT memo_logs_url_key;

DROP TABLE IF EXISTS memo_authors;

```

# migrations/schemas/20240513093025-extend_table_discount_accounts.sql

```sql
-- +migrate Up
ALTER TABLE discord_accounts
RENAME COLUMN username TO discord_username;

UPDATE discord_accounts 
SET discord_username = '' WHERE discord_username IS NULL;

ALTER TABLE discord_accounts  
ALTER COLUMN discord_username SET NOT NULL,
ALTER COLUMN discord_username SET DEFAULT '';

ALTER TABLE discord_accounts
ADD COLUMN roles TEXT[] DEFAULT NULL,
ADD COLUMN memo_username TEXT NOT NULL DEFAULT '',
ADD COLUMN github_username TEXT NOT NULL DEFAULT '',
ADD COLUMN personal_email TEXT NOT NULL DEFAULT '';

-- +migrate Down
ALTER TABLE discord_accounts
DROP COLUMN roles,
DROP COLUMN memo_username,
DROP COLUMN github_username,
DROP COLUMN personal_email;

ALTER TABLE discord_accounts
ALTER COLUMN discord_username DROP DEFAULT,
ALTER COLUMN discord_username DROP NOT NULL;

UPDATE discord_accounts
SET discord_username = NULL WHERE discord_username = '';

ALTER TABLE discord_accounts
RENAME COLUMN discord_username TO username;

```

# migrations/schemas/20240502144255-create_discord_events.sql

```sql
-- +migrate Up
CREATE TABLE events (
    id uuid PRIMARY KEY DEFAULT (uuid()),
    name TEXT NOT NULL,
    description TEXT,
    date TIMESTAMP(6),
    discord_event_id VARCHAR,
    discord_channel_id VARCHAR,
    discord_message_id VARCHAR,
    discord_creator_id VARCHAR,
    event_type VARCHAR,
    created_at TIMESTAMP(6) DEFAULT (now()),
    updated_at TIMESTAMP(6) DEFAULT (now()),
    deleted_at TIMESTAMP(6) DEFAULT NULL
);

CREATE TABLE event_speakers (
    event_id UUID NOT NULL,
    discord_account_id UUID NOT NULL,
    topic TEXT,
    UNIQUE (event_id, discord_account_id)
);

ALTER TABLE event_speakers
    ADD CONSTRAINT event_speakers_discord_event_id_fkey FOREIGN KEY (event_id) REFERENCES events (id);

ALTER TABLE event_speakers
    ADD CONSTRAINT event_speakers_discord_account_id_fkey FOREIGN KEY (discord_account_id) REFERENCES discord_accounts (id);

-- +migrate Down

DROP TABLE event_speakers;
DROP TABLE events;

```

# migrations/schemas/20240417112538-add_memo_logs_table.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS memo_logs (
    id              UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6) DEFAULT (now()),
    updated_at      TIMESTAMP(6) DEFAULT (now()),

    title           TEXT NOT NULL,
    url             TEXT NOT NULL,
    authors         JSONB,
    tags            JSONB,
    description     TEXT,
    published_at    TIMESTAMP(6) NOT NULL,
    reward          DECIMAL
);

-- +migrate Down
DROP TABLE IF EXISTS memo_logs;

```

# migrations/schemas/20240322145850-remove_schedules_tabls.sql

```sql
-- +migrate Up
DROP TABLE schedule_discord_events;
DROP TABLE schedule_google_calendars;
DROP TABLE schedule_notion_pages;
DROP TABLE schedules;

-- +migrate Down
CREATE TABLE schedules (
    id UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6) DEFAULT (NOW()),
    updated_at TIMESTAMP(6) DEFAULT (NOW()),
    synced_at TIMESTAMP(6) DEFAULT (NOW()),

    name TEXT,
    description TEXT,
    start_time TIMESTAMP(6),
    end_time TIMESTAMP(6),
    schedule_type TEXT
);

CREATE TABLE schedule_google_calendars (
    id UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6) DEFAULT (NOW()),
    updated_at TIMESTAMP(6) DEFAULT (NOW()),

    schedule_id UUID REFERENCES schedules(id),
    google_calendar_id TEXT,
    description TEXT,
    hangout_link TEXT
);

CREATE TABLE schedule_discord_events (
    id UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6) DEFAULT (NOW()),
    updated_at TIMESTAMP(6) DEFAULT (NOW()),

    schedule_id UUID REFERENCES schedules(id),
    discord_event_id TEXT,
    description TEXT,
    voice_channel_id TEXT
);

CREATE TABLE schedule_notion_pages (
    id UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6) DEFAULT (NOW()),
    updated_at TIMESTAMP(6) DEFAULT (NOW()),

    schedule_id UUID REFERENCES schedules(id),
    notion_page_id TEXT,
    description TEXT
);





```

# migrations/schemas/20240318011415-add_invoice_bonus.sql

```sql
-- +migrate Up
ALTER TABLE "invoices" ADD COLUMN "bonus" DECIMAL;
ALTER TABLE "invoices" ADD COLUMN "total_without_bonus" DECIMAL;

-- +migrate Down
ALTER TABLE "invoices" DROP COLUMN "bonus";
ALTER TABLE "invoices" DROP COLUMN "total_without_bonus";

```

# migrations/schemas/20231201075923-init_user_bank_account.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS "banks" (
    id         UUID PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at TIMESTAMP(6)     DEFAULT (NOW()),

    "name"       TEXT DEFAULT NULL,
    "code"       TEXT DEFAULT NULL,
    "bin"        TEXT DEFAULT NULL,
    "short_name" TEXT DEFAULT NULL,
    "logo"       TEXT DEFAULT NULL,
    "swift_code" TEXT DEFAULT NULL
);

CREATE TABLE IF NOT EXISTS "user_bank_accounts" (
    id         UUID PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at TIMESTAMP(6)     DEFAULT (NOW()),

    "discord_account_id" UUID,
    "employee_id"        UUID NULL,
    "bank_id"            UUID,
    "account_number"     TEXT DEFAULT NULL,
    "branch"             TEXT DEFAULT NULL
);

ALTER TABLE "user_bank_accounts"
    ADD FOREIGN KEY ("discord_account_id") REFERENCES "discord_accounts" ("id");

ALTER TABLE "user_bank_accounts"
    ADD FOREIGN KEY ("employee_id") REFERENCES "employees" ("id");
-- +migrate Down
DROP TABLE IF EXISTS "user_bank_accounts";
DROP TABLE IF EXISTS "banks";

```

# migrations/schemas/20231130215800-change-advance-salary-amount-type.sql

```sql
-- +migrate Up
ALTER TABLE payrolls
ALTER COLUMN salary_advance_amount TYPE FLOAT8 USING salary_advance_amount::FLOAT8;

ALTER TABLE payrolls
    ALTER COLUMN salary_advance_amount SET DEFAULT 0;

-- +migrate Down

ALTER TABLE payrolls
ALTER COLUMN salary_advance_amount TYPE INT8 USING salary_advance_amount::INT8;

ALTER TABLE payrolls
    ALTER COLUMN salary_advance_amount SET DEFAULT NULL;
```

# migrations/schemas/20231130215800-add-advance-salary-amount.sql

```sql
-- +migrate Up
ALTER TABLE payrolls ADD COLUMN salary_advance_amount INT8;

-- +migrate Down
ALTER TABLE payrolls DROP COLUMN salary_advance_amount;

```

# migrations/schemas/20231112134909-init-config.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS configs (
    id          uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at  TIMESTAMP(6),
    created_at  TIMESTAMP(6)     DEFAULT (now()),
    updated_at  TIMESTAMP(6)     DEFAULT (now()),
    key        TEXT NOT NULL,
    value      TEXT NOT NULL
);

ALTER TABLE configs ADD UNIQUE (key);

-- +migrate Down
DROP TABLE IF EXISTS configs;

```

# migrations/schemas/20231111011111-add_currency_conversion_rate.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS conversion_rates (
    id              UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6) DEFAULT (now()),
    updated_at      TIMESTAMP(6) DEFAULT (now()),

    currency_id     UUID DEFAULT NULL,
    to_usd          DECIMAL,
    to_vnd          DECIMAL
);

ALTER TABLE conversion_rates
    ADD CONSTRAINT conversion_rates_currency_id_fkey FOREIGN KEY (currency_id) REFERENCES currencies (id);

-- +migrate Down
DROP TABLE IF EXISTS conversion_rates;

```

# migrations/schemas/20231026123737-init-advance-salary-history.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS salary_advance_histories (
    id          uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at  TIMESTAMP(6),
    created_at  TIMESTAMP(6)     DEFAULT (now()),
    updated_at  TIMESTAMP(6)     DEFAULT (now()),
    amount_icy        int8 NOT NULL DEFAULT 0,
    amount_usd        DECIMAL NOT NULL DEFAULT 0,
    base_amount       DECIMAL NOT NULL DEFAULT 0,
    is_paid_back      BOOLEAN   DEFAULT FALSE,
    paid_at           TIMESTAMP(6),
    conversion_rate   DECIMAL          DEFAULT 0,
    currency_id       uuid,
    employee_id       uuid
);

ALTER TABLE salary_advance_histories ADD CONSTRAINT salary_advance_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);
ALTER TABLE salary_advance_histories ADD CONSTRAINT salary_advance_currency_id_fkey FOREIGN KEY (currency_id) REFERENCES currencies (id);

-- +migrate Down
ALTER TABLE salary_advance_histories DROP CONSTRAINT salary_advance_employee_id_fkey;
ALTER TABLE salary_advance_histories DROP CONSTRAINT salary_advance_currency_id_fkey;
DROP TABLE IF EXISTS salary_advance_histories;

```

# migrations/schemas/20231005040551-add_employee_mma_scores_table.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS employee_mma_scores (
    id              UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6) DEFAULT (now()),
    updated_at      TIMESTAMP(6) DEFAULT (now()),

    employee_id     UUID DEFAULT NULL,
    mastery_score   DECIMAL,
    autonomy_score  DECIMAL,
    meaning_score   DECIMAL,
    rated_at        TIMESTAMP(6) DEFAULT (now())
);

ALTER TABLE employee_mma_scores
    ADD CONSTRAINT employee_mma_scores_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

-- +migrate Down
DROP TABLE IF EXISTS employee_mma_scores;

```

# migrations/schemas/20230720050455-add-view-monthly-lelivery-metrics.sql

```sql

-- +migrate Up
CREATE VIEW "vw_monthly_delivery_metrics" AS
SELECT 
	DATE_TRUNC('month', date) as "month",
	SUM(weight) AS "sum_weight",
	SUM(effort) AS "sum_effort"
FROM delivery_metrics
GROUP BY DATE_TRUNC('month', date)
ORDER BY "month" DESC;

-- +migrate Down
DROP VIEW "vw_monthly_delivery_metrics";

```

# migrations/schemas/20230718143052-add-view-weekly-delivery-metrics.sql

```sql

-- +migrate Up
CREATE INDEX delivery_metrics_date_idx ON delivery_metrics ((date::date) DESC NULLS LAST);

CREATE VIEW "vw_weekly_delivery_metrics" AS
SELECT "date", 
	SUM(weight) AS "sum_weight", 
	SUM(effort) AS "sum_effort"
FROM delivery_metrics
GROUP BY "date";

-- +migrate Down
DROP VIEW "vw_weekly_delivery_metrics";

DROP INDEX IF EXISTS delivery_metrics_date_idx;

```

# migrations/schemas/20230713033838-add_delivery_metric_logs_table.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS delivery_metrics (
    id            UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at    TIMESTAMP(6),
    created_at    TIMESTAMP(6)     DEFAULT (now()),
    updated_at    TIMESTAMP(6)     DEFAULT (now()),

    weight        DECIMAL NOT NULL DEFAULT 0,
    effort        DECIMAL NOT NULL DEFAULT 0,
    effectiveness DECIMAL NOT NULL DEFAULT 0,
    date          DATE    NOT NULL,
    employee_id   UUID    NULL     DEFAULT NULL,
    project_id    UUID    NULL     DEFAULT NULL,
    ref           INT     NOT NULL DEFAULT 0
);

ALTER TABLE delivery_metrics
    ADD CONSTRAINT delivery_metrics_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

ALTER TABLE delivery_metrics
    ADD CONSTRAINT delivery_metrics_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);

-- +migrate Down
DROP TABLE IF EXISTS delivery_metrics;

```

# migrations/schemas/20230701072225-add_column_clients.sql

```sql
-- +migrate Up
ALTER TABLE clients ADD COLUMN city TEXT DEFAULT NULL;
ALTER TABLE clients ADD COLUMN avatar TEXT DEFAULT NULL;
ALTER TABLE clients ADD COLUMN company_size TEXT DEFAULT NULL;
ALTER TABLE clients ADD COLUMN solution_type TEXT DEFAULT NULL;
ALTER TABLE clients ADD COLUMN lat TEXT DEFAULT NULL;
ALTER TABLE clients ADD COLUMN long TEXT DEFAULT NULL;
ALTER TABLE clients ADD COLUMN is_public BOOLEAN DEFAULT FALSE;

-- +migrate Down
ALTER TABLE clients DROP COLUMN city;
ALTER TABLE clients DROP COLUMN avatar;
ALTER TABLE clients DROP COLUMN company_size;
ALTER TABLE clients DROP COLUMN solution_type;
ALTER TABLE clients DROP COLUMN lat;
ALTER TABLE clients DROP COLUMN long;
ALTER TABLE clients DROP COLUMN is_public;

```

# migrations/schemas/20230630082538-remove_unused_columns_employees.sql

```sql
-- +migrate Up
DROP VIEW vw_employees_recently_joined;

ALTER TABLE employees DROP COLUMN gitlab_id;
ALTER TABLE employees DROP COLUMN github_id;
ALTER TABLE employees DROP COLUMN discord_id;
ALTER TABLE employees DROP COLUMN notion_id;
ALTER TABLE employees DROP COLUMN discord_name;
ALTER TABLE employees DROP COLUMN notion_name;
ALTER TABLE employees DROP COLUMN notion_email;
ALTER TABLE employees DROP COLUMN linkedin_name;

CREATE OR REPLACE VIEW vw_employees_recently_joined AS
SELECT *
FROM employees
WHERE joined_date BETWEEN CURRENT_DATE - INTERVAL '7 days' AND CURRENT_DATE;

-- +migrate StatementBegin
CREATE OR REPLACE FUNCTION public.fn_insert_keyword_vector ()
	RETURNS TRIGGER
	LANGUAGE plpgsql
	AS $function$
BEGIN
	NEW. "keyword_vector" = array_to_tsvector ((
			SELECT
				array_agg(DISTINCT substring(lexeme FOR len))
			FROM
				unnest(
				    to_tsvector(
				        fn_remove_vietnamese_accents(
				            LOWER(COALESCE(NEW. "full_name", '') || ' ' || COALESCE(NEW. "team_email", ''))
				        )
				    )
				),
				generate_series(1, length(lexeme)) len));
RETURN NEW;
END;
$function$;
-- +migrate StatementEnd
UPDATE
    "employees" c
SET "keyword_vector" = array_to_tsvector ((
    SELECT
        array_agg(DISTINCT substring(lexeme FOR len))
    FROM
        unnest(
                to_tsvector(
                        fn_remove_vietnamese_accents(
                                LOWER(COALESCE(c. "full_name", '') || ' ' || COALESCE(c. "team_email", ''))
                            )
                    )
            ),
        generate_series(1, length(lexeme)) len))
WHERE TRUE;

-- +migrate Down
ALTER TABLE employees ADD COLUMN gitlab_id TEXT;
ALTER TABLE employees ADD COLUMN github_id TEXT;
ALTER TABLE employees ADD COLUMN discord_id TEXT;
ALTER TABLE employees ADD COLUMN notion_id TEXT;
ALTER TABLE employees ADD COLUMN discord_name TEXT;
ALTER TABLE employees ADD COLUMN notion_name TEXT;
ALTER TABLE employees ADD COLUMN notion_email TEXT;
ALTER TABLE employees ADD COLUMN linkedin_name TEXT;

-- +migrate StatementBegin
CREATE OR REPLACE FUNCTION public.fn_insert_keyword_vector ()
	RETURNS TRIGGER
	LANGUAGE plpgsql
	AS $function$
BEGIN
    NEW. "keyword_vector" = array_to_tsvector ((
        SELECT
            array_agg(DISTINCT substring(lexeme FOR len))
        FROM
            unnest(
                to_tsvector(
                    fn_remove_vietnamese_accents(
                        LOWER(COALESCE(NEW. "full_name", '') || ' ' || COALESCE(NEW. "team_email", '') || ' ' || COALESCE(NEW. "discord_id", '') || ' ' || COALESCE(NEW. "notion_id", '') || ' ' || COALESCE(NEW. "github_id", '') || ' ' || COALESCE(NEW. "notion_name", '') || ' ' || COALESCE(NEW. "discord_name", ''))
                    )
                )
            ),
            generate_series(1, length(lexeme)) len));
RETURN NEW;
END;
$function$;
-- +migrate StatementEnd
UPDATE
    "employees" c
SET
    "keyword_vector" = array_to_tsvector ((
        SELECT
            array_agg(DISTINCT substring(lexeme FOR len))
        FROM
            unnest(
                    to_tsvector(
                            fn_remove_vietnamese_accents(
                                    LOWER(COALESCE(c. "full_name", '') || ' ' || COALESCE(c. "team_email", '') || ' ' || COALESCE(c. "discord_id", '') || ' ' || COALESCE(c. "notion_id", '') || ' ' || COALESCE(c. "github_id", '') || ' ' || COALESCE(c. "notion_name", '') || ' ' || COALESCE(c. "discord_name", ''))
                                )
                        )
                ),
            generate_series(1, length(lexeme)) len))
WHERE TRUE;

```

# migrations/schemas/20230622072538-add_coors_col_in_employees.sql

```sql
-- +migrate Up
DROP VIEW IF EXISTS vw_employees_recently_joined;
ALTER TABLE employees ADD COLUMN lat TEXT DEFAULT NULL;
ALTER TABLE employees ADD COLUMN long TEXT DEFAULT NULL;

CREATE OR REPLACE VIEW vw_employees_recently_joined AS
SELECT *
FROM employees
WHERE joined_date BETWEEN CURRENT_DATE - INTERVAL '7 days' AND CURRENT_DATE;
-- +migrate Down
ALTER TABLE employees DROP COLUMN lat CASCADE;
ALTER TABLE employees DROP COLUMN long CASCADE;

```

# migrations/schemas/20230620172538-add_discord_accounts_table.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS discord_accounts (
    id         UUID PRIMARY KEY DEFAULT UUID(),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT NOW(),
    updated_at TIMESTAMP(6)     DEFAULT NOW(),

    discord_id TEXT NOT NULL,
    username   TEXT
);


ALTER TABLE employees ADD COLUMN discord_account_id UUID DEFAULT NULL;
ALTER TABLE employees ADD CONSTRAINT employees_discord_account_id_fkey FOREIGN KEY (discord_account_id) REFERENCES discord_accounts (id);
ALTER TABLE discord_accounts ADD UNIQUE (discord_id);

-- +migrate Down
ALTER TABLE employees DROP COLUMN discord_account_id;
DROP TABLE IF EXISTS discord_accounts;

```

# migrations/schemas/20230619112538-add_brainery_reports_table.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS brainery_logs (
    id              UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6) DEFAULT (now()),
    updated_at      TIMESTAMP(6) DEFAULT (now()),

    title           TEXT NOT NULL,
    url             TEXT NOT NULL,
    github_id       TEXT,
    discord_id      TEXT NOT NULL,
    employee_id     UUID DEFAULT NULL,
    tags            JSONB,
    published_at    TIMESTAMP(6) NOT NULL,
    reward          DECIMAL
);

ALTER TABLE brainery_logs
    ADD CONSTRAINT brainery_logs_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

-- +migrate Down
DROP TABLE IF EXISTS brainery_logs;

```

# migrations/schemas/20230613062354-engagements_rollup_init.sql

```sql
-- +migrate Up
CREATE TABLE engagements_rollup
(
    id               uuid PRIMARY KEY DEFAULT (uuid()),
    discord_user_id  BIGINT,
    last_message_id  BIGINT,
    discord_username VARCHAR(40),
    -- Discord's usernames have the form "username#number"
    -- for example: thanhnguyen2187#4183
    -- the username part's maximal length is 32, while the number part's length is 4
    channel_id       BIGINT,
    category_id      BIGINT,
    message_count    INT NOT NULL DEFAULT 0,
    reaction_count   INT NOT NULL DEFAULT 0,
    deleted_at       TIMESTAMP(6),
    created_at       TIMESTAMP(6),
    updated_at       TIMESTAMP(6),

    UNIQUE (discord_user_id, channel_id)
);
-- TODO: migrate before 2084, since BIGINT of Postgres is int64
--       its maximal value is 9223372036854775807, which is equivalent to 2084-09-06T15:47:35.551Z
-- https://www.postgresql.org/docs/current/datatype-numeric.html
-- https://discord.com/developers/docs/reference#snowflakes
-- https://snowsta.mp/?l=en&z=n&f=ixetipsqxx-c73

-- +migrate Down
DROP TABLE engagements_rollup;


```

# migrations/schemas/20230611051221-alter_icy_txn_table.sql

```sql
-- +migrate Up
ALTER TABLE icy_transactions ALTER COLUMN dest_employee_id DROP NOT NULL;
ALTER TABLE icy_transactions ALTER COLUMN src_employee_id DROP NOT NULL;

ALTER TABLE icy_transactions ADD COLUMN sender TEXT;
ALTER TABLE icy_transactions ADD COLUMN target TEXT;

ALTER TABLE icy_transactions DROP CONSTRAINT unique_icy_txn_src_dest_category;
ALTER TABLE icy_transactions ADD CONSTRAINT unique_icy_txn_src_dest_category UNIQUE (sender, target, category, amount, txn_time);

CREATE OR REPLACE VIEW "vw_icy_employee_dashboard" AS
SELECT
    t.dest_employee_id as employee_id,
    e.full_name,
    e.team_email,
    e.personal_email,
    SUM(t.amount) AS "total_earned"
FROM
    icy_transactions t
        JOIN employees e ON e.id = t.dest_employee_id
GROUP BY
    t.dest_employee_id,
    e.full_name,
    e.team_email,
    e.personal_email
ORDER BY
    SUM(t.amount) DESC;

-- +migrate Down
ALTER TABLE icy_transactions DROP CONSTRAINT unique_icy_txn_src_dest_category;
ALTER TABLE icy_transactions ADD CONSTRAINT unique_icy_txn_src_dest_category UNIQUE (src_employee_id, dest_employee_id, category, amount, txn_time);

ALTER TABLE icy_transactions DROP COLUMN sender;
ALTER TABLE icy_transactions DROP COLUMN target;

CREATE OR REPLACE VIEW "vw_icy_employee_dashboard" AS
SELECT
    t.dest_employee_id as employee_id,
    e.full_name,
    e.team_email,
    e.personal_email,
    SUM(t.amount) AS "total_earned"
FROM
    icy_transactions t
        LEFT JOIN employees e ON e.id = t.dest_employee_id
GROUP BY
    t.dest_employee_id,
    e.full_name,
    e.team_email,
    e.personal_email
ORDER BY
    SUM(t.amount) DESC;

```

# migrations/schemas/20230610112300-alter_projects_table_add_rating_important_cols.sql

```sql
-- +migrate Up
CREATE TYPE project_important_level_type AS ENUM (
    'low',
    'medium-',
    'medium',
    'medium+',
    'high'
);

ALTER TABLE projects ADD COLUMN account_rating INT NOT NULL DEFAULT 0;
ALTER TABLE projects ADD COLUMN delivery_rating INT NOT NULL  DEFAULT 0;
ALTER TABLE projects ADD COLUMN lead_rating INT NOT NULL  DEFAULT 0;
ALTER TABLE projects ADD COLUMN important_level project_important_level_type DEFAULT NULL;

-- +migrate Down
ALTER TABLE projects DROP COLUMN account_rating;
ALTER TABLE projects DROP COLUMN delivery_rating;
ALTER TABLE projects DROP COLUMN lead_rating;
ALTER TABLE projects DROP COLUMN important_level;
DROP TYPE project_important_level_type;

```

# migrations/schemas/20230610100900-alter_roles_table_add_is_show_column.sql

```sql
-- +migrate Up
ALTER TABLE roles ADD COLUMN is_show BOOL NOT NULL DEFAULT TRUE;
ALTER TABLE roles ADD COLUMN color TEXT;
-- +migrate Down
ALTER TABLE roles DROP COLUMN is_show;
ALTER TABLE roles DROP COLUMN color;

```

# migrations/schemas/20230531143430-add_onleave_request_table.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS "on_leave_requests" (
    id                 UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at         TIMESTAMP(6),
    created_at         TIMESTAMP(6)     DEFAULT (now()),
    updated_at         TIMESTAMP(6)     DEFAULT (now()),

    title               TEXT NOT NULL,
    type                TEXT NOT NULL,
    start_date          DATE NOT NULL,
    end_date            DATE NOT NULL,
    shift               TEXT,
    description         TEXT,
    creator_id          UUID NOT NULL,
    approver_id         UUID NOT NULL,
    assignee_ids        JSONB
);

ALTER TABLE on_leave_requests
    ADD CONSTRAINT on_leave_requests_creator_id_fkey FOREIGN KEY (creator_id) REFERENCES employees (id);

ALTER TABLE on_leave_requests
    ADD CONSTRAINT on_leave_requests_approver_id_fkey FOREIGN KEY (approver_id) REFERENCES employees (id);

-- +migrate Down
DROP TABLE IF EXISTS on_leave_requests;

```

# migrations/schemas/20230525000301-add_table_monthly_chapter_members_weekly_project_charge_rate.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS "monthly_chapter_members" (
    id                 uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at         TIMESTAMP(6),
    created_at         TIMESTAMP(6)     DEFAULT (now()),
    updated_at         TIMESTAMP(6)     DEFAULT (now()),

    month              DATE,
    chapter_group_name TEXT NOT NULL,
    total_member       INT
);

CREATE TABLE IF NOT EXISTS "weekly_project_charge_rates" (
    id                 UUID PRIMARY KEY DEFAULT (UUID()),
    deleted_at         TIMESTAMP(6),
    created_at         TIMESTAMP(6)     DEFAULT (now()),
    updated_at         TIMESTAMP(6)     DEFAULT (now()),

    week               DATE,
    project_id         UUID NOT NULL,
    project_name       TEXT NOT NULL,
    member_id          UUID NOT NULL,
    member_name        TEXT NOT NULL,
    charge_rate_amount DECIMAL,
    deployment_type    deployment_types
);

ALTER TABLE weekly_project_charge_rates
    ADD CONSTRAINT weekly_project_charge_rates_member_id_fkey FOREIGN KEY (member_id) REFERENCES employees (id);

ALTER TABLE weekly_project_charge_rates
    ADD CONSTRAINT weekly_project_charge_rates_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);

-- +migrate Down
DROP TABLE IF EXISTS monthly_chapter_members;
DROP TABLE IF EXISTS weekly_project_charge_rates;

```

# migrations/schemas/20230517000301-add_table_employee_invitations.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS employee_invitations (
    id                          uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at                  TIMESTAMP(6),
    created_at                  TIMESTAMP(6)     DEFAULT (now()),
    updated_at                  TIMESTAMP(6)     DEFAULT (now()),

    employee_id                 uuid    NOT NULL,
    invited_by                  uuid    NOT NULL,
    invitation_code             TEXT    NOT NULL,
    is_completed                BOOLEAN NOT NULL DEFAULT false,
    is_info_updated             BOOLEAN NOT NULL DEFAULT false,
    is_discord_role_assigned    BOOLEAN NOT NULL DEFAULT false,
    is_basecamp_account_created BOOLEAN NOT NULL DEFAULT false,
    is_team_email_created       BOOLEAN NOT NULL DEFAULT false
);

ALTER TABLE employee_invitations
    ADD CONSTRAINT employee_invitations_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);
ALTER TABLE employee_invitations
    ADD CONSTRAINT employee_invitations_invited_by_fkey FOREIGN KEY (invited_by) REFERENCES employees (id);

-- +migrate Down
DROP TABLE IF EXISTS employee_invitations;

```

# migrations/schemas/20230516091724-alter_table_icy_tx_add_unique.sql

```sql

-- +migrate Up
alter table icy_transactions add constraint unique_icy_txn_src_dest_category unique (src_employee_id, dest_employee_id, category, amount, txn_time);
-- +migrate Down
alter table icy_transactions drop constraint unique_icy_txn_src_dest_category;

```

# migrations/schemas/20230516000300-alter_employee_drop_not_null_team_email.sql

```sql
-- +migrate Up
ALTER TABLE employees ALTER  COLUMN  team_email DROP NOT NULL;

-- +migrate Down

```

# migrations/schemas/20230515162554-view-idle-employees.sql

```sql

-- +migrate Up
DROP VIEW IF EXISTS "vw_idle_employees";
CREATE OR REPLACE VIEW "vw_idle_employees" AS
SELECT DISTINCT
	emp.full_name,
	o.name AS org_name
FROM
	employees emp
	JOIN employee_organizations eo ON emp.id = eo.employee_id
	JOIN organizations o ON o.id = eo.organization_id
WHERE
	emp.working_status NOT in('left', 'contractor')
	AND emp.id NOT in( SELECT DISTINCT
			mem.employee_id FROM projects p
		LEFT JOIN project_members mem ON mem.project_id = p.id
	WHERE
		p.status = 'active'
		AND mem.rate > 0
		AND mem.deployment_type <> 'shadow'
		AND mem.status <> 'inactive');

-- +migrate Down

DROP VIEW IF EXISTS "vw_idle_employees";
CREATE OR REPLACE VIEW "vw_idle_employees" AS
SELECT
  DISTINCT emp.*
FROM
  employees emp
  JOIN project_members pj ON pj.employee_id = emp.id
  AND emp.working_status <> 'left'
WHERE
  deployment_type <> 'shadow'
  OR rate = 0;

```

# migrations/schemas/20230512110852-report-views.sql

```sql
-- +migrate Up

CREATE OR REPLACE VIEW "vw_idle_employees" AS
SELECT
  DISTINCT emp.*
FROM
  employees emp
  JOIN project_members pj ON pj.employee_id = emp.id
  AND emp.working_status <> 'left'
WHERE
  deployment_type <> 'shadow'
  OR rate = 0;

CREATE OR REPLACE VIEW "vw_subscribers_last_7days" AS
SELECT 
  *
FROM
  audiences
WHERE now() :: date - created_at :: date <= 7;

CREATE OR REPLACE VIEW "vw_icy_earning_by_team_monthly" AS 
WITH weekly_earning AS (
  SELECT
    date_trunc('month', txn_time) AS "month",
    date_trunc('week', txn_time) AS "week",
    category,
    SUM(amount) AS "amount"
  FROM
    icy_transactions
  GROUP BY
    date_trunc('month', txn_time),
    date_trunc('week', txn_time),
    category
  ORDER BY
    date_trunc('week', txn_time) DESC,
    SUM(amount) DESC
)
SELECT
  to_char(date_trunc('month', txn_time), 'yyyy-mm') as "period",
  t.category as "team",
  SUM(t.amount) as "amount",
  AVG(w.amount) AS "avg_earning_weekly"
FROM
  icy_transactions t
  LEFT JOIN weekly_earning w ON w.category = t.category
  AND w.month = date_trunc('month', txn_time)
GROUP BY
  date_trunc('month', txn_time),
  t.category
ORDER BY
  date_trunc('month', txn_time) DESC,
  SUM(t.amount) DESC;

CREATE OR REPLACE VIEW "vw_icy_earning_by_team_all_time" AS WITH monthly_earning AS (
  SELECT
    date_trunc('month', txn_time) AS "month",
    category,
    SUM(amount) AS "amount"
  FROM
    icy_transactions
  GROUP BY
    date_trunc('month', txn_time),
    category
  ORDER BY
    date_trunc('month', txn_time) DESC,
    SUM(amount) DESC
),
weekly_earning AS (
  SELECT
    date_trunc('month', txn_time) AS "month",
    date_trunc('week', txn_time) AS "week",
    category,
    SUM(amount) AS "amount"
  FROM
    icy_transactions
  GROUP BY
    date_trunc('month', txn_time),
    date_trunc('week', txn_time),
    category
  ORDER BY
    date_trunc('week', txn_time) DESC,
    SUM(amount) DESC
)
SELECT
  m.category AS "team",
  SUM(t.amount) AS "amount",
  AVG(m.amount) AS "avg_earning_monthy",
  AVG(w.amount) AS "avg_earning_weekly"
FROM
  icy_transactions t
  LEFT JOIN monthly_earning m ON m.category = t.category
  LEFT JOIN weekly_earning w ON w.category = t.category
  AND w.month = m.month
GROUP BY
  m.category
ORDER BY
  SUM(t.amount) DESC;

CREATE OR REPLACE VIEW "vw_icy_earning_by_team_weekly" AS
SELECT
  to_char(date_trunc('week', txn_time), 'yyyy-mm-dd') AS "period",
  category AS "team",
  SUM(t.amount) AS "amount"
FROM
  icy_transactions t
GROUP BY
  date_trunc('week', txn_time),
  category
ORDER BY
  date_trunc('week', txn_time) DESC,
  SUM(t.amount) DESC;

CREATE OR REPLACE VIEW "vw_icy_employee_dashboard" AS
SELECT
  t.dest_employee_id as employee_id,
  e.full_name,
  e.team_email,
  e.personal_email,
  SUM(t.amount) AS "total_earned"
FROM
  icy_transactions t
  LEFT JOIN employees e ON e.id = t.dest_employee_id
GROUP BY
  t.dest_employee_id,
  e.full_name,
  e.team_email,
  e.personal_email
ORDER BY
  SUM(t.amount) DESC;

-- +migrate Down

DROP VIEW IF EXISTS "vw_subscribers_last_7days";

DROP VIEW IF EXISTS "vw_icy_earning_by_team_weekly";

DROP VIEW IF EXISTS "vw_icy_earning_by_team_monthly";

DROP VIEW IF EXISTS "vw_icy_earning_by_team_all_time";

DROP VIEW IF EXISTS "vw_icy_employee_dashboard";

DROP VIEW IF EXISTS "vw_idle_employees";

```

# migrations/schemas/20230512091526-new-icy-txn.sql

```sql
-- +migrate Up
-- +migrate StatementBegin
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'enum_icy_txn_category') THEN
    CREATE TYPE "enum_icy_txn_category" AS ENUM ('learning', 'community', 'delivery', 'tooling');
  END IF;
END $$;
-- +migrate StatementEnd

CREATE TABLE IF NOT EXISTS "icy_transactions" (
  "id" uuid PRIMARY KEY DEFAULT uuid(),
  "created_at" timestamptz NOT NULL DEFAULT now(),
  "updated_at" timestamptz NOT NULL DEFAULT now(),
  "deleted_at" timestamptz,
  "txn_time" timestamptz NOT NULL DEFAULT now(),
  "src_employee_id" uuid REFERENCES employees ("id"),
  "dest_employee_id" uuid REFERENCES employees ("id"),
  "category" enum_icy_txn_category NOT NULL,
  "amount" numeric NOT NULL DEFAULT 0,
  "note" text
);
-- +migrate Down

DROP TABLE icy_transactions;

DROP TYPE IF EXISTS "enum_icy_txn_category";

```

# migrations/schemas/20230512091353-drop-old-icy-txn.sql

```sql
-- +migrate Up

DROP VIEW "vw_icy_treasury_funds";

DROP TABLE "icy_transactions_out";

DROP TABLE "icy_transactions_in";

DROP TABLE "icy_treasury_categories";

-- +migrate Down

CREATE TABLE "icy_treasury_categories" (
  "id" uuid NOT NULL DEFAULT uuid(),
  "created_at" timestamp(8) DEFAULT NOW(),
  "deleted_at" timestamp(8),
  "name" text,
  "category_manager_id" uuid,
  CONSTRAINT "icy_treasury_categories_category_manager_id_fkey" FOREIGN KEY ("category_manager_id") REFERENCES "employees" ("id"),
  PRIMARY KEY ("id")
);

CREATE TABLE "icy_transactions_out" (
  "id" uuid NOT NULL DEFAULT uuid(),
  "created_at" timestamp(8) DEFAULT NOW(),
  "deleted_at" timestamp(8),
  "amount" text,
  "description" text,
  "category_id" uuid,
  "to_employee_id" uuid NOT NULL,
  "approver_id" uuid,
  CONSTRAINT "icy_transactions_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "icy_treasury_categories" ("id"),
  CONSTRAINT "icy_transactions_to_employee_id_fkey" FOREIGN KEY ("to_employee_id") REFERENCES "employees" ("id"),
  CONSTRAINT "icy_transactions_approver_id_fkey" FOREIGN KEY ("approver_id") REFERENCES "employees" ("id"),
  PRIMARY KEY ("id")
);

CREATE TABLE "icy_transactions_in" (
  "id" uuid NOT NULL DEFAULT uuid(),
  "created_at" timestamp(8) DEFAULT NOW(),
  "deleted_at" timestamp(8),
  "date" timestamp(8) DEFAULT NOW(),
  "description" text,
  "amount" text,
  "category_id" uuid,
  CONSTRAINT "icy_transactions_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "icy_treasury_categories" ("id"),
  PRIMARY KEY ("id")
);

CREATE VIEW "vw_icy_treasury_funds" AS
SELECT
  t1.category_id,
  t2.total_in - t1.total_out AS balance
FROM
  (
    SELECT
      category_id,
      SUM(amount :: NUMERIC) AS total_out
    FROM
      icy_transactions_out ito
    GROUP BY
      category_id
  ) t1
  JOIN (
    SELECT
      category_id,
      SUM(amount :: NUMERIC) AS total_in
    FROM
      icy_transactions_in iti
    GROUP BY
      category_id
  ) t2 ON t1.category_id = t2.category_id;

```

# migrations/schemas/20230509095554-add_discord_log_template.sql

```sql
-- +migrate Up
create table if not EXISTS discord_log_templates (
    id uuid PRIMARY KEY DEFAULT(uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6) DEFAULT(NOW()),
    updated_at TIMESTAMP(6) DEFAULT(NOW()),

    type TEXT,
    content TEXT
);

-- +migrate Down
drop table discord_log_templates;

```

# migrations/schemas/20230419095554-add_employee_data_view.sql

```sql
-- +migrate Up
CREATE OR REPLACE VIEW vw_employee_count_by_chapter AS
    WITH chapter_data as (
        SELECT c.id,
        CASE
            WHEN c.code IN ('backend', 'web', 'mobile', 'blockchain', 'devops', 'data') THEN 'Developer'
            WHEN c.code = 'qa' THEN 'QA'
            WHEN c.code = 'design' THEN 'Designer'
            WHEN c.code IN ('operations', 'pm') THEN 'Operation'
            WHEN c.code = 'sales' THEN 'Sales'
            ELSE c.code
        END AS chapter_group_name,
        c.name,
        c.code,
        c.lead_id
        FROM chapters c
    )
    SELECT
        chapter_data.chapter_group_name,
        COUNT(DISTINCT (ec.employee_id)) AS employee_count
    FROM chapter_data
         LEFT JOIN employee_chapters ec ON ec.chapter_id = chapter_data.id
         LEFT JOIN employees e ON ec.employee_id = e.id
    WHERE e.working_status IN ('probation', 'full-time', 'contractor')
    GROUP BY chapter_data.chapter_group_name
    ORDER BY employee_count DESC
;

CREATE OR REPLACE VIEW vw_employees_recently_joined AS
    SELECT *
    FROM employees
    WHERE joined_date BETWEEN CURRENT_DATE - INTERVAL '7 days' AND CURRENT_DATE
;

CREATE OR REPLACE VIEW vw_employees_project_charge_rates AS
    WITH time as (SELECT NOW() as now)
    SELECT e.id as employee_id, e.full_name, pm.project_id, pm.rate, ba.currency_id
    FROM time,
         project_members pm
             JOIN projects p ON pm.project_id = p.id
             JOIN employees e ON pm.employee_id = e.id
             JOIN bank_accounts ba on p.bank_account_id = ba.id
    WHERE e.working_status IN ('probation', 'full-time', 'contractor')
      AND p.type = 'time-material'
      AND p.status = 'active'
      AND (pm.start_date <= time.now::DATE AND (pm.end_date IS NULL OR pm.end_date <= time.now::DATE))
      AND pm.rate > 0
      AND pm.deployment_type = 'official'
;

-- +migrate Down
DROP VIEW vw_employee_count_by_chapter;
DROP VIEW vw_employees_project_charge_rates;

```

# migrations/schemas/20230419095553-change_invoice_number_data_type.sql

```sql
-- +migrate Up
ALTER TABLE invoices ALTER COLUMN discount TYPE DECIMAL USING discount::DECIMAL;
ALTER TABLE invoices ALTER COLUMN tax TYPE DECIMAL USING tax::DECIMAL;
ALTER TABLE invoices ALTER COLUMN sub_total TYPE DECIMAL USING sub_total::DECIMAL;

-- +migrate Down
ALTER TABLE invoices ALTER COLUMN discount TYPE INTEGER USING discount::INTEGER;
ALTER TABLE invoices ALTER COLUMN tax TYPE INTEGER USING tax::INTEGER;
ALTER TABLE invoices ALTER COLUMN sub_total TYPE INTEGER USING sub_total::INTEGER;

```

# migrations/schemas/20230419095552-add_missing_updated_at_field_base_salary.sql

```sql

-- +migrate Up
ALTER TABLE base_salaries ADD COLUMN updated_at TIMESTAMP(6) DEFAULT (NOW());

-- +migrate Down
ALTER TABLE base_salaries DROP COLUMN updated_at;

```

# migrations/schemas/20230419095551-create-audience-table.sql

```sql
-- +migrate Up
create table if not exists "audiences" (
    "id" uuid primary key default (uuid()),
    "created_at" timestamptz(6) default now(),
    "updated_at" timestamptz(6) default now(),
    "deleted_at" timestamptz(6),
    "email" text,
    "full_name" text,
    "first_name" text,
    "last_name" text,
    "source" text,
    "notion_id" text,
    "subscribed_dwarves_updates" boolean,
    "subscribed_techie_story" boolean,
    "subscribed_webuild" boolean
);

-- +migrate Down
drop table if exists "audiences";

```

# migrations/schemas/20230417095551-create-expenses-table.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS "expenses" (
    "id"                        UUID PRIMARY KEY                    DEFAULT (uuid()),
    "created_at"                TIMESTAMPTZ(6)                      DEFAULT NOW(),
    "updated_at"                TIMESTAMPTZ(6)                      DEFAULT NOW(),
    "deleted_at"                TIMESTAMPTZ(6),
    "employee_id"               UUID,
    "reason"                    TEXT COLLATE "pg_catalog"."default",
    "issued_date"               TIMESTAMPTZ(6)                      DEFAULT NOW(),
    "amount"                    INT8,
    "currency_id"               UUID,
    "currency"                  TEXT COLLATE "pg_catalog"."default" DEFAULT 'VND'::TEXT,
    "invoice_image_url"         TEXT COLLATE "pg_catalog"."default",
    "metadata"                  JSON,
    "accounting_transaction_id" UUID,
    "basecamp_id"               INT8
)
;
-- ----------------------------
-- Foreign Keys structure for table expense
-- ----------------------------
ALTER TABLE "expenses"
    ADD CONSTRAINT "expenses_accounting_transaction_id_fkey" FOREIGN KEY ("accounting_transaction_id") REFERENCES "accounting_transactions" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "expenses"
    ADD CONSTRAINT "expenses_currency_id_fkey" FOREIGN KEY ("currency_id") REFERENCES "currencies" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- +migrate Down
ALTER TABLE "expenses" DROP CONSTRAINT "expenses_accounting_transaction_id_fkey";
ALTER TABLE "expenses" DROP CONSTRAINT "expenses_currency_id_fkey";
DROP TABLE IF EXISTS "expenses";
```

# migrations/schemas/20230410074638-add-bank-info.sql

```sql

-- +migrate Up
alter table public.bank_accounts add column intermediary_bank_address text;
alter table public.bank_accounts add column intermediary_bank_name text;

-- +migrate Down
alter table public.bank_accounts drop column intermediary_bank_address;
alter table public.bank_accounts drop column intermediary_bank_name;

```

# migrations/schemas/20230410074637-create_service_table.sql

```sql

-- +migrate Up
CREATE TABLE IF NOT EXISTS public.operational_services (
    id            uuid PRIMARY KEY DEFAULT (uuid()),
    created_at    TIMESTAMP(6) DEFAULT NOW(),
    update_at     TIMESTAMP(6) DEFAULT NOW(),
    deleted_at    TIMESTAMP(6),
    name          TEXT,
    amount        INT8,
    currency_id   UUID REFERENCES public.currencies (id),
    note          TEXT,
    register_date DATE      DEFAULT NOW(),
    start_at      DATE      DEFAULT NOW(),
    end_at        DATE,
    is_active     BOOLEAN   DEFAULT TRUE
);
-- +migrate Down
DROP TABLE public.operational_services;

```

# migrations/schemas/20230313023454-add_missing_updated_at_field.sql

```sql

-- +migrate Up
ALTER TABLE accounting_transactions ADD COLUMN updated_at TIMESTAMP(6) DEFAULT (NOW());

-- +migrate Down
ALTER TABLE accounting_transactions DROP COLUMN updated_at;

```

# migrations/schemas/20230313023453-alter_project_members_table.sql

```sql

-- +migrate Up
ALTER TABLE project_members ADD COLUMN upsell_commission_rate DECIMAL;

-- +migrate Down
ALTER TABLE project_members DROP COLUMN IF EXISTS upsell_commission_rate;

```

# migrations/schemas/20230307184910-create_payroll_tables.sql

```sql
-- +migrate Up
UPDATE "employees"
SET "basecamp_id" = NULL
WHERE "basecamp_id" = '';
ALTER TABLE "employees"
ALTER COLUMN "basecamp_id" TYPE integer USING ("basecamp_id"::integer);

CREATE TABLE IF NOT EXISTS "base_salaries" (
    "id"                      UUID PRIMARY KEY DEFAULT (uuid()),
    "created_at"              TIMESTAMPTZ(6)   DEFAULT NOW(),
    "deleted_at"              TIMESTAMPTZ(6),

    "employee_id"             UUID,
    "contract_amount"         int8 NOT NULL    DEFAULT 0,
    "company_account_amount"  int8 NOT NULL    DEFAULT 0,
    "personal_account_amount" int8 NOT NULL    DEFAULT 0,
    "insurance_amount"        int8 NOT NULL    DEFAULT 0,
    "currency_id"             UUID,
    "effective_date"          DATE,
    "is_active"               BOOL             DEFAULT TRUE,
    "batch"                   INT4,
    "type"                    TEXT COLLATE "pg_catalog"."default",
    "category"                TEXT COLLATE "pg_catalog"."default"
);
ALTER TABLE "base_salaries"
    ADD CONSTRAINT "base_salaries_currency_id_fkey" FOREIGN KEY ("currency_id") REFERENCES "currencies" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
ALTER TABLE "base_salaries"
    ADD CONSTRAINT "base_salaries_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "employees" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
CREATE TABLE IF NOT EXISTS "accounting_categories" (
    "id"         UUID PRIMARY KEY DEFAULT (uuid()),
    "created_at" TIMESTAMPTZ(6)   DEFAULT now(),
    "updated_at" TIMESTAMPTZ(6)   DEFAULT NOW(),
    "deleted_at" TIMESTAMPTZ(6),

    "name"       TEXT COLLATE "pg_catalog"."default",
    "type"       TEXT COLLATE "pg_catalog"."default"
);

CREATE TABLE IF NOT EXISTS "employee_commissions" (
    "id"              UUID PRIMARY KEY DEFAULT (uuid()),
    "created_at"      TIMESTAMPTZ(6)   DEFAULT NOW(),
    "updated_at"      TIMESTAMPTZ(6)   DEFAULT NOW(),
    "deleted_at"      TIMESTAMPTZ(6),

    "invoice_id"      UUID NOT NULL,
    "employee_id"     UUID,
    "amount"          INT4,
    "project"         TEXT COLLATE "pg_catalog"."default",
    "conversion_rate" DECIMAL          DEFAULT 0,
    "is_paid"         BOOL             DEFAULT FALSE,
    "formula"         TEXT COLLATE "pg_catalog"."default",
    "note"            TEXT COLLATE "pg_catalog"."default",
    "paid_at"         TIMESTAMPTZ(6)
);
ALTER TABLE "employee_commissions" ADD CONSTRAINT "employee_commissions_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "employees" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

CREATE TABLE IF NOT EXISTS "employee_bonuses" (
    "id"          UUID PRIMARY KEY DEFAULT (uuid()),
    "employee_id" UUID NOT NULL,
    "amount"      INT8,
    "is_active"   BOOL             DEFAULT TRUE,
    "name"        TEXT COLLATE "pg_catalog"."default",
    "created_at"  TIMESTAMPTZ(6)     DEFAULT now()
);
ALTER TABLE "employee_bonuses"
    ADD CONSTRAINT "employee_bonuses_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "employees" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

CREATE TABLE IF NOT EXISTS "payrolls" (
    "id"                     uuid PRIMARY KEY DEFAULT (uuid()),
    "employee_id"            uuid NOT NULL,
    "total"                  int8 NOT NULL    DEFAULT 0,
    "month"                  int4,
    "year"                   int4,
    "commission_amount"      int8 NOT NULL    DEFAULT 0,
    "commission_explain"     json,
    "employee_rank_snapshot" json,
    "total_explain"          json,
    "project_bonus_amount"   int8 NOT NULL    DEFAULT 0,
    "due_date"               date,
    "project_bonus_explain"  json,
    "is_paid"                bool             DEFAULT FALSE,
    "conversion_amount"      int8 NOT NULL    DEFAULT 0,
    "base_salary_amount"     int8 NOT NULL    DEFAULT 0,
    "contract_amount"        int8
);

ALTER TABLE "payrolls" ADD CONSTRAINT "payrolls_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "employees" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

CREATE TABLE IF NOT EXISTS "project_commission_configs" (
    "id"              UUID PRIMARY KEY DEFAULT (uuid()),
    "deleted_at"      TIMESTAMP(6),
    "created_at"      TIMESTAMP(6)     DEFAULT (NOW()),
    "updated_at"      TIMESTAMP(6)     DEFAULT (NOW()),
    "project_id"      UUID,
    "position"        project_head_positions,
    "commission_rate" DECIMAL
);

ALTER TABLE "project_commission_configs" ADD CONSTRAINT "project_commission_configs_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "projects" ("id");

CREATE TABLE IF NOT EXISTS "cached_payrolls" (
    "id"       UUID PRIMARY KEY DEFAULT (uuid()),
    "month"    INT4,
    "year"     INT4,
    "batch"    INT4,
    "payrolls" JSON
);
ALTER TABLE "cached_payrolls" ADD CONSTRAINT "cached_payrolls_month_year_batch_key" UNIQUE ("month", "year", "batch");

-- +migrate Down
DROP TABLE IF EXISTS "base_salaries";
DROP TABLE IF EXISTS "accounting_categories";
DROP TABLE IF EXISTS "payrolls";
DROP TABLE IF EXISTS "employee_commissions";
DROP TABLE IF EXISTS "employee_bonuses";
DROP TABLE IF EXISTS "project_commission_configs";
DROP TABLE IF EXISTS "cached_payrolls";
DROP TABLE IF EXISTS "base_salaries";
```

# migrations/schemas/20230303090207-alter_audits_table.sql

```sql

-- +migrate Up
alter table audits
    alter column auditor_id drop not null;

-- +migrate Down
alter table audits
    alter column auditor_id set not null;

```

# migrations/schemas/20230222033838-alter_project_slots_table.sql

```sql

-- +migrate Up
ALTER TABLE project_slots ADD COLUMN note TEXT;
ALTER TABLE project_members ADD COLUMN note TEXT;

-- +migrate Down
ALTER TABLE project_members DROP COLUMN IF EXISTS note;
ALTER TABLE project_slots DROP COLUMN IF EXISTS note;

```

# migrations/schemas/20230221215626-update_content_table.sql

```sql

-- +migrate Up
ALTER TABLE contents DROP CONSTRAINT contents_employee_id_fkey;
ALTER TABLE contents DROP CONSTRAINT contents_upload_by_fkey;

ALTER TABLE contents RENAME COLUMN employee_id TO target_id;

ALTER TABLE contents ADD COLUMN target_type VARCHAR(20);

ALTER TABLE contents ADD COLUMN auth_type VARCHAR(20);


-- +migrate Down

ALTER TABLE contents RENAME COLUMN target_id TO employee_id;

ALTER TABLE contents ADD CONSTRAINT contents_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);
ALTER TABLE contents ADD CONSTRAINT contents_upload_by_fkey FOREIGN KEY (upload_by) REFERENCES employees (id);

ALTER TABLE contents DROP COLUMN target_type;

ALTER TABLE contents DROP COLUMN auth_type;


```

# migrations/schemas/20230215021807-alter_projects_table.sql

```sql

-- +migrate Up
ALTER TABLE projects ADD COLUMN "organization_id" UUID;
ALTER TABLE projects
    ADD CONSTRAINT projects_organizations_id_fkey FOREIGN KEY (organization_id) REFERENCES organizations (id);

-- +migrate Down
ALTER TABLE projects DROP CONSTRAINT IF EXISTS projects_organizations_id_fkey;
ALTER TABLE projects DROP COLUMN IF EXISTS "organization_id";

```

# migrations/schemas/20230214122834-create_api_keys_table_and_auth_permissions.sql

```sql
-- +migrate Up

CREATE TABLE IF NOT EXISTS api_keys (
    id uuid PRIMARY KEY DEFAULT(uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6) DEFAULT(NOW()),
    updated_at TIMESTAMP(6) DEFAULT(NOW()),

    client_id TEXT,
    secret_key TEXT,
    status TEXT
    );

CREATE TABLE IF NOT EXISTS api_key_roles (
    id          uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at  TIMESTAMP(6),
    created_at  TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at  TIMESTAMP(6)     DEFAULT (NOW()),
    api_key_id uuid NOT NULL,
    role_id uuid NOT NULL
    );

ALTER TABLE api_key_roles
    ADD CONSTRAINT api_key_roles_api_key_id_fkey FOREIGN KEY (api_key_id) REFERENCES api_keys (id);

ALTER TABLE api_key_roles
    ADD CONSTRAINT api_key_roles_role_id_fkey FOREIGN KEY (role_id) REFERENCES roles (id);
-- +migrate Down
DROP TABLE IF EXISTS api_key_roles;
DROP TABLE IF EXISTS api_keys;
```

# migrations/schemas/20230209143233-add_schedule.sql

```sql
-- +migrate Up
create table schedules (
    id uuid primary key default (uuid()),
    deleted_at timestamp(6),
    created_at timestamp(6) default (now()),
    updated_at timestamp(6) default (now()),
    synced_at timestamp(6) default (now()),

    name text,
    description text,
    start_time timestamp(6),
    end_time timestamp(6),
    schedule_type text
);

create table schedule_google_calendars (
    id uuid primary key default (uuid()),
    deleted_at timestamp(6),
    created_at timestamp(6) default (now()),
    updated_at timestamp(6) default (now()),

    schedule_id uuid references schedules(id),
    google_calendar_id text,
    description text,
    hangout_link text
);

create table schedule_discord_events (
    id uuid primary key default (uuid()),
    deleted_at timestamp(6),
    created_at timestamp(6) default (now()),
    updated_at timestamp(6) default (now()),

    schedule_id uuid references schedules(id),
    discord_event_id text,
    description text,
    voice_channel_id text
);

create table schedule_notion_pages (
    id uuid primary key default (uuid()),
    deleted_at timestamp(6),
    created_at timestamp(6) default (now()),
    updated_at timestamp(6) default (now()),

    schedule_id uuid references schedules(id),
    notion_page_id text,
    description text
);



-- +migrate Down
drop table schedule_discord_events;
drop table schedule_google_calendars;
drop table schedule_notion_pages;
drop table schedules;

```

# migrations/schemas/20230208143342-add_project_notion_table.sql

```sql
-- +migrate Up
DELETE FROM action_item_snapshots;
DELETE FROM audit_participants;
DELETE FROM audit_action_items;
DELETE FROM action_items;
DELETE FROM audit_items;
DELETE FROM audits;
DELETE FROM audit_cycles;
ALTER TABLE audit_cycles DROP CONSTRAINT IF EXISTS audit_cycles_project_notion_id_fkey;
ALTER TABLE audits DROP CONSTRAINT IF EXISTS audits_project_notion_id_fkey;
ALTER TABLE action_items DROP CONSTRAINT IF EXISTS action_items_project_notion_id_fkey;
ALTER TABLE action_item_snapshots DROP CONSTRAINT IF EXISTS action_item_snapshots_project_notion_id_fkey;

ALTER TABLE projects DROP COLUMN IF EXISTS "notion_id";

CREATE TABLE IF NOT EXISTS project_notions
(
    id             uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at     TIMESTAMP(6),
    created_at     TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at     TIMESTAMP(6)     DEFAULT (NOW()),
    project_id       uuid NOT NULL,
    audit_notion_id uuid
);

ALTER TABLE project_notions ADD UNIQUE (audit_notion_id);
ALTER TABLE project_notions ADD CONSTRAINT project_notions_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);
ALTER TABLE audit_cycles ADD CONSTRAINT audit_cycles_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES project_notions (audit_notion_id);
ALTER TABLE audits ADD CONSTRAINT audits_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES project_notions (audit_notion_id);
ALTER TABLE action_items ADD CONSTRAINT action_items_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES project_notions (audit_notion_id);
ALTER TABLE action_item_snapshots ADD CONSTRAINT action_item_snapshots_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES project_notions (audit_notion_id);

-- +migrate Down
ALTER TABLE audit_cycles DROP CONSTRAINT IF EXISTS audit_cycles_project_notion_id_fkey;
ALTER TABLE audits DROP CONSTRAINT IF EXISTS audits_project_notion_id_fkey;
ALTER TABLE action_items DROP CONSTRAINT IF EXISTS action_items_project_notion_id_fkey;
ALTER TABLE action_item_snapshots DROP CONSTRAINT IF EXISTS action_item_snapshots_project_notion_id_fkey;
ALTER TABLE project_notions DROP CONSTRAINT IF EXISTS project_notions_project_id_fkey;
DROP TABLE IF EXISTS project_notions;
ALTER TABLE projects ADD COLUMN "notion_id" UUID;
ALTER TABLE projects ADD UNIQUE (notion_id);
ALTER TABLE audit_cycles ADD CONSTRAINT audit_cycles_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES projects (notion_id);
ALTER TABLE audits ADD CONSTRAINT audits_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES projects (notion_id);
ALTER TABLE action_items ADD CONSTRAINT action_items_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES projects (notion_id);
ALTER TABLE action_item_snapshots ADD CONSTRAINT action_item_snapshots_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES projects (notion_id);

```

# migrations/schemas/20230208143233-add_client_company_invoice_caching_table.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS clients (
    id                  uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at          TIMESTAMP(6),
    created_at          TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at          TIMESTAMP(6)     DEFAULT (NOW()),

    name                TEXT,
    description         TEXT,
    registration_number TEXT,
    address             TEXT,
    country             TEXT,
    industry            TEXT,
    website             TEXT,
    emails              TEXT[]
);

CREATE TABLE IF NOT EXISTS client_contacts (
    id              uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at      TIMESTAMP(6)     DEFAULT (NOW()),

    name            TEXT,
    client_id       UUID,
    role            TEXT,
    metadata        JSONB,
    emails          JSONB,
    is_main_contact BOOLEAN          DEFAULT FALSE
);

CREATE TABLE IF NOT EXISTS company_infos (
    id                  uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at          TIMESTAMP(6),
    created_at          TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at          TIMESTAMP(6)     DEFAULT (NOW()),

    name                TEXT,
    description         TEXT,
    registration_number TEXT,
    info                JSONB
);

CREATE TABLE IF NOT EXISTS invoice_number_caching (
    id         uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at TIMESTAMP(6)     DEFAULT (NOW()),

    key        TEXT,
    number     INT
);

ALTER TABLE projects ADD COLUMN "client_id" UUID NULL;
ALTER TABLE projects ADD COLUMN "company_info_id" UUID NULL;

ALTER TABLE client_contacts
    ADD CONSTRAINT client_contacts_client_id_fkey FOREIGN KEY (client_id) REFERENCES clients (id);
ALTER TABLE projects
    ADD CONSTRAINT projects_client_id_fkey FOREIGN KEY (client_id) REFERENCES clients (id);
ALTER TABLE projects
    ADD CONSTRAINT projects_company_info_id_fkey FOREIGN KEY (company_info_id) REFERENCES company_infos (id);

-- +migrate Down

ALTER TABLE client_contacts
    DROP CONSTRAINT IF EXISTS client_contacts_client_id_fkey;
ALTER TABLE projects
    DROP CONSTRAINT IF EXISTS projects_client_id_fkey;
ALTER TABLE projects DROP COLUMN client_id;
ALTER TABLE projects DROP COLUMN company_info_id;

DROP TABLE IF EXISTS clients;
DROP TABLE IF EXISTS client_contacts;
DROP TABLE IF EXISTS company_infos;
DROP TABLE IF EXISTS invoice_number_caching;

```

# migrations/schemas/20230208045042-icy_treasury.sql

```sql
-- +migrate Up
CREATE TABLE "icy_treasury_categories" (
    "id"                  uuid NOT NULL DEFAULT uuid(),
    "created_at"          timestamp(8)  DEFAULT NOW(),
    "deleted_at"          timestamp(8),
    "name"                text,
    "category_manager_id" uuid,
    CONSTRAINT "icy_treasury_categories_category_manager_id_fkey" FOREIGN KEY ("category_manager_id") REFERENCES "employees" ("id"),
    PRIMARY KEY ("id")
);

CREATE TABLE "icy_transactions_out" (
    "id"             uuid NOT NULL DEFAULT uuid(),
    "created_at"     timestamp(8)  DEFAULT NOW(),
    "deleted_at"     timestamp(8),
    "amount"         text,
    "description"    text,
    "category_id"    uuid,
    "to_employee_id" uuid NOT NULL,
    "approver_id"    uuid,
    CONSTRAINT "icy_transactions_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "icy_treasury_categories" ("id"),
    CONSTRAINT "icy_transactions_to_employee_id_fkey" FOREIGN KEY ("to_employee_id") REFERENCES "employees" ("id"),
    CONSTRAINT "icy_transactions_approver_id_fkey" FOREIGN KEY ("approver_id") REFERENCES "employees" ("id"),
    PRIMARY KEY ("id")
);

CREATE TABLE "icy_transactions_in" (
    "id"          uuid NOT NULL DEFAULT uuid(),
    "created_at"  timestamp(8)  DEFAULT NOW(),
    "deleted_at"  timestamp(8),
    "date"        timestamp(8)  DEFAULT NOW(),
    "description" text,
    "amount"      text,
    "category_id" uuid,
    CONSTRAINT "icy_transactions_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "icy_treasury_categories" ("id"),
    PRIMARY KEY ("id")
);

CREATE VIEW "vw_icy_treasury_funds" AS
SELECT
	t1.category_id,
	t2.total_in - t1.total_out AS balance
FROM (
	SELECT
		category_id,
		SUM(amount::NUMERIC) AS total_out
	FROM
		icy_transactions_out ito
	GROUP BY
		category_id) t1
	JOIN (
		SELECT
			category_id,
			SUM(amount::NUMERIC) AS total_in
		FROM
			icy_transactions_in iti
		GROUP BY
			category_id) t2 ON t1.category_id = t2.category_id;


-- +migrate Down
DROP VIEW "vw_icy_treasury_funds";
DROP TABLE "icy_transactions_out";
DROP TABLE "icy_transactions_in";
DROP TABLE "icy_treasury_categories";

```

# migrations/schemas/20230207063521-alter_projects_table.sql

```sql
-- +migrate Up
ALTER TABLE projects ADD COLUMN "bank_account_id" UUID;
ALTER TABLE projects ADD CONSTRAINT projects_bank_account_id_fkey FOREIGN KEY (bank_account_id) REFERENCES bank_accounts (id);

-- +migrate Down
ALTER TABLE projects DROP CONSTRAINT IF EXISTS projects_bank_account_id_fkey;
ALTER TABLE projects DROP COLUMN IF EXISTS "bank_account_id";

```

# migrations/schemas/20230206045042-alter_employees_table.sql

```sql
-- +migrate Up
ALTER TABLE employees ADD COLUMN "referred_by" UUID;
ALTER TABLE employees ADD CONSTRAINT employees_referred_by_fkey FOREIGN KEY (referred_by) REFERENCES employees (id);

-- +migrate Down
ALTER TABLE employees DROP CONSTRAINT IF EXISTS employees_referred_by_fkey;
ALTER TABLE employees DROP COLUMN IF EXISTS "referred_by";


```

# migrations/schemas/20230201063507-init_social_accounts_table.sql

```sql

-- +migrate Up
CREATE TABLE IF NOT EXISTS social_accounts (
    id              uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at      TIMESTAMP(6)     DEFAULT (NOW()),
    employee_id     uuid,
    type            TEXT,
    account_id      TEXT, -- e.g. id use for integrate with social platform.
    name            TEXT,
    email           TEXT
);

ALTER TABLE social_accounts
    ADD CONSTRAINT social_accounts_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

-- +migrate Down
ALTER TABLE social_accounts DROP CONSTRAINT IF EXISTS social_accounts_employee_id_fkey;

DROP TABLE IF EXISTS social_accounts;

```

# migrations/schemas/20230130084819-add_organizations_table.sql

```sql

-- +migrate Up
CREATE TABLE IF NOT EXISTS organizations (
	id uuid PRIMARY KEY DEFAULT(uuid()),
	deleted_at TIMESTAMP(6),
	created_at TIMESTAMP(6) DEFAULT(NOW()),
	updated_at TIMESTAMP(6) DEFAULT(NOW()),
	name TEXT,
	code TEXT,
	avatar TEXT
);

CREATE TABLE IF NOT EXISTS employee_organizations (
    id          uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at  TIMESTAMP(6),
    created_at  TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at  TIMESTAMP(6)     DEFAULT (NOW()),
    employee_id uuid NOT NULL,
    organization_id uuid NOT NULL
);

ALTER TABLE employee_organizations
    ADD CONSTRAINT employee_organizations_organizations_id_fkey FOREIGN KEY (organization_id) REFERENCES organizations (id);

ALTER TABLE employee_organizations
    ADD CONSTRAINT employee_organizations_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

ALTER TABLE employees DROP COLUMN organization;
-- +migrate Down
ALTER TABLE employees
	ADD COLUMN organization TEXT;

DROP TABLE IF EXISTS employee_organizations;

DROP TABLE IF EXISTS organizations;


```

# migrations/schemas/20230118101417-alter_project_members_update_leftDate_joinedDate.sql

```sql

-- +migrate Up
ALTER TABLE project_members RENAME COLUMN joined_date TO start_date;
ALTER TABLE project_members RENAME COLUMN left_date TO end_date;

ALTER TABLE project_heads RENAME COLUMN joined_date TO start_date;
ALTER TABLE project_heads RENAME COLUMN left_date TO end_date;

ALTER TABLE work_unit_members RENAME COLUMN joined_date TO start_date;
ALTER TABLE work_unit_members RENAME COLUMN left_date TO end_date;

-- +migrate Down
ALTER TABLE project_members RENAME COLUMN end_date TO left_date;
ALTER TABLE project_members RENAME COLUMN start_date TO joined_date;

ALTER TABLE project_heads RENAME COLUMN end_date TO left_date;
ALTER TABLE project_heads RENAME COLUMN start_date TO joined_date;

ALTER TABLE work_unit_members RENAME COLUMN end_date TO left_date;
ALTER TABLE work_unit_members RENAME COLUMN start_date TO joined_date;

```

# migrations/schemas/20230117023858-alter_projects_table.sql

```sql
-- +migrate Up
ALTER TABLE "projects" ADD COLUMN "notion_id" UUID;
ALTER TABLE projects ADD UNIQUE (notion_id);

ALTER TABLE audit_cycles DROP CONSTRAINT IF EXISTS audit_cycles_project_id_fkey;
ALTER TABLE audits DROP CONSTRAINT IF EXISTS audits_project_id_fkey;
ALTER TABLE action_items DROP CONSTRAINT IF EXISTS action_items_project_id_fkey;
ALTER TABLE action_item_snapshots DROP CONSTRAINT IF EXISTS action_item_snapshots_project_id_fkey;

ALTER TABLE audit_cycles
    ADD CONSTRAINT audit_cycles_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES projects (notion_id);
ALTER TABLE audits
    ADD CONSTRAINT audits_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES projects (notion_id);
ALTER TABLE action_items
    ADD CONSTRAINT action_items_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES projects (notion_id);
ALTER TABLE action_item_snapshots
    ADD CONSTRAINT action_item_snapshots_project_notion_id_fkey FOREIGN KEY (project_id) REFERENCES projects (notion_id);


-- +migrate Down
ALTER TABLE audit_cycles
    ADD CONSTRAINT audit_cycles_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);
ALTER TABLE audits
    ADD CONSTRAINT audits_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);
ALTER TABLE action_items
    ADD CONSTRAINT action_items_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);
ALTER TABLE action_item_snapshots
    ADD CONSTRAINT action_item_snapshots_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);

ALTER TABLE audit_cycles DROP CONSTRAINT IF EXISTS audit_cycles_project_notion_id_fkey;
ALTER TABLE audits DROP CONSTRAINT IF EXISTS audits_project_notion_id_fkey;
ALTER TABLE action_items DROP CONSTRAINT IF EXISTS action_items_project_notion_id_fkey;
ALTER TABLE action_item_snapshots DROP CONSTRAINT IF EXISTS action_item_snapshots_project_notion_id_fkey;

ALTER TABLE "projects" DROP COLUMN "notion_id";

```

# migrations/schemas/20230109154551-init_audit_schema.sql

```sql

-- +migrate Up

CREATE TYPE audit_status AS ENUM (
    'pending',
    'audited'
    );

CREATE TYPE audit_flag AS ENUM (
    'red',
    'yellow',
    'green',
    'none'
    );

CREATE TABLE IF NOT EXISTS audit_cycles
(
    id                  uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at          TIMESTAMP(6),
    created_at          TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at          TIMESTAMP(6)     DEFAULT (NOW()),
    project_id          uuid NOT NULL,
    notion_db_id        uuid NOT NULL,
    health_audit_id     uuid             DEFAULT NULL,
    process_audit_id    uuid             DEFAULT NULL,
    backend_audit_id    uuid             DEFAULT NULL,
    frontend_audit_id   uuid             DEFAULT NULL,
    system_audit_id     uuid             DEFAULT NULL,
    mobile_audit_id     uuid             DEFAULT NULL,
    blockchain_audit_id uuid             DEFAULT NULL,
    cycle               DECIMAL          DEFAULT 0,
    average_score       DECIMAL,
    status              audit_status,
    flag                audit_flag,
    quarter             TEXT             DEFAULT NULL,
    action_item_high    DECIMAL          DEFAULT 0,
    action_item_medium  DECIMAL          DEFAULT 0,
    action_item_low     DECIMAL          DEFAULT 0,
    sync_at             TIMESTAMP(6)     DEFAULT NULL
);

ALTER TABLE audit_cycles
    ADD CONSTRAINT audit_cycles_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);

CREATE TYPE audit_type AS ENUM (
    'engineering-health',
    'engineering-process',
    'frontend',
    'backend',
    'system',
    'mobile',
    'blockchain'
    );

CREATE TABLE IF NOT EXISTS audits
(
    id           uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at   TIMESTAMP(6),
    created_at   TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at   TIMESTAMP(6)     DEFAULT (NOW()),
    project_id   uuid NOT NULL,
    notion_db_id uuid NOT NULL,
    auditor_id   uuid NOT NULL,
    name         TEXT,
    type         audit_type,
    score        DECIMAL,
    status       audit_status,
    flag         audit_flag,
    action_item  DECIMAL,
    duration     DECIMAL,
    audited_at   TIMESTAMP(6)     DEFAULT NULL,
    sync_at      TIMESTAMP(6)     DEFAULT NULL
);

ALTER TABLE audits
    ADD CONSTRAINT audits_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);
ALTER TABLE audits
    ADD CONSTRAINT audits_auditor_id_fkey FOREIGN KEY (auditor_id) REFERENCES employees (id);

CREATE TYPE severity AS ENUM (
    'high',
    'medium',
    'low'
    );

CREATE TABLE IF NOT EXISTS audit_items
(
    id             uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at     TIMESTAMP(6),
    created_at     TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at     TIMESTAMP(6)     DEFAULT (NOW()),
    audit_id       uuid NOT NULL,
    notion_db_id uuid NOT NULL,
    name           TEXT,
    area           TEXT,
    requirements   TEXT,
    grade          DECIMAL,
    severity       severity,
    notes          TEXT,
    action_item_id uuid
);

ALTER TABLE audit_items
    ADD CONSTRAINT audit_items_audit_id_fkey FOREIGN KEY (audit_id) REFERENCES audits (id);


CREATE TYPE action_item_priority AS ENUM (
    'high',
    'medium',
    'low'
    );

CREATE TYPE action_item_status AS ENUM (
    'pending',
    'in-progress',
    'done'
    );

CREATE TABLE IF NOT EXISTS action_items
(
    id             uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at     TIMESTAMP(6),
    created_at     TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at     TIMESTAMP(6)     DEFAULT (NOW()),
    project_id     uuid,
    notion_db_id   uuid,
    pic_id uuid,
    audit_cycle_id uuid,
    name           TEXT,
    description    TEXT,
    need_help      BOOLEAN,
    priority       action_item_priority,
    status         action_item_status
);

ALTER TABLE action_items
    ADD CONSTRAINT action_items_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);
ALTER TABLE action_items
    ADD CONSTRAINT action_items_audit_cycle_id_fkey FOREIGN KEY (audit_cycle_id) REFERENCES audit_cycles (id);
ALTER TABLE action_items
    ADD CONSTRAINT action_items_pic_id_fkey FOREIGN KEY (pic_id) REFERENCES employees (id);

CREATE TABLE IF NOT EXISTS audit_action_items
(
    id             uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at     TIMESTAMP(6),
    created_at     TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at     TIMESTAMP(6)     DEFAULT (NOW()),
    audit_id       uuid NOT NULL,
    action_item_id uuid NOT NULL
);

ALTER TABLE audit_action_items
    ADD CONSTRAINT audit_action_items_audit_id_fkey FOREIGN KEY (audit_id) REFERENCES audits (id);
ALTER TABLE audit_action_items
    ADD CONSTRAINT audit_action_items_action_item_id_fkey FOREIGN KEY (action_item_id) REFERENCES action_items (id);

CREATE TABLE IF NOT EXISTS action_item_snapshots
(
    id             uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at     TIMESTAMP(6),
    created_at     TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at     TIMESTAMP(6)     DEFAULT (NOW()),
    project_id     uuid NOT NULL,
    audit_cycle_id uuid NOT NULL,
    high           DECIMAL          DEFAULT 0,
    medium         DECIMAL          DEFAULT 0,
    low            DECIMAL          DEFAULT 0
);

ALTER TABLE action_item_snapshots
    ADD CONSTRAINT action_item_snapshots_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);
ALTER TABLE action_item_snapshots
    ADD CONSTRAINT action_item_snapshots_audit_cycle_id_fkey FOREIGN KEY (audit_cycle_id) REFERENCES audit_cycles (id);

CREATE TABLE IF NOT EXISTS audit_participants
(
    id             uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at     TIMESTAMP(6),
    created_at     TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at     TIMESTAMP(6)     DEFAULT (NOW()),
    audit_id       uuid NOT NULL,
    employee_id    uuid NOT NULL
);

ALTER TABLE audit_participants
    ADD CONSTRAINT audit_participants_audit_id_fkey FOREIGN KEY (audit_id) REFERENCES audits (id);
ALTER TABLE audit_participants
    ADD CONSTRAINT audit_participants_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);
    
-- +migrate Down
ALTER TABLE audit_cycles DROP CONSTRAINT IF EXISTS audit_cycles_project_id_fkey;
ALTER TABLE audits DROP CONSTRAINT IF EXISTS audits_project_id_fkey;
ALTER TABLE audits DROP CONSTRAINT IF EXISTS audits_auditor_id_fkey;
ALTER TABLE audit_items DROP CONSTRAINT IF EXISTS audit_items_audit_id_fkey;
ALTER TABLE action_items DROP CONSTRAINT IF EXISTS action_items_project_id_fkey;
ALTER TABLE action_items DROP CONSTRAINT IF EXISTS action_items_audit_cycle_id_fkey;
ALTER TABLE action_items DROP CONSTRAINT IF EXISTS action_items_pic_id_fkey;
ALTER TABLE audit_action_items DROP CONSTRAINT IF EXISTS audit_action_items_audit_id_fkey;
ALTER TABLE audit_action_items DROP CONSTRAINT IF EXISTS audit_action_items_action_item_id_fkey;
ALTER TABLE action_item_snapshots DROP CONSTRAINT IF EXISTS action_item_snapshots_project_id_fkey;
ALTER TABLE action_item_snapshots DROP CONSTRAINT IF EXISTS action_item_snapshots_audit_cycle_id_fkey;
ALTER TABLE audit_participants DROP CONSTRAINT IF EXISTS audit_participants_audit_id_fkey;
ALTER TABLE audit_participants DROP CONSTRAINT IF EXISTS audit_participants_employee_id_fkey;

DROP TABLE IF EXISTS audit_cycles;
DROP TABLE IF EXISTS audits;
DROP TABLE IF EXISTS audit_items;
DROP TABLE IF EXISTS action_items;
DROP TABLE IF EXISTS audit_action_items;
DROP TABLE IF EXISTS action_item_snapshots;
DROP TABLE IF EXISTS audit_participants;

DROP TYPE IF EXISTS audit_status;
DROP TYPE IF EXISTS audit_flag;
DROP TYPE IF EXISTS audit_type;
DROP TYPE IF EXISTS severity;
DROP TYPE IF EXISTS action_item_status;
DROP TYPE IF EXISTS action_item_priority;

```

# migrations/schemas/20230106075550-alter_table_add_missing_columns.sql

```sql

-- +migrate Up
ALTER TABLE "seniorities" ADD COLUMN "level" INT;
ALTER TABLE "employees" ADD COLUMN "organization" TEXT;

-- +migrate Down
ALTER TABLE "seniorities" DROP COLUMN "level";
ALTER TABLE "employees" DROP COLUMN "organization";

```

# migrations/schemas/20230106033812-valuation.sql

```sql
-- +migrate Up
create or replace view vw_account_receivables as
 SELECT COALESCE(vnd.vnd, 0::numeric) AS vnd,
    COALESCE(usd.usd, 0::numeric) AS usd,
    COALESCE(sgd.sgd, 0::numeric) AS sgd,
    COALESCE(eur.eur, 0::numeric) AS eur,
    COALESCE(gbp.gbp, 0::numeric) AS gbp,
    timetable.year
   FROM ( SELECT invoices.year
           FROM invoices
          GROUP BY invoices.year) timetable
     LEFT JOIN ( SELECT COALESCE(sum(invoices.total), 0::numeric) AS vnd,
            invoices.year
           FROM invoices
          WHERE (invoices.status not in ('draft', 'paid', 'error')) AND (invoices.bank_id IN ( SELECT bank_accounts.id
                   FROM bank_accounts
                  WHERE (bank_accounts.currency_id IN ( SELECT currencies.id
                           FROM currencies
                          WHERE currencies.name = 'VND'::text))))
          GROUP BY invoices.year) vnd ON timetable.year = vnd.year
     LEFT JOIN ( SELECT COALESCE(sum(invoices.total), 0::numeric) AS usd,
            invoices.year
           FROM invoices
          WHERE (invoices.status not in ('draft', 'paid', 'error')) AND (invoices.bank_id IN ( SELECT bank_accounts.id
                   FROM bank_accounts
                  WHERE (bank_accounts.currency_id IN ( SELECT currencies.id
                           FROM currencies
                          WHERE currencies.name = 'USD'::text))))
          GROUP BY invoices.year) usd ON timetable.year = usd.year
     LEFT JOIN ( SELECT COALESCE(sum(invoices.total), 0::numeric) AS sgd,
            invoices.year
           FROM invoices
          WHERE (invoices.status not in ('draft', 'paid', 'error')) AND (invoices.bank_id IN ( SELECT bank_accounts.id
                   FROM bank_accounts
                  WHERE (bank_accounts.currency_id IN ( SELECT currencies.id
                           FROM currencies
                          WHERE currencies.name = 'SGD'::text))))
          GROUP BY invoices.year) sgd ON timetable.year = usd.year
     LEFT JOIN ( SELECT COALESCE(sum(invoices.total), 0::numeric) AS eur,
            invoices.year
           FROM invoices
          WHERE (invoices.status not in ('draft', 'paid', 'error')) AND (invoices.bank_id IN ( SELECT bank_accounts.id
                   FROM bank_accounts
                  WHERE (bank_accounts.currency_id IN ( SELECT currencies.id
                           FROM currencies
                          WHERE currencies.name = 'EUR'::text))))
          GROUP BY invoices.year) eur ON timetable.year = eur.year
     LEFT JOIN ( SELECT COALESCE(sum(invoices.total), 0::numeric) AS gbp,
            invoices.year
           FROM invoices
          WHERE (invoices.status not in ('draft', 'paid', 'error')) AND (invoices.bank_id IN ( SELECT bank_accounts.id
                   FROM bank_accounts
                  WHERE (bank_accounts.currency_id IN ( SELECT currencies.id
                           FROM currencies
                          WHERE currencies.name = 'GBP'::text))))
          GROUP BY invoices.year) gbp ON timetable.year = gbp.year
  ORDER BY timetable.year DESC;

create or replace view vw_liabilities as
SELECT
	COALESCE(vnd.vnd, 0::numeric) AS vnd,
	COALESCE(usd.usd, 0::numeric) AS usd,
	COALESCE(sgd.sgd, 0::numeric) AS sgd,
	COALESCE(eur.eur, 0::numeric) AS eur,
	COALESCE(gbp.gbp, 0::numeric) AS gbp,
	timetable.year
FROM (
	SELECT
		date_part('year', liabilities.created_at) AS year
	FROM
		liabilities
	GROUP BY
		year) timetable
	LEFT JOIN (
		SELECT
			COALESCE(sum(liabilities.total), 0::numeric) AS vnd,
			date_part('year', liabilities.created_at) AS year
		FROM
			liabilities
		WHERE (liabilities.paid_at IS NULL)
		AND(liabilities.currency_id IN(
				SELECT
					id FROM currencies
				WHERE
					name = 'VND'::text))
	GROUP BY
		year) vnd ON timetable.year = vnd.year
	LEFT JOIN (
		SELECT
			COALESCE(sum(liabilities.total), 0::numeric) AS usd, date_part('year', liabilities.created_at) AS year
		FROM
			liabilities
		WHERE (liabilities.paid_at IS NULL)
		AND(liabilities.currency_id IN(
				SELECT
					id FROM currencies
				WHERE
					name = 'USD'::text))
	GROUP BY
		year) usd ON timetable.year = usd.year
	LEFT JOIN (
		SELECT
			COALESCE(sum(liabilities.total), 0::numeric) AS eur, date_part('year', liabilities.created_at) AS year
		FROM
			liabilities
		WHERE (liabilities.paid_at IS NULL)
		AND(liabilities.currency_id IN(
				SELECT
					id FROM currencies
				WHERE
					name = 'EUR'::text))
	GROUP BY
		year) eur ON timetable.year = eur.year
	LEFT JOIN (
		SELECT
			COALESCE(sum(liabilities.total), 0::numeric) AS gbp, date_part('year', liabilities.created_at) AS year
		FROM
			liabilities
		WHERE (liabilities.paid_at IS NULL)
		AND(liabilities.currency_id IN(
				SELECT
					id FROM currencies
				WHERE
					name = 'GBP'::text))
	GROUP BY
		year) gbp ON timetable.year = gbp.year
	LEFT JOIN (
		SELECT
			COALESCE(sum(liabilities.total), 0::numeric) AS sgd, date_part('year', liabilities.created_at) AS year
		FROM
			liabilities
		WHERE (liabilities.paid_at IS NULL)
		AND(liabilities.currency_id IN(
				SELECT
					id FROM currencies
				WHERE
					name = 'SGD'::text))
	GROUP BY
		year) sgd ON timetable.year = sgd.year
ORDER BY
	timetable.year DESC;


-- //////////////////////////////////////
-- VIEW INCOMES
-- //////////////////////////////////////
create or replace view vw_incomes AS
SELECT
	COALESCE(
		vnd.vnd, 0::numeric::double precision) AS vnd,
	COALESCE(
		usd.usd, 0::numeric::double precision) AS usd,
	COALESCE(
		eur.eur, 0::numeric::double precision) AS eur,
	COALESCE(
		gbp.gbp, 0::numeric::double precision) AS gbp,
	COALESCE(
		sgd.sgd, 0::numeric::double precision) AS sgd,
	timetable.month,
	timetable.year
FROM (
	SELECT
		date_part('month'::text, accounting_transactions.date) AS month,
		date_part('year'::text, accounting_transactions.date) AS year
	FROM
		accounting_transactions
	GROUP BY
		(date_part('month'::text, accounting_transactions.date)),
		(date_part('year'::text, accounting_transactions.date))) timetable
	LEFT JOIN (
		SELECT
			COALESCE(sum(t.amount), 0::numeric::double precision) AS vnd,
			date_part('year'::text, t.date) AS year,
			date_part('month'::text, t.date) AS month
		FROM
			accounting_transactions t
		WHERE
			t.category = 'In' ::text
			AND t.currency = 'VND' ::text
		GROUP BY
			(date_part('month'::text, t.date)),
			(date_part('year'::text, t.date))) vnd ON timetable.month = vnd.month
	AND timetable.year = vnd.year
	LEFT JOIN (
		SELECT
			COALESCE(sum(t.amount), 0::numeric::double precision) AS usd,
			date_part('year'::text, t.date) AS year,
			date_part('month'::text, t.date) AS month
		FROM
			accounting_transactions t
		WHERE
			t.category = 'In' ::text
			AND t.currency = 'USD' ::text
		GROUP BY
			(date_part('month'::text, t.date)),
			(date_part('year'::text, t.date))) usd ON timetable.month = usd.month
	AND timetable.year = usd.year
	LEFT JOIN (
		SELECT
			COALESCE(sum(t.amount), 0::numeric::double precision) AS eur,
			date_part('year'::text, t.date) AS year,
			date_part('month'::text, t.date) AS month
		FROM
			accounting_transactions t
		WHERE
			t.category = 'In' ::text
			AND t.currency = 'EUR' ::text
		GROUP BY
			(date_part('month'::text, t.date)),
			(date_part('year'::text, t.date))) eur ON timetable.month = eur.month
	AND timetable.year = eur.year
	LEFT JOIN (
		SELECT
			COALESCE(sum(t.amount), 0::numeric::double precision) AS gbp,
			date_part('year'::text, t.date) AS year,
			date_part('month'::text, t.date) AS month
		FROM
			accounting_transactions t
		WHERE
			t.category = 'In' ::text
			AND t.currency = 'GBP' ::text
		GROUP BY
			(date_part('month'::text, t.date)),
			(date_part('year'::text, t.date))) gbp ON timetable.month = gbp.month
	AND timetable.year = gbp.year
	LEFT JOIN (
		SELECT
			COALESCE(sum(t.amount), 0::numeric::double precision) AS sgd,
			date_part('year'::text, t.date) AS year,
			date_part('month'::text, t.date) AS month
		FROM
			accounting_transactions t
		WHERE
			t.category = 'In' ::text
			AND t.currency = 'SGD' ::text
		GROUP BY
			(date_part('month'::text, t.date)),
			(date_part('year'::text, t.date))) sgd ON timetable.month = sgd.month
	AND timetable.year = sgd.year
ORDER BY
	timetable.year DESC,
	timetable.month DESC;

create or replace view vw_expenses as
SELECT sum(t.conversion_amount) AS vnd,
	date_part('year'::text, t.date) AS year
	FROM accounting_transactions t
WHERE (t.category <> 'In'::text OR t.category IS NULL) AND t.category !~~ '%Payroll%'::text AND t.category !~~ '%Commission%'::text AND t.category !~~ '%Investment%'::text
GROUP BY (date_part('year'::text, t.date))
ORDER BY (date_part('year'::text, t.date)) DESC;

create or replace view vw_payrolls as
 SELECT COALESCE(total.total, 0::bigint) AS total,
    COALESCE(jan.jan, 0::bigint) AS jan,
    COALESCE(feb.feb, 0::bigint) AS feb,
    COALESCE(mar.mar, 0::bigint) AS mar,
    COALESCE(apr.apr, 0::bigint) AS apr,
    COALESCE(may.may, 0::bigint) AS may,
    COALESCE(jun.jun, 0::bigint) AS jun,
    COALESCE(jul.jul, 0::bigint) AS jul,
    COALESCE(aug.aug, 0::bigint) AS aug,
    COALESCE(sep.sep, 0::bigint) AS sep,
    COALESCE(oct.oct, 0::bigint) AS oct,
    COALESCE(nov.nov, 0::bigint) AS nov,
    COALESCE("dec"."dec", 0::bigint) AS "dec",
    timetable.year
   FROM ( SELECT DISTINCT date_part('year'::text, accounting_transactions.date) AS year
           FROM accounting_transactions) timetable
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS total,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text
          GROUP BY (date_part('year'::text, t.date))) total ON timetable.year = total.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS jan,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 1::double precision
          GROUP BY (date_part('year'::text, t.date))) jan ON timetable.year = jan.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS feb,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 2::double precision
          GROUP BY (date_part('year'::text, t.date))) feb ON timetable.year = feb.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS mar,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 3::double precision
          GROUP BY (date_part('year'::text, t.date))) mar ON timetable.year = mar.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS apr,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 4::double precision
          GROUP BY (date_part('year'::text, t.date))) apr ON timetable.year = apr.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS may,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 5::double precision
          GROUP BY (date_part('year'::text, t.date))) may ON timetable.year = may.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS jun,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 6::double precision
          GROUP BY (date_part('year'::text, t.date))) jun ON timetable.year = jun.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS jul,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 7::double precision
          GROUP BY (date_part('year'::text, t.date))) jul ON timetable.year = jul.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS aug,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 8::double precision
          GROUP BY (date_part('year'::text, t.date))) aug ON timetable.year = aug.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS sep,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 9::double precision
          GROUP BY (date_part('year'::text, t.date))) sep ON timetable.year = sep.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS oct,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 10::double precision
          GROUP BY (date_part('year'::text, t.date))) oct ON timetable.year = oct.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS nov,
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 11::double precision
          GROUP BY (date_part('year'::text, t.date))) nov ON timetable.year = nov.year
     LEFT JOIN ( SELECT COALESCE(sum(t.conversion_amount), 0::numeric)::bigint AS "dec",
            date_part('year'::text, t.date) AS year
           FROM accounting_transactions t
          WHERE (t.category ~~ 'Payroll %'::text OR t.category ~~ '%Commission%'::text) AND date_part('month'::text, t.date) = 12::double precision
          GROUP BY (date_part('year'::text, t.date))) "dec" ON timetable.year = "dec".year
  ORDER BY timetable.year DESC;

create or replace view vw_investments as
 SELECT
	sum(t.conversion_amount) AS vnd,
	date_part('year'::text, t.date) AS year
FROM
	accounting_transactions t
WHERE (t.category = 'Investment'::text)
GROUP BY
	(date_part('year'::text, t.date))
ORDER BY
	(date_part('year'::text, t.date))
	DESC;

-- +migrate Down
drop view if exists vw_expenses;
drop view if exists vw_incomes;
drop view if exists vw_account_receivables;
drop view if exists vw_payrolls;
drop view if exists vw_liabilities;
drop view if exists vw_investments;

```

# migrations/schemas/20230106033811-accounting.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS "accounting_transactions" (
    "id"                UUID NOT NULL DEFAULT UUID(),
    "created_at"        TIMESTAMP(6)  DEFAULT NOW(),
    "deleted_at"        TIMESTAMP(6),

    "date"              TIMESTAMP(6)  DEFAULT NOW(),
    "name"              TEXT,
    "amount"            FLOAT8,
    "currency_id"       UUID NOT NULL,
    "conversion_amount" INT8,
    "organization"      TEXT,
    "metadata"          JSON,
    "category"          TEXT,
    "currency"          TEXT,
    "conversion_rate"   FLOAT8,
    "type"              TEXT,
    PRIMARY KEY ("id")
);

ALTER TABLE "accounting_transactions" ADD CONSTRAINT "accounting_transactions_currency_id_fkey" FOREIGN KEY ("currency_id") REFERENCES "currencies" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
ALTER TABLE "accounting_transactions" ADD CONSTRAINT "transaction_info_unique" UNIQUE ("name", "date");

CREATE TABLE IF NOT EXISTS "assets" (
    "id"           UUID PRIMARY KEY NOT NULL DEFAULT UUID(),
    "created_at"   TIMESTAMP(6)              DEFAULT NOW(),
    "deleted_at"   TIMESTAMP(6),
    "name"         TEXT,
    "quantity"     TEXT,
    "price"        INT8,
    "currency_id"  UUID,
    "location"     TEXT,
    "used_by"      UUID,
    "purchased_at" date,
    "note"         TEXT,
    CONSTRAINT "assets_currency_id_fkey" FOREIGN KEY ("currency_id") REFERENCES "currencies" ("id") ON DELETE CASCADE,
    CONSTRAINT "assets_used_by_fkey" FOREIGN KEY ("used_by") REFERENCES "employees" ("id") ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS "liabilities" (
    "id"          UUID PRIMARY KEY NOT NULL DEFAULT UUID(),
    "created_at"  TIMESTAMP(6)              DEFAULT NOW(),
    "deleted_at"  TIMESTAMP(6),
    "paid_at"     TIMESTAMP(6),
    "name"        TEXT,
    "total"       FLOAT8,
    "currency_id" UUID,
    CONSTRAINT "liabilities_currency_id_fkey" FOREIGN KEY ("currency_id") REFERENCES "currencies" ("id") ON DELETE CASCADE
);

-- +migrate Down
DROP TABLE "accounting_transactions";
DROP TABLE "assets";
DROP TABLE "liabilities";

```

# migrations/schemas/20230105032842-alter_projects_table.sql

```sql

-- +migrate Up
CREATE TYPE project_functions AS ENUM (
    'development',
    'learning',
    'training',
    'management'
);
ALTER TABLE "projects" ADD COLUMN "function" project_functions;

-- +migrate Down
ALTER TABLE "projects" DROP COLUMN "function";
DROP TYPE project_functions;

```

# migrations/schemas/20230103062027-add_employee_mentees_table.sql

```sql

-- +migrate Up
CREATE TABLE employee_mentees (
    id              uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6)     DEFAULT (now()),
    updated_at      TIMESTAMP(6)     DEFAULT (now()),
    mentor_id       uuid NOT NULL,
    mentee_id       uuid NOT NULL
);

ALTER TABLE employee_mentees
    ADD CONSTRAINT employee_mentees_mentor_id_fkey FOREIGN KEY (mentor_id) REFERENCES employees (id);

ALTER TABLE employee_mentees
    ADD CONSTRAINT employee_mentees_mentee_id_fkey FOREIGN KEY (mentee_id) REFERENCES employees (id);

-- +migrate Down
ALTER TABLE employee_mentees DROP CONSTRAINT IF EXISTS employee_mentees_mentee_id_fkey;
ALTER TABLE employee_mentees DROP CONSTRAINT IF EXISTS employee_mentees_mentor_id_fkey;
DROP TABLE IF EXISTS employee_mentees;

```

# migrations/schemas/20221227042737-alter_employees_add_missing_column.sql

```sql

-- +migrate Up
ALTER TABLE "employees" ADD COLUMN "place_of_residence" TEXT;
ALTER TABLE "employees" ADD COLUMN "country" TEXT;
ALTER TABLE "employees" ADD COLUMN "city" TEXT;
ALTER TABLE "employees" ADD COLUMN "notion_email" TEXT;
ALTER TABLE "employees" ADD COLUMN "linkedin_name" TEXT;

ALTER TABLE "employees" ALTER COLUMN "gender" DROP NOT NULL;
ALTER TABLE "employees" ALTER COLUMN "avatar" DROP NOT NULL;

-- +migrate Down
ALTER TABLE "employees" DROP COLUMN "place_of_residence";
ALTER TABLE "employees" DROP COLUMN "country";
ALTER TABLE "employees" DROP COLUMN "city";
ALTER TABLE "employees" DROP COLUMN "notion_email";
ALTER TABLE "employees" DROP COLUMN "linkedin_name";

ALTER TABLE "employees" ALTER COLUMN "gender" SET NOT NULL;

```

# migrations/schemas/20221227024809-alter_project_table.sql

```sql

-- +migrate Up
ALTER TABLE "projects" ADD COLUMN "code" TEXT;
ALTER TABLE projects ADD UNIQUE (code);

-- +migrate Down
ALTER TABLE "projects" DROP CONSTRAINT IF EXISTS projects_code_key;
ALTER TABLE "projects" DROP COLUMN "code";

```

# migrations/schemas/20221221053842-add_full_text_search_employees_table.sql

```sql

-- +migrate Up
ALTER TABLE "employees" ADD COLUMN "keyword_vector" tsvector;

CREATE TEXT SEARCH DICTIONARY english_stem_nostop (
    Template = snowball
    , Language = english
);

CREATE TEXT SEARCH CONFIGURATION public.english_nostop ( COPY = pg_catalog.english );

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
   ALTER MAPPING FOR asciiword, asciihword, hword_asciipart, hword, hword_part, word WITH english_stem_nostop;

CREATE INDEX idx_employees_keyword_vector ON "employees" USING gin(keyword_vector);

-- +migrate StatementBegin
CREATE OR REPLACE FUNCTION public.fn_remove_vietnamese_accents(x text)
RETURNS text
LANGUAGE plpgsql
AS $function$
DECLARE
  accents text;
  no_accents text;
  r text;
BEGIN
  accents = 'áàảãạâấầẩẫậăắằẳẵặđéèẻẽẹêếềểễệíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵÁÀẢÃẠÂẤẦẨẪẬĂẮẰẲẴẶĐÉÈẺẼẸÊẾỀỂỄỆÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴ';
  no_accents = 'aaaaaaaaaaaaaaaaadeeeeeeeeeeeiiiiiooooooooooooooooouuuuuuuuuuuyyyyyAAAAAAAAAAAAAAAAADEEEEEEEEEEEIIIIIOOOOOOOOOOOOOOOOOUUUUUUUUUUUYYYYY';
  r = x;
  FOR i IN 0..length(accents)
  LOOP
    r = replace(r, substr(accents, i, 1), substr(no_accents, i, 1));
  END LOOP;
  RETURN r;
END;
$function$;
-- +migrate StatementEnd

-- +migrate StatementBegin
CREATE OR REPLACE FUNCTION public.fn_insert_keyword_vector ()
	RETURNS TRIGGER
	LANGUAGE plpgsql
	AS $function$
BEGIN
	NEW. "keyword_vector" = array_to_tsvector ((
			SELECT
				array_agg(DISTINCT substring(lexeme FOR len))
			FROM
				unnest(to_tsvector(fn_remove_vietnamese_accents(LOWER(COALESCE(NEW. "full_name", '') || ' ' || COALESCE(NEW. "team_email", '') || ' ' || COALESCE(NEW. "discord_id", '') || ' ' || COALESCE(NEW. "notion_id", '') || ' ' || COALESCE(NEW. "github_id", '') || ' ' || COALESCE(NEW. "notion_name", '') || ' ' || COALESCE(NEW. "discord_name", ''))))),
				generate_series(1, length(lexeme)) len));
	RETURN NEW;
END;
$function$
-- +migrate StatementEnd

CREATE TRIGGER trig_insert_keyword_vector
     BEFORE INSERT OR UPDATE ON employees
     FOR EACH ROW
     EXECUTE PROCEDURE fn_insert_keyword_vector();

UPDATE
      "employees" c
    SET
      "keyword_vector" = array_to_tsvector ((
          SELECT
            array_agg(DISTINCT substring(lexeme FOR len))
          FROM
            unnest(to_tsvector(fn_remove_vietnamese_accents(LOWER(COALESCE(c. "full_name", '') || ' ' || COALESCE(c. "team_email", '') || ' ' || COALESCE(c. "discord_id", '') || ' ' || COALESCE(c. "notion_id", '') || ' ' || COALESCE(c. "github_id", '') || ' ' || COALESCE(c. "notion_name", '') || ' ' || COALESCE(c. "discord_name", ''))))),
            generate_series(1, length(lexeme)) len));

-- +migrate Down
DROP TRIGGER IF EXISTS trig_insert_keyword_vector ON employees;
DROP FUNCTION fn_insert_keyword_vector;

ALTER TABLE "employees" DROP COLUMN "keyword_vector";
DROP TEXT SEARCH CONFIGURATION  IF EXISTS public.english_nostop;
DROP TEXT SEARCH DICTIONARY  IF EXISTS  english_stem_nostop;


```

# migrations/schemas/20221212015001-gen_username_data_for_employee.sql

```sql
-- +migrate Up
ALTER TABLE "employees" DROP CONSTRAINT IF EXISTS employees_username_key;
-- +migrate StatementBegin
UPDATE employees
SET username = SPLIT_PART(team_email, '@', 1);
-- +migrate StatementEnd
-- +migrate Down
ALTER TABLE "employees" DROP CONSTRAINT IF EXISTS employees_username_key;
UPDATE employees
SET username = NULL;

ALTER TABLE employees ADD UNIQUE (username);

```

# migrations/schemas/20221212015000-alter_table_add_missing_column.sql

```sql
-- +migrate Up
ALTER TABLE "employee_event_reviewers" DROP COLUMN "status";
ALTER TABLE "employee_event_reviewers" ADD COLUMN "author_status" TEXT;
ALTER TABLE "employee_event_reviewers" ADD COLUMN "reviewer_status" TEXT;
ALTER TABLE "employee_event_reviewers" ADD COLUMN "is_forced_done" BOOLEAN DEFAULT FALSE;
ALTER TABLE "employee_event_questions" ADD COLUMN "domain" TEXT;
ALTER TABLE "questions" ADD COLUMN "domain" TEXT;

ALTER TABLE "projects" ADD COLUMN "allows_sending_survey" BOOLEAN DEFAULT FALSE;
ALTER TABLE "projects" ADD COLUMN "avatar" TEXT;

ALTER TABLE "employees" ADD COLUMN "username" TEXT;
ALTER TABLE employees ADD UNIQUE (username);
ALTER TABLE "employees" ADD COLUMN "discord_name" TEXT;
ALTER TABLE "employees" ADD COLUMN "notion_name" TEXT;

ALTER TABLE "roles" ADD COLUMN "level" INT;

-- +migrate Down
ALTER TABLE "employee_event_reviewers" ADD COLUMN "status" TEXT;
ALTER TABLE "employee_event_reviewers" DROP COLUMN "author_status";
ALTER TABLE "employee_event_reviewers" DROP COLUMN "reviewer_status";
ALTER TABLE "employee_event_reviewers" DROP COLUMN "is_forced_done";
ALTER TABLE "employee_event_questions" DROP COLUMN "domain";
ALTER TABLE "questions" DROP COLUMN "domain";

ALTER TABLE "projects" DROP COLUMN "allows_sending_survey";
ALTER TABLE "projects" DROP COLUMN "avatar";

ALTER TABLE "employees" DROP COLUMN "username";
ALTER TABLE "employees" DROP CONSTRAINT IF EXISTS employees_username_key;
ALTER TABLE "employees" DROP COLUMN "discord_name";
ALTER TABLE "employees" DROP COLUMN "notion_name";

ALTER TABLE "roles" DROP COLUMN "level";

```

# migrations/schemas/20221205153244-init_feedbacks_schema.sql

```sql
-- +migrate Up
CREATE TYPE "event_types" AS ENUM (
    'feedback',
    'survey'
);

CREATE TYPE "event_subtypes" AS ENUM (
    'peer-review',
    'engagement',
    'work',
    'appreciation',
    'comment'
);

CREATE TYPE "relationships" AS ENUM (
    'peer',
    'line-manager',
    'chapter-lead',
    'self'
);

CREATE TABLE IF NOT EXISTS "feedback_events" (
    "id"         uuid PRIMARY KEY DEFAULT uuid(),
    "deleted_at" TIMESTAMP(6),
    "created_at" TIMESTAMP(6)     DEFAULT NOW(),
    "updated_at" TIMESTAMP(6)     DEFAULT NOW(),

    "title"      TEXT,
    "type"       event_types,
    "subtype"    event_subtypes,
    "status"     TEXT,
    "created_by" uuid NOT NULL,
    "start_date" TIMESTAMP(6),
    "end_date"   TIMESTAMP(6)
);

CREATE TABLE IF NOT EXISTS "employee_event_topics" (
    "id"          uuid PRIMARY KEY DEFAULT uuid(),
    "deleted_at"  TIMESTAMP(6),
    "created_at"  TIMESTAMP(6)     DEFAULT NOW(),
    "updated_at"  TIMESTAMP(6)     DEFAULT NOW(),

    "title"       TEXT,
    "event_id"    uuid NOT NULL,
    "employee_id" uuid NOT NULL,
    "project_id"  uuid NULL
);

CREATE TABLE IF NOT EXISTS "employee_event_reviewers" (
    "id"                      uuid PRIMARY KEY DEFAULT uuid(),
    "deleted_at"              TIMESTAMP(6),
    "created_at"              TIMESTAMP(6)     DEFAULT NOW(),
    "updated_at"              TIMESTAMP(6)     DEFAULT NOW(),

    "event_id"                uuid NOT NULL,
    "employee_event_topic_id" uuid NOT NULL,
    "reviewer_id"             uuid NOT NULL,
    "status"                  TEXT,
    "relationship"            relationships,
    "is_shared"               BOOL             DEFAULT FALSE,
    "is_read"                 BOOL             DEFAULT FALSE
);

CREATE TABLE IF NOT EXISTS "employee_event_questions" (
    "id"                         uuid PRIMARY KEY DEFAULT uuid(),
    "deleted_at"                 TIMESTAMP(6),
    "created_at"                 TIMESTAMP(6)     DEFAULT NOW(),
    "updated_at"                 TIMESTAMP(6)     DEFAULT NOW(),

    "event_id"                   uuid NOT NULL,
    "employee_event_reviewer_id" uuid NOT NULL,
    "type"                       TEXT,
    "content"                    TEXT,
    "answer"                     TEXT,
    "note"                       TEXT,
    "question_id"                uuid,
    "order"                      INT
);

CREATE TABLE IF NOT EXISTS "questions" (
    "id"          uuid PRIMARY KEY DEFAULT uuid(),
    "deleted_at"  TIMESTAMP(6),
    "created_at"  TIMESTAMP(6)     DEFAULT NOW(),
    "updated_at"  TIMESTAMP(6)     DEFAULT NOW(),

    "type"        TEXT,
    "category"    TEXT,
    "subcategory" TEXT,
    "content"     TEXT,
    "order"       INT
);

ALTER TABLE "employee_event_topics"
    ADD CONSTRAINT employee_event_topics_event_id_fkey FOREIGN KEY ("event_id") REFERENCES "feedback_events" ("id");

ALTER TABLE "employee_event_topics"
    ADD CONSTRAINT employee_event_topics_project_id_fkey FOREIGN KEY ("project_id") REFERENCES "projects" ("id");

ALTER TABLE "employee_event_questions"
    ADD CONSTRAINT employee_event_questions_employee_event_reviewer_id_fkey FOREIGN KEY ("employee_event_reviewer_id") REFERENCES "employee_event_reviewers" ("id");

ALTER TABLE "employee_event_questions"
    ADD CONSTRAINT "employee_event_questions_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "feedback_events" ("id");

ALTER TABLE "employee_event_reviewers"
    ADD CONSTRAINT "employee_event_reviewers_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "feedback_events" ("id");

ALTER TABLE "employee_event_reviewers"
    ADD CONSTRAINT employee_event_reviewers_employee_event_topic_id_fkey FOREIGN KEY ("employee_event_topic_id") REFERENCES "employee_event_topics" ("id");

ALTER TABLE "employee_event_reviewers"
    ADD CONSTRAINT employee_event_reviewers_reviewer_id_fkey FOREIGN KEY ("reviewer_id") REFERENCES "employees" ("id");

ALTER TABLE "employee_event_topics"
    ADD CONSTRAINT employee_event_topics_employee_id_fkey FOREIGN KEY ("employee_id") REFERENCES "employees" ("id");

ALTER TABLE "feedback_events"
    ADD CONSTRAINT feedback_events_created_by_fkey FOREIGN KEY ("created_by") REFERENCES "employees" ("id");

-- +migrate Down
ALTER TABLE "employee_event_topics"
    DROP CONSTRAINT IF EXISTS employee_event_topics_event_id_fkey;
ALTER TABLE "employee_event_topics"
    DROP CONSTRAINT IF EXISTS employee_event_topics_project_id_fkey;
ALTER TABLE "employee_event_questions"
    DROP CONSTRAINT IF EXISTS employee_event_questions_employee_event_reviewer_id_fkey;
ALTER TABLE "employee_event_reviewers"
    DROP CONSTRAINT IF EXISTS employee_event_reviewers_employee_event_topic_id_fkey;
ALTER TABLE "employee_event_reviewers"
    DROP CONSTRAINT IF EXISTS employee_event_reviewers_reviewer_id_fkey;
ALTER TABLE "employee_event_topics"
    DROP CONSTRAINT IF EXISTS employee_event_topics_employee_id_fkey;
ALTER TABLE "feedback_events"
    DROP CONSTRAINT IF EXISTS feedback_events_created_by_fkey;

DROP TABLE IF EXISTS "questions";
DROP TABLE IF EXISTS "employee_event_questions";
DROP TABLE IF EXISTS "employee_event_reviewers";
DROP TABLE IF EXISTS "employee_event_topics";
DROP TABLE IF EXISTS "feedback_events";

DROP TYPE IF EXISTS event_types;
DROP TYPE IF EXISTS event_subtypes;
DROP TYPE IF EXISTS relationships;

```

# migrations/schemas/20221129122450-init_work_units_schema.sql

```sql
-- +migrate Up
CREATE TYPE work_unit_types AS ENUM (
  'development',
  'management',
  'training',
  'learning'
);

CREATE TYPE work_unit_statuses AS ENUM (
  'active',
  'archived'
);

CREATE TABLE IF NOT EXISTS work_units (
    id               uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at       TIMESTAMP(6),
    created_at       TIMESTAMP(6)     DEFAULT (now()),
    updated_at       TIMESTAMP(6)     DEFAULT (now()),
    name             TEXT,
    status           work_unit_statuses,
    type             work_unit_types,
    source_url       TEXT,
    project_id       uuid NOT NULL,
    source_metadata  JSONB            DEFAULT '[]'::JSONB
);

CREATE TABLE IF NOT EXISTS work_unit_stacks (
    id                uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at        TIMESTAMP(6),
    created_at        TIMESTAMP(6)     DEFAULT (now()),
    updated_at        TIMESTAMP(6)     DEFAULT (now()),
    stack_id          uuid NOT NULL,
    work_unit_id      uuid NOT NULL
);

CREATE TABLE IF NOT EXISTS work_unit_members (
    id                uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at        TIMESTAMP(6),
    created_at        TIMESTAMP(6)     DEFAULT (now()),
    updated_at        TIMESTAMP(6)     DEFAULT (now()),
    joined_date       DATE NOT NULL,
    left_date         DATE             DEFAULT NULL,
    status            TEXT,
    project_id        uuid NOT NULL,
    employee_id       uuid NOT NULL,
    work_unit_id      uuid NOT NULL
);

ALTER TABLE work_units
    ADD CONSTRAINT work_units_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);

ALTER TABLE work_unit_stacks
    ADD CONSTRAINT work_unit_stacks_stack_id_fkey FOREIGN KEY (stack_id) REFERENCES stacks (id);

ALTER TABLE work_unit_stacks
    ADD CONSTRAINT work_unit_stacks_work_unit_id_fkey FOREIGN KEY (work_unit_id) REFERENCES work_units (id);

ALTER TABLE work_unit_members
    ADD CONSTRAINT work_unit_members_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);

ALTER TABLE work_unit_members
    ADD CONSTRAINT work_unit_members_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

ALTER TABLE work_unit_members
    ADD CONSTRAINT work_unit_members_work_unit_id_fkey FOREIGN KEY (work_unit_id) REFERENCES work_units (id);

-- +migrate Down

ALTER TABLE work_units DROP CONSTRAINT IF EXISTS work_units_project_id_fkey;
ALTER TABLE work_unit_stacks DROP CONSTRAINT IF EXISTS work_unit_stacks_stack_id_fkey;
ALTER TABLE work_unit_stacks DROP CONSTRAINT IF EXISTS work_unit_stacks_work_unit_id_fkey;
ALTER TABLE work_unit_members DROP CONSTRAINT  IF EXISTS work_unit_members_project_id_fkey;
ALTER TABLE work_unit_members DROP CONSTRAINT IF EXISTS work_unit_members_employee_id_fkey;
ALTER TABLE work_unit_members DROP CONSTRAINT  IF EXISTS work_unit_members_work_unit_id_fkey;

DROP TABLE IF EXISTS work_unit_members;
DROP TABLE IF EXISTS work_unit_stacks;
DROP TABLE IF EXISTS work_units;

DROP TYPE IF EXISTS work_unit_statuses;
DROP TYPE IF EXISTS work_unit_types;
```

# migrations/schemas/20221127165238-create_invoices_table.sql

```sql

-- +migrate Up
CREATE TABLE IF NOT EXISTS currencies (
    id uuid     PRIMARY KEY  DEFAULT (uuid()),
    deleted_at  TIMESTAMP(6),
    created_at  TIMESTAMP(6) DEFAULT (now()),
    updated_at  TIMESTAMP(6) DEFAULT (now()),
    name        TEXT,
    symbol      TEXT,
    locale      varchar(6),
    type        TEXT         DEFAULT 'fiat'::TEXT
);

CREATE TABLE IF NOT EXISTS bank_accounts (
    id uuid         PRIMARY KEY  DEFAULT (uuid()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6) DEFAULT (now()),
    updated_at  TIMESTAMP(6) DEFAULT (now()),
    account_number  TEXT NOT NULL,
    bank_name       TEXT,
    currency_id     uuid NOT NULL,
    owner_name      TEXT,
    address         TEXT,
    swift_code      TEXT,
    routing_number  varchar(255),
    name            varchar(255),
    uk_sort_code    varchar(12)
);

ALTER TABLE bank_accounts
    ADD CONSTRAINT bank_accounts_currency_id_fkey FOREIGN KEY (currency_id) REFERENCES currencies(id);


CREATE TYPE  invoice_statuses AS ENUM (
  'draft',
  'sent',
  'overdue',
  'paid',
  'error',
  'scheduled'
);

CREATE TABLE invoices (
    id                uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at        TIMESTAMP(6),
    created_at        TIMESTAMP(6)     DEFAULT (now()),
    updated_at        TIMESTAMP(6)     DEFAULT (now()),
    number            TEXT,
    due_at            TIMESTAMP(6),
    project_id        uuid NOT NULL,
    description       TEXT,
    bank_id           uuid NOT NULL,
    sub_total         int4,
    tax               int4,
    discount          int4,
    invoice_file_url  TEXT,
    error_invoice_id  uuid,
    metadata          json,
    paid_at           TIMESTAMP(6),
    note              TEXT,
    line_items        json,
    failed_at         TIMESTAMP(6),
    month             int4,
    year              int4,
    invoiced_at       date,
    status            invoice_statuses,
    email             varchar(255),
    cc                json,
    thread_id         varchar(255),
    sent_by           uuid NOT NULL,
    total             numeric,
    conversion_amount int8,
    scheduled_date    TIMESTAMP(6),
    conversion_rate   float4
);

ALTER TABLE invoices
    ADD CONSTRAINT invoices_sent_by_fkey FOREIGN KEY (sent_by) REFERENCES employees(id);

ALTER TABLE invoices
    ADD CONSTRAINT invoices_err_invoice FOREIGN KEY (error_invoice_id) REFERENCES invoices(id);

ALTER TABLE invoices
    ADD CONSTRAINT invoices_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(id);

ALTER TABLE invoices
    ADD CONSTRAINT invoices_bank_id_fkey FOREIGN KEY (bank_id) REFERENCES bank_accounts(id);

-- +migrate Down
DROP TABLE IF EXISTS invoices;
DROP TABLE IF EXISTS bank_accounts;
DROP TABLE IF EXISTS base_salaries;
DROP TABLE IF EXISTS currencies;
DROP TYPE IF EXISTS invoice_statuses;

```

# migrations/schemas/20221127165235-init_file_contents_schema.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS contents (
    id          uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at  TIMESTAMP(6),
    created_at  TIMESTAMP(6)     DEFAULT (now()),
    updated_at  TIMESTAMP(6)     DEFAULT (now()),
    type        TEXT,
    extension   TEXT,
    path        TEXT,
    upload_by   uuid,
    employee_id uuid
);

ALTER TABLE contents ADD CONSTRAINT contents_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);
ALTER TABLE contents ADD CONSTRAINT contents_upload_by_fkey FOREIGN KEY (upload_by) REFERENCES employees (id);

-- +migrate Down
ALTER TABLE contents DROP CONSTRAINT contents_employee_id_fkey;
ALTER TABLE contents DROP CONSTRAINT contents_upload_by_fkey;
DROP TABLE IF EXISTS contents;


```

# migrations/schemas/20221108214100-init_projects_schema.sql

```sql
-- +migrate Up
CREATE TYPE project_types AS ENUM (
    'time-material',
    'fixed-cost',
    'dwarves'
);

CREATE TYPE project_head_positions AS ENUM (
    'delivery-manager',
    'account-manager',
    'sale-person',
    'technical-lead'
);

CREATE TYPE project_statuses AS ENUM (
    'on-boarding',
    'active',
    'closed',
    'paused'
);

CREATE TYPE deployment_types AS ENUM (
    'shadow',
    'official',
    'part-time'
);

CREATE TYPE project_member_statuses AS ENUM (
    'pending',
    'on-boarding',
    'active',
    'inactive'
);

CREATE TABLE IF NOT EXISTS projects (
    id            uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at    TIMESTAMP(6),
    created_at    TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at    TIMESTAMP(6)     DEFAULT (NOW()),
    name          TEXT,
    type          project_types,
    start_date    DATE,
    end_date      DATE,
    status        project_statuses,
    country_id    uuid,
    client_email  TEXT,
    project_email TEXT
);

CREATE TABLE IF NOT EXISTS project_slots (
    id               uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at       TIMESTAMP(6),
    created_at       TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at       TIMESTAMP(6)     DEFAULT (NOW()),
    project_id       uuid NOT NULL,
    seniority_id     uuid NOT NULL,
    upsell_person_id uuid             DEFAULT NULL,
    deployment_type  deployment_types,
    rate             DECIMAL,
    discount         DECIMAL,
    status           TEXT
);

CREATE TABLE IF NOT EXISTS project_slot_positions (
    id              uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6)     DEFAULT (now()),
    updated_at      TIMESTAMP(6)     DEFAULT (now()),
    project_slot_id uuid NOT NULL,
    position_id     uuid NOT NULL
);

CREATE TABLE IF NOT EXISTS project_members (
    id               uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at       TIMESTAMP(6),
    created_at       TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at       TIMESTAMP(6)     DEFAULT (NOW()),
    project_id       uuid NOT NULL,
    project_slot_id  uuid NOT NULL,
    employee_id      uuid NOT NULL,
    seniority_id     uuid NOT NULL,
    joined_date      DATE NOT NULL,
    left_date        DATE             DEFAULT NULL,
    rate             DECIMAL,
    discount         DECIMAL,
    status           project_member_statuses,
    deployment_type  deployment_types,
    upsell_person_id uuid             DEFAULT NULL
);

CREATE TABLE IF NOT EXISTS project_member_positions (
    id                uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at        TIMESTAMP(6),
    created_at        TIMESTAMP(6)     DEFAULT (now()),
    updated_at        TIMESTAMP(6)     DEFAULT (now()),
    project_member_id uuid NOT NULL,
    position_id       uuid NOT NULL
);

CREATE TABLE IF NOT EXISTS project_heads (
    id              uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at      TIMESTAMP(6)     DEFAULT (NOW()),
    project_id      uuid NOT NULL,
    employee_id     uuid NOT NULL,
    joined_date     DATE NOT NULL,
    left_date       DATE             DEFAULT NULL,
    commission_rate DECIMAL,
    position        project_head_positions
);

CREATE TABLE IF NOT EXISTS project_stacks (
    id         uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at TIMESTAMP(6)     DEFAULT (NOW()),
    project_id uuid NOT NULL,
    stack_id   uuid NOT NULL
);

ALTER TABLE project_slots
    ADD CONSTRAINT project_slots_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);

ALTER TABLE project_slots
    ADD CONSTRAINT project_slots_seniority_id_fkey FOREIGN KEY (seniority_id) REFERENCES seniorities (id);

ALTER TABLE project_slots
    ADD CONSTRAINT project_slots_upsell_person_id_fkey FOREIGN KEY (upsell_person_id) REFERENCES employees (id);

ALTER TABLE project_slot_positions
    ADD CONSTRAINT project_slot_positions_project_member_id_fkey FOREIGN KEY (project_slot_id) REFERENCES project_slots (id);

ALTER TABLE project_slot_positions
    ADD CONSTRAINT project_slot_positions_position_id_fkey FOREIGN KEY (position_id) REFERENCES positions (id);

ALTER TABLE project_members
    ADD CONSTRAINT project_members_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);

ALTER TABLE project_members
    ADD CONSTRAINT project_members_project_slot_id_fkey FOREIGN KEY (project_slot_id) REFERENCES project_slots (id);

ALTER TABLE project_members
    ADD CONSTRAINT project_members_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

ALTER TABLE project_members
    ADD CONSTRAINT project_members_upsell_person_id_fkey FOREIGN KEY (upsell_person_id) REFERENCES employees (id);

ALTER TABLE project_members
    ADD CONSTRAINT project_members_seniority_id_fkey FOREIGN KEY (seniority_id) REFERENCES seniorities (id);

ALTER TABLE project_heads
    ADD CONSTRAINT project_heads_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);

ALTER TABLE project_heads
    ADD CONSTRAINT project_heads_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

ALTER TABLE project_stacks
    ADD CONSTRAINT project_stacks_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects (id);

ALTER TABLE project_stacks
    ADD CONSTRAINT project_stacks_stack_id_fkey FOREIGN KEY (stack_id) REFERENCES stacks (id);

ALTER TABLE project_member_positions
    ADD CONSTRAINT project_member_positions_project_member_id_fkey FOREIGN KEY (project_member_id) REFERENCES project_members (id);

ALTER TABLE project_member_positions
    ADD CONSTRAINT project_member_positions_position_id_fkey FOREIGN KEY (position_id) REFERENCES positions (id);

ALTER TABLE project_member_positions
    ADD CONSTRAINT project_member_positions_unique UNIQUE (project_member_id, position_id);

-- +migrate Down
ALTER TABLE project_slots DROP CONSTRAINT IF EXISTS project_slots_project_id_fkey;
ALTER TABLE project_slots DROP CONSTRAINT IF EXISTS project_slots_seniority_id_fkey;
ALTER TABLE project_slots DROP CONSTRAINT IF EXISTS project_slots_upsell_person_id_fkey;
ALTER TABLE project_slot_positions DROP CONSTRAINT IF EXISTS project_slot_positions_project_member_id_fkey;
ALTER TABLE project_slot_positions DROP CONSTRAINT IF EXISTS project_slot_positions_position_id_fkey;
ALTER TABLE project_members DROP CONSTRAINT IF EXISTS project_members_project_id_fkey;
ALTER TABLE project_members DROP CONSTRAINT IF EXISTS project_members_project_slot_id_fkey;
ALTER TABLE project_members DROP CONSTRAINT IF EXISTS project_members_employee_id_fkey;
ALTER TABLE project_members DROP CONSTRAINT IF EXISTS project_members_upsell_person_id_fkey;
ALTER TABLE project_members DROP CONSTRAINT IF EXISTS project_members_seniority_id_fkey;
ALTER TABLE project_heads DROP CONSTRAINT IF EXISTS project_heads_project_id_fkey;
ALTER TABLE project_heads DROP CONSTRAINT IF EXISTS project_heads_employee_id_fkey;
ALTER TABLE project_stacks DROP CONSTRAINT IF EXISTS project_stacks_project_id_fkey;
ALTER TABLE project_stacks DROP CONSTRAINT IF EXISTS project_stacks_stack_id_fkey;
ALTER TABLE project_member_positions DROP CONSTRAINT IF EXISTS project_member_positions_project_member_id_fkey;
ALTER TABLE project_member_positions DROP CONSTRAINT IF EXISTS project_member_positions_position_id_fkey;
ALTER TABLE project_member_positions DROP CONSTRAINT IF EXISTS project_member_positions_unique;

DROP TABLE IF EXISTS project_stacks;
DROP TABLE IF EXISTS project_heads;
DROP TABLE IF EXISTS project_member_positions;
DROP TABLE IF EXISTS project_members;
DROP TABLE IF EXISTS project_slot_positions;
DROP TABLE IF EXISTS project_slots;
DROP TABLE IF EXISTS projects;

DROP TYPE IF EXISTS project_types;
DROP TYPE IF EXISTS project_head_positions;
DROP TYPE IF EXISTS project_statuses;
DROP TYPE IF EXISTS deployment_types;
DROP TYPE IF EXISTS project_member_statuses;

```

# migrations/schemas/20221104144115-init_user_permissions_schema.sql

```sql
-- +migrate Up
CREATE TABLE IF NOT EXISTS permissions (
    id         uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (now()),
    updated_at TIMESTAMP(6)     DEFAULT (now()),
    name       TEXT,
    code       TEXT
);

CREATE TABLE IF NOT EXISTS roles (
    id         uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (now()),
    updated_at TIMESTAMP(6)     DEFAULT (now()),
    name       TEXT,
    code       TEXT
);

CREATE TABLE IF NOT EXISTS role_permissions (
    id            uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at    TIMESTAMP(6),
    created_at    TIMESTAMP(6)     DEFAULT (now()),
    updated_at    TIMESTAMP(6)     DEFAULT (now()),
    role_id       uuid NOT NULL,
    permission_id uuid NOT NULL
);

CREATE TABLE IF NOT EXISTS employee_roles (
    id          uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at  TIMESTAMP(6),
    created_at  TIMESTAMP(6)     DEFAULT (now()),
    updated_at  TIMESTAMP(6)     DEFAULT (now()),
    employee_id uuid NOT NULL,
    role_id     uuid NOT NULL
);

ALTER TABLE role_permissions
    ADD CONSTRAINT role_permissions_role_id_fkey FOREIGN KEY (role_id) REFERENCES roles (id);

ALTER TABLE role_permissions
    ADD CONSTRAINT role_permissions_permission_id_fkey FOREIGN KEY (permission_id) REFERENCES permissions (id);

ALTER TABLE employee_roles
    ADD CONSTRAINT employee_roles_role_id_fkey FOREIGN KEY (role_id) REFERENCES roles (id);

ALTER TABLE employee_roles
    ADD CONSTRAINT employee_roles_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

-- +migrate Down

ALTER TABLE role_permissions DROP CONSTRAINT IF EXISTS role_permissions_role_id_fkey;

ALTER TABLE role_permissions DROP CONSTRAINT IF EXISTS role_permissions_permission_id_fkey;

ALTER TABLE employee_roles DROP CONSTRAINT IF EXISTS employee_roles_role_id_fkey;

ALTER TABLE employee_roles DROP CONSTRAINT  IF EXISTS employee_roles_employee_id_fkey;

DROP TABLE IF EXISTS employee_roles;

DROP TABLE IF EXISTS role_permissions;

DROP TABLE IF EXISTS roles;

DROP TABLE IF EXISTS permissions;

```

# migrations/schemas/20221102153827-init_employees_schema.sql

```sql
-- +migrate Up
CREATE OR REPLACE FUNCTION uuid() RETURNS uuid
    LANGUAGE c
AS
    '$libdir/pgcrypto',
    'pg_random_uuid';

CREATE TYPE working_status AS ENUM (
    'left',
    'probation',
    'full-time',
    'contractor',
    'on-boarding'
);

CREATE TABLE IF NOT EXISTS stacks (
    id         uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at TIMESTAMP(6)     DEFAULT (NOW()),
    name       TEXT,
    code       TEXT,
    avatar     TEXT
);

CREATE TABLE IF NOT EXISTS countries (
    id         uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (now()),
    updated_at TIMESTAMP(6)     DEFAULT (now()),
    name       TEXT,
    code       TEXT,
    cities     JSONB            DEFAULT '[]'::JSONB
);

CREATE TABLE IF NOT EXISTS positions (
    id         uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (now()),
    updated_at TIMESTAMP(6)     DEFAULT (now()),
    name       TEXT,
    code       TEXT
);

CREATE TABLE IF NOT EXISTS seniorities (
    id         uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (now()),
    updated_at TIMESTAMP(6)     DEFAULT (now()),

    name       TEXT,
    code       TEXT
);

CREATE TABLE IF NOT EXISTS employees (
    id                        uuid PRIMARY KEY DEFAULT uuid(),
    deleted_at                TIMESTAMP(6),
    created_at                TIMESTAMP(6)     DEFAULT NOW(),
    updated_at                TIMESTAMP(6)     DEFAULT NOW(),
    full_name                 TEXT NOT NULL,
    display_name              TEXT NOT NULL,
    gender                    TEXT NOT NULL,
    team_email                TEXT NOT NULL,
    personal_email            TEXT NOT NULL,
    avatar                    TEXT NOT NULL,
    phone_number              TEXT,
    address                   TEXT,
    mbti                      TEXT,
    horoscope                 TEXT,
    passport_photo_front      TEXT,
    passport_photo_back       TEXT,
    identity_card_photo_front TEXT,
    identity_card_photo_back  TEXT,
    date_of_birth             DATE,
    working_status            working_status,
    joined_date               DATE,
    left_date                 DATE,
    basecamp_id               TEXT,
    basecamp_attachable_sgid  TEXT,
    gitlab_id                 TEXT,
    github_id                 TEXT,
    discord_id                TEXT,
    notion_id                 TEXT,
    wise_recipient_email      TEXT,
    wise_recipient_name       TEXT,
    wise_recipient_id         TEXT,
    wise_account_number       TEXT,
    wise_currency             TEXT,
    local_bank_branch         TEXT,
    local_bank_number         TEXT,
    local_bank_currency       TEXT,
    local_branch_name         TEXT,
    local_bank_recipient_name TEXT,
    seniority_id              uuid,
    line_manager_id           uuid
);

CREATE TABLE IF NOT EXISTS employee_positions (
    id          uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at  TIMESTAMP(6),
    created_at  TIMESTAMP(6)     DEFAULT (NOW()),
    updated_at  TIMESTAMP(6)     DEFAULT (NOW()),
    employee_id uuid NOT NULL,
    position_id uuid NOT NULL
);

CREATE TABLE employee_stacks (
    id              uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at      TIMESTAMP(6),
    created_at      TIMESTAMP(6)     DEFAULT (now()),
    updated_at      TIMESTAMP(6)     DEFAULT (now()),
    employee_id     uuid NOT NULL,
    stack_id        uuid NOT NULL
);

CREATE TABLE IF NOT EXISTS chapters (
    id         uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at TIMESTAMP(6),
    created_at TIMESTAMP(6)     DEFAULT (now()),
    updated_at TIMESTAMP(6)     DEFAULT (now()),
    name       TEXT,
    code       TEXT,
    lead_id    uuid
);

CREATE TABLE IF NOT EXISTS employee_chapters (
    id          uuid PRIMARY KEY DEFAULT (uuid()),
    deleted_at  TIMESTAMP(6),
    created_at  TIMESTAMP(6)     DEFAULT (now()),
    updated_at  TIMESTAMP(6)     DEFAULT (now()),
    employee_id uuid NOT NULL,
    chapter_id  uuid NOT NULL
);

ALTER TABLE employees
    ADD CONSTRAINT employees_seniority_id_fkey FOREIGN KEY (seniority_id) REFERENCES seniorities (id);

ALTER TABLE employees
    ADD CONSTRAINT employee_line_manager_id_fkey FOREIGN KEY (line_manager_id) REFERENCES employees (id);

ALTER TABLE employee_positions
    ADD CONSTRAINT employee_positions_position_id_fkey FOREIGN KEY (position_id) REFERENCES positions (id);

ALTER TABLE employee_positions
    ADD CONSTRAINT employee_positions_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

ALTER TABLE employee_stacks
    ADD CONSTRAINT employee_stacks_stack_id_fkey FOREIGN KEY (stack_id) REFERENCES stacks (id);

ALTER TABLE employee_stacks
    ADD CONSTRAINT employee_stacks_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

ALTER TABLE employee_chapters
    ADD CONSTRAINT employee_chapters_chapter_id_fkey FOREIGN KEY (chapter_id) REFERENCES chapters (id);

ALTER TABLE employee_chapters
    ADD CONSTRAINT employee_chapters_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES employees (id);

ALTER TABLE chapters
    ADD CONSTRAINT chapters_lead_id_fkey FOREIGN KEY (lead_id) REFERENCES employees (id);

-- +migrate Down
ALTER TABLE employees DROP CONSTRAINT IF EXISTS employees_seniority_id_fkey;
ALTER TABLE employees DROP CONSTRAINT IF EXISTS employees_chapter_id_fkey;
ALTER TABLE employees DROP CONSTRAINT IF EXISTS employee_line_manager_id_fkey;
ALTER TABLE employee_positions DROP CONSTRAINT IF EXISTS employee_positions_position_id_fkey;
ALTER TABLE employee_positions DROP CONSTRAINT IF EXISTS employee_positions_employee_id_fkey;
ALTER TABLE employee_stacks DROP CONSTRAINT IF EXISTS employee_stacks_stack_id_fkey;
ALTER TABLE employee_stacks DROP CONSTRAINT IF EXISTS employee_stacks_employee_id_fkey;
ALTER TABLE employee_chapters DROP CONSTRAINT IF EXISTS employee_chapters_chapter_id_fkey;
ALTER TABLE employee_chapters DROP CONSTRAINT IF EXISTS employee_chapters_employee_id_fkey;
ALTER TABLE chapters DROP CONSTRAINT IF EXISTS chapters_lead_id_fkey;

DROP TABLE IF EXISTS employee_chapters;
DROP TABLE IF EXISTS chapters;
DROP TABLE IF EXISTS employee_stacks;
DROP TABLE IF EXISTS employee_positions;
DROP TABLE IF EXISTS seniorities;
DROP TABLE IF EXISTS positions;
DROP TABLE IF EXISTS stacks;
DROP TABLE IF EXISTS countries;
DROP TABLE IF EXISTS employees;

DROP TYPE IF EXISTS working_status;

```

# pkg/utils/timeutil/util_test.go

```go
package timeutil

import (
	"reflect"
	"testing"
	"time"
)

func TestLastDayOfMonth(t *testing.T) {
	testcases := []struct {
		name    string
		month   int
		year    int
		wantDay int
	}{
		{
			name:    "case last day is 31",
			month:   8,
			year:    2019,
			wantDay: 31,
		},
		{
			name:    "case last day is 30",
			month:   9,
			year:    2019,
			wantDay: 30,
		},
		{
			name:    "case last day is 29",
			month:   2,
			year:    2020,
			wantDay: 29,
		},
		{
			name:    "case last day is 28",
			month:   2,
			year:    2019,
			wantDay: 28,
		},
	}
	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			out := LastDayOfMonth(tc.month, tc.year)
			if out.Day() != tc.wantDay {
				t.Errorf("timeutil.LastDayOfMonth() want output: %v, got output: %v", tc.wantDay, out.Day())
			}
		})
	}
}

func TestLastMonthYear(t *testing.T) {
	testcases := []struct {
		name      string
		month     int
		year      int
		wantMonth int
		wantYear  int
	}{
		{
			name:      "case same year",
			month:     8,
			year:      2019,
			wantMonth: 7,
			wantYear:  2019,
		},
		{
			name:      "case different year",
			month:     1,
			year:      2020,
			wantMonth: 12,
			wantYear:  2019,
		},
	}
	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			m, y := LastMonthYear(tc.month, tc.year)
			if m != tc.wantMonth || y != tc.wantYear {
				t.Errorf("timeutil.LastMonthYear() want output: %v/%v, got output: %v/%v", tc.wantYear, tc.wantMonth, y, m)
			}
		})
	}
}

func TestCountWeekendDays(t *testing.T) {
	testcases := []struct {
		name    string
		from    time.Time
		to      time.Time
		wantDay int
	}{
		{
			name:    "case in one month",
			from:    time.Date(2020, time.January, 1, 0, 0, 0, 0, time.Now().Location()),
			to:      time.Date(2020, time.January, 31, 0, 0, 0, 0, time.Now().Location()),
			wantDay: 8,
		},
		{
			name:    "case from date is weekend",
			from:    time.Date(2020, time.January, 12, 0, 0, 0, 0, time.Now().Location()),
			to:      time.Date(2020, time.January, 31, 0, 0, 0, 0, time.Now().Location()),
			wantDay: 5,
		},
		{
			name:    "case two different months",
			from:    time.Date(2020, time.January, 15, 0, 0, 0, 0, time.Now().Location()),
			to:      time.Date(2020, time.February, 24, 0, 0, 0, 0, time.Now().Location()),
			wantDay: 12,
		},
		{
			name:    "case two different year",
			from:    time.Date(2019, time.December, 23, 0, 0, 0, 0, time.Now().Location()),
			to:      time.Date(2020, time.January, 17, 0, 0, 0, 0, time.Now().Location()),
			wantDay: 6,
		},
		{
			name:    "case from > to",
			from:    time.Date(2020, time.January, 17, 0, 0, 0, 0, time.Now().Location()),
			to:      time.Date(2019, time.December, 23, 0, 0, 0, 0, time.Now().Location()),
			wantDay: 6,
		},
	}
	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			days := CountWeekendDays(tc.from, tc.to)
			if days != tc.wantDay {
				t.Errorf("timeutil.CountWeekendDays() want output: %v, got output: %v", tc.wantDay, days)
			}
		})
	}
}

func TestChunkDateRange(t *testing.T) {
	// Set the time zone for the test
	utc := time.UTC

	startDate := time.Date(2023, time.January, 1, 0, 0, 0, 0, utc)
	endDate := time.Date(2023, time.January, 31, 0, 0, 0, 0, utc)

	expectedWeeks := [][2]time.Time{
		{
			time.Date(2023, time.January, 2, 0, 0, 0, 0, utc),
			time.Date(2023, time.January, 6, 0, 0, 0, 0, utc),
		},
		{
			time.Date(2023, time.January, 9, 0, 0, 0, 0, utc),
			time.Date(2023, time.January, 13, 0, 0, 0, 0, utc),
		},
		{
			time.Date(2023, time.January, 16, 0, 0, 0, 0, utc),
			time.Date(2023, time.January, 20, 0, 0, 0, 0, utc),
		},
		{
			time.Date(2023, time.January, 23, 0, 0, 0, 0, utc),
			time.Date(2023, time.January, 27, 0, 0, 0, 0, utc),
		},
		{
			time.Date(2023, time.January, 30, 0, 0, 0, 0, utc),
			time.Date(2023, time.January, 31, 0, 0, 0, 0, utc),
		},
	}

	resultWeeks := ChunkDateRange(startDate, endDate)

	if !reflect.DeepEqual(resultWeeks, expectedWeeks) {
		t.Errorf("Result weeks do not match expected weeks.\nExpected: %v\nGot: %v", expectedWeeks, resultWeeks)
	}
}

```

# pkg/utils/timeutil/util.go

```go
package timeutil

import (
	"errors"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/jinzhu/now"
)

const dataFormat = "2006-01-02"

var months = [...]string{
	"january",
	"february",
	"march",
	"april",
	"may",
	"june",
	"july",
	"august",
	"september",
	"october",
	"november",
	"december",
}

// WeekdayDuration returns duration (in day) between 2 weekdays.
// mon - tue = 2 - 1 = 1
// mon - fri = 5 - 1 = 4
// mon - mon = 0 - 0 + 7 = 7
// mon - sun = 0 - 1 + 7 = 6
func WeekdayDuration(from, to time.Weekday) time.Duration {
	offset := to - from
	if from >= to {
		offset += 7
	}
	return time.Duration(offset) * 24 * time.Hour
}

// GetQuarterFromMonth get quarter from month
func GetQuarterFromMonth(m time.Month) int {
	switch {
	case m < 4:
		return 1
	case m < 7:
		return 2
	case m < 10:
		return 3
	default:
		return 4
	}
}

// IsCurrentMonth is a function checking whether a given month and year is current month
func IsCurrentMonth(m, y int) bool {
	if int(time.Now().Month()) != m {
		return false
	}
	if time.Now().Year() != y {
		return false
	}

	return true
}

// BeginningOfYear return first day of the year
func BeginningOfYear(year int) time.Time {
	return time.Date(year, time.January, 1, 0, 0, 0, 0, time.Now().Location())
}

// EndOfYear return last day of the year
func EndOfYear(year int) time.Time {
	return BeginningOfYear(year).AddDate(1, 0, 0).Add(-time.Nanosecond)
}

// ParseStringToDate parse string input as date format to time.Time
func ParseStringToDate(s string) (*time.Time, error) {
	t, err := time.Parse(dataFormat, s)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

// ParseStringToDateWithFormat parse string input as date format to time.Time with input format
func ParseStringToDateWithFormat(s, format string) (*time.Time, error) {
	if s == "" {
		return nil, nil
	}

	t, err := time.Parse(format, s)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

// IsSameDay indicate same day (ignore hour, minutes, seconds, ...)
func IsSameDay(a, b time.Time) bool {
	return a.Year() == b.Year() &&
		a.Month() == b.Month() &&
		a.Day() == b.Day()
}

// ParseTimeToDateFormat parse time input to yyyy-mm-dd format
func ParseTimeToDateFormat(t *time.Time) string {
	str := t.String()
	results := strings.Split(str, " ")
	return results[0]
}

// LastDayOfMonth return value type time.Time
// of the last day from input month and year
func LastDayOfMonth(month, year int) time.Time {
	return now.New(time.Date(year, time.Month(month), 1, 0, 0, 0, 0, time.Now().Location())).EndOfMonth()
}

func FirstDayOfMonth(month, year int) time.Time {
	return now.New(time.Date(year, time.Month(month), 1, 0, 0, 0, 0, time.Now().Location())).Time
}

func LastFridayOfMonth(month, year int) int {
	d := time.Date(year, time.Month(month)+1, 1, 0, 0, 0, 0, time.UTC).Add(-24 * time.Hour)
	d = d.Add(-time.Duration((d.Weekday()+7-time.Friday)%7) * 24 * time.Hour)
	return d.Day()
}

func FormatDatetime(t time.Time) string {
	date := strconv.Itoa(t.Day())
	switch t.Day() % 10 {
	case 1:
		date += "st"
	case 2:
		date += "nd"
	case 3:
		date += "rd"
	default:
		date += "th"
	}
	return fmt.Sprintf("%v %v, %v", t.Month().String(), date, t.Year())
}

func LastMonthYear(month, year int) (int, int) {
	if month == 1 {
		return 12, year - 1
	}
	return month - 1, year
}

func ParseWithMultipleFormats(s string) (*time.Time, error) {
	formats := []string{time.RFC3339, "2006-01-02", "02-01-2006", "2-1-2006", "02/01/2006", "2/1/2006"}
	for i := range formats {
		t, err := time.Parse(formats[i], s)
		if err == nil {
			return &t, nil
		}
	}
	return nil, fmt.Errorf(`parsing time %s does not match any remaining time format`, s)
}

func GetMonthFromString(s string) (int, error) {
	for i := range months {
		if strings.ToLower(s) == months[i] {
			return i + 1, nil
		}
	}
	return 0, fmt.Errorf(`%s is not a month`, s)
}

func GetMonthAndYearOfNextMonth() (month, year int) {
	nextMonth := time.Now().AddDate(0, 1, 0)
	return int(nextMonth.Month()), nextMonth.Year()
}

func CountWeekendDays(from, to time.Time) int {
	if from.After(to) {
		temp := from
		from = to
		to = temp
	}
	weekend := 0
	for i := from; i.Before(to); i = i.AddDate(0, 0, 1) {
		if i.Weekday() == time.Saturday || i.Weekday() == time.Sunday {
			weekend++
		}
	}
	return weekend
}

// GetStartDayOfWeek get monday 00:00:00
// Example: today: 2023-05-12 07:34:21
// return 2023-05-08 00:00:00
// weekday value
// sunday = 0
// moday = 1
// tuesday = 2
// ...
func GetStartDayOfWeek(tm time.Time) time.Time {
	weekday := time.Duration(tm.Weekday())
	if weekday == 0 {
		weekday = 7
	}
	year, month, day := tm.Date()
	currentStartDay := time.Date(year, month, day, 0, 0, 0, 0, time.Local) // return 2023-05-12 00:00:00

	return currentStartDay.Add(-1 * (weekday - 1) * 24 * time.Hour)
}

// GetEndDayOfWeek get sunday 23:59:59
// Example: today: 2023-05-12 07:34:21
// return 2023-05-14 23:59:59
// weekday value
// sunday = 0
// moday = 1
// tuesday = 2
// ...
func GetEndDayOfWeek(tm time.Time) time.Time {
	weekday := time.Duration(tm.Weekday())
	if weekday == 0 {
		weekday = 7
	}
	year, month, day := tm.Date()
	currentEndDay := time.Date(year, month, day, 23, 59, 59, 0, time.Local) // return 2023-05-12 00:00:00
	return currentEndDay.Add((7 - weekday) * 24 * time.Hour)
}

// in curl special character need to be convert to ascii
//
//	Example: curl --request GET \
//	  --url 'http://localhost:8200/api/v1/vault/55/transaction?start_time=2023-05-08T00%3A00%3A00%2B07%3A00&end_time=2023-05-14T23%3A59%3A59%2B07%3A00'
func FormatDateForCurl(isoTime string) string {
	isoTime = strings.ReplaceAll(isoTime, ":", "%3A")
	isoTime = strings.ReplaceAll(isoTime, "+", "%2B")
	return isoTime
}

// GetTimeRange parses the time range from a string
// Example time range format: 13/01/2020 - 17/01/2020
// Returns err if failed to parse
func GetTimeRange(timeString string) ([]*time.Time, error) {
	var startDate, endDate *time.Time

	// string input is not a time range
	if !isTimeRange(timeString) {
		startDate = tryParseTime(timeString)
		if startDate != nil {
			return []*time.Time{startDate}, nil
		}
		return nil, errors.New("cannot parse time")
	}

	// If in time range format
	ranges := strings.Split(timeString, "-")
	if len(ranges) < 2 {
		return nil, errors.New("cannot parse wrong time range format")
	}
	startDate = tryParseTime(ranges[0])
	endDate = tryParseTime(ranges[1])

	if startDate == nil || endDate == nil {
		return nil, errors.New("cannot parse time")
	}

	return []*time.Time{startDate, endDate}, nil
}

func isTimeRange(s string) bool {
	// This regexp will validate whether s string input is a time range
	// Example time range format: 13/01/2020 - 17/01/2020
	// Explain regexp:
	// (0[1-9] | [1-9] | [1-2][0-9] | 3[0-1]) / (0[1-9] | [1-9] | 1[0-2]) / (20[0-9]{2})
	// (01->09 OR 1->9 OR 10->29 OR 30->31) / 01->09 OR 1->9 OR 10->12 / 20(00->99)
	// (day) / (month) / (year)
	timeRangeRegexp := regexp.MustCompile(`(0[1-9]|[1-9]|[1-2][0-9]|3[0-1])/(0[1-9]|[1-9]|1[0-2])/(20[0-9]{2}) - (0[1-9]|[1-9]|[1-2][0-9]|3[0-1])/(0[1-9]|[1-9]|1[0-2])/(20[0-9]{2})`)
	return timeRangeRegexp.FindStringSubmatch(s) != nil
}

func tryParseTime(timeString string) *time.Time {
	timeString = strings.TrimSpace(timeString)
	time, err := time.Parse("2/1/2006", timeString)
	if err != nil {
		return nil
	}
	return &time
}

func ChunkDateRange(start, end time.Time) [][2]time.Time {
	var weeks [][2]time.Time

	currentDate := start
	for currentDate.Before(end) || currentDate.Equal(end) {
		if currentDate.Weekday() >= time.Monday && currentDate.Weekday() <= time.Friday {
			weekStart := currentDate
			for currentDate.Weekday() >= time.Monday && currentDate.Weekday() <= time.Friday && (currentDate.Before(end) || currentDate.Equal(end)) {
				currentDate = currentDate.AddDate(0, 0, 1)
			}
			weekEnd := currentDate.AddDate(0, 0, -1)

			weeks = append(weeks, [2]time.Time{weekStart, weekEnd})
		} else {
			currentDate = currentDate.AddDate(0, 0, 1)
		}
	}

	return weeks
}

```

# pkg/utils/mailutils/mailutils.go

```go
package mailutils

import (
	"errors"
	"regexp"
	"strings"
)

// email regex
var (
	emailRegex        = "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$"
	teamEmailRegex    = ".+@((dwarvesv\\.com)|(d\\.foundation))"
	oldTeamEmailRegex = ".+@((dwarvesv\\.com))"
)

// Regex : validate regex
func Regex(regex, sample string) error {
	c, err := regexp.Compile(regex)
	if err != nil {
		return err
	}
	if !c.MatchString(sample) {
		return errors.New("invalid input")
	}

	return nil
}

// Email validate
func Email(email string) bool {
	err := Regex(emailRegex, email)
	return err == nil
}

func IsDwarvesMail(mail string) bool {
	regex, _ := regexp.Compile(teamEmailRegex)
	return regex.MatchString(mail)
}

func IsOldDwarvesMail(mail string) bool {
	regex, _ := regexp.Compile(oldTeamEmailRegex)
	return regex.MatchString(mail)
}

func TransformToNewDomainEmail(email string) string {
	if IsOldDwarvesMail(email) {
		mailParts := strings.Split(email, "@")
		return mailParts[0] + "@d.foundation"
	}

	return email
}

```

# pkg/utils/testhelper/db_test.go

```go
package testhelper

import (
	"testing"

	_ "github.com/lib/pq"
	"github.com/stretchr/testify/require"
)

func TestLoadFixture(t *testing.T) {
	tests := []struct {
		name string
	}{
		{
			name: "success",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			require.NotNil(t, LoadTestDB())
		})
	}
}

```

# pkg/utils/testhelper/db.go

```go
package testhelper

import (
	"database/sql"
	"fmt"
	"os"
	"strings"
	"sync"
	"testing"

	"github.com/go-testfixtures/testfixtures/v3"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/require"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

var (
	db              *gorm.DB
	fixtures        *testfixtures.Loader
	singletonTestDB sync.Once
)

func LoadTestDB() *gorm.DB {
	var err error
	var conn *sql.DB

	singletonTestDB.Do(func() {
		// initiate logger
		l := logger.NewLogrusLogger()

		conn, err = sql.Open("postgres", "host=localhost port=35432 user=postgres password=postgres dbname=fortress_local_test sslmode=disable")
		if err != nil {
			l.Fatalf(err, "failed to open database connection")
			return
		}

		path, err := os.Getwd()
		if err != nil {
			l.Error(err, "unable to get dir")
		}
		fmt.Println(path) // for example /home/user

		// load fixture and restore db
		fixtures, err = testfixtures.New(
			testfixtures.Database(conn),
			testfixtures.Dialect("postgres"),
			testfixtures.Directory("../../../migrations/test_seed"),
		)
		if err != nil {
			l.Fatalf(err, "failed to load fixture")
			return
		}

		if err = fixtures.Load(); err != nil {
			l.Fatalf(err, "failed to load fixture")
			return
		}

		db, err = gorm.Open(postgres.New(
			postgres.Config{Conn: conn}),
			&gorm.Config{
				NamingStrategy: schema.NamingStrategy{
					SingularTable: false,
				},
			})
		if err != nil {
			l.Fatalf(err, "gorm: failed to open database connection")
		}
	})

	return db
}

func TestWithTxDB(t *testing.T, callback func(tx store.DBRepo)) {
	var appDB store.DBRepo
	var err error
	var conn *sql.DB

	conn, err = sql.Open("postgres", "host=localhost port=35432 user=postgres password=postgres dbname=fortress_local_test sslmode=disable")
	require.NoError(t, err)
	db, err := gorm.Open(postgres.New(
		postgres.Config{Conn: conn}),
		&gorm.Config{
			NamingStrategy: schema.NamingStrategy{
				SingularTable: false,
			},
		})
	require.NoError(t, err)

	sqlDB, err := db.DB()
	require.NoError(t, err)
	defer sqlDB.Close()

	appDB = store.NewTestRepo(db)
	newTx := appDB.DB().Begin()
	defer newTx.Rollback()
	appDB.SetNewDB(newTx)
	callback(appDB)
}

func LoadTestSQLFile(t *testing.T, txRepo store.DBRepo, fileName string) {
	file, err := os.ReadFile(fileName)
	require.NoError(t, err)
	for _, q := range strings.Split(string(file), ";") {
		q := strings.TrimSpace(q)
		if q == "" {
			continue
		}
		err = txRepo.DB().Exec(q).Error
		require.NoError(t, err)
	}
}

```

# pkg/utils/authutils/auth_test.go

```go
package authutils

import (
	"testing"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

func TestGenerateJWTToken(t *testing.T) {
	type args struct {
		info      *model.AuthenticationInfo
		expiresAt int64
		secretKey string
	}
	tests := []struct {
		name    string
		args    args
		want    string
		wantErr bool
	}{
		{
			name: "happy case",
			args: args{
				info: &model.AuthenticationInfo{
					UserID: "2655832e-f009-4b73-a535-64c3a22e558f",
				},
				expiresAt: 4823407476,
				secretKey: "JWTSecretKey",
			},
			want:    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjQ4MjM0MDc0NzYsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiIiwiZW1haWwiOiIifQ.lPYfCDdI7J7lgCEzGLr3xEL80AzcCQ3KtmeIrsEkuB4",
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := GenerateJWTToken(tt.args.info, tt.args.expiresAt, tt.args.secretKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("GenerateJWTToken() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("GenerateJWTToken() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGetUserIDFromToken(t *testing.T) {
	cfg := config.LoadTestConfig()
	type args struct {
		tokenString string
	}
	tests := []struct {
		name    string
		args    args
		want    string
		wantErr bool
	}{
		{
			name: "happy case",
			args: args{
				tokenString: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjQ4MjM0MDc0NzYsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiIiwiZW1haWwiOiIifQ.lPYfCDdI7J7lgCEzGLr3xEL80AzcCQ3KtmeIrsEkuB4",
			},
			want:    "2655832e-f009-4b73-a535-64c3a22e558f",
			wantErr: false,
		},
		{
			name: "invalid token case",
			args: args{
				tokenString: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjEwLCJpZCI6IjI2NTU4MzJlLWYwMDktNGI3My1hNTM1LTY0YzNhMjJlNTU4ZiIsImF2YXRhciI6IiIsImVtYWlsIjoiIn0.jGnI2bJks8uYV0Siwt-NFj-RpC2ZdHBiAG-iVBZWfLU",
			},
			want:    "",
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := GetUserIDFromToken(&cfg, tt.args.tokenString)
			if (err != nil) != tt.wantErr {
				t.Errorf("GetUserIDFromToken() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("GetUserIDFromToken() = %v, want %v", got, tt.want)
			}
		})
	}
}

```

# pkg/utils/authutils/auth.go

```go
package authutils

import (
	"encoding/base64"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v4"
	gonanoid "github.com/matoous/go-nanoid"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils"
)

const (
	alphabet        = "abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNPQRSTUVWXYZ123456789"
	ClientIDLength  = 24
	SecretKeyLength = 32
)

// GenerateJWTToken ...
func GenerateJWTToken(info *model.AuthenticationInfo, expiresAt int64, secretKey string) (string, error) {
	info.ExpiresAt = expiresAt
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, info)
	encryptedToken, err := token.SignedString([]byte(secretKey))
	if err != nil {
		return "", err
	}
	return encryptedToken, nil
}

func GenerateUniqueNanoID(length int) (string, error) {
	rs, err := gonanoid.Generate(alphabet, length)
	if err != nil {
		return "", err
	}
	return rs, nil
}

func GenerateHashedKey(key string) (string, error) {
	val := strings.TrimSpace(key)
	hashedKey, err := bcrypt.GenerateFromPassword([]byte(val), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hashedKey), nil
}

func ExtractAPIKey(apiKey string) (string, string, error) {
	clientID, key := "", ""

	decodedStr, err := base64.StdEncoding.DecodeString(apiKey)
	if err != nil {
		return "", "", err
	}

	decodedAPIKey := string(decodedStr)
	clientID = decodedAPIKey[:ClientIDLength]
	key = decodedAPIKey[ClientIDLength:]

	return clientID, key, nil
}

func ValidateHashedKey(hashedKey string, key string) error {
	return bcrypt.CompareHashAndPassword([]byte(hashedKey), []byte(key))
}

func GetUserIDFromToken(cfg *config.Config, tokenString string) (string, error) {
	claims := model.AuthenticationInfo{}
	token, err := jwt.ParseWithClaims(tokenString, &claims, func(token *jwt.Token) (interface{}, error) {
		return []byte(cfg.JWTSecretKey), nil
	})

	if !token.Valid {
		return "", utils.ErrInvalidToken
	}
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			return "", utils.ErrInvalidSignature
		}
		return "", utils.ErrBadToken
	}
	if time.Unix(claims.ExpiresAt, 0).Before(time.Now()) {
		return "", utils.ErrInvalidToken
	}
	return claims.UserID, nil
}

func GetUserIDFromContext(c *gin.Context, cfg *config.Config) (string, error) {
	accessToken, err := GetTokenFromRequest(c)
	if err != nil {
		return "", err
	}

	if IsAPIKey(c) {
		return "", nil
	}

	return GetUserIDFromToken(cfg, accessToken)
}

func GetTokenFromRequest(c *gin.Context) (string, error) {
	headers := strings.Split(c.Request.Header.Get("Authorization"), " ")
	if len(headers) != 2 {
		return "", utils.ErrUnexpectedAuthorizationHeader
	}
	switch headers[0] {
	case "Bearer":
		return headers[1], nil
	case "ApiKey":
		return headers[1], nil
	default:
		return "", utils.ErrAuthenticationTypeHeaderInvalid
	}
}

func IsAPIKey(c *gin.Context) bool {
	return strings.HasPrefix(c.Request.Header.Get("Authorization"), "ApiKey")
}

func HasPermission(perms map[string]string, requiredPerm model.PermissionCode) bool {
	_, ok := perms[requiredPerm.String()]

	return ok
}

func GetLoggedInUserInfo(c *gin.Context, storeDB *store.Store, db *gorm.DB, cfg *config.Config) (*model.CurrentLoggedUserInfo, error) {
	if IsAPIKey(c) {
		accessToken, err := GetTokenFromRequest(c)
		if err != nil {
			return nil, err
		}

		clientID, key, err := ExtractAPIKey(accessToken)
		if err != nil {
			return nil, err
		}

		apikey, err := storeDB.APIKey.GetByClientID(db, clientID)
		if err != nil {
			return nil, err
		}

		if apikey.Status != model.ApikeyStatusValid {
			return nil, err
		}

		err = ValidateHashedKey(apikey.SecretKey, key)
		if err != nil {
			return nil, err
		}

		perms, err := storeDB.Permission.GetByApiKeyID(db, apikey.ID.String())
		if err != nil {
			return nil, err
		}

		return &model.CurrentLoggedUserInfo{
			UserID:      clientID,
			Permissions: model.ToPermissionMap(perms),
		}, nil
	}

	userID, err := GetUserIDFromContext(c, cfg)
	if err != nil {
		return nil, err
	}

	e, err := storeDB.Employee.One(db, userID, false)
	if err != nil {
		return nil, err
	}

	perms, err := storeDB.Permission.GetByEmployeeID(db, userID)
	if err != nil {
		return nil, err
	}

	//Get a map of the project and managed flag if they are lead of project.

	projects, err := storeDB.Project.GetByEmployeeID(db, userID)
	if err != nil {
		return nil, err
	}

	projectMap := make(map[model.UUID]*model.Project)
	for _, p := range projects {
		projectMap[p.ID] = p
	}

	rs := &model.CurrentLoggedUserInfo{
		UserID:      userID,
		Permissions: model.ToPermissionMap(perms),
		Projects:    projectMap,
		Role:        e.EmployeeRoles[0].Role.Code,
	}

	return rs, nil
	//return userID, model.ToPermissionMap(perms), projectMap, nil
}

```

# pkg/utils/stringutils/strings.go

```go
package stringutils

import (
	"regexp"
	"strings"

	"github.com/dwarvesf/fortress-api/pkg/constant"
)

func ExtractPattern(str string, pattern string) []string {
	re := regexp.MustCompile(pattern)
	matches := re.FindAllStringSubmatch(str, -1)
	var result []string
	for _, match := range matches {
		result = append(result, match[1])
	}

	return result
}

func ExtractEmailPattern(str string) []string {
	re := regexp.MustCompile(constant.RegexPatternEmail)
	matches := re.FindAllStringSubmatch(str, -1)
	var result []string
	for _, match := range matches {
		result = append(result, match[0])
	}

	return result
}

func ExtractNumber(str string) []string {
	re := regexp.MustCompile(constant.RegexPatternNumber)
	matches := re.FindAllStringSubmatch(str, -1)
	var result []string
	for _, match := range matches {
		result = append(result, match[0])
	}

	return result
}

func FormatString(str string) string {
	// Replace spaces with a single space
	re := regexp.MustCompile(`\s+`)
	formattedStr := re.ReplaceAllString(str, " ")

	// Remove spaces after the "#" symbol
	formattedStr = strings.ReplaceAll(formattedStr, "# ", "#")

	return formattedStr
}

```

# pkg/service/youtube/youtube.go

```go
package youtube

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	"golang.org/x/oauth2"
	"google.golang.org/api/option"
	"google.golang.org/api/youtube/v3"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type youtubeService struct {
	config    *oauth2.Config
	token     *oauth2.Token
	service   *youtube.Service
	appConfig *config.Config
}

// New function return Google service
func New(config *oauth2.Config, appConfig *config.Config) IService {
	return &youtubeService{
		config:    config,
		appConfig: appConfig,
	}
}

func (yt *youtubeService) prepareService() error {
	client := yt.config.Client(context.Background(), yt.token)
	service, err := youtube.NewService(context.Background(), option.WithHTTPClient(client))
	if err != nil {
		return errors.New("Get Youtube Service Failed " + err.Error())
	}

	yt.service = service

	return nil
}

func (yt *youtubeService) ensureToken(refreshToken string) error {
	token := &oauth2.Token{
		RefreshToken: refreshToken,
	}

	if !yt.token.Valid() {
		tks := yt.config.TokenSource(context.Background(), token)
		tok, err := tks.Token()
		if err != nil {
			return err
		}

		yt.token = tok
	}

	return nil
}

// CreateBroadcast function create broadcast on youtube
func (yt *youtubeService) CreateBroadcast(e *model.Event) (err error) {
	// Load the Vietnam timezone location
	location, err := time.LoadLocation("Asia/Ho_Chi_Minh")
	if err != nil {
		return err
	}
	// Get the current time in the Vietnam timezone
	t := time.Now().In(location)
	// check if the event is before 17h, then set the broadcast to 17h in Vietnam
	if t.Hour() < 17 {
		// set the broadcast to 17h in timezone vietnam
		t = time.Date(t.Year(), t.Month(), t.Day(), 17, 0, 0, 0, location)
	}

	// Insert broadcast
	return yt.insertBroadcast(e, t)
}

func (yt *youtubeService) insertBroadcast(e *model.Event, startTime time.Time) error {
	if err := yt.ensureToken(yt.appConfig.Youtube.RefreshToken); err != nil {
		return err
	}

	if err := yt.prepareService(); err != nil {
		return err
	}

	liveBroadcast := &youtube.LiveBroadcast{
		Snippet: &youtube.LiveBroadcastSnippet{
			Title:              e.Name,
			Description:        e.Description,
			ScheduledStartTime: startTime.Format(time.RFC3339),
		},
		Status: &youtube.LiveBroadcastStatus{
			PrivacyStatus: "unlisted",
		},
	}

	lbc, err := yt.service.LiveBroadcasts.Insert([]string{"snippet", "status"}, liveBroadcast).Do()
	if err != nil {
		return err
	}

	if e.Image == "" {
		return nil
	}

	// download by url and open the image file
	imgPath := fmt.Sprintf("/tmp/%v.png", e.Image)
	err = yt.downloadImage(fmt.Sprintf("https://cdn.discordapp.com/guild-events/%v/%v.png?size=4096", e.DiscordEventID, e.Image), imgPath)
	if err != nil {
		return err
	}

	// Upload a thumbnail
	file, err := os.Open(imgPath)
	if err != nil {
		return err
	}
	defer file.Close()

	thumbnailCall := yt.service.Thumbnails.Set(lbc.Id)
	_, err = thumbnailCall.Media(file).Do()
	if err != nil {
		return err
	}

	return nil
}

func (yt *youtubeService) downloadImage(url, filepath string) error {
	// Get the data
	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("error downloading image: %w", err)
	}
	defer resp.Body.Close()

	// Create the file
	out, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("error creating file: %w", err)
	}
	defer out.Close()

	// Write the body to file
	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return fmt.Errorf("error saving image: %w", err)
	}

	return nil
}

// get the latest broadcast
func (yt *youtubeService) GetLatestBroadcast() (*youtube.LiveBroadcast, error) {
	if err := yt.ensureToken(yt.appConfig.Youtube.RefreshToken); err != nil {
		return nil, err
	}

	if err := yt.prepareService(); err != nil {
		return nil, err
	}

	broadcasts, err := yt.listBroadcasts("completed")
	if err != nil {
		return nil, err
	}

	if len(broadcasts) == 0 {
		return nil, nil
	}

	return broadcasts[0], nil
}

// listBroadcasts function list all broadcasts on youtube
// status: all, active, completed, upcoming
func (yt *youtubeService) listBroadcasts(status string) ([]*youtube.LiveBroadcast, error) {
	if err := yt.ensureToken(yt.appConfig.Youtube.RefreshToken); err != nil {
		return nil, err
	}

	if err := yt.prepareService(); err != nil {
		return nil, err
	}

	broadcasts, err := yt.service.LiveBroadcasts.List([]string{"id", "snippet", "status"}).BroadcastStatus(status).Do()
	if err != nil {
		return nil, err
	}

	return broadcasts.Items, nil
}

```

# pkg/service/youtube/interface.go

```go
package youtube

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"google.golang.org/api/youtube/v3"
)

// IService interface contain related google calendar method
type IService interface {
	GetLatestBroadcast() (*youtube.LiveBroadcast, error)
	CreateBroadcast(*model.Event) (err error)
}

```

# pkg/service/wise/wise.go

```go
package wise

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

var (
	// default for now
	client = http.Client{
		Timeout: 5 * time.Second,
	}
)

const (
	// api version
	apiV1 = "v1/"

	// get quote url
	quotes = "quotes"

	// get transfer rates
	rates = "rates"
)

type wiseService struct {
	sync.Mutex
	cacheMap map[string]float64
	profile  string
	cfg      *config.Config
	l        logger.Logger
}

func New(cfg *config.Config, l logger.Logger) IService {
	client := &wiseService{
		cfg:      cfg,
		l:        l,
		profile:  cfg.Wise.Profile,
		cacheMap: make(map[string]float64),
	}
	go client.janitor()
	return client
}

func (w *wiseService) janitor() {
	t := time.NewTicker(5 * time.Minute)
	for {
		<-t.C
		w.Lock()
		w.cacheMap = map[string]float64{}
		w.Unlock()
	}
}

func (w *wiseService) Convert(amount float64, sourceCurrency, targetCurrency string) (float64, float64, error) {
	rate, err := w.GetRate(sourceCurrency, targetCurrency)
	if err != nil {
		return 0, 0, err
	}

	return amount * rate, rate, nil
}

func (w *wiseService) GetRate(sourceCurrency, targetCurrency string) (float64, error) {
	if sourceCurrency == targetCurrency {
		return 1, nil
	}
	return w.getTWRate(sourceCurrency, targetCurrency)
}

func (w *wiseService) getTWRate(sourceCurrency, targetCurrency string) (float64, error) {
	// if run_mode is non-prod, we use mock data
	if w.cfg.Env != "prod" {
		sourceRate, err := getLocalRate(sourceCurrency)
		if err != nil {
			return 0, err
		}
		targetRate, err := getLocalRate(targetCurrency)
		if err != nil {
			return 0, err
		}
		return targetRate / sourceRate, nil
	}

	var conversionRate []model.WiseConversionRate

	l := w.l.Fields(logger.Fields{
		"handler": "wise",
		"method":  "getTWRate",
	})

	// try to get from cache to reduce api call
	rate := w.getCache(sourceCurrency + targetCurrency)
	if rate != 0 {
		return rate, nil
	}

	// build up request
	url := fmt.Sprintf("%v?source=%v&target=%v", w.getUrl(rates), sourceCurrency, targetCurrency)
	req, err := w.newRequest("GET", url, nil)
	if err != nil {
		l.Error(err, "can't build request")
		return 0, err
	}

	client := http.Client{
		Timeout: 5 * time.Second,
	}

	// read response
	resp, err := client.Do(req)
	if err != nil {
		l.Error(err, "can't get response")
		return 0, err
	}
	defer resp.Body.Close()
	body := resp.Body
	res, err := io.ReadAll(body)
	if err != nil {
		l.Error(err, "can't read response")
		return 0, err
	}

	err = json.Unmarshal(res, &conversionRate)
	if len(conversionRate) == 0 {
		l.Fields(logger.Fields{"msg": string(res)}).Error(err, "can't unmarshal response")
		return 0, errors.New("cannot get exchange rates")
	}

	// save to cache for further request within 5 minutes
	w.setCache(sourceCurrency+targetCurrency, conversionRate[0].Rate)

	return conversionRate[0].Rate, nil
}

// ///////////////////
// INTERNAL FUNCTIONS
// ///////////////////
func (w *wiseService) getCache(key string) float64 {
	if rate, ok := w.cacheMap[key]; ok {
		return rate
	}
	return 0
}

func (w *wiseService) setCache(key string, val float64) {
	w.Lock()
	defer w.Unlock()
	w.cacheMap[key] = val
}

// getLocalRate get conversion rate without making api call, for non-prod env
func getLocalRate(target string) (float64, error) {
	switch target {
	case "USD":
		return 1, nil
	case "CAD":
		return 1.34275, nil
	case "GBP":
		return 0.79185, nil
	case "EUR":
		return 0.89795, nil
	case "VND":
		return 23416, nil
	case "SGD":
		return 1.3845, nil
	}
	return 1, nil
}

func (w *wiseService) getUrl(api string) string {
	return w.cfg.Wise.Url + apiV1 + api
}

func (w *wiseService) getAuthHeader() string {
	return "Bearer " + w.cfg.Wise.APIKey
}

func (w *wiseService) newRequest(method, url string, body io.Reader) (*http.Request, error) {
	req, err := http.NewRequest(method, url, body)
	req.Header.Set("Authorization", w.getAuthHeader())
	req.Header.Set("Content-Type", "application/json")
	return req, err
}

func (w *wiseService) GetPayrollQuotes(sourceCurrency, targetCurrency string, targetAmount float64) (*model.TWQuote, error) {
	var q *model.TWQuote
	if w.cfg.Env != "prod" {
		return &model.TWQuote{
			SourceAmount: 0,
			Fee:          0,
			Rate:         0,
		}, nil
	}

	// Todo: (hnh)
	payload := strings.NewReader(fmt.Sprintf("{\n\t\"profile\": %v,\n\t\"source\": \"%s\",\n\t\"target\": \"%s\",\n\t\"rateType\": \"FIXED\",\n\t\"targetAmount\": %v,\n\t\"type\": \"BALANCE_PAYOUT\"\n}", w.profile, sourceCurrency, targetCurrency, targetAmount))

	req, _ := w.newRequest("POST", w.getUrl(quotes), payload)

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	body := resp.Body

	res, _ := io.ReadAll(body)

	return q, json.Unmarshal(res, &q)
}

```

# pkg/service/wise/interface.go

```go
package wise

import "github.com/dwarvesf/fortress-api/pkg/model"

type IService interface {
	Convert(amount float64, source, target string) (convertedAmount float64, rate float64, error error)
	GetPayrollQuotes(sourceCurrency, targetCurrency string, targetAmount float64) (*model.TWQuote, error)
	GetRate(source, target string) (rate float64, err error)
}

```

# pkg/service/vault/vault.go

```go
package vault

import (
	"fmt"
	"strconv"

	"github.com/dwarvesf/fortress-api/pkg/config"
	vault "github.com/hashicorp/vault/api"
)

type Vault struct {
	data map[string]interface{}
}

func New(cfg *config.Config) (IService, error) {
	defaultConfig := vault.DefaultConfig()
	defaultConfig.Address = cfg.Vault.Address

	client, err := vault.NewClient(defaultConfig)
	if err != nil {
		return nil, fmt.Errorf("unable to initialize Vault client: %v", err)
	}

	client.SetToken(cfg.Vault.Token)

	secret, err := client.Logical().Read(cfg.Vault.Path)
	if err != nil {
		return nil, fmt.Errorf("unable to read secret: %v", err)
	}

	data, ok := secret.Data["data"].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("unable to read secret data")
	}

	return &Vault{
		data: data,
	}, nil
}

func (v *Vault) GetString(key string) string {
	value, _ := v.data[key].(string)
	return value
}

func (v *Vault) GetBool(key string) bool {
	data, _ := v.data[key].(string)
	value, _ := strconv.ParseBool(data)
	return value
}

```

# pkg/service/vault/interface.go

```go
package vault

type IService interface {
	GetString(key string) string
	GetBool(key string) bool
}

```

# pkg/service/sendgrid/sendgrid.go

```go
package sendgrid

import (
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/sendgrid/sendgrid-go"
	"github.com/sendgrid/sendgrid-go/helpers/mail"
)

type IService interface {
	SendEmail(*model.Email) error
}

type sendgridClient struct {
	client *sendgrid.Client
	cfg    *config.Config
	l      logger.Logger
}

func New(key string, cfg *config.Config, l logger.Logger) IService {
	client := sendgrid.NewSendClient(key)
	return &sendgridClient{
		client: client,
		cfg:    cfg,
		l:      l,
	}
}

func (s *sendgridClient) SendEmail(email *model.Email) error {
	// boundary check to make sure we don't mess up
	if s.cfg.Env != "prod" {
		email.To = []*mail.Email{
			mail.NewEmail("Minh Luu", "leo@d.foundation"),
			// mail.NewEmail("Nikki", "nikki@d.foundation"),
		}
		email.Bcc = []*mail.Email{}
	}
	m := mail.NewV3Mail()
	m.SetFrom(email.From)
	m.AddContent(mail.NewContent("text/html", email.HTMLContent))
	m.AddCategories(email.Categories...)

	personalization := mail.NewPersonalization()
	personalization.Subject = email.Subject
	personalization.AddTos(email.To...)
	personalization.AddBCCs(email.Bcc...)

	m.AddPersonalizations(personalization)

	s.l.Infof("Sending email", m.Personalizations)
	response, err := s.client.Send(m)
	if err != nil {
		s.l.Error(err, "SendEmail() failed with ")
		return err
	}

	if response.StatusCode != http.StatusOK && response.StatusCode != http.StatusAccepted {
		s.l.Error(err, "Email not sent")
		return err
	}

	return nil
}

```

# pkg/service/reddit/new.go

```go
package reddit

import (
	"fmt"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/vartanbeno/go-reddit/v2/reddit"
)

type service struct {
	client *reddit.Client
}

func New(cfg *config.Config, l logger.Logger) (IService, error) {
	clientID := cfg.Reddit.ClientID
	if clientID == "" {
		l.Warn("reddit client id is empty")
	}

	clientSecret := cfg.Reddit.ClientSecret
	if clientSecret == "" {
		l.Warn("reddit client secret is empty")
	}

	username := cfg.Reddit.Username
	if username == "" {
		l.Warn("reddit username is empty")
	}

	password := cfg.Reddit.Password
	if password == "" {
		l.Warn("reddit password is empty")
	}

	auth := reddit.Credentials{
		ID:       clientID,
		Secret:   clientSecret,
		Username: username,
		Password: password,
	}

	client, err := reddit.NewClient(auth, reddit.WithUserAgent("fortress-bot"))
	if err != nil {
		return nil, fmt.Errorf("create reddit client failed: %w", err)
	}

	return &service{
		client: client,
	}, nil
}

```

# pkg/service/reddit/interface.go

```go
package reddit

import (
	"context"

	"github.com/vartanbeno/go-reddit/v2/reddit"
)

type IService interface {
	// FetchGolangNews fetches the latest Golang news posts and filters the rising posts from the new posts.
	FetchGolangNews(ctx context.Context) ([]*reddit.Post, error)
}

```

# pkg/service/reddit/fetch_go_news.go

```go
package reddit

import (
	"context"

	"github.com/vartanbeno/go-reddit/v2/reddit"
)

const (
	redditGolangChannel = "golang"
)

// FetchGolangNews fetches the latest Golang news posts from the rising posts.
func (s *service) FetchGolangNews(ctx context.Context) ([]*reddit.Post, error) {
	risingPosts, _, err := s.client.Subreddit.RisingPosts(ctx, redditGolangChannel, &reddit.ListOptions{
		Limit: 50,
	})
	if err != nil {
		return nil, err
	}

	return risingPosts, nil
}

```

# pkg/service/ogifmemosummarizer/interface.go

```go
package ogifmemosummarizer

type IService interface {
	SummarizeOGIFMemo(youtubeURL string) (content string, err error)
}

```

# pkg/service/ogifmemosummarizer/dify.go

```go
package ogifmemosummarizer

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/config"
)

type difyService struct {
	appConfig *config.Config
}

// New function return dify service
func New(appConfig *config.Config) IService {
	return &difyService{
		appConfig: appConfig,
	}
}

// BaseEvent represents the common fields in the event
type BaseEvent struct {
	Event          string `json:"event,omitempty"`
	ConversationID string `json:"conversation_id,omitempty"`
	MessageID      string `json:"message_id,omitempty"`
	CreatedAt      int64  `json:"created_at,omitempty"`
	TaskID         string `json:"task_id,omitempty"`
	ID             string `json:"id,omitempty"`
	Position       int    `json:"position,omitempty"`
}

// AgentThought represents the specific fields for agent_thought events
type AgentThought struct {
	BaseEvent
	Thought      string      `json:"thought,omitempty"`
	Observation  string      `json:"observation,omitempty"`
	Tool         string      `json:"tool,omitempty"`
	ToolLabels   interface{} `json:"tool_labels,omitempty"`
	ToolInput    string      `json:"tool_input,omitempty"`
	MessageFiles interface{} `json:"message_files,omitempty"`
}

// AgentMessage represents the specific fields for agent_message events
type AgentMessage struct {
	BaseEvent
	Answer string `json:"answer,omitempty"`
}

func (d *difyService) SummarizeOGIFMemo(youtubeURL string) (content string, err error) {
	// Define the URL and request body
	requestBody, err := json.Marshal(map[string]interface{}{
		"inputs":          map[string]interface{}{},
		"query":           youtubeURL,
		"response_mode":   "streaming",
		"conversation_id": "",
		"user":            "abc-123",
	})
	if err != nil {
		return "", err
	}

	// Create the HTTP request
	req, err := http.NewRequest("POST", d.appConfig.Dify.URL, bytes.NewBuffer(requestBody))
	if err != nil {
		return "", nil
	}

	// Set the required headers
	req.Header.Set("Authorization", "Bearer "+d.appConfig.Dify.Token)
	req.Header.Set("Content-Type", "application/json")

	// Send the request using http.Client
	client := &http.Client{Timeout: 5 * time.Minute}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// Check the response status
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	// Handle streaming response
	fmt.Println("Streaming response...")
	thoughts := []AgentThought{}
	reader := bufio.NewReader(resp.Body)
	for {
		line, err := reader.ReadBytes('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return "", err
		}

		// Remove the "data: " prefix
		line = bytes.TrimPrefix(line, []byte("data: "))
		line = bytes.TrimSpace(line)
		if len(line) == 0 {
			continue
		}

		// Parse the JSON event to a map to determine the event type
		var rawEvent map[string]interface{}
		err = json.Unmarshal(line, &rawEvent)
		if err != nil {
			fmt.Printf("Error unmarshal: %v\n", string(line))
			continue
		}

		eventType, ok := rawEvent["event"].(string)
		if !ok {
			fmt.Println("Error: event type is missing or not a string")
			continue
		}

		// Process specific event types
		switch eventType {
		case "agent_thought":
			var event AgentThought
			err = json.Unmarshal(line, &event)
			if err != nil {
				fmt.Printf("Error parsing agent_thought JSON: %v\n", err)
				continue
			}
			thoughts = append(thoughts, event)
		case "agent_message":
			// just ignore agent_message event
			// var event AgentMessage
			// err = json.Unmarshal(line, &event)
			// if err != nil {
			// 	fmt.Printf("Error parsing agent_message JSON: %v\n", err)
			// 	continue
			// }
			// fmt.Printf("Agent Message: %s\n", event.Answer)
		default:
			// fmt.Printf("Unknown event type: %s\n", eventType)
		}
	}

	// get the last event
	if len(thoughts) == 0 {
		return "", fmt.Errorf("no thought found")
	}

	fmt.Println("Processing thoughts...")
	for i := len(thoughts) - 1; i >= 0; i-- {
		if thoughts[i].Thought != "" {
			content = thoughts[i].Thought
			break
		}
	}

	fmt.Println("Completed processing thoughts")
	return content, nil
}

```

# pkg/service/notion/template.go

```go
package notion

// MJMLChangelogTemplate is the template for the MJML email
const MJMLChangelogTemplate = ` <mjml> <mj-head> <mj-title>Changelog Email</mj-title> <mj-attributes> <mj-all font-family="Helvetica, sans-serif"></mj-all> <mj-section padding="0px"></mj-section>
      <mj-text font-weight="400" font-size="12px" line-height="16px" font-family="helvetica"></mj-text>
    </mj-attributes>
  </mj-head>
  <mj-body>
    <mj-section padding="20px 0">
      <mj-column>
        %s
      </mj-column>
    </mj-section>
    <mj-section>
      <mj-column>
        <mj-table>
          <tr>
            <td style="font-family: arial, helvetica, sans-serif; font-size: 12px; font-style: normal; font-weight: 400; line-height: 16px; color: #222222; max-width: 640px;">
              <p style="font-family: arial, helvetica, sans-serif;
            font-style: normal;
            font-weight: 400;
            font-size: 11px;
            line-height: 14px;
            margin-top: 10px;
            margin-bottom: 10px;
            color: #222222;">View full archive at <a href="%s">%s</a>.</p>
              <p style="font-family: arial, helvetica, sans-serif;
            font-style: italic;
            font-weight: 400;
            font-size: 11px;
            line-height: 14px;
            color: #222222;
            margin-top: 10px;
            margin-bottom: 10px;">Copyright © 2023 Dwarves,
                LLC, All rights reserved.</p>
              <p style="font-family: arial, helvetica, sans-serif;
            font-style: normal;
            font-weight: 400;
            font-size: 11px;
            line-height: 14px;
            margin-top: 10px;
            margin-bottom: 10px;
            color: #222222;">You're receiving this because we
                would love to have you as a part of the journey. If
                you don't want to be on the list, you can
                unsubscribe.</p>
              <p style="font-family: Helvetica;
            font-style: normal;
            font-weight: 700;
            font-size: 11px;
            line-height: 14px;
            color: #222222;">My mailing address is:</p>
              <p style="font-family: Helvetica;
            font-style: normal;
            font-weight: 400;
            font-size: 11px;
            line-height: 14px;
            color: #222222;">Hado Centrosa Garden</p>
              <p style="font-family: Helvetica;
            font-style: normal;
            font-weight: 400;
            font-size: 11px;
            line-height: 14px;
            color: #222222;">200 3/2 street</p>
              <p style="font-family: Helvetica;
            font-style: normal;
            font-weight: 400;
            font-size: 11px;
            line-height: 14px;
            color: #222222;">District 10</p>
              <p style="font-family: Helvetica;
            font-style: normal;
            font-weight: 400;
            font-size: 11px;
            line-height: 14px;
            color: #222222;">Ho Chi Minh City</p>
              <p style="font-family: Helvetica;
            font-style: normal;
            font-weight: 400;
            font-size: 11px;
            line-height: 14px;
            color: #222222;">Vietnam</p>
            </td>
          </tr>
        </mj-table>
      </mj-column>
    </mj-section>
  </mj-body>
</mjml>
`

// MJMLDFUpdateTemplate is the template for the Dwarves Updates email
const MJMLDFUpdateTemplate = ` <mjml> <mj-head> <mj-title>Changelog Email</mj-title> <mj-attributes> <mj-all font-family="Helvetica, sans-serif"></mj-all> <mj-section padding="0px"></mj-section>
      <mj-text font-weight="400" font-size="14px" line-height="18px" font-family="helvetica"></mj-text>
    </mj-attributes>
  </mj-head>
  <mj-body>
    <mj-section padding="20px 0">
      <mj-column>
        %s
      </mj-column>
    </mj-section>
    <mj-section>
      <mj-column>
        <mj-table>
          <tr>
            <td style="font-family: arial, helvetica, sans-serif; font-size: 12px; font-style: normal; font-weight: 400; line-height: 16px; color: #222222; max-width: 640px;">
              <p style="font-family: arial, helvetica, sans-serif;
            font-style: italic;
            font-weight: 400;
            font-size: 11px;
            line-height: 14px;
            color: #222222;
            margin-top: 10px;
            margin-bottom: 10px;">Copyright © 2023 Dwarves,
                LLC, All rights reserved.</p>
              <p style="font-family: arial, helvetica, sans-serif;
            font-style: normal;
            font-weight: 400;
            font-size: 11px;
            line-height: 14px;
            margin-top: 10px;
            margin-bottom: 10px;
            color: #222222;">You're receiving this because we
                would love to have you as a part of the journey. If you don't want to be on the list, reply this email with "Unsubscribe".</p>
            </td>
          </tr>
        </mj-table>
      </mj-column>
    </mj-section>
  </mj-body>
</mjml>
`

```

# pkg/service/notion/notion.go

```go
package notion

import (
	"context"
	"errors"
	"fmt"
	"strings"

	nt "github.com/dstotijn/go-notion"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils"
)

type notionService struct {
	notionClient *nt.Client
	projectsDBID string
	l            logger.Logger
}

func New(secret, projectID string, l logger.Logger) IService {
	return &notionService{
		notionClient: nt.NewClient(secret),
		projectsDBID: projectID,
		l:            l,
	}
}

// GetBlock implements IService
func (n *notionService) GetBlock(pageID string) (blockResponse nt.Block, err error) {
	ctx := context.Background()

	res, err := n.notionClient.FindBlockByID(ctx, pageID)
	if err != nil {
		return nil, err
	}

	return res, nil
}

// ToChangelogMJML implements Service
func (n *notionService) ToChangelogMJML(blocks []nt.Block, email model.Email) (string, error) {
	var resutl string
	for i, block := range blocks {
		switch v := block.(type) {
		case *nt.Heading1Block:
			// get array of plain text
			var plainText []string
			for _, text := range v.RichText {
				plainText = append(plainText, text.PlainText)
			}

			resutl = resutl + fmt.Sprintf(`<mj-text padding-bottom="0px" line-height="30px">
     	     <h1 style="font-weight: bold"> 
			 %s
					</h1>
        </mj-text>`, strings.Join(plainText, " "))
		case *nt.Heading2Block:
			// get array of plain text
			var plainText []string
			for _, text := range v.RichText {
				plainText = append(plainText, text.PlainText)
			}

			resutl = resutl + fmt.Sprintf(`<mj-text padding-bottom="0px" line-height="28px">
		  <h2 style="font-weight: bold"> 
		 %s
				</h2>
	</mj-text>`, strings.Join(plainText, " "))
		case *nt.Heading3Block:
			// get array of plain text
			var plainText []string
			for _, text := range v.RichText {
				plainText = append(plainText, text.PlainText)
			}

			resutl = resutl + fmt.Sprintf(`<mj-text padding-bottom="0px" font-size="16px" line-height="24px">
	  <h3 style="font-weight: bold"> 
	 %s
			</h3>
</mj-text>`, strings.Join(plainText, " "))
		case *nt.ParagraphBlock:
			// get array of plain text
			var plainText []string
			for _, text := range v.RichText {
				if text.HRef != nil {
					link := *text.HRef
					// check if text.href is a link
					if !utils.HasDomain(*text.HRef) {
						link = fmt.Sprintf("https://www.notion.so/dwarves/%s", *text.HRef)
					}

					text.PlainText = fmt.Sprintf(`<a href="%s">%s</a>`, link, text.PlainText)
				}
				plainText = append(plainText, text.PlainText)
			}

			resutl = resutl + fmt.Sprintf(`<mj-text padding-bottom="0px" padding-top="0px">
	  <p style="margin:4px 0px;"> 
	 %s
			</p>
</mj-text>`, strings.Join(plainText, " "))
		case *nt.BulletedListItemBlock:
			// get array of plain text
			var plainText []string
			for _, text := range v.RichText {
				plainText = append(plainText, text.PlainText)
			}

			// if first block
			if i == 0 {
				resutl = resutl + fmt.Sprintf(`<mj-text padding="0px 0px">
							<ul>
								  <li style="margin: 4px 0px;"> 
									%s
								  </li>`, strings.Join(plainText, " "))
				resutl = handleNestedBulletText(v, resutl)
			} else { // handle block in between first and last block
				// if block before this is a bullet list
				if _, ok := blocks[i-1].(*nt.BulletedListItemBlock); ok {
					if _, ok := blocks[i+1].(*nt.BulletedListItemBlock); ok { // and block after this is a bullet list
						resutl = resutl + fmt.Sprintf(`
								  <li style="margin: 4px 0px;"> 
									%s
								  </li>
						`, strings.Join(plainText, " "))
						resutl = handleNestedBulletText(v, resutl)
					} else { // and block after this is not a bullet list
						resutl = resutl + fmt.Sprintf(`
								  <li style="margin: 4px 0px;"> 
									%s
								  </li>
							</ul>
						</mj-text>`, strings.Join(plainText, " "))
						resutl = handleNestedBulletText(v, resutl)
					}
				} else { // if block before this is not a bullet list
					// if this is last block
					if i == len(blocks)-1 {
						resutl = resutl + fmt.Sprintf(`<mj-text padding="0px 0px">
							<ul>
								  <li style="margin: 4px 0px;"> 
									%s
								  </li>
							</ul>
						</mj-text>`, strings.Join(plainText, " "))
						resutl = handleNestedBulletText(v, resutl)
					} else { // if this is not last block
						if _, ok := blocks[i+1].(*nt.BulletedListItemBlock); ok { // and block after this is a bullet list
							resutl = resutl + fmt.Sprintf(`<mj-text padding="0px 0px">
							<ul>
								  <li style="margin: 4px 0px;"> 
									%s
								  </li>`, strings.Join(plainText, " "))
							resutl = handleNestedBulletText(v, resutl)
						} else {
							resutl = resutl + fmt.Sprintf(`<mj-text padding="0px 0px">
							<ul>
								  <li style="margin: 4px 0px;"> 
									%s
								  </li>
							</ul>
						</mj-text>`, strings.Join(plainText, " "))
							resutl = handleNestedBulletText(v, resutl)
						}
					}
				}
			}
		case *nt.ImageBlock:
			if v.External != nil {
				resutl = resutl + fmt.Sprintf(` <mj-image width="600px" padding-top="0" src="%s"></mj-image>`, v.External.URL)
			} else {
				resutl = resutl + fmt.Sprintf(` <mj-image width="600px" padding-top="0" src="%s"></mj-image>`, v.File.URL)
			}
		}
	}
	return resutl, nil
}

func handleNestedBulletText(v *nt.BulletedListItemBlock, resutl string) string {
	for _, child := range v.Children {
		switch child := child.(type) {
		case *nt.BulletedListItemBlock:
			var plainTextChild []string
			for _, textChild := range child.RichText {
				plainTextChild = append(plainTextChild, textChild.PlainText)
			}
			resutl = resutl + fmt.Sprintf(`<mj-text padding="0px 0px">
			<ul>
			  <li style="margin: 4px 0px;"> 
				%s
			  </li>
			  %s
			</ul>
	</mj-text>`, strings.Join(plainTextChild, " "), handleNestedBulletText(child, ""))
		}
	}
	return resutl
}

func (n *notionService) FindClientPageForChangelog(clientID string) (nt.Page, error) {
	ctx := context.Background()
	res, err := n.notionClient.FindPageByID(ctx, clientID)
	if err != nil {
		return nt.Page{}, err
	}

	return res, nil
}

func (n *notionService) GetDatabase(databaseID string, filter *nt.DatabaseQueryFilter, sorts []nt.DatabaseQuerySort, pageSize int) (*nt.DatabaseQueryResponse, error) {
	ctx := context.Background()

	q := &nt.DatabaseQuery{
		Filter: filter,
		Sorts:  sorts,
	}
	if pageSize > 0 {
		q.PageSize = pageSize
	}

	res, err := n.notionClient.QueryDatabase(ctx, databaseID, q)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (n *notionService) GetDatabaseWithStartCursor(databaseID string, startCursor string) (*nt.DatabaseQueryResponse, error) {
	ctx := context.Background()

	res, err := n.notionClient.QueryDatabase(ctx, databaseID, &nt.DatabaseQuery{
		StartCursor: startCursor,
	})
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (n *notionService) GetBlockChildren(pageID string) (*nt.BlockChildrenResponse, error) {
	ctx := context.Background()

	res, err := n.notionClient.FindBlockChildrenByID(ctx, pageID, &nt.PaginationQuery{})
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (n *notionService) GetPagePropByID(pageID, propID string, query *nt.PaginationQuery) (*nt.PagePropResponse, error) {
	ctx := context.Background()

	res, err := n.notionClient.FindPagePropertyByID(ctx, pageID, propID, query)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (n *notionService) GetProjectInDB(pageID string) (*nt.DatabasePageProperties, error) {
	ctx := context.Background()

	// 1. get all project records in project page
	res, err := n.notionClient.QueryDatabase(ctx, n.projectsDBID, &nt.DatabaseQuery{})
	if err != nil {
		return nil, err
	}

	// 2. loop through all projects to find the project by page id
	for _, r := range res.Results {
		if strings.ReplaceAll(r.ID, "-", "") == strings.ReplaceAll(pageID, "-", "") {
			p := r.Properties.(nt.DatabasePageProperties)
			if len(p["Project"].Title) != 0 && p["Changelog"].URL != nil {
				if *p["Changelog"].URL == "" {
					continue
				}
				clID := strings.Split(strings.Split(*p["Changelog"].URL, "/")[len(strings.Split(*p["Changelog"].URL, "/"))-1], "?")[0]
				cls, err := n.notionClient.QueryDatabase(ctx, clID, &nt.DatabaseQuery{
					Sorts: []nt.DatabaseQuerySort{
						{
							Property:  "Created",
							Direction: nt.SortDirDesc,
						},
					},
				})
				if err != nil {
					n.l.Errorf(err, "query project change log err", clID, p["Project"].Title[0].Text.Content)
					continue
				}

				if len(cls.Results) != 0 && len(cls.Results[0].Properties.(nt.DatabasePageProperties)["Title"].Title) != 0 {
					p["EmailSubject"] = nt.DatabasePageProperty{
						Title: []nt.RichText{
							{
								Type:      nt.RichTextTypeText,
								Text:      &nt.Text{Content: cls.Results[0].Properties.(nt.DatabasePageProperties)["Title"].Title[0].Text.Content},
								PlainText: cls.Results[0].Properties.(nt.DatabasePageProperties)["Title"].Title[0].Text.Content,
							},
						},
					}
				}
			}
			return &p, nil
		}
	}

	return nil, errors.New("page not found")
}

func (n *notionService) GetProjectsInDB(pageIDs []string, projectPageID string) (map[string]nt.DatabasePageProperties, error) {
	ctx := context.Background()

	// 1. get all project records in project page
	res, err := n.notionClient.QueryDatabase(ctx, projectPageID, &nt.DatabaseQuery{})
	if err != nil {
		return nil, err
	}

	// 2. loop through all projects to find the projects by page ids
	pages := map[string]nt.DatabasePageProperties{}
	for _, id := range pageIDs {
		pages[strings.ReplaceAll(id, "-", "")] = nt.DatabasePageProperties{}
	}
	for _, r := range res.Results {
		if _, ok := pages[strings.ReplaceAll(r.ID, "-", "")]; ok {
			pages[strings.ReplaceAll(r.ID, "-", "")] = r.Properties.(nt.DatabasePageProperties)
		}
	}

	return pages, nil
}

func (n *notionService) GetPage(pageID string) (nt.Page, error) {
	ctx := context.Background()

	res, err := n.notionClient.FindPageByID(ctx, pageID)
	if err != nil {
		return nt.Page{}, err
	}

	return res, nil
}

func (n *notionService) CreatePage() error {
	return nil
}

// create a record in notion database
func (n *notionService) CreateDatabaseRecord(databaseID string, properties map[string]interface{}) (string, error) {
	ctx := context.Background()

	props, err := convertMapToProperties(properties)
	if err != nil {
		return "", err
	}
	p, err := n.notionClient.CreatePage(ctx, nt.CreatePageParams{
		ParentType:             nt.ParentTypeDatabase,
		ParentID:               databaseID,
		DatabasePageProperties: &props,
	})
	if err != nil {
		return "", err
	}

	return p.ID, nil
}

func convertMapToProperties(properties map[string]interface{}) (nt.DatabasePageProperties, error) {
	props := nt.DatabasePageProperties{}

	for key, value := range properties {
		switch key {
		case "Name":
			props["Name"] = nt.DatabasePageProperty{
				Type:  nt.DBPropTypeTitle,
				Title: []nt.RichText{{Text: &nt.Text{Content: value.(string)}}},
			}
		case "Status":
			props["Status"] = nt.DatabasePageProperty{
				Type: nt.DBPropTypeSelect,
				Select: &nt.SelectOptions{
					Name: value.(string),
				},
			}
		// case "Assign":
		// 	props["Assign"] = nt.DatabasePageProperty{
		// 		Type: nt.DatabasePropertyType(nt.DBPropTypePeople),
		// 		People: []nt.User{
		// 			{
		// 				BaseUser: nt.BaseUser{
		// 					ID: value.(string),
		// 				},
		// 			},
		// 		},
		// 	}

		default:
			return nil, fmt.Errorf("unsupported property: %s", key)
		}
	}

	return props, nil
}

func (n *notionService) ListProject() ([]model.ProjectChangelogPage, error) {
	ctx := context.Background()
	prjs, err := n.notionClient.QueryDatabase(ctx, n.projectsDBID, &nt.DatabaseQuery{
		Filter: &nt.DatabaseQueryFilter{
			Property: "Status",
			DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{
				Select: &nt.SelectDatabaseQueryFilter{
					Equals: "Active",
				},
			},
		},
	})
	if err != nil {
		return nil, err
	}

	res := []model.ProjectChangelogPage{}
	for _, r := range prjs.Results {
		p := r.Properties.(nt.DatabasePageProperties)
		if len(p["Project"].Title) != 0 && p["Changelog"].URL != nil {
			if *p["Changelog"].URL == "" {
				continue
			}
			clID := strings.Split(strings.Split(*p["Changelog"].URL, "/")[len(strings.Split(*p["Changelog"].URL, "/"))-1], "?")[0]
			cls, err := n.notionClient.QueryDatabase(ctx, clID, &nt.DatabaseQuery{
				Sorts: []nt.DatabaseQuerySort{
					{
						Property:  "Created",
						Direction: nt.SortDirDesc,
					},
				},
			})
			if err != nil {
				n.l.Errorf(err, "query project change log err", clID, p["Project"].Title[0].Text.Content)
				continue
			}
			if len(cls.Results) != 0 && len(cls.Results[0].Properties.(nt.DatabasePageProperties)["Title"].Title) != 0 {
				res = append(res, model.ProjectChangelogPage{
					RowID:        r.ID,
					Name:         p["Project"].Title[0].Text.Content,
					Title:        cls.Results[0].Properties.(nt.DatabasePageProperties)["Title"].Title[0].Text.Content,
					ChangelogURL: cls.Results[0].URL,
				})
			}
		}
	}
	return res, nil
}

func (n *notionService) QueryAudienceDatabase(audienceDBId, audience string) (records []nt.Page, err error) {
	ctx := context.Background()
	var t bool = true
	var cursor string = ""

	var filter *nt.DatabaseQueryFilter
	switch audience {
	case "Developers Only":
		filter = &nt.DatabaseQueryFilter{
			And: []nt.DatabaseQueryFilter{
				{
					Or: []nt.DatabaseQueryFilter{
						{Property: "Personas", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{Contains: "Developer"}}},
						{Property: "Personas", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{Contains: "Engineer"}}},
						{Property: "Personas", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{Contains: "Tester"}}},
						{Property: "Personas", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{Contains: "Product Manager"}}},
					},
				},
				{
					And: []nt.DatabaseQueryFilter{
						{Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Community"}}},
						{Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Employee"}}},
						{Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "CLient"}}},
						{Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Past Client"}}},
						{Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Fellowship"}}},
						{Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Prospect"}}},
						{Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Failed CV"}}},
						{Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Failed Test"}}},
						{Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Failed Interview"}}},
					},
				},
			},
		}
	case "Partner Updates", "Dwarves Updates":
		filter = &nt.DatabaseQueryFilter{
			And: []nt.DatabaseQueryFilter{
				{
					Property: audience,
					DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{
						Checkbox: &nt.CheckboxDatabaseQueryFilter{
							Equals: &t,
						},
					},
				},
			},
		}

	default:
		return nil, errors.New("audience not found")
	}

	// filter out unsubscribed
	var unsubscribed bool = false
	filter.And = append(filter.And, nt.DatabaseQueryFilter{
		Property: "Unsubscribed",
		DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{
			Checkbox: &nt.CheckboxDatabaseQueryFilter{
				Equals: &unsubscribed,
			},
		},
	})

	n.l.Info("start querying audience database")
	for {
		res, err := n.notionClient.QueryDatabase(ctx, audienceDBId, &nt.DatabaseQuery{
			Filter: filter,
			Sorts: []nt.DatabaseQuerySort{
				{
					Property:  "Created Time",
					Direction: nt.SortDirAsc,
				},
			},
			StartCursor: cursor,
			PageSize:    100,
		})
		if err != nil {
			return nil, err
		}
		records = append(records, res.Results...)
		if !res.HasMore {
			break
		}
		cursor = *res.NextCursor
	}
	n.l.Info("finish querying audience database")
	return records, nil
}

```

# pkg/service/notion/interface.go

```go
package notion

import (
	nt "github.com/dstotijn/go-notion"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IService interface {
	GetPage(pageID string) (clientPage nt.Page, err error)
	GetDatabase(databaseID string, filter *nt.DatabaseQueryFilter, sorts []nt.DatabaseQuerySort, pageSize int) (database *nt.DatabaseQueryResponse, err error)
	GetDatabaseWithStartCursor(databaseID string, startCursor string) (*nt.DatabaseQueryResponse, error)
	FindClientPageForChangelog(clientID string) (clientPage nt.Page, err error)
	GetProjectInDB(pageID string) (project *nt.DatabasePageProperties, err error)
	GetProjectsInDB(pageIDs []string, projectPageID string) (projects map[string]nt.DatabasePageProperties, err error)
	GetBlockChildren(pageID string) (blockChildrenResponse *nt.BlockChildrenResponse, err error)
	GetBlock(pageID string) (blockResponse nt.Block, err error)
	ListProject() ([]model.ProjectChangelogPage, error)
	GetPagePropByID(pageID, propID string, query *nt.PaginationQuery) (*nt.PagePropResponse, error)

	// CreatePage create a page in notion
	CreatePage() error
	CreateDatabaseRecord(databaseID string, properties map[string]interface{}) (pageID string, err error)
	ToChangelogMJML(blocks []nt.Block, email model.Email) (string, error)

	QueryAudienceDatabase(audienceDBId, audience string) (records []nt.Page, err error)
}

```

# pkg/service/mochiprofile/request.go

```go
package mochiprofile

import "time"

type ProfilePlatform string

const (
	ProfilePlatformDiscord ProfilePlatform = "discord"
	ProfilePlatformGithub  ProfilePlatform = "github"
)

type Pagination struct {
	Total int64 `json:"total"`
	Page  int64 `json:"page"`
	Size  int64 `json:"size"`
}

type GetMochiProfilesResponse struct {
	Data       []MochiProfile `json:"data"`
	Pagination Pagination     `json:"pagination"`
}

type MochiProfile struct {
	ID                 string               `json:"id"`
	ProfileName        string               `json:"profile_name"`
	Avatar             string               `json:"avatar"`
	AssociatedAccounts []AssociatedAccounts `json:"associated_accounts"`
	Type               string               `json:"type"`
	CreatedAt          time.Time            `json:"created_at"`
	UpdatedAt          time.Time            `json:"updated_at"`
}

type AssociatedAccounts struct {
	Id                 string                 `json:"id"`
	ProfileId          string                 `json:"profile_id"`
	Platform           ProfilePlatform        `json:"platform"`
	PlatformIdentifier string                 `json:"platform_identifier"`
	PlatformMetadata   map[string]interface{} `json:"platform_metadata"`
	IsGuildMember      bool                   `json:"is_guild_member"`
	CreatedAt          string                 `json:"created_at"`
	UpdatedAt          string                 `json:"updated_at"`
}

type ListProfilesRequest struct {
	Types []ProfileType `json:"type"`
	IDs   []ProfileID   `json:"ids"`
	Page  int64         `json:"page"`
	Size  int64         `json:"size"`
}

type ProfileID string

func (i ProfileID) String() string {
	return string(i)
}

type ProfileType string

const (
	ProfileTypeUser        ProfileType = "user"
	ProfileTypeApplication ProfileType = "application"
	ProfileTypeVault       ProfileType = "vault"
)

func (t ProfileType) String() string {
	return string(t)
}

```

# pkg/service/mochiprofile/mochiprofile.go

```go
package mochiprofile

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
)

type IService interface {
	GetProfile(id string) (*MochiProfile, error)
	GetListProfiles(req ListProfilesRequest) (*GetMochiProfilesResponse, error)
	GetProfileByDiscordID(discordID string) (*MochiProfile, error)
	GetProfileByEvmAddress(address string) (*MochiProfile, error)
}

type client struct {
	cfg *config.Config
	l   logger.Logger
}

func New(cfg *config.Config, l logger.Logger) IService {
	return &client{
		cfg: cfg,
		l:   l,
	}
}

func (m *client) GetProfile(id string) (*MochiProfile, error) {
	var client = &http.Client{
		Timeout: 10 * time.Second,
	}

	url := fmt.Sprintf("%s/api/v1/profiles?ids=%s", m.cfg.MochiProfile.BaseURL, id)
	r, err := client.Get(url)
	if err != nil {
		m.l.Errorf(err, "[mochipay.GetListTransaction] client.Get failed")
		return nil, err
	}
	defer r.Body.Close()

	res := &GetMochiProfilesResponse{}
	if err := json.NewDecoder(r.Body).Decode(&res); err != nil {
		m.l.Errorf(err, "[mochiprofile.GetProfile] decoder.Decode failed")
		return nil, err
	}

	if len(res.Data) == 0 {
		return nil, nil
	}

	if len(res.Data) > 1 {
		m.l.Errorf(nil, "[mochiprofile.GetProfile] more than 1 profile")
		return nil, fmt.Errorf("more than 1 profile")
	}

	return &res.Data[0], handleErrorStatusCode("Get Mochi profile", r.StatusCode)
}

func (m *client) GetProfileByDiscordID(discordID string) (*MochiProfile, error) {
	var client = &http.Client{
		Timeout: 10 * time.Second,
	}

	url := fmt.Sprintf("%s/api/v1/profiles/get-by-discord/%s", m.cfg.MochiProfile.BaseURL, discordID)
	r, err := client.Get(url)
	if err != nil {
		m.l.Errorf(err, "[mochipay.GetListTransaction] client.Get failed")
		return nil, err
	}
	defer r.Body.Close()

	res := &MochiProfile{}
	if err := json.NewDecoder(r.Body).Decode(&res); err != nil {
		m.l.Errorf(err, "[mochipay.GetListTransaction] decoder.Decode failed")
		return nil, err
	}

	return res, handleErrorStatusCode("Get Mochi profile by discord ID", r.StatusCode)
}

func (m *client) GetProfileByEvmAddress(address string) (*MochiProfile, error) {
	var client = &http.Client{
		Timeout: 10 * time.Second,
	}

	url := fmt.Sprintf("%s/api/v1/profiles/get-by-evm/%s", m.cfg.MochiProfile.BaseURL, address)
	r, err := client.Get(url)
	if err != nil {
		m.l.Errorf(err, "[mochiprofile.GetProfileByEvmAddress] client.Get failed")
		return nil, err
	}
	defer r.Body.Close()

	res := &MochiProfile{}
	if err := json.NewDecoder(r.Body).Decode(&res); err != nil {
		m.l.Errorf(err, "[mochiprofile.GetProfileByEvmAddress] decoder.Decode failed")
		return nil, err
	}

	return res, handleErrorStatusCode("Get Mochi profile by evm address", r.StatusCode)
}

func (m *client) GetListProfiles(req ListProfilesRequest) (*GetMochiProfilesResponse, error) {
	var client = &http.Client{
		Timeout: 10 * time.Second,
	}

	queryParams := url.Values{}
	var pageSize int64 = 10
	if req.Size != 0 {
		pageSize = req.Size
	}
	queryParams.Add("size", fmt.Sprintf("%v", pageSize))
	queryParams.Add("page", fmt.Sprintf("%v", req.Page))

	if len(req.IDs) > 0 {
		ids := getListParams(req.IDs)
		queryParams.Add("ids", ids)
	}

	if len(req.Types) > 0 {
		types := getListParams(req.Types)
		queryParams.Add("types", types)
	}

	url := fmt.Sprintf("%s/api/v1/profiles?", m.cfg.MochiProfile.BaseURL) + queryParams.Encode()
	r, err := client.Get(url)
	if err != nil {
		m.l.Errorf(err, "[mochiprofile.GetListProfile] client.Get failed")
		return nil, err
	}
	defer r.Body.Close()

	res := &GetMochiProfilesResponse{}
	if err := json.NewDecoder(r.Body).Decode(res); err != nil {
		m.l.Errorf(err, "[mochiprofile.GetListProfiles] decoder.Decode failed")
		return nil, err
	}

	return res, nil
}

func handleErrorStatusCode(method string, statusCode int) error {
	if statusCode >= 200 && statusCode < 300 {
		return nil
	}

	return fmt.Errorf("%s status code: %d", method, statusCode)
}

func getListParams[T fmt.Stringer](data []T) string {
	param := ""
	for i, a := range data {
		if i == 0 {
			param += fmt.Sprintf("%s", a)
			continue
		}
		param += fmt.Sprintf("|%s", a)
	}

	return param
}

```

# pkg/service/mochipay/request.go

```go
package mochipay

import (
	"time"
)

type TransactionType string

const (
	TransactionTypeSend    TransactionType = "out"
	TransactionTypeReceive TransactionType = "in"
)

type TransactionStatus string

const (
	TransactionStatusPending   TransactionStatus = "pending"
	TransactionStatusSubmitted TransactionStatus = "submitted"
	TransactionStatusSuccess   TransactionStatus = "success"
	TransactionStatusFailed    TransactionStatus = "failed"
	TransactionStatusExpired   TransactionStatus = "expired"
	TransactionStatusCancelled TransactionStatus = "cancelled" //nolint:all
)

type TransactionAction string

const (
	TransactionActionTransfer      TransactionAction = "transfer"
	TransactionActionAirdrop       TransactionAction = "airdrop"
	TransactionActionDeposit       TransactionAction = "deposit"
	TransactionActionWithdraw      TransactionAction = "withdraw"
	TransactionActionSwap          TransactionAction = "swap"
	TransactionActionVaultTransfer TransactionAction = "vault_transfer"
)

type TransactionPlatform string

const (
	TransactionPlatformDiscord TransactionPlatform = "discord"
)

type ListTransactionsRequest struct {
	Type         TransactionType       `json:"type"`
	Status       TransactionStatus     `json:"status"`
	ActionList   []TransactionAction   `json:"action_list"`
	TokenAddress string                `json:"token_address"`
	ProfileID    string                `json:"profile_id"`
	Platforms    []TransactionPlatform `json:"platforms"`
	ChainIDs     []string              `json:"chain_ids"`
	Page         int64                 `json:"page"`
	Size         int64                 `json:"size"`
	IsSender     *bool                 `json:"is_sender"`
	SortBy       string                `json:"sort_by"`
}

type ListTransactionsResponse struct {
	Data       []TransactionData `json:"data"`
	Pagination Pagination        `json:"pagination"`
}

type Pagination struct {
	Total int64 `json:"total"`
	Page  int64 `json:"page"`
	Size  int64 `json:"size"`
}

type TransactionData struct {
	Id                 string                 `json:"id"`
	FromProfileId      string                 `json:"from_profile_id"`
	OtherProfileId     string                 `json:"other_profile_id"`
	FromProfileSource  string                 `json:"from_profile_source"`
	OtherProfileSource string                 `json:"other_profile_source"`
	SourcePlatform     string                 `json:"source_platform"`
	Amount             string                 `json:"amount"`
	TokenId            string                 `json:"token_id"`
	ChainId            string                 `json:"chain_id"`
	InternalId         int64                  `json:"internal_id"`
	ExternalId         string                 `json:"external_id"`
	OnchainTxHash      string                 `json:"onchain_tx_hash"`
	Type               TransactionType        `json:"type"`
	Action             TransactionAction      `json:"action"`
	Status             TransactionStatus      `json:"status"`
	CreatedAt          time.Time              `json:"created_at"`
	UpdatedAt          time.Time              `json:"updated_at"`
	ExpiredAt          *time.Time             `json:"expired_at"`
	SettledAt          *time.Time             `json:"settled_at"`
	Token              *Token                 `json:"token"`
	OriginalTxId       string                 `json:"original_tx_id"`
	OtherProfile       *MochiProfile          `json:"other_profile"`
	FromProfile        *MochiProfile          `json:"from_profile"`
	OtherProfiles      []MochiProfile         `json:"other_profiles"`
	AmountEachProfiles []AmountEachProfiles   `json:"amount_each_profiles"`
	UsdAmount          float64                `json:"usd_amount"`
	Metadata           map[string]interface{} `json:"metadata"`

	// used in airdrop response
	OtherProfileIds []string `json:"other_profile_ids"`
	TotalAmount     string   `json:"total_amount"`

	// used in swap response
	FromTokenId string `json:"from_token_id"`
	ToTokenId   string `json:"to_token_id"`
	FromToken   *Token `json:"from_token,omitempty"`
	ToToken     *Token `json:"to_token,omitempty"`
	FromAmount  string `json:"from_amount"`
	ToAmount    string `json:"to_amount"`
}

type Token struct {
	Id          string  `json:"id"`
	Name        string  `json:"name"`
	Symbol      string  `json:"symbol"`
	Decimal     int64   `json:"decimal"`
	ChainId     string  `json:"chain_id"`
	Native      bool    `json:"native"`
	Address     string  `json:"address"`
	Icon        string  `json:"icon"`
	CoinGeckoId string  `json:"coin_gecko_id"`
	Price       float64 `json:"price"`
	Chain       *Chain  `json:"chain"`
}

type Chain struct {
	Id       string `json:"id"`
	ChainId  string `json:"chain_id"`
	Name     string `json:"name"`
	Symbol   string `json:"symbol"`
	Rpc      string `json:"rpc"`
	Explorer string `json:"explorer"`
	Icon     string `json:"icon"`
	Type     string `json:"type"`
}

type MochiProfile struct {
	Id                 string               `json:"id"`
	CreatedAt          string               `json:"created_at"`
	UpdatedAt          string               `json:"updated_at"`
	ProfileName        string               `json:"profile_name"`
	Avatar             string               `json:"avatar"`
	AssociatedAccounts []AssociatedAccounts `json:"associated_accounts"`
	Type               string               `json:"type"`
	Application        *Application         `json:"application"`
}

type Application struct {
	Id                   int     `json:"id"`
	Name                 string  `json:"name"`
	OwnerProfileId       string  `json:"owner_profile_id"`
	ServiceFee           float64 `json:"service_fee"`
	ApplicationProfileId string  `json:"application_profile_id"`
	Active               bool    `json:"active"`
}

type AssociatedAccounts struct {
	Id                 string      `json:"id"`
	ProfileId          string      `json:"profile_id"`
	Platform           string      `json:"platform"`
	PlatformIdentifier string      `json:"platform_identifier"`
	PlatformMetadata   interface{} `json:"platform_metadata"`
	IsGuildMember      bool        `json:"is_guild_member"`
	CreatedAt          string      `json:"created_at"`
	UpdatedAt          string      `json:"updated_at"`
}

type AmountEachProfiles struct {
	ProfileId string  `json:"profile_id"`
	Amount    string  `json:"amount"`
	UsdAmount float64 `json:"usd_amount"`
}

type TokenInfo struct {
	Address     string `json:"address"`
	Chain       *Chain `json:"chain"`
	ChainID     string `json:"chain_id"`
	CoinGeckoID string `json:"coin_gecko_id"`
	Decimal     int    `json:"decimal"`
	Icon        string `json:"icon"`
	ID          string `json:"id"`
	Name        string `json:"name"`
	Native      bool   `json:"native"`
	Price       int    `json:"price"`
	Symbol      string `json:"symbol"`
}

type VaultRequest struct {
	Amount     string     `json:"amount"`
	Chain      string     `json:"chain"`
	ListNotify []string   `json:"list_notify"`
	Message    string     `json:"message"`
	Name       string     `json:"name"`
	Platform   string     `json:"platform"`
	PrivateKey string     `json:"private_key"`
	ProfileID  string     `json:"profile_id"`
	Receiver   string     `json:"receiver"`
	RequestID  int        `json:"request_id"`
	To         string     `json:"to"`
	Token      string     `json:"token"`
	TokenID    string     `json:"token_id"`
	TokenInfo  *TokenInfo `json:"token_info"`
	VaultID    int        `json:"vault_id"`
}

type TransactionMetadata struct {
	Message              string        `json:"message"`
	RecipientProfileType string        `json:"recipient_profile_type"`
	RequestID            int           `json:"request_id"`
	SenderProfileType    string        `json:"sender_profile_type"`
	TransferType         string        `json:"transfer_type"`
	TxHash               string        `json:"tx_hash"`
	VaultRequest         *VaultRequest `json:"vault_request"`
}

type BatchBalancesResponse struct {
	Data []BatchBalancesData `json:"data"`
}

type BatchBalancesData struct {
	Id        string `json:"id"`
	ProfileID string `json:"profile_id"`
	TokenID   string `json:"token_id"`
	Amount    string `json:"amount"`
	Token     Token  `json:"token"`
}

```

# pkg/service/mochipay/mochipay.go

```go
package mochipay

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
)

const (
	ICYAddress       = "0xf289e3b222dd42b185b7e335fa3c5bd6d132441d"
	BASEChainID      = "8453"
	RewardDefaultMsg = "Send money to treasurer"
	ICYTokenMochiID  = "9d25232e-add3-4bd8-b7c6-be6c14debc58"
	BaseChainName    = "BASE"
)

type IService interface {
	GetListTransactions(req ListTransactionsRequest) (*ListTransactionsResponse, error)
	GetBatchBalances(profileIds []string) (*BatchBalancesResponse, error)
}

type client struct {
	cfg *config.Config
	l   logger.Logger
}

func New(cfg *config.Config, l logger.Logger) IService {
	return &client{
		cfg: cfg,
		l:   l,
	}
}

func (m *client) GetListTransactions(req ListTransactionsRequest) (*ListTransactionsResponse, error) {
	var client = &http.Client{
		Timeout: 10 * time.Second,
	}

	queryParams := url.Values{}
	var pageSize int64 = 10
	if req.Size != 0 {
		pageSize = req.Size
	}
	queryParams.Add("size", fmt.Sprintf("%v", pageSize))
	queryParams.Add("page", fmt.Sprintf("%v", req.Page))

	if len(req.ActionList) > 0 {
		actions := ""
		for i, a := range req.ActionList {
			if i == 0 {
				actions += string(a)
				continue
			}
			actions += fmt.Sprintf("|%s", a)
		}
		queryParams.Add("action", actions)
	}
	if req.Type != "" {
		queryParams.Add("type", string(req.Type))
	}
	if req.Status != "" {
		queryParams.Add("status", string(req.Status))
	}

	if req.TokenAddress != "" {
		queryParams.Add("token_address", req.TokenAddress)
	}

	if len(req.Platforms) != 0 {
		platforms := make([]string, 0)
		for _, p := range req.Platforms {
			platforms = append(platforms, string(p))
		}

		queryParams.Add("platforms", strings.Join(platforms, "|"))
	}

	if len(req.ChainIDs) != 0 {
		queryParams.Add("chain_ids", strings.Join(req.ChainIDs, "|"))
	}

	if req.ProfileID != "" {
		queryParams.Add("profile_id", req.ProfileID)
	}

	if req.IsSender != nil {
		queryParams.Add("is_sender", fmt.Sprintf("%v", *req.IsSender))
	}

	if req.SortBy != "" {
		queryParams.Add("sort_by", req.SortBy)
	}

	url := fmt.Sprintf("%s/api/v1/transactions?", m.cfg.MochiPay.BaseURL) + queryParams.Encode()
	r, err := client.Get(url)
	if err != nil {
		m.l.Errorf(err, "[mochipay.GetListTransaction] client.Get failed")
		return nil, err
	}
	defer r.Body.Close()

	res := &ListTransactionsResponse{}
	if err := json.NewDecoder(r.Body).Decode(&res); err != nil {
		m.l.Errorf(err, "[mochipay.GetListTransaction] decoder.Decode failed")
		return nil, err
	}

	return res, nil
}

func (m *client) GetBatchBalances(profileIds []string) (*BatchBalancesResponse, error) {
	var client = &http.Client{
		Timeout: 10 * time.Second,
	}

	url := fmt.Sprintf("%s/api/v1/mochi-wallet/balances/multiple", m.cfg.MochiPay.BaseURL)
	body, err := json.Marshal(struct {
		ProfileIDs []string `json:"profile_ids"`
	}{ProfileIDs: profileIds})
	if err != nil {
		m.l.Errorf(err, "[mochipay.GetchBatchbalances] json.Marshal failed")
		return nil, err
	}
	r, err := client.Post(url, "application/json", bytes.NewBuffer(body))
	if err != nil {
		m.l.Errorf(err, "[mochipay.GetBatchBalances] client.Get failed")
		return nil, err
	}
	defer r.Body.Close()

	res := &BatchBalancesResponse{}
	if err := json.NewDecoder(r.Body).Decode(res); err != nil {
		m.l.Errorf(err, "[mochipay.GetBatchBalances] decoder.Decode failed")
		return nil, err
	}

	return res, nil
}

```

# pkg/service/lobsters/news.go

```go
package lobsters

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

type LobsterPost struct {
	ShortID          string    `json:"short_id"`
	ShortIDURL       string    `json:"short_id_url"`
	CreatedAt        time.Time `json:"created_at"`
	Title            string    `json:"title"`
	URL              string    `json:"url"`
	Score            int       `json:"score"`
	Flags            int       `json:"flags"`
	CommentCount     int       `json:"comment_count"`
	Description      string    `json:"description"`
	DescriptionPlain string    `json:"description_plain"`
	CommentsURL      string    `json:"comments_url"`
	SubmitterUser    string    `json:"submitter_user"`
	UserIsAuthor     bool      `json:"user_is_author"`
	Tags             []string  `json:"tags"`
}

const lobstersURL = "https://lobste.rs/"

func (s service) FetchNews(tag string) ([]LobsterPost, error) {
	// Create a new HTTP client
	client := &http.Client{}

	if strings.TrimSpace(tag) == "" {
		return nil, nil
	}

	// Make the GET request
	resp, err := client.Get(lobstersURL + "t/" + tag + ".json")
	if err != nil {
		return nil, fmt.Errorf("make get request failed: %w", err)
	}
	defer resp.Body.Close()

	// Read the response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read response body failed: %w", err)
	}

	// Unmarshal the response body
	var posts []LobsterPost
	err = json.Unmarshal(body, &posts)
	if err != nil {
		return nil, fmt.Errorf("unmarshal response body failed: %w", err)
	}

	return posts, nil
}

```

# pkg/service/lobsters/new.go

```go
package lobsters

type service struct {
}

func New() IService {
	return &service{}
}

```

# pkg/service/lobsters/interface.go

```go
package lobsters

type IService interface {
	FetchNews(tag string) ([]LobsterPost, error)
}

```

# pkg/service/mochi/response.go

```go
package mochi

// GetListVaultsResponse is the response model for mochi-api GetListVaults
type GetListVaultsResponse struct {
	Data []Vault `json:"data"`
}

```

# pkg/service/mochi/request.go

```go
package mochi

type VaultTransactionRequest struct {
	VaultID   string `json:"vault_id"`
	StartTime string `json:"start_time"`
	EndTime   string `json:"end_time"`
}

type VaultTransactionResponse struct {
	Data []VaultTransaction `json:"data"`
}

type VaultTransaction struct {
	ID          int64  `json:"id"`
	GuildID     string `json:"guild_id"`
	VaultID     int64  `json:"vault_id"`
	VaultName   string `json:"vault_name"`
	Action      string `json:"action"`
	FromAddress string `json:"from_address"`
	ToAddress   string `json:"to_address"`
	Target      string `json:"target"`
	Sender      string `json:"sender"`
	Amount      string `json:"amount"`
	Token       string `json:"token"`
	Threshold   string `json:"threshold"`
	CreatedAt   string `json:"created_at"`
	UpdatedAt   string `json:"updated_at"`
}

```

# pkg/service/mochi/model.go

```go
package mochi

// Vault is the model for mochi vault that is fetched from mochi-api
type Vault struct {
	ID      int64  `json:"id"`
	GuildID string `json:"guild_id"`
}

```

# pkg/service/mochi/mochi.go

```go
package mochi

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"

	mochisdk "github.com/consolelabs/mochi-go-sdk/mochi"
	mochiconfig "github.com/consolelabs/mochi-go-sdk/mochi/config"
	"github.com/consolelabs/mochi-go-sdk/mochi/model"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service/mochipay"
)

type IService interface {
	GetVaultTransaction(req *VaultTransactionRequest) (*VaultTransactionResponse, error)
	SendFromAccountToUser(amount float64, discordID, description, references string) ([]model.Transaction, error)
	GetListVaults(noFetchAmount bool) ([]Vault, error)
}

type client struct {
	cfg         *config.Config
	l           logger.Logger
	mochiClient mochisdk.APIClient
}

func New(cfg *config.Config, l logger.Logger) IService {
	config := &mochiconfig.Config{
		MochiPay: mochiconfig.MochiPay{
			ApplicationID:   cfg.Mochi.ApplicationID,
			ApplicationName: cfg.Mochi.ApplicationName,
			APIKey:          cfg.Mochi.APIKey,
		},
	}

	mochiClient := mochisdk.NewClient(config)
	return &client{
		cfg:         cfg,
		l:           l,
		mochiClient: mochiClient,
	}
}

// SendFromAccountToUser implements IService.
func (c *client) SendFromAccountToUser(amount float64, discordID, description, references string) ([]model.Transaction, error) {
	profile, err := c.mochiClient.GetByDiscordID(discordID)
	if err != nil {
		return nil, err
	}

	txs, err := c.mochiClient.Transfer(&model.TransferRequest{
		RecipientIDs: []string{profile.ID},
		Amounts:      []string{strconv.FormatFloat(amount, 'f', -1, 64)},
		TokenID:      mochipay.ICYTokenMochiID,
		Description:  description,
		References:   references,
	})
	if err != nil {
		return nil, err
	}

	return txs, nil
}

func (m *client) GetVaultTransaction(req *VaultTransactionRequest) (*VaultTransactionResponse, error) {
	var client = &http.Client{}
	request, err := http.NewRequest("GET", fmt.Sprintf("%s/api/v1/vault/%s/transaction?start_time=%s&end_time=%s", m.cfg.Mochi.BaseURL, req.VaultID, req.StartTime, req.EndTime), nil)
	if err != nil {
		return nil, err
	}

	response, err := client.Do(request)
	if err != nil {
		return nil, err
	}

	defer response.Body.Close()
	resBody, err := io.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}

	res := &VaultTransactionResponse{}
	err = json.Unmarshal(resBody, res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

// GetListVaults call to mochi-api to get all vaults
func (m *client) GetListVaults(noFetchAmount bool) ([]Vault, error) {
	var client = &http.Client{}
	request, err := http.NewRequest("GET", fmt.Sprintf("%s/api/v1/vault?no_fetch_amount=%v", m.cfg.Mochi.BaseURL, noFetchAmount), nil)
	if err != nil {
		return nil, err
	}

	response, err := client.Do(request)
	if err != nil {
		return nil, err
	}

	defer response.Body.Close()
	resBody, err := io.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}

	res := &GetListVaultsResponse{}
	err = json.Unmarshal(resBody, res)
	if err != nil {
		return nil, err
	}

	return res.Data, nil
}

```

# pkg/service/improvmx/service.go

```go
package improvmx

type IService interface {
	CreateAccount(email, fwdEmail string) error
	DeleteAccount(email string) error
}

```

# pkg/service/improvmx/improvmx.go

```go
package improvmx

import (
	"errors"
	"strings"

	"github.com/issyl0/go-improvmx"
)

type improvMXService struct {
	service *improvmx.Client
}

// New function return Google service
func New(token string) IService {
	return &improvMXService{
		service: improvmx.NewClient(token),
	}
}

func (g *improvMXService) CreateAccount(email, emailFwd string) error {
	alias := strings.Replace(email, "@d.foundation", "", -1)

	resp := g.service.CreateEmailForward("d.foundation", alias, emailFwd)
	if !resp.Success {
		return errors.New(resp.Error)
	}

	return nil
}

func (g *improvMXService) DeleteAccount(mail string) error {
	alias := strings.Replace(mail, "@d.foundation", "", -1)

	resp := g.service.DeleteEmailForward("d.foundation", alias)
	if !resp.Success {
		return errors.New(resp.Error)
	}
	return nil
}

```

# pkg/service/icyswap/icyswap.go

```go
package icyswap

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"

	"github.com/dwarvesf/fortress-api/pkg/config"
	icyswapabi "github.com/dwarvesf/fortress-api/pkg/contracts/icyswap"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service/evm"
)

type IService interface {
	ConversionRate() (*big.Int, error)
	UsdcFund() (*big.Int, error)
}

type icyswap struct {
	instance *icyswapabi.IcySwap
	evm      evm.IService
	cfg      *config.Config
	l        logger.Logger
}

const (
	ICYSwapAddress = "0x982d2c5A654E4f7CC65ACDCa4ECc649fE4F4DAa4"
	USDCAddress    = "0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA"
)

func New(evm evm.IService, cfg *config.Config, l logger.Logger) (IService, error) {
	instance, err := icyswapabi.NewIcySwap(common.HexToAddress(ICYSwapAddress), evm.Client())
	if err != nil {
		return nil, err
	}
	return &icyswap{
		instance: instance,
		evm:      evm,
		cfg:      cfg,
		l:        l,
	}, nil
}

func (i *icyswap) ConversionRate() (*big.Int, error) {
	rate, err := i.instance.IcyToUsdcConversionRate(nil)
	if err != nil {
		return nil, err
	}

	return rate, nil
}

func (i *icyswap) UsdcFund() (*big.Int, error) {
	balance, err := i.evm.ERC20Balance(common.HexToAddress(USDCAddress), common.HexToAddress(ICYSwapAddress))
	if err != nil {
		return nil, err
	}
	return balance, nil
}

```

# pkg/service/googlestorage/interface.go

```go
package googlestorage

import (
	"io"
)

type IService interface {
	UploadContentGCS(file io.Reader, fileName string) error
}

```

# pkg/service/googlestorage/google.go

```go
package googlestorage

import (
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"time"

	"cloud.google.com/go/storage"
	"google.golang.org/api/option"
)

type service struct {
	gcs *CloudStorage
}

// New function return Google service
func New(BucketName string, GCSProjectID string, GCSCredentials string) (IService, error) {
	decoded, err := base64.StdEncoding.DecodeString(GCSCredentials)
	if err != nil {
		return nil, fmt.Errorf("failed to decode gcs credentials: %v", err)
	}

	client, err := storage.NewClient(context.Background(), option.WithCredentialsJSON(decoded))
	if err != nil {
		return nil, fmt.Errorf("failed to create client: %v", err)
	}

	return &service{
		gcs: &CloudStorage{
			client:     client,
			projectID:  GCSProjectID,
			bucketName: BucketName,
		},
	}, nil
}

func (g *service) UploadContentGCS(file io.Reader, filePath string) error {
	ctx := context.Background()

	ctx, cancel := context.WithTimeout(ctx, time.Second*50)
	defer cancel()

	// Upload an object with storage.Writer.
	wc := g.gcs.client.Bucket(g.gcs.bucketName).Object(filePath).NewWriter(ctx)
	if _, err := io.Copy(wc, file); err != nil {
		return fmt.Errorf("io.Copy: %v", err)
	}
	if err := wc.Close(); err != nil {
		return fmt.Errorf("Writer.Close: %v", err)
	}

	return nil
}

```

# pkg/service/googlestorage/gcs.go

```go
package googlestorage

import (
	"cloud.google.com/go/storage"
)

type CloudStorage struct {
	client     *storage.Client
	projectID  string
	bucketName string
}

```

# pkg/service/googlesheet/types.go

```go
package googlesheet

type SheetData struct {
	Range          string     `json:"range"`
	MajorDimension string     `json:"majorDimension"`
	Values         [][]string `json:"values"`
}

type DeliveryMetricRawData struct {
	Person        string `json:"person"`
	Weight        string `json:"weight"`
	Effort        string `json:"effort"`
	Effectiveness string `json:"effectiveness"`
	Date          string `json:"date"`
	Project       string `json:"project"`
	Email         string `json:"email"`
}

```

# pkg/service/googlesheet/interface.go

```go
package googlesheet

var ()

type IService interface {
	FetchSheetContent(fromIdx int) ([]DeliveryMetricRawData, error)
}

```

# pkg/service/googlesheet/google_sheet.go

```go
package googlesheet

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/dwarvesf/fortress-api/pkg/config"
	"golang.org/x/oauth2"
	"google.golang.org/api/option"
	"google.golang.org/api/sheets/v4"
	"strings"
)

const SpreedSheetReadOnlyScope = "https://www.googleapis.com/auth/spreadsheets.readonly\t"

type googleService struct {
	config    *oauth2.Config
	token     *oauth2.Token
	service   *sheets.Service
	appConfig *config.Config
}

// New function return Google service
func New(config *oauth2.Config, appConfig *config.Config) IService {
	return &googleService{
		config:    config,
		appConfig: appConfig,
	}
}

func (g *googleService) ensureToken(rToken string) error {
	token := &oauth2.Token{
		RefreshToken: rToken,
	}

	if !token.Valid() {
		tks := g.config.TokenSource(context.Background(), token)
		tok, err := tks.Token()
		if err != nil {
			return err
		}
		g.token = tok
	}

	return nil
}

func (g *googleService) prepareService() error {
	client := g.config.Client(context.Background(), g.token)
	service, err := sheets.NewService(context.Background(), option.WithHTTPClient(client))
	if err != nil {
		return errors.New("Get Sheets Service Failed " + err.Error())
	}
	g.service = service
	return nil
}

func (g *googleService) FetchSheetContent(fromIdx int) ([]DeliveryMetricRawData, error) {
	DeliveryMetricSheetID := "1KXUVyDrC9199Dp6wpT6ovIkIvZRtf455eaqwZmvTAFU"
	DeliveryMetricSheetRange := "All Data"
	if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil {
		return nil, err
	}

	if err := g.prepareService(); err != nil {
		return nil, err
	}
	// Fetch the content of the specified Google Sheets file
	resp, err := g.service.Spreadsheets.Values.Get(DeliveryMetricSheetID, DeliveryMetricSheetRange).Do()
	if err != nil {
		return nil, fmt.Errorf("unable to retrieve data from sheet: %v", err)
	}

	// Convert the response to JSON
	jsonData, err := json.Marshal(resp)
	if err != nil {
		return nil, fmt.Errorf("unable to convert sheet data to JSON: %v", err)
	}

	/// Create a struct instance to hold the data
	var sheetData SheetData

	// Unmarshal the JSON data into the struct
	err = json.Unmarshal(jsonData, &sheetData)
	if err != nil {
		return nil, fmt.Errorf("unable to unmarshal sheet data: %v", err)
	}
	deliveryMetricRawData := make([]DeliveryMetricRawData, 0)

	for idx := fromIdx - 1; idx < len(sheetData.Values); idx++ {
		itm := sheetData.Values[idx]

		c0 := strings.TrimSpace(itm[0])
		c1 := strings.TrimSpace(itm[1])
		c2 := strings.TrimSpace(itm[2])
		c3 := strings.TrimSpace(itm[3])
		c4 := strings.TrimSpace(itm[4])
		c5 := strings.TrimSpace(itm[5])
		c6 := strings.TrimSpace(itm[6])

		if c4 == "" || c5 == "" || c6 == "" {
			continue
		}

		if c1 == "" {
			c1 = "0"
		}

		if c2 == "" {
			c2 = "0"
		}

		if c3 == "" {
			c3 = "0"
		}

		tmp := DeliveryMetricRawData{
			Person:        c0,
			Weight:        c1,
			Effort:        c2,
			Effectiveness: c3,
			Date:          c4,
			Project:       c5,
			Email:         c6,
		}

		deliveryMetricRawData = append(deliveryMetricRawData, tmp)
	}

	return deliveryMetricRawData, nil
}

```

# pkg/service/googlemail/utils.go

```go
package googlemail

import (
	"bytes"
	"encoding/base64"
	"os"
	"path/filepath"
	"text/template"

	"github.com/dwarvesf/fortress-api/pkg/config"
)

var (
	accountingUser = "accounting"
	teamEmail      = "team"
	spawnEmail     = "spawn"
)

type MailParseInfo struct {
	Sender           string
	TemplateFileName string
	Data             interface{}
	FuncMap          map[string]interface{}
}

func composeMailContent(appConfig *config.Config, m *MailParseInfo) (string, error) {
	templatePath := appConfig.Invoice.TemplatePath
	if appConfig.Env == "local" || templatePath == "" {
		pwd, err := os.Getwd()
		if err != nil {
			pwd = os.Getenv("GOPATH") + "/src/github.com/dwarvesf/fortress-api"
		}
		templatePath = filepath.Join(pwd, "pkg/templates")
	}
	m.FuncMap["signatureName"] = func() string {
		switch m.Sender {
		case accountingUser:
			return "Eddie Ng"
		case teamEmail:
			return "Dwarves Foundation"
		case spawnEmail:
			return "Team Dwarves"
		default:
			return ""
		}
	}

	m.FuncMap["signatureTitle"] = func() string {
		switch m.Sender {
		case accountingUser:
			return "Accountant"
		case teamEmail:
			return "Team Dwarves"
		case spawnEmail:
			return "Hiring"
		default:
			return ""
		}
	}

	tmpl, err := template.New("mail").Funcs(m.FuncMap).ParseFiles(filepath.Join(templatePath, m.TemplateFileName), filepath.Join(templatePath, "signature.tpl"))
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := tmpl.ExecuteTemplate(&buf, m.TemplateFileName, m.Data); err != nil {
		return "", err
	}

	return base64.URLEncoding.EncodeToString(buf.Bytes()), nil
}

```

# pkg/service/googlemail/interface.go

```go
package googlemail

import (
	"errors"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

var (
	ErrMissingThreadID     = errors.New("missing thread_id")
	ErrInvalidEmail        = errors.New("invalid email")
	ErrEmptyMessageThread  = errors.New("empty message thread")
	ErrCannotFindMessageID = errors.New("cannot find message id")
)

// IService interface contain related google calendar method
type IService interface {
	SendInvitationMail(invitation *model.InvitationEmail) (err error)
	SendInvoiceMail(invoice *model.Invoice) (msgID string, err error)
	SendInvoiceOverdueMail(invoice *model.Invoice) (err error)
	SendInvoiceThankYouMail(invoice *model.Invoice) (err error)
	SendPayrollPaidMail(p *model.Payroll) (err error)
}

```

# pkg/service/googlemail/google_mail.go

```go
package googlemail

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"text/template"
	"time"

	"golang.org/x/oauth2"
	"google.golang.org/api/gmail/v1"
	"google.golang.org/api/option"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/utils/mailutils"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
)

type googleService struct {
	config         *oauth2.Config
	token          *oauth2.Token
	StartHistoryId uint64
	service        *gmail.Service
	appConfig      *config.Config
}

// New function return Google service
func New(config *oauth2.Config, appConfig *config.Config) IService {
	return &googleService{
		config:    config,
		appConfig: appConfig,
	}
}

func (g *googleService) prepareService() error {
	client := g.config.Client(context.Background(), g.token)
	service, err := gmail.NewService(context.Background(), option.WithHTTPClient(client))
	if err != nil {
		return errors.New("Get Gmail Service Failed " + err.Error())
	}

	g.service = service

	return nil
}

func (g *googleService) ensureToken(refreshToken string) error {
	token := &oauth2.Token{
		RefreshToken: refreshToken,
	}

	if !g.token.Valid() {
		tks := g.config.TokenSource(context.Background(), token)
		tok, err := tks.Token()
		if err != nil {
			return err
		}

		g.token = tok
	}

	return nil
}

// SendInvoiceMail function to send invoice email
func (g *googleService) SendInvoiceMail(invoice *model.Invoice) (msgID string, err error) {
	err = g.filterReceiver(invoice)
	if err != nil {
		return "", err
	}

	if err = g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil {
		return "", err
	}

	if err := g.prepareService(); err != nil {
		return "", err
	}

	if !mailutils.Email(invoice.Email) {
		return "", errors.New("email invalid")
	}

	lastDayOfMonth := timeutil.LastDayOfMonth(invoice.Month, invoice.Year)
	addresses, err := model.GatherAddresses(invoice.CC)
	if err != nil {
		return "", err
	}

	funcMap := template.FuncMap{
		"formatDate": func(t *time.Time) string {
			return timeutil.FormatDatetime(*t)
		},
		"lastDayOfMonth": func() string {
			return timeutil.FormatDatetime(lastDayOfMonth)
		},
		"encodedPDF": func() string {
			return base64.StdEncoding.EncodeToString(invoice.InvoiceFileContent)
		},
		"description": func() string {
			if invoice.Description == "" {
				return ""
			}
			return "Description: " + invoice.Description + "."
		},
		"gatherAddress": func() string {
			return addresses
		},
		"toString": func(month int) string {
			return time.Month(month).String()
		},
	}

	encodedEmail, err := composeMailContent(g.appConfig,
		&MailParseInfo{
			accountingUser,
			"invoice.tpl",
			&invoice,
			funcMap,
		})
	if err != nil {
		return
	}
	id := g.appConfig.Google.AccountingEmailID

	threadID, err := g.sendEmail(encodedEmail, id)
	if err != nil {
		return
	}

	return threadID, nil
}

// SendInvoiceThankYouMail function send thank you email
func (g *googleService) SendInvoiceThankYouMail(invoice *model.Invoice) (err error) {
	err = g.filterReceiver(invoice)
	if err != nil {
		return err
	}

	if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil {
		return err
	}

	if err := g.prepareService(); err != nil {
		return err
	}

	if invoice.ThreadID == "" {
		return ErrMissingThreadID
	}

	id := g.appConfig.Google.AccountingEmailID
	thread, err := g.service.Users.Threads.Get(id, invoice.ThreadID).Do()
	if err != nil {
		return err
	}

	invoice.MessageID, invoice.References, err = getMessageIDFromThread(thread)
	if err != nil {
		return err
	}

	if !mailutils.Email(invoice.Email) {
		return ErrInvalidEmail
	}

	addresses, err := model.GatherAddresses(invoice.CC)
	if err != nil {
		return err
	}

	funcMap := template.FuncMap{
		"gatherAddress": func() string {
			return addresses
		},
		"toString": func(month int) string {
			return time.Month(month).String()
		},
	}

	encodedEmail, err := composeMailContent(g.appConfig,
		&MailParseInfo{
			accountingUser,
			"invoiceThankyou.tpl",
			&invoice,
			funcMap,
		})
	if err != nil {
		return err
	}

	_, err = g.sendEmail(encodedEmail, id)
	return err
}

// SendInvoiceOverdueMail function send overdue email
func (g *googleService) SendInvoiceOverdueMail(invoice *model.Invoice) error {
	if err := g.filterReceiver(invoice); err != nil {
		return err
	}

	if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil {
		return err
	}

	if invoice.ThreadID == "" {
		return ErrMissingThreadID
	}

	if err := g.prepareService(); err != nil {
		return err
	}

	id := g.appConfig.Google.AccountingEmailID
	thread, err := g.getEmailThread(invoice.ThreadID, id)
	if err != nil {
		return err
	}

	invoice.MessageID, invoice.References, err = getMessageIDFromThread(thread)
	if err != nil {
		return err
	}

	if !mailutils.Email(invoice.Email) {
		return ErrInvalidEmail
	}

	addresses, err := model.GatherAddresses(invoice.CC)
	if err != nil {
		return err
	}
	funcMap := template.FuncMap{
		"gatherAddress": func() string {
			return addresses
		},
		"toString": func(month int) string {
			return time.Month(month).String()
		},
	}

	encodedEmail, err := composeMailContent(g.appConfig,
		&MailParseInfo{
			accountingUser,
			"invoiceOverdue.tpl",
			&invoice,
			funcMap,
		})
	if err != nil {
		return err
	}

	_, err = g.sendEmail(encodedEmail, id)
	return err
}

func (g *googleService) sendEmail(encodedEmail, id string) (msgID string, err error) {
	rs, err := g.service.Users.Messages.Send(id, &gmail.Message{
		Raw: encodedEmail,
	}).Do()
	if err != nil {
		return
	}

	return rs.ThreadId, nil
}

func (g *googleService) getEmailThread(threadID, id string) (*gmail.Thread, error) {
	thread, err := g.service.Users.Threads.Get(id, threadID).Do()
	if err != nil {
		return nil, err
	}

	return thread, nil
}

func getMessageIDFromThread(thread *gmail.Thread) (msgID, references string, err error) {
	if len(thread.Messages) == 0 {
		return "", "", ErrEmptyMessageThread
	}

	for _, v := range thread.Messages[len(thread.Messages)-1].Payload.Headers {
		if strings.ToLower(v.Name) == "message-id" {
			msgID = v.Value
		}
		if strings.ToLower(v.Name) == "references" {
			references = v.Value
		}
	}

	if msgID == "" {
		return "", "", ErrCannotFindMessageID
	}

	return msgID, fmt.Sprintf(`%s %s`, references, msgID), nil
}

func (g *googleService) filterReceiver(i *model.Invoice) error {
	if g.appConfig.Env == "prod" {
		return nil
	}

	if !mailutils.IsDwarvesMail(i.Email) {
		i.Email = g.appConfig.Invoice.TestEmail
	}

	var ccList []string
	if err := json.Unmarshal(i.CC, &ccList); err != nil {
		return err
	}

	for idx := range ccList {
		if ccList[idx] == "" {
			continue
		}
		if !mailutils.IsDwarvesMail(ccList[idx]) {
			ccList[idx] = g.appConfig.Invoice.TestEmail
		}
	}

	b, err := json.Marshal(ccList)
	if err != nil {
		return err
	}

	var js model.JSON
	if err := js.Scan(b); err != nil {
		return err
	}
	i.CC = js

	return nil
}

// SendPayrollPaidMail after paid a payroll for a user to notify that
// we have been paid their payroll
func (g *googleService) SendPayrollPaidMail(p *model.Payroll) (err error) {
	if g.appConfig.Env == "local" {
		p.Employee.TeamEmail = "benjamin@d.foundation"
	}

	if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil {
		return err
	}

	if err := g.prepareService(); err != nil {
		return err
	}

	id := g.appConfig.Google.AccountingEmailID

	if !mailutils.Email(p.Employee.TeamEmail) {
		return errors.New("email invalid")
	}

	funcMap := g.getPaidSuccessfulEmailFuncMap(p)
	encodedEmail, err := composeMailContent(g.appConfig,
		&MailParseInfo{
			accountingUser,
			"paidPayroll.tpl",
			p,
			funcMap,
		})
	if err != nil {
		return err
	}

	_, err = g.sendEmail(encodedEmail, id)
	return err
}

// ToPaidSuccessfulEmailContent to parse the payroll object
// into template when sending email after payroll is paid
func (g *googleService) getPaidSuccessfulEmailFuncMap(p *model.Payroll) map[string]interface{} {
	// the salary will be the contract(companyAccountAmount in DB)
	// plus the base salary(personalAccountAmount in DB)

	var addresses string = "quang@d.foundation"
	if g.appConfig.Env == "prod" {
		addresses = "quang@d.foundation, accounting@d.foundation"
	}

	return template.FuncMap{
		"ccList": func() string {
			return addresses
		},
		"userFirstName": func() string {
			return p.Employee.GetFirstNameFromFullName()
		},
		"currency": func() string {
			return p.Employee.BaseSalary.Currency.Symbol
		},
		"currencyName": func() string {
			return p.Employee.BaseSalary.Currency.Name
		},
		"formattedCurrentMonth": func() string {
			fm := time.Month(int(p.Month))
			return fm.String()
		},
		"formattedBaseSalaryAmount": func() string {
			return utils.FormatNumber(p.BaseSalaryAmount)
		},
		"formattedTotalAllowance": func() string {
			return utils.FormatNumber(int64(p.TotalAllowance))
		},
		"formattedSalaryAdvance": func() string {
			return utils.FormatNumber(int64(p.SalaryAdvanceAmount))
		},
		"haveBonusOrCommission": func() bool {
			return len(p.CommissionExplains) > 0 || len(p.ProjectBonusExplains) > 0
		},
		"haveCommission": func() bool {
			return len(p.CommissionExplains) > 0
		},
		"haveBonus": func() bool {
			return len(p.ProjectBonusExplains) > 0
		},
		"commissionExplain": func() []model.CommissionExplain {
			return p.CommissionExplains
		},
		"projectBonusExplains": func() []model.ProjectBonusExplain {
			return p.ProjectBonusExplains
		},
	}
}

// SendInvitationMail ...
func (g *googleService) SendInvitationMail(invitation *model.InvitationEmail) (err error) {
	if err := g.ensureToken(g.appConfig.Google.TeamGoogleRefreshToken); err != nil {
		return err
	}

	if err := g.prepareService(); err != nil {
		return err
	}

	invitation.Link = strings.Replace(invitation.Link, "=", "=3D", -1)

	encodedEmail, err := composeMailContent(g.appConfig,
		&MailParseInfo{
			teamEmail,
			"invitation.tpl",
			&invitation,
			map[string]interface{}{},
		})
	if err != nil {
		return err
	}
	id := g.appConfig.Google.TeamEmailID

	_, err = g.sendEmail(encodedEmail, id)
	return err
}

```

# pkg/service/googledrive/interface.go

```go
package googledrive

import (
	"errors"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

var (
	ErrInvoicePDFNotFound = errors.New("invoice pdf not found")
)

type IService interface {
	UploadInvoicePDF(invoice *model.Invoice, dirName string) error
	MoveInvoicePDF(invoice *model.Invoice, fromDirName, toDirName string) error
	DownloadInvoicePDF(invoice *model.Invoice, dirName string) ([]byte, error)
}

```

# pkg/service/googledrive/google_drive.go

```go
package googledrive

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"golang.org/x/oauth2"
	"google.golang.org/api/drive/v3"
	"google.golang.org/api/option"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

const FullDriveAccessScope = "https://www.googleapis.com/auth/drive"

type googleService struct {
	config    *oauth2.Config
	token     *oauth2.Token
	service   *drive.Service
	appConfig *config.Config
}

// New function return Google service
func New(config *oauth2.Config, appConfig *config.Config) IService {
	return &googleService{
		config:    config,
		appConfig: appConfig,
	}
}

func (g *googleService) UploadInvoicePDF(invoice *model.Invoice, dirName string) error {
	if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil {
		return err
	}

	if err := g.prepareService(); err != nil {
		return err
	}

	dir, err := g.findInvoiceDir(strconv.Itoa(invoice.Year), dirName)
	if err != nil {
		return err
	}

	_, err = g.newFile(fmt.Sprintf("#%s.pdf", invoice.Number), "application/pdf", bytes.NewReader(invoice.InvoiceFileContent), dir.Id)
	if err != nil {
		return err
	}

	return nil
}

func (g *googleService) MoveInvoicePDF(invoice *model.Invoice, fromDirName, toDirName string) error {
	if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil {
		return err
	}

	if err := g.prepareService(); err != nil {
		return err
	}

	fromDir, err := g.findInvoiceDir(strconv.Itoa(invoice.Year), fromDirName)
	if err != nil {
		return err
	}
	if fromDir == nil {
		return fmt.Errorf(`%v directory not found`, fromDirName)
	}

	toDir, err := g.findInvoiceDir(strconv.Itoa(invoice.Year), toDirName)
	if err != nil {
		return err
	}
	if toDir == nil {
		return fmt.Errorf(`%v directory not found`, toDirName)
	}

	invoicePdf, err := g.searchFile(fmt.Sprintf("#%s.pdf", invoice.Number), fromDir.Id, false)
	if err != nil {
		return err
	}
	if invoicePdf == nil {
		return ErrInvoicePDFNotFound
	}

	return g.updateInvoiceDir(invoicePdf.Id, fromDir.Id, toDir.Id)
}

func (g *googleService) updateInvoiceDir(fileID, oldDirID, newDirID string) error {
	_, err := g.service.Files.Update(fileID, nil).
		AddParents(newDirID).
		RemoveParents(oldDirID).
		Do()
	return err
}

func (g *googleService) findInvoiceDir(year, status string) (*drive.File, error) {
	yearDir, err := g.getDirID(year, g.appConfig.Invoice.DirID)
	if err != nil {
		return nil, err
	}

	return g.getDirID(status, yearDir.Id)
}

func (g *googleService) getDirID(dirName, parentDirID string) (*drive.File, error) {
	dir, err := g.searchFile(dirName, parentDirID, true)
	if err != nil {
		return nil, err
	}

	if dir != nil {
		return dir, nil
	}

	return g.newDir(dirName, parentDirID)
}

func (g *googleService) ensureToken(rToken string) error {
	token := &oauth2.Token{
		RefreshToken: rToken,
	}

	if !token.Valid() {
		tks := g.config.TokenSource(context.Background(), token)
		tok, err := tks.Token()
		if err != nil {
			return err
		}
		g.token = tok
	}

	return nil
}

func (g *googleService) prepareService() error {
	client := g.config.Client(context.Background(), g.token)
	service, err := drive.NewService(context.Background(), option.WithHTTPClient(client))
	if err != nil {
		return errors.New("Get Drive Service Failed " + err.Error())
	}
	g.service = service
	return nil
}

func (g *googleService) searchFile(name, parentId string, isFolder bool) (*drive.File, error) {
	var folderQuery string
	if isFolder {
		folderQuery = "mimeType='application/vnd.google-apps.folder' and "
	}

	var parentQuery string
	if parentId != "root" {
		parentQuery = fmt.Sprintf("'%s' in parents and ", parentId)
	}
	r, err := g.service.Files.List().
		Q(parentQuery + folderQuery + fmt.Sprintf("name='%s'", name)).
		Fields("nextPageToken, files(id, name)").
		Do()
	if err != nil {
		return nil, err
	}
	if len(r.Files) == 0 {
		return nil, nil
	}

	return r.Files[0], nil
}

func (g *googleService) newDir(name string, parentId string) (*drive.File, error) {
	d := &drive.File{
		Name:     name,
		MimeType: "application/vnd.google-apps.folder",
		Parents:  []string{parentId},
	}

	return g.service.Files.Create(d).Do()
}

func (g *googleService) newFile(name string, mimeType string, content io.Reader, parentId string) (*drive.File, error) {
	f := &drive.File{
		MimeType: mimeType,
		Name:     name,
		Parents:  []string{parentId},
	}

	return g.service.Files.Create(f).Media(content).Do()
}

// func (g *googleService) deleteFile(id string) error {
// 	return g.service.Files.Delete(id).Do()
// }

// func getDrivePreviewLink(fileID string) string {
// 	return fmt.Sprintf(`https://drive.google.com/file/d/%s/view`, fileID)
// }

// func getFileIDFromLink(url string) string {
// 	s := strings.Replace(url, "https://drive.google.com/file/d/", "", 1)
// 	return strings.Replace(s, "/view", "", 1)
// }

func (g *googleService) DownloadInvoicePDF(invoice *model.Invoice, dirName string) ([]byte, error) {
	if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil {
		return nil, err
	}

	if err := g.prepareService(); err != nil {
		return nil, err
	}

	dir, err := g.findInvoiceDir(strconv.Itoa(invoice.Year), dirName)
	if err != nil {
		return nil, err
	}

	f, err := g.searchFile(fmt.Sprintf("#%s.pdf", invoice.Number), dir.Id, false)
	if err != nil {
		return nil, err
	}

	if f == nil {
		return nil, fmt.Errorf(`file not found`)
	}

	resp, err := g.service.Files.Get(f.Id).Download()
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	return io.ReadAll(resp.Body)
}

```

# pkg/service/googleadmin/interface.go

```go
package googleadmin

// IService interface contain related google calendar method
type IService interface {
	GetGroupMemberEmails(groupEmail string) ([]string, error)
	DeleteAccount(mail string) error
}

```

# pkg/service/googleadmin/google_admin.go

```go
package googleadmin

import (
	"context"
	"errors"
	"fmt"
	"google.golang.org/api/option"

	"golang.org/x/oauth2"
	admin "google.golang.org/api/admin/directory/v1"

	"github.com/dwarvesf/fortress-api/pkg/config"
)

type googleService struct {
	config    *oauth2.Config
	token     *oauth2.Token
	service   *admin.Service
	appConfig *config.Config
}

// New function return Google service
func New(config *oauth2.Config, appConfig *config.Config) IService {
	return &googleService{
		config:    config,
		appConfig: appConfig,
	}
}

func (g *googleService) DeleteAccount(mail string) error {
	if err := g.ensureToken(g.appConfig.Google.AdminGoogleRefreshToken); err != nil {
		return err
	}

	if err := g.prepareService(); err != nil {
		return err
	}

	err := g.service.Users.Delete(mail).Do()
	return err
}

func (g *googleService) GetGroupMemberEmails(groupEmail string) ([]string, error) {
	if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil {
		return nil, err
	}

	if err := g.prepareService(); err != nil {
		return nil, err
	}

	var memberEmails []string

	members, err := g.service.Members.List(groupEmail).Do()
	if err != nil {
		return nil, err
	}

	if members == nil {
		return nil, fmt.Errorf("No member in group %v", groupEmail)
	}

	for _, m := range members.Members {
		memberEmails = append(memberEmails, m.Email)
	}

	return memberEmails, nil
}

func (g *googleService) ensureToken(rToken string) error {
	token := &oauth2.Token{
		RefreshToken: rToken,
	}

	if !g.token.Valid() {
		tks := g.config.TokenSource(context.Background(), token)
		tok, err := tks.Token()
		if err != nil {
			return err
		}
		g.token = tok
	}
	return nil
}

func (g *googleService) prepareService() error {
	client := g.config.Client(context.Background(), g.token)
	service, err := admin.NewService(context.Background(), option.WithHTTPClient(client))
	if err != nil {
		return errors.New("failed to prepare google admin service " + err.Error())
	}
	g.service = service
	return nil
}

```

# pkg/service/google/interface.go

```go
package google

type IService interface {
	GetLoginURL() string
	GetAccessToken(code string, redirectURL string) (accessToken string, err error)
	GetGoogleEmailLegacy(accessToken string) (email string, err error)
	GetGoogleEmail(accessToken string) (email string, err error)
}

```

# pkg/service/google/google.go

```go
package google

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"

	"golang.org/x/oauth2"
)

const (
	state                              = "state-token"
	getGoogleUserInfoAPIEndpointLegacy = "https://www.googleapis.com/plus/v1/people/me"
	getGoogleUserInfoAPIEndpoint       = "https://people.googleapis.com/v1/people/me"
)

type googleService struct {
	config *oauth2.Config
}

// New function return Google service
func New(config *oauth2.Config) (IService, error) {
	return &googleService{
		config: config,
	}, nil
}

// GetLoginURL return url for user loggin to google account
func (g *googleService) GetLoginURL() string {
	authURL := g.config.AuthCodeURL(state, oauth2.AccessTypeOffline)
	return authURL
}

// GetAccessToken return google access token
func (g *googleService) GetAccessToken(code string, redirectURL string) (string, error) {
	g.config.RedirectURL = redirectURL
	fmt.Println("GetAccessToken: ", g.config.ClientID)
	token, err := g.config.Exchange(context.Background(), code)
	if err != nil {
		return "", fmt.Errorf("failed to exchange code for token. err: %v, client: %v", err, g.config.ClientID)
	}
	return token.AccessToken, nil
}

// GetGoogleEmailLegacy return google user info
func (g *googleService) GetGoogleEmailLegacy(accessToken string) (email string, err error) {
	var gu struct {
		DisplayName string `json:"displayName"`
		ID          string `json:"id"`
		Emails      []struct {
			Type  string `json:"type"`
			Value string `json:"value"`
		} `json:"emails"`
	}

	response, err := http.Get(getGoogleUserInfoAPIEndpointLegacy + "?access_token=" + accessToken)
	if err != nil {
		return "", err
	}
	defer response.Body.Close()

	body, err := io.ReadAll(response.Body)
	if err != nil {
		return "", err
	}
	if err = json.Unmarshal(body, &gu); err != nil {
		return "", err
	}

	var primaryEmail string
	for i := range gu.Emails {
		if strings.ToLower(gu.Emails[i].Type) == "account" || gu.Emails[i].Type == "primary" {
			primaryEmail = gu.Emails[i].Value
			break
		}
	}
	return primaryEmail, nil
}

// GetGoogleEmail return google user info
func (g *googleService) GetGoogleEmail(accessToken string) (email string, err error) {
	var gu struct {
		DisplayName string `json:"displayName"`
		ID          string `json:"id"`
		Emails      []struct {
			Metadata struct {
				Primary       bool `json:"primary"`
				Verified      bool `json:"verified"`
				SourcePrimary bool `json:"sourcePrimary"`
			} `json:"metadata"`
			Value string `json:"value"`
		} `json:"emailAddresses"`
	}

	response, err := http.Get(getGoogleUserInfoAPIEndpoint + "?&personFields=emailAddresses&access_token=" + accessToken)
	if err != nil {
		return "", err
	}
	defer response.Body.Close()

	body, err := io.ReadAll(response.Body)
	if err != nil {
		return "", err
	}
	if err = json.Unmarshal(body, &gu); err != nil {
		return "", err
	}

	var primaryEmail string
	for i := range gu.Emails {
		if gu.Emails[i].Metadata.SourcePrimary {
			primaryEmail = gu.Emails[i].Value
			break
		}
	}

	return primaryEmail, nil
}

```

# pkg/service/github/service.go

```go
package github

import (
	"context"

	"github.com/google/go-github/v52/github"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IService interface {
	RemoveFromOrganizationByEmail(ctx context.Context, email string) error
	RemoveFromOrganizationByUsername(ctx context.Context, username string) error
	SendInvitationByEmail(ctx context.Context, e *model.Employee) error
	RetrieveUsernameByID(ctx context.Context, id int64) (string, error)
	FetchOpenPullRequest(ctx context.Context, repo string) ([]*github.PullRequest, error)
}

```

# pkg/service/github/github.go

```go
package github

import (
	"context"

	"github.com/google/go-github/v52/github"
	"golang.org/x/oauth2"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type githubService struct {
	Client *github.Client
	log    logger.Logger
}

var (
	defaultRole          = "direct_member"
	dwarvesFoundationOrg = "dwarvesf"
)

func New(cfg *config.Config, l logger.Logger) IService {
	if cfg.Github.Token == "" {
		return &githubService{}
	}
	return &githubService{
		Client: github.NewClient(
			oauth2.NewClient(context.Background(), oauth2.StaticTokenSource(
				&oauth2.Token{
					AccessToken: cfg.Github.Token,
				},
			))),
		log: l,
	}
}

func (s githubService) SendInvitationByEmail(ctx context.Context, e *model.Employee) error {
	if s.Client == nil {
		s.log.Warn("[SendInvitationByEmail] github token is empty")
		return nil
	}

	role := defaultRole
	opt := github.CreateOrgInvitationOptions{
		Email:  &e.PersonalEmail,
		Role:   &role,
		TeamID: []int64{},
	}

	s.log.Infof("[SendInvitationByEmail] Send invitation to user", "email", e.PersonalEmail)
	_, _, err := s.Client.Organizations.CreateOrgInvitation(ctx, dwarvesFoundationOrg, &opt)
	if err != nil {
		s.log.Errorf(err, "[SendInvitationByEmail] Fail to send invitation", "email", e.PersonalEmail)
		return err
	}

	return nil
}

func (s githubService) RemoveFromOrganizationByEmail(ctx context.Context, email string) error {
	if s.Client == nil {
		return nil
	}

	sOpts := github.SearchOptions{}

	result, _, err := s.Client.Search.Users(ctx, email, &sOpts)
	if err != nil {
		s.log.Errorf(err, "[RemoveFromOrganizationByEmail] fail to search user by email", "email", email)
		return err
	}

	switch {
	case len(result.Users) > 1:
		s.log.Errorf(ErrFoundOneMoreGithubAccount, "[RemoveFromOrganizationByEmail] more than 1 result return", "email", email)
		return ErrFoundOneMoreGithubAccount
	case len(result.Users) == 0:
		s.log.Errorf(ErrFailedToGetGithubAccount, "[RemoveFromOrganizationByEmail] can not found github account from user email", "email", email)
		return ErrFailedToGetGithubAccount
	}

	s.log.Infof("[RemoveFromOrganizationByEmail] Remove github member out of organization", "username", result.Users[0].GetLogin())
	_, err = s.Client.Organizations.RemoveMember(ctx, dwarvesFoundationOrg, result.Users[0].GetLogin())
	if err != nil {
		return err
	}

	return nil
}

func (s githubService) RemoveFromOrganizationByUsername(ctx context.Context, username string) error {
	if s.Client == nil {
		return nil
	}

	result, _, err := s.Client.Users.Get(ctx, username)
	if err != nil {
		s.log.Errorf(err, "[RemoveFromOrganizationByUsername] fail to search user by email", "username", username)
		return err
	}

	s.log.Infof("[RemoveFromOrganizationByUsername] remove github member out of organization", "username", result.GetLogin())
	_, err = s.Client.Organizations.RemoveMember(ctx, dwarvesFoundationOrg, result.GetLogin())
	if err != nil {
		return err
	}

	return nil
}

func (s githubService) RetrieveUsernameByID(ctx context.Context, id int64) (string, error) {
	user, _, err := s.Client.Users.GetByID(ctx, id)
	if err != nil {
		s.log.Errorf(err, "[RetrieveUsernameByID] fail to get user by id", "id", id)
		return "", err
	}

	return user.GetLogin(), nil
}

func (s githubService) FetchOpenPullRequest(ctx context.Context, repo string) (prs []*github.PullRequest, err error) {
	opts := &github.PullRequestListOptions{
		State:     "open",
		Sort:      "created",
		Direction: "desc",
		ListOptions: github.ListOptions{
			Page:    0,
			PerPage: 15,
		},
	}
	prs, _, err = s.Client.PullRequests.List(ctx, dwarvesFoundationOrg, repo, opts)
	if err != nil {
		s.log.Errorf(err, "[FetchOpenPullRequest] fail to fetch pull request", "repo", repo)
		return prs, err
	}

	return prs, nil
}

```

# pkg/service/github/errors.go

```go
package github

import "errors"

var (
	ErrFailedToGetGithubAccount  = errors.New("failed to get github account")
	ErrFoundOneMoreGithubAccount = errors.New("failed to get github account due to more than 1 github account found")
)

```

# pkg/service/tono/tono.go

```go
package tono

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
)

type IService interface {
	GetGuildUserProfile(profileId, guildId string) (*GuildProfile, error)
}

type client struct {
	cfg *config.Config
	l   logger.Logger
}

func New(cfg *config.Config, l logger.Logger) IService {
	return &client{
		cfg: cfg,
		l:   l,
	}
}

func (m *client) GetGuildUserProfile(profileId, guildId string) (*GuildProfile, error) {
	var client = &http.Client{
		Timeout: 10 * time.Second,
	}

	url := fmt.Sprintf("%s/api/v1/users/profiles?profile_id=%s&guild_id=%s", m.cfg.Tono.BaseURL, profileId, guildId)
	r, err := client.Get(url)
	if err != nil {
		m.l.Errorf(err, "[tono.GetGuildUserProfile] client.Get failed")
		return nil, err
	}
	defer r.Body.Close()

	res := &GetGuildProfileResponse{}
	if err := json.NewDecoder(r.Body).Decode(&res); err != nil {
		m.l.Errorf(err, "[tono.GetGuildUserProfile] decoder.Decode failed")
		return nil, err
	}

	return &res.Data, handleErrorStatusCode("Get Guild User Profile", r.StatusCode)
}

func handleErrorStatusCode(method string, statusCode int) error {
	if statusCode >= 200 && statusCode < 300 {
		return nil
	}

	return fmt.Errorf("%s status code: %d", method, statusCode)
}

```

# pkg/service/tono/request.go

```go
package tono

type GetGuildProfileResponse struct {
	Data GuildProfile `json:"data"`
}

type GuildProfile struct {
	ID           string         `json:"id"`
	CurrentLevel *ConfigXpLevel `json:"current_level"`
	NextLevel    *ConfigXpLevel `json:"next_level"`
	GuildXP      int            `json:"guild_xp"`
	NrOfActions  int            `json:"nr_of_actions"`
	Progress     float64        `json:"progress"`
	GuildRank    int            `json:"guild_rank"`
}

type ConfigXpLevel struct {
	Level int `json:"level" gorm:"primaryKey"`
	MinXP int `json:"min_xp"`
}

```

# pkg/service/git/inteface.go

```go
package git

type IService interface {
	Dest() string
	CreateBranch(branchName string) (err error)
	Commit(message string) (err error)
	Push() (err error)
	CreatePullRequest(owner, repo, head, base, title, body string) (*int, error)
	RequestReview(owner, repo string, pullRequestNumber int, reviewers []string) error
}

```

# pkg/service/git/git.go

```go
package git

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
	"github.com/google/go-github/v52/github"
	"golang.org/x/oauth2"
)

type gitService struct {
	dest   string
	repo   *git.Repository
	auth   *http.BasicAuth
	w      *git.Worktree
	client *github.Client
}

func New(url, username, password string) IService {
	repo := strings.Split(url, "/")[4]
	if repo == "" {
		fmt.Println("invalid repository url")
		return nil
	}
	auth := &http.BasicAuth{
		Username: username,
		Password: password,
	}
	dest := "/tmp/" + repo
	r, err := git.PlainClone(dest, false, &git.CloneOptions{
		URL:      url,
		Progress: os.Stdout,
		Auth:     auth,
	})
	if err != nil {
		fmt.Println(err)
		return nil
	}

	ctx := context.Background()
	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: password},
	)
	tc := oauth2.NewClient(ctx, ts)

	return &gitService{
		dest:   dest,
		repo:   r,
		auth:   auth,
		client: github.NewClient(tc),
	}
}

func (g *gitService) Dest() string {
	return g.dest
}

// CreateBranch creates a new branch from the current HEAD, and check out to the new branch
func (g *gitService) CreateBranch(branchName string) (err error) {
	if g.repo == nil {
		return errors.New("repository is not initialized")
	}

	headRef, err := g.repo.Head()
	if err != nil {
		return err
	}

	branchRefName := plumbing.NewBranchReferenceName(branchName)
	ref := plumbing.NewHashReference(branchRefName, headRef.Hash())
	if err := g.repo.Storer.SetReference(ref); err != nil {
		return err
	}

	w, err := g.repo.Worktree()
	if err != nil {
		return err
	}

	if err := w.Checkout(&git.CheckoutOptions{
		Branch: branchRefName,
		Force:  true,
	}); err != nil {
		return err
	}

	g.w = w
	return nil
}

func (g *gitService) Commit(message string) (err error) {
	if g.w == nil {
		return errors.New("worktree is not initialized")
	}

	if err := g.w.AddWithOptions(&git.AddOptions{All: true}); err != nil {
		return err
	}

	_, err = g.w.Commit(message, &git.CommitOptions{
		Author: &object.Signature{
			Name:  g.auth.Username,
			Email: "quanglm.ops@gmail.com",
			When:  time.Now(),
		},
	})
	if err != nil {
		return err
	}

	return nil
}

func (g *gitService) Push() (err error) {
	if g.repo == nil {
		return errors.New("repository is not initialized")
	}
	if g.auth == nil {
		return errors.New("auth is not initialized")
	}
	return g.repo.Push(&git.PushOptions{Auth: g.auth})
}

func (g *gitService) CreatePullRequest(owner, repo, head, base, title, body string) (*int, error) {
	newPR := &github.NewPullRequest{
		Title: github.String(title),
		Head:  github.String(head),
		Base:  github.String(base),
		Body:  github.String(body),
	}

	pr, _, err := g.client.PullRequests.Create(context.Background(), owner, repo, newPR)
	if err != nil {
		return nil, err
	}

	return pr.Number, nil
}

func (g *gitService) RequestReview(owner, repo string, pullRequestNumber int, reviewers []string) error {
	_, _, err := g.client.PullRequests.RequestReviewers(context.Background(), owner, repo, pullRequestNumber, github.ReviewersRequest{
		Reviewers: reviewers,
	})
	if err != nil {
		return err
	}

	return nil
}

```

# pkg/service/evm/model.go

```go
package evm

type RpcClient struct {
	Url string
}

var (
	DefaultBASEClient = RpcClient{Url: "https://mainnet.base.org"}
)

```

# pkg/service/evm/evm.go

```go
package evm

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/contracts/erc20"
	"github.com/dwarvesf/fortress-api/pkg/logger"
)

type IService interface {
	Client() *ethclient.Client
	ERC20Balance(address, owner common.Address) (*big.Int, error)
}

type evm struct {
	client *ethclient.Client
	cfg    *config.Config
	l      logger.Logger
}

func New(rpc RpcClient, cfg *config.Config, l logger.Logger) (IService, error) {
	client, err := ethclient.Dial(rpc.Url)
	if err != nil {
		return nil, err
	}

	return &evm{
		client: client,
		cfg:    cfg,
		l:      l,
	}, nil
}

func (e *evm) Client() *ethclient.Client {
	return e.client
}

func (e *evm) ERC20Balance(address, owner common.Address) (*big.Int, error) {
	instance, err := erc20.NewErc20(address, e.client)
	if err != nil {
		return nil, err
	}

	balance, err := instance.BalanceOf(nil, owner)
	if err != nil {
		return nil, err
	}

	return balance, nil
}

```

# pkg/service/discord/utils.go

```go
package discord

import (
	"time"

	"github.com/bwmarrin/discordgo"
	
	"github.com/dwarvesf/fortress-api/pkg/model"
)

// normalize add some default to embedded message if not set
func normalize(original *model.OriginalDiscordMessage, response *discordgo.MessageEmbed) *discordgo.MessageEmbed {
	if response.Timestamp == "" {
		response.Timestamp = time.Now().Format(time.RFC3339)
	}

	// I did something tricky here, if timestamp is custom, we don't want to show it, because in case of user want to add a custom date time format in the footer
	// instead of automatically add it, we don't want to show it twice.
	if response.Timestamp == "custom" {
		response.Timestamp = ""
	}

	if response.Color == 0 {
		// default df color #D14960
		response.Color = 13715808
	}
	if response.Footer == nil {
		response.Footer = &discordgo.MessageEmbedFooter{
			IconURL: "https://cdn.discordapp.com/avatars/564764617545482251/9c9bd4aaba164fc0b92f13f052405b4d.webp?size=160",
			Text:    "?help to see all commands",
		}
	}
	return response
}

```

# pkg/service/discord/service.go

```go
package discord

import (
	"github.com/bwmarrin/discordgo"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type IService interface {
	PostBirthdayMsg(msg string) (model.DiscordMessage, error)
	GetMembers() ([]*discordgo.Member, error)
	GetMember(userID string) (*discordgo.Member, error)
	GetMemberByUsername(username string) (*discordgo.Member, error)
	SearchMember(discordName string) ([]*discordgo.Member, error)
	GetRoles() (Roles, error)
	AddRole(userID, roleID string) error
	RemoveRole(userID string, roleID string) error

	CreateEvent(event *model.Schedule) (scheduledEvent *discordgo.GuildScheduledEvent, err error)
	UpdateEvent(event *model.Schedule) (scheduledEvent *discordgo.GuildScheduledEvent, err error)
	DeleteEvent(event *model.Schedule) error
	ListEvents() ([]*discordgo.GuildScheduledEvent, error)

	GetChannels() ([]*discordgo.Channel, error)
	GetMessagesAfterCursor(channelID string, cursorMessageID string, lastMessageID string) ([]*discordgo.Message, error)
	GetChannelMessages(channelID, before, after string, limit int) ([]*discordgo.Message, error)
	GetEventByID(eventID string) (*discordgo.GuildScheduledEvent, error)

	ReportBraineryMetrics(queryView string, braineryMetric *view.BraineryMetric, channelID string) (*discordgo.Message, error)
	DeliveryMetricWeeklyReport(deliveryMetrics *view.DeliveryMetricWeeklyReport, leaderBoard *view.WeeklyLeaderBoard, channelID string) (*discordgo.Message, error)
	DeliveryMetricMonthlyReport(deliveryMetrics *view.DeliveryMetricMonthlyReport, leaderBoard *view.WeeklyLeaderBoard, channelID string) (*discordgo.Message, error)
	SendNewMemoMessage(guildID string, memos []model.MemoLog, channelID string) (*discordgo.Message, error)
	SendWeeklyMemosMessage(guildID string, memos []model.MemoLog, weekRangeStr, channelID string) (*discordgo.Message, error)
	/*
		WEBHOOK
	*/

	// SendMessage logs a message to a Discord channel through a webhook
	SendMessage(discordMsg model.DiscordMessage, webhookUrl string) (*model.DiscordMessage, error)
	SendEmbeddedMessageWithChannel(original *model.OriginalDiscordMessage, embed *discordgo.MessageEmbed, channelId string) (*discordgo.Message, error)
	SendDiscordMessageWithChannel(ses *discordgo.Session, msg *discordgo.Message, channelId string) error

	ListActiveThreadsByChannelID(guildID, channelID string) ([]discordgo.Channel, error)
}

```

# pkg/service/discord/discord.go

```go
package discord

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/bwmarrin/discordgo"
	"github.com/shopspring/decimal"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

var (
	client           = http.DefaultClient
	memoCategoryList = []string{memoCategoryFleeting, memoCategoryLiterature, memoCategoryEarn, memoCategoryOthers}
)

const (
	memoCategoryFleeting   = "00_fleeting"
	memoCategoryLiterature = "01_literature"
	memoCategoryEarn       = "earn"
	memoCategoryOthers     = "others"
	discordEmbedMaxLen     = 4096
)

type discordClient struct {
	cfg     *config.Config
	session *discordgo.Session
}

func New(cfg *config.Config) IService {
	ses, _ := discordgo.New("Bot " + cfg.Discord.SecretToken)
	return &discordClient{
		cfg:     cfg,
		session: ses,
	}
}

func (d *discordClient) PostBirthdayMsg(msg string) (model.DiscordMessage, error) {
	discordMsg := model.DiscordMessage{Content: msg}
	reqByte, err := json.Marshal(discordMsg)
	if err != nil {
		return discordMsg, err
	}

	payload := bytes.NewReader(reqByte)
	if _, err := d.newRequest(http.MethodPost, d.cfg.Discord.Webhooks.Campfire, payload); err != nil {
		return discordMsg, err
	}
	return discordMsg, nil
}

func (d *discordClient) CreateEvent(event *model.Schedule) (*discordgo.GuildScheduledEvent, error) {
	discordEvent := &discordgo.GuildScheduledEventParams{
		Name:               event.Name,
		Description:        event.Description,
		ScheduledStartTime: event.StartTime,
		ScheduledEndTime:   event.EndTime,
		PrivacyLevel:       discordgo.GuildScheduledEventPrivacyLevelGuildOnly,
	}

	// by default, set channel to unknown
	discordEvent.EntityType = discordgo.GuildScheduledEventEntityTypeExternal
	discordEvent.EntityMetadata = &discordgo.GuildScheduledEventEntityMetadata{
		Location: "Unknown",
	}

	if event.GoogleCalendar.HangoutLink != "" {
		discordEvent.EntityType = discordgo.GuildScheduledEventEntityTypeExternal
		discordEvent.EntityMetadata = &discordgo.GuildScheduledEventEntityMetadata{
			Location: event.GoogleCalendar.HangoutLink,
		}
	}

	return d.session.GuildScheduledEventCreate(d.cfg.Discord.IDs.DwarvesGuild, discordEvent)
}

func (d *discordClient) UpdateEvent(event *model.Schedule) (*discordgo.GuildScheduledEvent, error) {
	discordEvent := &discordgo.GuildScheduledEventParams{
		Name:               event.Name,
		Description:        event.Description,
		ScheduledStartTime: event.StartTime,
		ScheduledEndTime:   event.EndTime,
	}

	return d.session.GuildScheduledEventEdit(d.cfg.Discord.IDs.DwarvesGuild, event.DiscordEvent.DiscordEventID, discordEvent)
}

func (d *discordClient) DeleteEvent(event *model.Schedule) error {
	return d.session.GuildScheduledEventDelete(d.cfg.Discord.IDs.DwarvesGuild, event.DiscordEvent.DiscordEventID)
}

func (d *discordClient) ListEvents() ([]*discordgo.GuildScheduledEvent, error) {
	return d.session.GuildScheduledEvents(d.cfg.Discord.IDs.DwarvesGuild, false)
}

func (d *discordClient) newRequest(method string, url string, payload io.Reader) ([]byte, error) {
	req, err := http.NewRequest(method, url, payload)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")

	var res *http.Response
	if res, err = client.Do(req); err != nil {
		return nil, err
	}
	defer res.Body.Close()

	resBody, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}
	return resBody, nil
}

func (d *discordClient) GetMembers() ([]*discordgo.Member, error) {
	members := make([]*discordgo.Member, 0)

	after := ""
	limit := 1000
	for {
		guildMembers, err := d.session.GuildMembers(d.cfg.Discord.IDs.DwarvesGuild, after, limit)
		if err != nil {
			return nil, err
		}

		members = append(members, guildMembers...)

		if len(guildMembers) < limit {
			break
		}

		after = guildMembers[len(guildMembers)-1].User.ID
	}

	return members, nil
}

func (d *discordClient) SendMessage(discordMsg model.DiscordMessage, webhookUrl string) (*model.DiscordMessage, error) {
	reqByte, err := json.Marshal(discordMsg)
	if err != nil {
		return &discordMsg, err
	}

	payload := bytes.NewReader(reqByte)
	res, err := d.session.Client.Post(webhookUrl, "application/json", payload)
	if err != nil {
		return &discordMsg, err
	}
	defer res.Body.Close()

	return &discordMsg, nil
}

func (d *discordClient) SearchMember(discordName string) ([]*discordgo.Member, error) {
	members := make([]*discordgo.Member, 0)
	guildMembers, err := d.session.GuildMembersSearch(d.cfg.Discord.IDs.DwarvesGuild, discordName, 1000)
	if err != nil {
		return nil, err
	}

	members = append(members, guildMembers...)

	return members, nil
}

func (d *discordClient) GetMember(userID string) (*discordgo.Member, error) {
	member, err := d.session.GuildMember(d.cfg.Discord.IDs.DwarvesGuild, userID)
	if err != nil {
		return nil, err
	}

	return member, nil
}

func (d *discordClient) GetMemberByName(discordName string) ([]*discordgo.Member, error) {
	members := make([]*discordgo.Member, 0)
	guildMembers, err := d.session.GuildMembersSearch(d.cfg.Discord.IDs.DwarvesGuild, discordName, 1000)
	if err != nil {
		return nil, err
	}

	members = append(members, guildMembers...)

	return members, nil
}

func (d *discordClient) GetMemberByUsername(username string) (*discordgo.Member, error) {
	if username == "" {
		return nil, nil
	}

	guildMembers, err := d.SearchMember(username)
	if err != nil {
		return nil, err
	}

	var discordMember *discordgo.Member
	for _, m := range guildMembers {
		if m.User.Username == username {
			discordMember = m
		}
	}

	return discordMember, nil
}

func (d *discordClient) GetRoles() (Roles, error) {
	roles, err := d.session.GuildRoles(d.cfg.Discord.IDs.DwarvesGuild)
	if err != nil {
		return nil, err
	}

	return roles, nil
}

func (d *discordClient) AddRole(userID, roleID string) error {
	return d.session.GuildMemberRoleAdd(d.cfg.Discord.IDs.DwarvesGuild, userID, roleID)
}

func (d *discordClient) RemoveRole(userID string, roleID string) error {
	return d.session.GuildMemberRoleRemove(d.cfg.Discord.IDs.DwarvesGuild, userID, roleID)
}

type Roles discordgo.Roles

func (r Roles) DwarvesRoles() []*discordgo.Role {
	roleMap := getDwarvesRolesMap()

	dwarvesRoles := make([]*discordgo.Role, 0)
	for _, dRole := range r {
		_, ok := roleMap[dRole.Name]
		if ok {
			dwarvesRoles = append(dwarvesRoles, dRole)
		}
	}

	return dwarvesRoles
}

func (r Roles) ByCode(code string) *discordgo.Role {
	for _, dRole := range r {
		if dRole.Name == code {
			return dRole
		}
	}

	return nil
}

func getDwarvesRolesMap() map[string]bool {
	return map[string]bool{
		"moderator":  true,
		"dwarf":      true,
		"booster":    true,
		"apprentice": true,
		"crafter":    true,
		"specialist": true,
		"principal":  true,
		"peeps":      true,
		"learning":   true,
		"engagement": true,
		"delivery":   true,
		"labs":       true,
		"baby dwarf": true,
		"ladies":     true,
		"sers":       true,
		"consultant": true,
		"chad":       true,
	}
}

func (d *discordClient) GetChannels() ([]*discordgo.Channel, error) {
	return d.session.GuildChannels(d.cfg.Discord.IDs.DwarvesGuild)
}

func (d *discordClient) GetMessagesAfterCursor(
	channelID string,
	cursorMessageID string,
	lastMessageID string,
) ([]*discordgo.Message, error) {
	cursorMessageIDUint, err := strconv.ParseUint(cursorMessageID, 10, 64)
	if err != nil {
		return nil, err
	}
	lastMessageIDUint, err := strconv.ParseUint(lastMessageID, 10, 64)
	if err != nil {
		return nil, err
	}

	allMessages := make([]*discordgo.Message, 0)
	for cursorMessageIDUint < lastMessageIDUint {
		messages, err := d.session.ChannelMessages(
			channelID,
			100, // 100 is the maximal number allowed
			"",
			cursorMessageID,
			"",
		)
		if len(messages) == 0 {
			// early break to avoid index out of bound error
			break
		}
		if err != nil {
			return nil, err
		}
		// reversal is needed since messages are sorted by newest first
		for i, j := 0, len(messages)-1; i < j; i, j = i+1, j-1 {
			messages[i], messages[j] = messages[j], messages[i]
		}

		allMessages = append(allMessages, messages...)
		newestMessage := messages[len(messages)-1]
		cursorMessageID = newestMessage.ID
		cursorMessageIDUint, err = strconv.ParseUint(cursorMessageID, 10, 64)
		if err != nil {
			return nil, err
		}
		// a pause is needed to avoid Discord's rate limiting
		time.Sleep(500 * time.Millisecond)
	}

	return allMessages, nil
}

func (d *discordClient) ReportBraineryMetrics(queryView string, braineryMetric *view.BraineryMetric, channelID string) (*discordgo.Message, error) {
	var messageEmbed []*discordgo.MessageEmbedField
	totalICY := decimal.NewFromInt(0)
	content := ""

	var newBraineryPost []view.Post
	newBraineryPost = append(newBraineryPost, braineryMetric.Contributors...)
	newBraineryPost = append(newBraineryPost, braineryMetric.NewContributors...)

	if len(newBraineryPost) == 0 {
		content += "There is no new brainery note in this period. This is where we keep track of our **top 10 latest** Brainery notes:\n\n"

		for _, itm := range braineryMetric.LatestPosts {
			content += fmt.Sprintf("• [%s](%s) <@%v>\n", itm.Title, itm.URL, itm.DiscordID)
		}
	} else {
		newBraineryPostStr := ""
		for _, itm := range newBraineryPost {
			totalICY = totalICY.Add(itm.Reward)
			newBraineryPostStr += fmt.Sprintf("• [%s](%s) <@%v>\n", itm.Title, itm.URL, itm.DiscordID)
		}

		if len(newBraineryPostStr) > 0 {
			content += "**Latest Notes** :fire::fire::fire:\n"
			content += newBraineryPostStr + "\n"
		}
	}

	if queryView == "monthly" {
		topContributor := calculateTopContributor(braineryMetric.TopContributors)
		content += topContributor + "\n"
	}

	newContributor := ""
	if len(braineryMetric.NewContributors) > 0 {
		ids := make(map[string]bool)
		for _, itm := range braineryMetric.NewContributors {
			v, ok := ids[itm.DiscordID]
			if ok && v {
				continue
			}
			ids[itm.DiscordID] = true
			newContributor += fmt.Sprintf("<@%v> ", itm.DiscordID)
		}
	}

	if newContributor != "" {
		content += "**New Contributors**\n"
		content += newContributor + "\n"
	}

	if totalICY.GreaterThan(decimal.NewFromInt(0)) {
		content += "\n**Total Reward Distributed**\n"
		content += totalICY.String() + " ICY 🧊"
	}

	tags := ""
	if len(braineryMetric.Tags) > 0 {
		for _, tag := range braineryMetric.Tags {
			tags += fmt.Sprintf("#%v ", tag)
		}
	}

	if len(tags) > 0 {
		embedField := &discordgo.MessageEmbedField{
			Name:   "Tags",
			Value:  tags,
			Inline: false,
		}

		messageEmbed = append(messageEmbed, embedField)
	}

	msg := &discordgo.MessageEmbed{
		Title:       fmt.Sprintf("BRAINERY %s REPORT", strings.ToTitle(queryView)),
		Fields:      messageEmbed,
		Description: content,
		Footer: &discordgo.MessageEmbedFooter{
			IconURL: "https://cdn.discordapp.com/avatars/564764617545482251/9c9bd4aaba164fc0b92f13f052405b4d.webp?size=160",
			Text:    "?help to see all commands",
		},
	}

	return d.SendEmbeddedMessageWithChannel(nil, msg, channelID)
}

func calculateTopContributor(topContributors []view.TopContributor) string {
	topContributorStr := ""
	if len(topContributors) == 0 {
		return ""
	}

	countMap := make(map[int][]string)
	var uniqueCounts []int

	for _, contributor := range topContributors {
		if contributor.Count > 1 {
			count := contributor.Count
			discordID := contributor.DiscordID
			countMap[count] = append(countMap[count], discordID)

			// Check if count is already in uniqueCounts
			found := false
			for _, uniqueCount := range uniqueCounts {
				if uniqueCount == count {
					found = true
					break
				}
			}

			// If count is not found, add it to uniqueCounts
			if !found {
				uniqueCounts = append(uniqueCounts, count)
			}
		}
	}

	emojiMap := map[int]string{
		0: ":first_place:",
		1: ":second_place:",
		2: ":third_place:",
	}

	// Iterate over uniqueCounts to access Discord IDs in order
	for idx, count := range uniqueCounts {
		discordIDs := countMap[count]
		discordIDStr := ""
		for i := 0; i < len(discordIDs); i++ {
			discordIDStr += "<@" + discordIDs[i] + ">, "
		}

		emojiIdx := idx
		if idx > 2 {
			emojiIdx = 2
		}

		topContributorStr += fmt.Sprintf("%v %v (x%v) \n", emojiMap[emojiIdx], strings.TrimSuffix(discordIDStr, ", "), count)
	}

	topContributor := ""
	if len(topContributorStr) > 0 {
		topContributor += "**Top Contributors**\n"
		topContributor += topContributorStr
	}

	return topContributor
}

func CreateDeliveryMetricWeeklyReportMessage(deliveryMetric *view.DeliveryMetricWeeklyReport, leaderBoard *view.WeeklyLeaderBoard) *discordgo.MessageEmbed {
	var messageEmbed []*discordgo.MessageEmbedField
	content := "*Track software team's performance. Encourages competition and collaboration. Optimizes project delivery. Promotes accountability.*\n\n"

	if leaderBoard != nil {
		leaderBoardStr := getLeaderBoardAsString(leaderBoard.Items)
		content += "**Leaderboard**\n"
		content += leaderBoardStr
		content += "\n\n"
	}

	previousWeek := fmt.Sprintf("**Previous Week - %v**\n", deliveryMetric.LastWeek.Date.Format("02 Jan 2006"))
	previousWeek += fmt.Sprintf("%v`Total Point.  %v pts`\n", getEmoji("STAR_ANIMATED"), utils.FloatToString(float64(deliveryMetric.LastWeek.TotalPoints)))
	previousWeek += fmt.Sprintf("%v`Effort.       %v hrs`\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.LastWeek.Effort)))
	previousWeek += fmt.Sprintf("%v`AVG W.Point.  %v pts`\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.LastWeek.AvgPoint)))
	previousWeek += fmt.Sprintf("%v`AVG W.Effort. %v hrs`\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.LastWeek.AvgEffort)))

	content += previousWeek

	emojiUp := getEmoji("ARROW_UP_ANIMATED")
	emojiDown := getEmoji("ARROW_DOWN_ANIMATED")

	pointChange := fmt.Sprintf("%v %v%%", emojiUp, deliveryMetric.TotalPointChangePercentage)
	if deliveryMetric.TotalPointChangePercentage < 0 {
		pointChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.TotalPointChangePercentage)
	}

	effortChange := fmt.Sprintf("%v%v%%", emojiUp, deliveryMetric.EffortChangePercentage)
	if deliveryMetric.EffortChangePercentage < 0 {
		effortChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.EffortChangePercentage)
	}

	avgPointChange := fmt.Sprintf("%v%v%%", emojiUp, deliveryMetric.AvgPointChangePercentage)
	if deliveryMetric.AvgPointChangePercentage < 0 {
		avgPointChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgPointChangePercentage)
	}

	avgEffortChange := fmt.Sprintf("%v %v%%", emojiUp, deliveryMetric.AvgEffortChangePercentage)
	if deliveryMetric.AvgEffortChangePercentage < 0 {
		avgEffortChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgEffortChangePercentage)
	}

	date := deliveryMetric.CurrentWeek.Date.Format("02 Jan 2006")
	currentWeek := fmt.Sprintf("\n**Current Week - %v**\n", deliveryMetric.CurrentWeek.Date.Format("02 Jan 2006"))
	currentWeek += fmt.Sprintf("%v`Total Point.  %v pts` (%v)\n", getEmoji("STAR_ANIMATED"), utils.FloatToString(float64(deliveryMetric.CurrentWeek.TotalPoints)), pointChange)
	currentWeek += fmt.Sprintf("%v`Effort.       %v hrs` (%v)\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.CurrentWeek.Effort)), effortChange)
	currentWeek += fmt.Sprintf("%v`AVG W.Point.  %v pts` (%v)\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.CurrentWeek.AvgPoint)), avgPointChange)
	currentWeek += fmt.Sprintf("%v`AVG W.Effort. %v hrs` (%v)\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.CurrentWeek.AvgEffort)), avgEffortChange)

	content += currentWeek

	msg := &discordgo.MessageEmbed{
		Title:       "**🏆 DELIVERY WEEKLY REPORT 🏆**" + " - " + strings.ToUpper(date),
		Fields:      messageEmbed,
		Description: content,
		Footer: &discordgo.MessageEmbedFooter{
			IconURL: "https://cdn.discordapp.com/avatars/564764617545482251/9c9bd4aaba164fc0b92f13f052405b4d.webp?size=160",
			Text:    "?help to see all commands",
		},
	}

	return msg
}

func (d *discordClient) DeliveryMetricWeeklyReport(deliveryMetric *view.DeliveryMetricWeeklyReport, leaderBoard *view.WeeklyLeaderBoard, channelID string) (*discordgo.Message, error) {
	msg := CreateDeliveryMetricWeeklyReportMessage(deliveryMetric, leaderBoard)
	return d.SendEmbeddedMessageWithChannel(nil, msg, channelID)
}

func CreateDeliveryMetricMonthlyReportMessage(deliveryMetric *view.DeliveryMetricMonthlyReport, leaderBoard *view.WeeklyLeaderBoard) *discordgo.MessageEmbed {
	content := "*Track software team's performance. Encourages competition and collaboration. Optimizes project delivery. Promotes accountability.*\n\n"

	if leaderBoard != nil {
		leaderBoardStr := getLeaderBoardAsString(leaderBoard.Items)
		content += "**Leaderboard**\n"
		content += leaderBoardStr
		content += "\n\n"
	}

	previousMonth := fmt.Sprintf("**Previous Month - %v**\n", deliveryMetric.LastMonth.Month.Format("Jan 2006"))
	previousMonth += fmt.Sprintf("%v`Total Point.  %v pts`\n", getEmoji("STAR_ANIMATED"), utils.FloatToString(float64(deliveryMetric.LastMonth.TotalWeight)))
	previousMonth += fmt.Sprintf("%v`Effort.       %v hrs`\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.LastMonth.Effort)))
	previousMonth += fmt.Sprintf("%v`AVG Point.    %v pts`\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.LastMonth.AvgWeight)))
	previousMonth += fmt.Sprintf("%v`AVG Effort.   %v hrs`\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.LastMonth.AvgEffort)))
	previousMonth += fmt.Sprintf("%v`AVG W.Point.  %v pts`\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.LastMonth.AvgWeeklyWeight)))
	previousMonth += fmt.Sprintf("%v`AVG W.Effort. %v hrs`\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.LastMonth.AvgWeeklyEffort)))

	content += previousMonth

	emojiUp := getEmoji("ARROW_UP_ANIMATED")
	emojiDown := getEmoji("ARROW_DOWN_ANIMATED")

	pointChange := fmt.Sprintf("%v %v%%", emojiUp, deliveryMetric.TotalPointChangePercentage)
	if deliveryMetric.TotalPointChangePercentage < 0 {
		pointChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.TotalPointChangePercentage)
	}

	effortChange := fmt.Sprintf("%v%v%%", emojiUp, deliveryMetric.EffortChangePercentage)
	if deliveryMetric.EffortChangePercentage < 0 {
		effortChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.EffortChangePercentage)
	}

	avgPointChange := fmt.Sprintf("%v%v%%", emojiUp, deliveryMetric.AvgWeightChangePercentage)
	if deliveryMetric.AvgWeightChangePercentage < 0 {
		avgPointChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgWeightChangePercentage)
	}

	avgEffortChange := fmt.Sprintf("%v %v%%", emojiUp, deliveryMetric.AvgEffortChangePercentage)
	if deliveryMetric.AvgEffortChangePercentage < 0 {
		avgEffortChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgEffortChangePercentage)
	}

	avgWeeklyPointChange := fmt.Sprintf("%v%v%%", emojiUp, deliveryMetric.AvgWeeklyPointChangePercentage)
	if deliveryMetric.AvgWeeklyPointChangePercentage < 0 {
		avgWeeklyPointChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgWeeklyPointChangePercentage)
	}

	avgWeeklyEffortChange := fmt.Sprintf("%v %v%%", emojiUp, deliveryMetric.AvgWeeklyEffortChangePercentage)
	if deliveryMetric.AvgWeeklyEffortChangePercentage < 0 {
		avgWeeklyEffortChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgWeeklyEffortChangePercentage)
	}

	currentMonth := fmt.Sprintf("\n**Current Month - %v**\n", deliveryMetric.CurrentMonth.Month.Format("Jan 2006"))
	currentMonth += fmt.Sprintf("%v`Total Point.  %v pts` (%v)\n", getEmoji("STAR_ANIMATED"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.TotalWeight)), pointChange)
	currentMonth += fmt.Sprintf("%v`Effort.       %v hrs` (%v)\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.Effort)), effortChange)
	currentMonth += fmt.Sprintf("%v`AVG Point.    %v pts` (%v)\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.AvgWeight)), avgPointChange)
	currentMonth += fmt.Sprintf("%v`AVG Effort.   %v hrs` (%v)\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.AvgEffort)), avgEffortChange)
	currentMonth += fmt.Sprintf("%v`AVG W.Point.  %v pts` (%v)\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.AvgWeeklyWeight)), avgWeeklyPointChange)
	currentMonth += fmt.Sprintf("%v`AVG W.Effort. %v hrs` (%v)\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.AvgWeeklyEffort)), avgWeeklyEffortChange)

	content += currentMonth

	month := deliveryMetric.CurrentMonth.Month.Format("Jan 2006")
	msg := &discordgo.MessageEmbed{
		Title:       "**🏆 DELIVERY MONTHLY REPORT 🏆**" + " - " + strings.ToUpper(month),
		Description: content,
		Footer: &discordgo.MessageEmbedFooter{
			IconURL: "https://cdn.discordapp.com/avatars/564764617545482251/9c9bd4aaba164fc0b92f13f052405b4d.webp?size=160",
			Text:    "?help to see all commands",
		},
	}

	return msg
}

func (d *discordClient) DeliveryMetricMonthlyReport(deliveryMetric *view.DeliveryMetricMonthlyReport, leaderBoard *view.WeeklyLeaderBoard, channelID string) (*discordgo.Message, error) {
	msg := CreateDeliveryMetricMonthlyReportMessage(deliveryMetric, leaderBoard)
	return d.SendEmbeddedMessageWithChannel(nil, msg, channelID)
}

func getLeaderBoardAsString(data []view.LeaderBoardItem) string {
	emojiMap := map[int]string{
		1: getEmoji("BADGE1"),
		2: getEmoji("BADGE2"),
		3: getEmoji("BADGE3"),
		4: getEmoji("BADGE5"),
		5: getEmoji("BADGE5"),
	}
	// Sort the data by rank in ascending order
	var currentRank int
	var leaderBoardString strings.Builder
	for _, employee := range data {
		rank := employee.Rank
		if rank > 5 {
			break
		}
		if rank == 5 {
			rank = 4
		}
		if rank != currentRank {
			if currentRank > 0 {
				leaderBoardString.WriteString("\n")
			}
			currentRank = employee.Rank
			leaderBoardString.WriteString(fmt.Sprintf("%v ", emojiMap[currentRank]))
		}

		leaderBoardString.WriteString(fmt.Sprintf("<@%v> ", employee.DiscordID))
	}

	return leaderBoardString.String()
}
func (d *discordClient) SendEmbeddedMessageWithChannel(original *model.OriginalDiscordMessage, embed *discordgo.MessageEmbed, channelId string) (*discordgo.Message, error) {
	msg, err := d.session.ChannelMessageSendEmbed(channelId, normalize(original, embed))
	return msg, err
}

func (d *discordClient) SendNewMemoMessage(guildID string, memos []model.MemoLog, channelID string) (*discordgo.Message, error) {
	for i, content := range memos {
		if i <= 10 {
			var textMessage string

			authorField := ""
			for _, author := range content.Authors {
				if author.DiscordID != "" {
					authorField += fmt.Sprintf(" <@%s> ", author.DiscordID)
				} else if author.DiscordUsername != "" {
					authorField += fmt.Sprintf(" @%s ", author.DiscordUsername)
				} else {
					authorField += " **@unknown-user**"
				}
			}

			// Use memo username if discord username is not available
			if authorField == "" {
				for _, author := range content.AuthorMemoUsernames {
					authorField += fmt.Sprintf(" **%s** ", author)
				}
			}

			author := ""
			if authorField != "" {
				author = "from" + authorField
			}

			textMessage += fmt.Sprintf("New memo post %v \n [%s](%s)\n", author, content.Title, content.URL)

			msg := &discordgo.Message{
				Content: textMessage,
			}

			err := d.SendDiscordMessageWithChannel(d.session, msg, channelID)
			if err != nil {
				return nil, err
			}
		}
	}

	return nil, nil
}

func (d *discordClient) SendWeeklyMemosMessage(guildID string, memos []model.MemoLog, weekRangeStr, channelID string) (*discordgo.Message, error) {
	bagde1Emoji := getEmoji("BADGE1")
	bagde5Emoji := getEmoji("BADGE5")
	pepeNoteEmoji := getEmoji("PEPE_NOTE")
	authorMap := make(map[string]int)

	var content strings.Builder
	var memolistString strings.Builder

	content.WriteString("*What is going on with our memo this week?*\n\n")
	content.WriteString("**OVERVIEW**\n")
	content.WriteString(fmt.Sprintf("%v `Total publication.` **%v** posts\n", bagde5Emoji, len(memos)))
	memolistString.WriteString("**PUBLICATIONS**\n")

	//Group by category
	memosByCategory := map[string][]model.MemoLog{
		memoCategoryFleeting:   make([]model.MemoLog, 0),
		memoCategoryLiterature: make([]model.MemoLog, 0),
		memoCategoryEarn:       make([]model.MemoLog, 0),
		memoCategoryOthers:     make([]model.MemoLog, 0),
	}

	for _, mem := range memos {
		isMapped := false
		for _, category := range mem.Category {
			if strings.EqualFold(category, memoCategoryFleeting) ||
				strings.EqualFold(category, memoCategoryLiterature) ||
				strings.EqualFold(category, memoCategoryEarn) {
				memosByCategory[category] = append(memosByCategory[category], mem)
				isMapped = true
				break
			}
		}

		if !isMapped {
			memosByCategory[memoCategoryOthers] = append(memosByCategory[memoCategoryOthers], mem)
		}
	}

	for _, category := range memoCategoryList {
		memos := memosByCategory[category]

		// Category
		memolistString.WriteString(fmt.Sprintf("🔹 **%s** - %v posts\n", strings.ToUpper(category), len(memos)))

		for idx, mem := range memos {
			authorField := ""
			for _, author := range mem.Authors {
				authorMap[author.DiscordID] += 1

				if author.DiscordID != "" {
					authorField += fmt.Sprintf(" <@%s> ", author.DiscordID)
				} else if author.DiscordUsername != "" {
					authorField += fmt.Sprintf(" @%s ", author.DiscordUsername)
				} else {
					authorField += " **@unknown-user**"
				}
			}

			if authorField == "" {
				authorField = "**@unknown-user**"
			}

			memolistString.WriteString(fmt.Sprintf("[[%v](%s)] %s - %v\n", idx+1, mem.URL, mem.Title, authorField))
		}

		memolistString.WriteString("\n")
	}

	// update author count based on finally updated value
	content.WriteString(fmt.Sprintf("%v `Total author.` **%v** authors\n\n", pepeNoteEmoji, len(authorMap)))
	content.WriteString(memolistString.String())

	msg := &discordgo.MessageEmbed{
		Title:       fmt.Sprintf("%v WEEKLY MEMO REPORT (%v) %v", bagde1Emoji, weekRangeStr, bagde1Emoji),
		Description: content.String(),
	}

	_, err := d.SendEmbeddedMessageWithChannel(nil, msg, channelID)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

func (d *discordClient) SendDiscordMessageWithChannel(ses *discordgo.Session, msg *discordgo.Message, channelId string) error {
	_, err := ses.ChannelMessageSend(channelId, msg.Content)
	return err
}

func (d *discordClient) GetChannelMessages(channelID, before, after string, limit int) ([]*discordgo.Message, error) {
	return d.session.ChannelMessages(channelID, limit, before, after, "")
}

func (d *discordClient) GetEventByID(eventID string) (*discordgo.GuildScheduledEvent, error) {
	return d.session.GuildScheduledEvent(d.cfg.Discord.IDs.DwarvesGuild, eventID, false)
}

func (d *discordClient) ListActiveThreadsByChannelID(guildID, channelID string) ([]discordgo.Channel, error) {
	threadsList, err := d.session.GuildThreadsActive(guildID)
	if err != nil {
		return nil, err
	}

	result := make([]discordgo.Channel, 0)
	for _, thread := range threadsList.Threads {
		if thread.ParentID == channelID {
			result = append(result, *thread)
		}
	}

	return result, nil
}

```

# pkg/service/discord/const.go

```go
package discord

import "os"

var mapEmoji = map[string]string{
	"ARROW_DOWN_ANIMATED": "<a:arrow_down_animated:1131789144759214171>",
	"ARROW_UP_ANIMATED":   "<a:arrow_up_animated:1131789319644921936>",
	"BADGE1":              "<a:badge1:1131850989062852638>",
	"BADGE2":              "<a:badge2:1131850991663337554>",
	"BADGE3":              "<a:badge3:1131850996159610930>",
	"BADGE5":              "<a:badge5:1131851001117294672>",
	"LOG_CHANNEL":         "<:log_channel:1131863319377100841>",
	"STAR_ANIMATED":       "<a:star_animated:1131862886592024586>",
	"INCREASING_ANIMATED": "<a:increasing_animated:1131862879319097394>",
	"CLOCK_NEW":           "<:clock_new:1131863089185292428>",
	"PEPE_NOTE":           "<:pepenote:885515949673951282>",
}

func getEmoji(emoji string) string {
	if os.Getenv("ENV") != "prod" {
		return mapEmojiDev[emoji]
	}
	return mapEmoji[emoji]
}

var mapEmojiDev = map[string]string{
	"ARROW_DOWN_ANIMATED": "<a:arrow_up_animated:1131317348670902292>",
	"ARROW_UP_ANIMATED":   "<a:arrow_down_animated:1131317344774397992>",
	"BADGE1":              "<a:badge1:1133460615684440167>",
	"BADGE2":              "<a:badge2:1133460619253796914>",
	"BADGE3":              "<a:badge3:1133460622365958304>",
	"BADGE5":              "<a:badge5:1133460625784320021>",
	"LOG_CHANNEL":         "<:logchannel:1133460455906627614>",
	"STAR_ANIMATED":       "<a:star_animated:1133460443550195832>",
	"INCREASING_ANIMATED": "<a:increasing_animated:1133460451091550289>",
	"CLOCK_NEW":           "<:clock:1133460445257281658>",
	"PEPE_NOTE":           "<:pepenote:1240695189622755530>",
}

```

# pkg/service/communitynft/communitynft.go

```go
package communitynft

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"

	"github.com/dwarvesf/fortress-api/pkg/config"
	erc721abi "github.com/dwarvesf/fortress-api/pkg/contracts/erc721"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service/evm"
)

type IService interface {
	OwnerOf(tokenId int) (string, error)
}

type nft struct {
	instance *erc721abi.ERC721
	evm      evm.IService
	cfg      *config.Config
	l        logger.Logger
}

const (
	DefaultCommunityNftContractAddress = "0x3150825A8b9990567790B22a4F987b6A82d89d54"
)

func New(evm evm.IService, cfg *config.Config, l logger.Logger) (IService, error) {
	addr := cfg.CommunityNft.ContractAddress
	if addr == "" {
		addr = DefaultCommunityNftContractAddress
	}
	instance, err := erc721abi.NewERC721(common.HexToAddress(addr), evm.Client())
	if err != nil {
		return nil, err
	}

	return &nft{
		instance: instance,
		evm:      evm,
		cfg:      cfg,
		l:        l,
	}, nil
}

func (n *nft) OwnerOf(tokenId int) (string, error) {
	owner, err := n.instance.OwnerOf(nil, big.NewInt(int64(tokenId)))
	if err != nil {
		return "", err
	}
	return owner.String(), nil
}

```

# pkg/service/currency/interface.go

```go
package currency

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type IService interface {
	USDToVND(usd float64) (float64, error)
	VNDToUSD(vnd float64) (float64, error)

	Convert(value float64, target, dest string) (float64, float64, error)

	GetByName(db *gorm.DB, name string) (*model.Currency, error)
	GetByID(db *gorm.DB, id model.UUID) (*model.Currency, error)
	GetCurrencyOption(db *gorm.DB) ([]model.Currency, error)

	GetRate(target string) (float64, error)
}

const (
	// VNDCurrency : VietNam dong
	VNDCurrency = "VND"

	// USDCurrency : US dollar
	USDCurrency = "USD"

	// GBPCurrency :  British Pound
	GBPCurrency = "GBP"

	// SGDCurrency : Singapore Dollar
	SGDCurrency = "SGD"

	// EURCurrency : Europe dollar
	EURCurrency = "EUR"

	// EURCurrency : Canadian dollar
	CADCurrency = "CAD"
)

```

# pkg/service/currency/currency.go

```go
package currency

import (
	"encoding/json"
	"math"
	"net/http"
	"time"

	"github.com/patrickmn/go-cache"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type service struct {
	cacheMap *cache.Cache
	token    string
	cfg      *config.Config
}

func New(cfg *config.Config) IService {
	cacheMap := cache.New(24*time.Hour, 24*time.Hour)
	return &service{
		token:    cfg.CurrencyLayer.APIKey,
		cacheMap: cacheMap,
		cfg:      cfg,
	}
}

// TODO: need test
func (s *service) Convert(value float64, src, target string) (float64, float64, error) {
	rate, err := s.getRateForTwoCurrency(src, target)
	if err != nil {
		return 0, 0, err
	}
	return math.Ceil(value * rate), rate, nil
}

// here come the magic, since we can convert to USD only
// 1 USD = X_src
// 1 USD = Y_target
// <=> X_src = Y_target
// <=> src = Y/X target
func (s *service) getRateForTwoCurrency(src, target string) (float64, error) {
	x, err := s.GetRate(src)
	if err != nil {
		return 0, err
	}
	y, err := s.GetRate(target)
	if err != nil {
		return 0, err
	}
	return y / x, nil
}

func (s *service) USDToVND(usd float64) (float64, error) {
	res, err := s.usdCentToVND(int64(usd) * 100)
	if err != nil {
		return 0, err
	}
	return float64(res / 100), nil
}

func (s *service) VNDToUSD(vnd float64) (float64, error) {
	res, err := s.vndToUSDCent(int64(vnd))
	if err != nil {
		return 0, err
	}
	return float64(res / 100), nil
}

func (s *service) usdCentToVND(usd int64) (int64, error) {
	rate, err := s.getRate("VND")
	if err != nil {
		return 0, err
	}
	return usd * int64(rate), nil
}

func (s *service) vndToUSDCent(vnd int64) (int64, error) {
	rate, err := s.getRate("VND")
	if err != nil {
		return 0, err
	}
	float := float64(vnd) / rate
	return int64(math.Ceil(float) * 100), nil
}

func (s *service) GetByName(db *gorm.DB, name string) (*model.Currency, error) {
	c := model.Currency{}
	return &c, db.Where("name = ?", name).First(&c).Error
}

func (s *service) GetByID(db *gorm.DB, id model.UUID) (*model.Currency, error) {
	c := model.Currency{}
	return &c, db.Where("id = ?", id).First(&c).Error
}

// getRate will return the conversation rate between USD and target currency
func (s *service) GetRate(target string) (float64, error) {
	return s.getRate(target)
}

// TODO: clean this up
func (s *service) getRate(target string) (float64, error) {
	// first, we hit the cache
	t, _ := s.cacheMap.Get(target)
	if target, ok := t.(float64); ok {
		if target != 0 {
			return target, nil
		}
	}

	// move on, if on prod we do a real query, otherwise do fixed rate for reduce the cost
	if s.cfg.Env != "prod" {
		switch target {
		case "USD":
			return 1, nil
		case "CAD":
			return 1.34275, nil
		case "GBP":
			return 0.79185, nil
		case "EUR":
			return 0.89795, nil
		case "VND":
			return 23416, nil
		}
	}

	var client http.Client
	endpoint := "http://apilayer.net/api/live?currencies=USD,CAD,GBP,EUR,VND&access_key=" + s.token

	req, err := http.NewRequest("GET", endpoint, nil)
	if err != nil {
		return 0, err
	}

	resp, err := client.Do(req)
	if err != nil {
		return 0, err
	}
	defer resp.Body.Close()

	type out struct {
		Quotes struct {
			USDVND float64 `json:"USDVND" desc:"US Dollar to Vietnamese Dong"`
			USDCAD float64 `json:"USDCAD" desc:"US Dollar to Canadian Dollar"`
			USDGBP float64 `json:"USDGBP" desc:"US Dollar to British Pound Sterling"`
			USDEUR float64 `json:"USDEUR" desc:"US Dollar to Euro"`
			USDUSD float64 `json:"USDUSD" desc:"US Dollar to US Dollar (always 1.0)"`
		} `json:"quotes"`
	}

	o := out{}
	err = json.NewDecoder(resp.Body).Decode(&o)
	if err != nil {
		return 0, err
	}

	s.cacheMap.Set("USD", o.Quotes.USDUSD, time.Hour*24)
	s.cacheMap.Set("GBP", o.Quotes.USDGBP, time.Hour*24)
	s.cacheMap.Set("EUR", o.Quotes.USDEUR, time.Hour*24)
	s.cacheMap.Set("VND", o.Quotes.USDVND, time.Hour*24)

	switch target {
	case "USD":
		return o.Quotes.USDUSD, nil
	case "GBP":
		return o.Quotes.USDGBP, nil
	case "EUR":
		return o.Quotes.USDEUR, nil
	case "VND":
		return o.Quotes.USDVND, nil
	case "CAD":
		return o.Quotes.USDCAD, nil
	}

	return 0, nil
}

func (s *service) GetCurrencyOption(db *gorm.DB) ([]model.Currency, error) {
	res := []model.Currency{}
	return res, db.Find(&res).Error
}

```

# pkg/service/basecamp/integration.go

```go
package basecamp

import (
	"encoding/json"
	"errors"
	"math"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/thoas/go-funk"
	"gorm.io/datatypes"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/currency"
	"github.com/dwarvesf/fortress-api/pkg/store/expense"
)

const (
	defaultCurrencyType = "VND"
	thousandUnit        = 1000
	millionUnit         = 1000000
	amountPat           = "(\\d+(k|tr|m)\\d+|\\d+(k|tr|m)|\\d+)"
)

// BasecampExpenseData --
type BasecampExpenseData struct {
	Reason          string
	Amount          int
	CurrencyType    string
	CreatorEmail    string
	InvoiceImageURL string
	MetaData        datatypes.JSON
	BasecampID      int
	CreatorID       int
}

// ExtractBasecampExpenseAmount --
func (s *Service) ExtractBasecampExpenseAmount(source string) int {
	return getAmount(strings.Replace(source, ".", "", -1))
}

// CreateBasecampExpense --
func (s *Service) CreateBasecampExpense(
	data BasecampExpenseData,
) error {
	employee, err := s.store.Employee.OneByBasecampID(s.repo.DB(), data.CreatorID)
	if err != nil {
		return errors.New("failed to get employee by basecampID: " + strconv.Itoa(data.BasecampID))
	}

	c, err := s.store.Currency.GetByName(s.repo.DB(), data.CurrencyType)
	if err != nil {
		return errors.New("failed to get currency by name: " + data.CurrencyType)
	}

	date := time.Now()

	e, err := s.store.Expense.Create(s.repo.DB(), &model.Expense{
		Amount:          data.Amount,
		Reason:          data.Reason,
		EmployeeID:      employee.ID,
		CurrencyID:      c.ID,
		InvoiceImageURL: data.InvoiceImageURL,
		Metadata:        data.MetaData,
		BasecampID:      data.BasecampID,
	})
	if err != nil {
		return err
	}

	m := model.AccountingMetadata{
		Source: "expense",
		ID:     e.ID.String(),
	}
	bonusBytes, err := json.Marshal(&m)
	if err != nil {
		return err
	}

	temp, rate, err := s.Wise.Convert(float64(data.Amount), c.Name, currency.VNDCurrency)
	if err != nil {
		return nil
	}
	am := model.NewVietnamDong(int64(temp))

	transaction := &model.AccountingTransaction{
		Name:             "Expense - " + data.Reason,
		Amount:           float64(data.Amount),
		ConversionAmount: am.Format(),
		Date:             &date,
		Category:         model.AccountingOfficeSupply,
		CurrencyID:       &c.ID,
		Currency:         c.Name,
		ConversionRate:   rate,
		Metadata:         bonusBytes,
		Type:             model.AccountingOV,
	}

	if err = s.store.Accounting.CreateTransaction(
		s.repo.DB(),
		transaction,
	); err != nil {
		return err
	}

	e.AccountingTransactionID = &transaction.ID

	if _, err = s.store.Expense.Update(s.repo.DB(), e); err != nil {
		return err
	}

	return nil
}

func (s *Service) UncheckBasecampExpenseHandler(
	data BasecampExpenseData,
) error {
	e, err := s.store.Expense.GetByQuery(s.repo.DB(), &expense.ExpenseQuery{BasecampID: data.BasecampID})
	if err != nil {
		return err
	}

	if _, err = s.store.Expense.Delete(s.repo.DB(), e); err != nil {
		return err
	}

	return nil
}

func getAmountStr(s string) string {
	c, _ := regexp.Compile(amountPat)
	return c.FindString(s)
}

// func getReason(s string) string {
// 	amount := getAmountStr(s)
// 	s = strings.Replace(s, amount, "", 1)
// 	return strings.TrimSpace(strings.Replace(s, "for", "", 1))
// }

func getAmount(source string) int {
	s := getAmountStr(source)
	if len(s) == 0 {
		return 0
	}

	switch {
	case isThousand(s):
		return thousand(s)
	case isMillion(s):
		return million(s)
	default:
		a, _ := strconv.Atoi(s)
		return a
	}
}

func isThousand(s string) bool {
	return funk.Contains(s, "k")
}

func thousand(s string) int {
	a := strings.Index(s, "k")
	if len(s[a+1:]) > 3 {
		return 0
	}
	prefix, _ := strconv.Atoi(s[0:a])
	suffix, _ := strconv.Atoi(s[a+1:])
	return prefix*thousandUnit + int(float64(suffix)/math.Pow10(len(s[a+1:])-1)*100)
}

func isMillion(s string) bool {
	return funk.Contains(s, "tr") || funk.Contains(s, "m")
}

func million(s string) int {
	newStr := strings.Replace(s, "tr", "m", -1)
	i := strings.Index(newStr, "m")
	if len(newStr[i+1:]) > 6 {
		return 0
	}
	pref, _ := strconv.Atoi(newStr[0:i])
	suf, _ := strconv.Atoi(newStr[i+1:])
	return (pref * millionUnit) + int(float64(suf)/math.Pow10(len(newStr[i+1:])-1)*thousandUnit*100)
}

```

# pkg/service/basecamp/basecamp.go

```go
package basecamp

import (
	"fmt"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/attachment"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/campfire"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/comment"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/messageboard"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/people"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/project"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/recording"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/schedule"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/subscription"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/todo"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/webhook"
	"github.com/dwarvesf/fortress-api/pkg/service/wise"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type Service struct {
	store  *store.Store
	repo   store.DBRepo
	config *config.Config
	logger logger.Logger

	Basecamp *model.Basecamp
	Client   client.Service

	Attachment   attachment.Service
	Campfire     campfire.Service
	Comment      comment.Service
	MsgBoard     messageboard.Service
	People       people.Service
	Project      project.Service
	Recording    recording.Service
	Schedule     schedule.Service
	Subscription subscription.Service
	Todo         todo.Service
	Webhook      webhook.Service

	Wise wise.IService
}

func New(store *store.Store, repo store.DBRepo, cfg *config.Config, bc *model.Basecamp, logger logger.Logger) *Service {
	c, err := client.NewClient(bc, cfg)
	if err != nil {
		logger.Error(err, "init basecamp service")
		return nil
	}

	return &Service{
		store:        store,
		repo:         repo,
		config:       cfg,
		logger:       logger,
		Basecamp:     bc,
		Client:       c,
		Attachment:   attachment.NewService(c),
		Campfire:     campfire.NewService(c, logger, cfg),
		Comment:      comment.NewService(c),
		MsgBoard:     messageboard.NewService(c),
		People:       people.NewService(c),
		Project:      project.NewService(c),
		Recording:    recording.NewService(c),
		Schedule:     schedule.NewService(c, logger),
		Subscription: subscription.NewService(c),
		Todo:         todo.NewService(c, cfg),
		Webhook:      webhook.NewService(c),
		Wise:         wise.New(cfg, logger),
	}
}

func (s *Service) BuildCommentMessage(bucketID, recordID int, content string, msgType string) model.BasecampCommentMessage {
	var cmtPayload *model.Comment
	switch msgType {
	case model.CommentMsgTypeFailed:
		cmtPayload = s.buildFailedComment(content)
	case model.CommentMsgTypeCompleted:
		cmtPayload = s.buildCompletedComment(content)
	default:
		cmtPayload = &model.Comment{Content: content}
	}

	return model.BasecampCommentMessage{
		RecordingID: recordID,
		ProjectID:   bucketID,
		Payload:     cmtPayload,
	}
}

func (s *Service) BasecampMention(basecampID int) (res string, err error) {
	if basecampID == consts.AutoBotID {
		return fmt.Sprintf(`<bc-attachment sgid="%s" content-type="application/vnd.basecamp.mention"></bc-attachment>`, consts.AutoBotSgID), nil
	}

	employee, err := s.store.Employee.OneByBasecampID(s.repo.DB(), basecampID)
	if err != nil {
		return
	}

	if employee.BasecampAttachableSGID == "" {
		u, err := s.People.GetByID(basecampID)
		if err != nil {
			return res, err
		}
		employee.BasecampAttachableSGID = u.AttachableSgID

		if _, err = s.store.Employee.UpdateSelectedFieldsByID(s.repo.DB(), employee.ID.String(), *employee, "basecamp_attachable_sgid"); err != nil {
			return res, err
		}
	}

	return fmt.Sprintf(`<bc-attachment sgid="%s" content-type="application/vnd.basecamp.mention"></bc-attachment>`, employee.BasecampAttachableSGID), nil
}

func (s *Service) buildFailedComment(content string) *model.Comment {
	if s.config.Env == "prod" {
		m, _ := s.BasecampMention(consts.HuyNguyenBasecampID)
		return &model.Comment{Content: fmt.Sprintf(`<img width="17" class="thread-entry__icon" src="https://3.basecamp-static.com/assets/icons/thread_events/uncompleted-6066b80e80b6463243d7773fa67373b62e2a7d159ba12a17c94b1e18b30a5770.svg"><div><em>%s</em> %s</div>`, content, m)}
	}
	return &model.Comment{Content: fmt.Sprintf(`<img width="17" class="thread-entry__icon" src="https://3.basecamp-static.com/assets/icons/thread_events/uncompleted-6066b80e80b6463243d7773fa67373b62e2a7d159ba12a17c94b1e18b30a5770.svg"><div><em>%s</em></div>`, content)}
}

func (s *Service) buildCompletedComment(content string) *model.Comment {
	return &model.Comment{Content: fmt.Sprintf(`<img width="17" class="thread-entry__icon" src="https://3.basecamp-static.com/assets/icons/thread_events/completed-12705cf5fc372d800bba74c8133d705dc43a12c939a8477099749e2ef056e739.svg"><div><em>%s</em></div>`, content)}
}

```

# pkg/store/workunitmember/work_unit_member.go

```go
package workunitmember

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One return a work member by workUnitID and employeeID
func (s *store) One(db *gorm.DB, workUnitID string, employeeID string, status string) (*model.WorkUnitMember, error) {
	var member *model.WorkUnitMember
	query := db.Where("work_unit_id = ? AND employee_id = ?", workUnitID, employeeID)

	return member, query.First(&member).Error
}

// Create create new WorkUnitMember
func (s *store) Create(db *gorm.DB, wum *model.WorkUnitMember) error {
	return db.Create(&wum).Error
}

// GetByWorkUnitID return list member of a work unit
func (s *store) GetByWorkUnitID(db *gorm.DB, wuID string) ([]*model.WorkUnitMember, error) {
	var members []*model.WorkUnitMember
	return members, db.Where("work_unit_id = ?", wuID).Find(&members).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.WorkUnitMember, updatedFields ...string) (*model.WorkUnitMember, error) {
	member := model.WorkUnitMember{}
	return &member, db.Model(&member).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// DeleteByWorkUnitID delete many workUnitMember by workUnitID
func (s *store) DeleteByWorkUnitID(db *gorm.DB, workUnitID string) error {
	return db.Unscoped().Where("work_unit_id = ?", workUnitID).Delete(&model.WorkUnitMember{}).Error
}

// SoftDeleteByWorkUnitID delete one workUnitMember by EmployeeID and workUnitID
func (s *store) SoftDeleteByWorkUnitID(db *gorm.DB, workUnitID string, employeeID string) error {
	return db.Where("work_unit_id = ? and employee_id = ?", workUnitID, employeeID).Delete(&model.WorkUnitMember{}).Error
}

// All get all active members of a work unit
func (s *store) All(db *gorm.DB, workUnitID string) ([]*model.WorkUnitMember, error) {
	var members []*model.WorkUnitMember
	return members, db.Where("work_unit_id = ? and status = 'active'", workUnitID).Find(&members).Error
}

func (s *store) GetPeerReviewerInTimeRange(db *gorm.DB, from *time.Time, to *time.Time) ([]model.WorkUnitPeer, error) {
	var peers []model.WorkUnitPeer

	query := db.Raw(`
	WITH peer AS (
			SELECT
				employee_id,
				reviewer_id
			FROM (
				SELECT
					w1.employee_id,
					w1.work_unit_id,
					w2.employee_id AS reviewer_id,
					w1.project_id
				FROM
					work_unit_members w1
					JOIN work_unit_members w2 ON w1.work_unit_id = w2.work_unit_id
				WHERE (w1.start_date < ?
					AND(w1.end_date > ?
						OR w1.end_date IS NULL))
				AND(w2.start_date < ?
					AND(w2.end_date > ?
						OR w2.end_date IS NULL))) a
			JOIN employees e ON a.employee_id = e.id
		WHERE
			employee_id <> reviewer_id
			AND e.working_status = 'full-time'
		GROUP BY
			employee_id,
			reviewer_id
		)
		SELECT
			p.employee_id,
			p.reviewer_id
		FROM
			peer p
			JOIN employees e ON e.id = p.reviewer_id
		WHERE
			e.line_manager_id <> p.reviewer_id
			AND e.working_status = 'full-time';	
	`, to, from, to, from)
	return peers, query.Scan(&peers).Error
}

func (s *store) GetActivePeerReviewer(db *gorm.DB) ([]model.WorkUnitPeer, error) {
	var peers []model.WorkUnitPeer

	query := db.Raw(`
	WITH peer AS (
		SELECT
			employee_id,
			reviewer_id
		FROM (
			SELECT
				w1.employee_id,
				w1.work_unit_id,
				w2.employee_id AS reviewer_id,
				w1.project_id
			FROM
				work_unit_members w1
				JOIN work_unit_members w2 ON w1.work_unit_id = w2.work_unit_id
			WHERE
				w1.status = 'active'
				AND w2.status = 'active') a
			JOIN employees e ON a.employee_id = e.id
		WHERE
			employee_id <> reviewer_id
			AND e.working_status = 'full-time'
		GROUP BY
			employee_id,
			reviewer_id
	)
	SELECT
		p.employee_id,
		p.reviewer_id
	FROM
		peer p
		JOIN employees e ON e.id = p.reviewer_id
	WHERE
		e.line_manager_id <> p.reviewer_id
		AND e.working_status = 'full-time';		
	`)
	return peers, query.Scan(&peers).Error
}

```

# pkg/store/workunitmember/interface.go

```go
package workunitmember

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, wum *model.WorkUnitMember) error
	GetByWorkUnitID(db *gorm.DB, wuID string) (wuMembers []*model.WorkUnitMember, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.WorkUnitMember, updatedFields ...string) (*model.WorkUnitMember, error)
	DeleteByWorkUnitID(db *gorm.DB, workUnitID string) error
	All(db *gorm.DB, workUnitID string) (members []*model.WorkUnitMember, err error)
	One(db *gorm.DB, workUnitID string, employeeID string, status string) (workUnitMember *model.WorkUnitMember, err error)
	SoftDeleteByWorkUnitID(db *gorm.DB, workUnitID string, employeeID string) (err error)
	GetPeerReviewerInTimeRange(db *gorm.DB, from *time.Time, to *time.Time) ([]model.WorkUnitPeer, error)
	GetActivePeerReviewer(db *gorm.DB) ([]model.WorkUnitPeer, error)
}

```

# pkg/store/workunitstack/work_unit_stack.go

```go
package workunitstack

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create create new WorkUnitStack
func (s *store) Create(db *gorm.DB, wus *model.WorkUnitStack) error {
	return db.Create(&wus).Error
}

// DeleteByWorkUnitID delete many workUnitStack by workUnitID
func (s *store) DeleteByWorkUnitID(db *gorm.DB, workUnitID string) error {
	return db.Unscoped().Where("work_unit_id = ?", workUnitID).Delete(&model.WorkUnitStack{}).Error
}

```

# pkg/store/workunitstack/interface.go

```go
package workunitstack

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, wus *model.WorkUnitStack) error
	DeleteByWorkUnitID(db *gorm.DB, workUnitID string) error
}

```

# pkg/store/valuation/valuation.go

```go
// please edit this file only with approval from hnh
package valuation

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) GetAccountReceivable(db *gorm.DB, year string) (*model.CurrencyView, error) {
	res := &model.CurrencyView{}
	return res, db.Raw("select * from vw_account_receivables where year = ?", year).Find(&res).Error
}

func (s *store) GetRevenue(db *gorm.DB, year string) (*model.CurrencyView, error) {
	res := &model.CurrencyView{}
	return res, db.Raw(`SELECT sum(vnd) AS vnd, sum(usd) AS usd, sum(gbp) AS gbp, sum(eur) AS eur, sum(sgd) as sgd
			FROM vw_incomes
			WHERE year = ?`, year).
		Find(&res).Error
}

func (s *store) GetInvestment(db *gorm.DB, year string) (*model.CurrencyView, error) {
	res := &model.CurrencyView{}
	return res, db.Raw(`SELECT * FROM vw_investments WHERE year = ?`, year).
		Find(&res).Error
}

func (s *store) GetLiabilities(db *gorm.DB, year string) (res []model.Liability, total *model.CurrencyView, err error) {
	err = db.Find(&res, "date_part('year', created_at) = ?", year).Error
	if err != nil {
		return nil, nil, err
	}

	return res, total, db.Raw(`SELECT sum(vnd) AS vnd, sum(usd) AS usd, sum(gbp) AS gbp, sum(eur) AS eur, sum(sgd) as sgd
	FROM vw_liabilities
	WHERE year = ?`, year).
		Find(&total).Error
}

func (s *store) GetAssetAmount(db *gorm.DB, year string) (float64, error) {
	return 0, nil
}

func (s *store) GetExpense(db *gorm.DB, year string) (*model.CurrencyView, error) {
	res := &model.CurrencyView{}
	return res, db.Raw("select * from vw_expenses where year = ?", year).Find(&res).Error
}

func (s *store) GetPayroll(db *gorm.DB, year string) (*model.CurrencyView, error) {
	res := &model.CurrencyView{}
	return res, db.Raw("select total as vnd from vw_payrolls where year = ?", year).Scan(&res).Error
}

```

# pkg/store/valuation/interface.go

```go
package valuation

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type IStore interface {
	GetAccountReceivable(db *gorm.DB, year string) (total *model.CurrencyView, err error)
	GetLiabilities(db *gorm.DB, year string) (res []model.Liability, total *model.CurrencyView, err error)
	GetRevenue(db *gorm.DB, year string) (total *model.CurrencyView, err error)
	GetInvestment(db *gorm.DB, year string) (total *model.CurrencyView, err error)

	// GetAssetAmount return total amount of current holding assets
	GetAssetAmount(db *gorm.DB, year string) (total float64, err error)
	GetExpense(db *gorm.DB, year string) (total *model.CurrencyView, err error)
	GetPayroll(db *gorm.DB, year string) (total *model.CurrencyView, err error)
}

```

# pkg/store/workunit/work_unit.go

```go
package workunit

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// GetByProjectID get all work units of a project and having the status as required
func (s *store) GetByProjectID(db *gorm.DB, projectID string, status model.WorkUnitStatus) ([]*model.WorkUnit, error) {
	var workUnits []*model.WorkUnit
	query := db.Where("project_id = ?", projectID)

	if status != "" {
		query = query.Where("status = ?", status)
	}

	if status == model.WorkUnitStatusActive {
		query = query.Preload("WorkUnitMembers", "deleted_at IS NULL and status = 'active'")
	} else {
		query = query.Preload("WorkUnitMembers", "deleted_at IS NULL")
	}

	return workUnits, query.Preload("WorkUnitMembers.Employee", "deleted_at IS NULL").
		Preload("WorkUnitStacks", "deleted_at IS NULL").
		Preload("WorkUnitStacks.Stack", "deleted_at IS NULL").
		Find(&workUnits).Error
}

// Create create new WorkUnit
func (s *store) Create(db *gorm.DB, workUnit *model.WorkUnit) error {
	return db.Create(&workUnit).Error
}

// One get 1 WorkUnit by ID
func (s *store) One(db *gorm.DB, id string) (*model.WorkUnit, error) {
	var workUnit *model.WorkUnit
	return workUnit, db.Where("id = ?", id).First(&workUnit).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.WorkUnit, updatedFields ...string) (*model.WorkUnit, error) {
	workUnit := model.WorkUnit{}
	return &workUnit, db.Model(&workUnit).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// IsExists check work unit existence
func (s *store) IsExists(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM work_units WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

func (s *store) GetAllWorkUnitByEmployeeID(db *gorm.DB, employeeID string) ([]*model.WorkUnit, error) {
	var workUnits []*model.WorkUnit
	return workUnits, db.Where(`id IN (
			SELECT work_unit_id 
			FROM work_unit_members 
				JOIN projects ON work_unit_members.project_id = projects.id 
			WHERE employee_id = ? AND projects.status IN (?, ?) AND work_unit_members.status = ?)`, employeeID, model.ProjectStatusActive, model.ProjectStatusOnBoarding, model.WorkUnitStatusActive).
		Preload("WorkUnitMembers", "deleted_at IS NULL").
		Preload("WorkUnitMembers.Employee", "deleted_at IS NULL").
		Preload("Project", "deleted_at IS NULL").
		Find(&workUnits).Error
}

```

# pkg/store/workunit/interface.go

```go
package workunit

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, workUnit *model.WorkUnit) error
	GetByProjectID(db *gorm.DB, projectID string, status model.WorkUnitStatus) (workUnits []*model.WorkUnit, err error)
	One(db *gorm.DB, id string) (*model.WorkUnit, error)
	IsExists(db *gorm.DB, id string) (bool, error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.WorkUnit, updatedFields ...string) (workUnit *model.WorkUnit, err error)
	GetAllWorkUnitByEmployeeID(db *gorm.DB, employeeID string) (workUnits []*model.WorkUnit, err error)
}

```

# pkg/store/stack/stack.go

```go
package stack

import (
	"fmt"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// All get all Senitorities
func (s *store) All(db *gorm.DB, keyword string, pagination *model.Pagination) (int64, []*model.Stack, error) {
	var stacks []*model.Stack
	var total int64

	query := db.Table("stacks")

	if keyword != "" {
		query = query.Where("name ILIKE ?", fmt.Sprintf("%%%s%%", keyword)).
			Where("code ILIKE ?", fmt.Sprintf("%%%s%%", keyword))
	}

	query = query.Count(&total).Order("code")

	if pagination != nil {
		limit, offset := pagination.ToLimitOffset()
		if pagination.Page > 0 {
			query = query.Limit(limit)
		}

		query = query.Offset(offset)
	}

	return total, stacks, query.Find(&stacks).Error
}

// One get 1 stack by id
func (s *store) One(db *gorm.DB, id string) (*model.Stack, error) {
	var stack *model.Stack
	return stack, db.Where("id = ?", id).First(&stack).Error
}

// GetByIDs return list stack by IDs
func (s *store) GetByIDs(db *gorm.DB, ids []model.UUID) ([]*model.Stack, error) {
	var stacks []*model.Stack
	return stacks, db.Where("id IN ?", ids).Find(&stacks).Error
}

// Update update the stack
func (s *store) Update(db *gorm.DB, stack *model.Stack) (*model.Stack, error) {
	return stack, db.Model(&model.Stack{}).Where("id = ?", stack.ID).Updates(&stack).First(&stack).Error
}

// Delete delete ProjectMember by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.Stack{}).Error
}

// Create create new stack
func (s *store) Create(db *gorm.DB, stack *model.Stack) (*model.Stack, error) {
	return stack, db.Create(stack).Error
}

```

# pkg/store/stack/interface.go

```go
package stack

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB, keyword string, pagination *model.Pagination) (int64, []*model.Stack, error)
	One(db *gorm.DB, id string) (*model.Stack, error)
	GetByIDs(db *gorm.DB, ids []model.UUID) (stacks []*model.Stack, err error)
	Update(db *gorm.DB, stack *model.Stack) (s *model.Stack, err error)
	Create(db *gorm.DB, stack *model.Stack) (s *model.Stack, err error)
	Delete(db *gorm.DB, id string) (err error)
}

```

# pkg/store/schedule/schedule.go

```go
package schedule

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) GetOneByGcalID(db *gorm.DB, gcalID string) (*model.Schedule, error) {
	var sch *model.Schedule
	return sch, db.
		Table("schedules").
		Joins("JOIN schedule_google_calendars sgc ON schedules.id = sgc.schedule_id").Where("sgc.google_calendar_id = ?", gcalID).First(&sch).Error
}

func (s *store) Create(db *gorm.DB, schedule *model.Schedule) (*model.Schedule, error) {
	return schedule, db.Create(schedule).Error
}

func (s *store) CreateDiscord(db *gorm.DB, schedule *model.ScheduleDiscordEvent) (*model.ScheduleDiscordEvent, error) {
	return schedule, db.Create(schedule).Error
}

func (s *store) Upsert(db *gorm.DB, schedule *model.Schedule) (*model.Schedule, error) {
	return schedule, db.Save(schedule).Error
}

func (s *store) Update(db *gorm.DB, schedule *model.Schedule) (*model.Schedule, error) {
	return schedule, db.Updates(schedule).Error
}

```

# pkg/store/schedule/interface.go

```go
package schedule

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, schedule *model.Schedule) (*model.Schedule, error)
	CreateDiscord(db *gorm.DB, schedule *model.ScheduleDiscordEvent) (*model.ScheduleDiscordEvent, error)
	GetOneByGcalID(db *gorm.DB, gcalID string) (*model.Schedule, error)

	Update(db *gorm.DB, schedule *model.Schedule) (*model.Schedule, error)
}

```

# pkg/store/seniority/seniority.go

```go
package seniority

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// All get all Seniorities
func (s *store) All(db *gorm.DB) ([]*model.Seniority, error) {
	var seniories []*model.Seniority
	return seniories, db.Order("level").Find(&seniories).Error
}

// One get 1 one by id
func (s *store) One(db *gorm.DB, id model.UUID) (*model.Seniority, error) {
	var sen *model.Seniority
	return sen, db.Where("id = ?", id).First(&sen).Error
}

// IsExist check existence of a seniority
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM seniorities WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

```

# pkg/store/seniority/interface.go

```go
package seniority

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB) ([]*model.Seniority, error)
	One(db *gorm.DB, id model.UUID) (seniorities *model.Seniority, err error)
	IsExist(db *gorm.DB, id string) (bool, error)
}

```

# pkg/store/salaryadvance/salary_advance.go

```go
package salaryadvance

import (
	"database/sql"
	"fmt"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) One(db *gorm.DB, id string) (*model.SalaryAdvance, error) {
	var salaryAdvance *model.SalaryAdvance
	return salaryAdvance, db.Where("id = ?", id).
		First(&salaryAdvance).Error
}

func (s *store) ListNotPayBackByEmployeeID(db *gorm.DB, employeeID string) ([]model.SalaryAdvance, error) {
	var advanceSalaries []model.SalaryAdvance
	return advanceSalaries, db.Where("employee_id = ?", employeeID).Where("is_paid_back = ?", false).Find(&advanceSalaries).Error
}

func (s *store) Save(db *gorm.DB, salaryAdvance *model.SalaryAdvance) (err error) {
	return db.Save(&salaryAdvance).Error
}

func (s *store) ListAggregatedSalaryAdvance(db *gorm.DB, idPaid *bool, paging model.Pagination, order model.SortOrder) (report []model.AggregatedSalaryAdvance, err error) {
	query := db.
		Table("salary_advance_histories").
		Select("employee_id, sum(amount_icy) as amount_icy, sum(amount_usd) as amount_usd")

	if idPaid != nil {
		query = query.Where("is_paid_back = ?", idPaid)
	}

	if paging.Sort != "" {
		query = query.Order(fmt.Sprintf("%s %s", paging.Sort, order))
	}

	limit, offset := paging.ToLimitOffset()
	if limit != 0 {
		query = query.Limit(limit).Offset(offset)
	}

	return report, query.Group("employee_id").Find(&report).Error
}

func (s *store) TotalAggregatedSalaryAdvance(db *gorm.DB, idPaid *bool) (int64, int64, float64, error) {
	queryCurrency := db.
		Table("salary_advance_histories").
		Select("sum(amount_icy) as total_icy, sum(amount_usd) as total_usd")

	queryCount := db.
		Table("salary_advance_histories")

	if idPaid != nil {
		queryCurrency = queryCurrency.Where("is_paid_back = ?", idPaid)
		queryCount = queryCount.Where("is_paid_back = ?", idPaid)
	}

	var (
		count   int64
		nullIcy sql.NullInt64
		nullUsd sql.NullFloat64
	)

	if err := queryCurrency.Row().Scan(&nullIcy, &nullUsd); err != nil {
		return 0, 0, 0, err
	}

	if err := queryCount.Group("employee_id").Count(&count).Error; err != nil {
		return 0, 0, 0, err
	}

	return count, nullIcy.Int64, nullUsd.Float64, nil
}

```

# pkg/store/salaryadvance/interface.go

```go
package salaryadvance

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (salaryAdvance *model.SalaryAdvance, err error)
	ListNotPayBackByEmployeeID(db *gorm.DB, employeeID string) (salaryAdvance []model.SalaryAdvance, err error)
	Save(db *gorm.DB, salaryAdvance *model.SalaryAdvance) (err error)
	ListAggregatedSalaryAdvance(db *gorm.DB, idPaid *bool, paging model.Pagination, order model.SortOrder) (report []model.AggregatedSalaryAdvance, err error)
	TotalAggregatedSalaryAdvance(db *gorm.DB, idPaid *bool) (count, totalIcy int64, totalUSD float64, err error)
}

```

# pkg/store/role/role.go

```go
package role

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// All get all positions
func (s *store) All(db *gorm.DB) ([]*model.Role, error) {
	var roles []*model.Role
	return roles, db.Where("is_show IS TRUE").Order("level").Find(&roles).Error
}

// GetByLevel get by input level
func (s *store) GetByLevel(db *gorm.DB, level int64) ([]*model.Role, error) {
	var roles []*model.Role
	return roles, db.Where("level >= ? AND is_show IS TRUE", level).Find(&roles).Error
}

func (s *store) GetByCode(db *gorm.DB, code string) (*model.Role, error) {
	var role *model.Role
	return role, db.Where("code = ?", code).First(&role).Error
}

func (s *store) GetByIDs(db *gorm.DB, ids []model.UUID) ([]*model.Role, error) {
	var roles []*model.Role
	return roles, db.Where("id IN ?", ids).Find(&roles).Error
}

// One get 1 one by id
func (s *store) One(db *gorm.DB, id model.UUID) (*model.Role, error) {
	var role *model.Role
	return role, db.Where("id = ?", id).First(&role).Error
}

// IsExist check the existence of employee
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM roles WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

```

# pkg/store/role/interface.go

```go
package role

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB) (roles []*model.Role, err error)
	One(db *gorm.DB, id model.UUID) (role *model.Role, err error)
	GetByLevel(db *gorm.DB, level int64) ([]*model.Role, error)
	GetByCode(db *gorm.DB, code string) (*model.Role, error)
	GetByIDs(db *gorm.DB, ids []model.UUID) ([]*model.Role, error)
	IsExist(db *gorm.DB, id string) (exists bool, err error)
}

```

# pkg/store/socialaccount/social_account.go

```go
package socialaccount

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create create new SocialAccount
func (s *store) Create(db *gorm.DB, sa *model.SocialAccount) (*model.SocialAccount, error) {
	return sa, db.Create(sa).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, sa *model.SocialAccount) (*model.SocialAccount, error) {
	return sa, db.Model(&sa).Where("id = ?", sa.ID).Updates(&sa).Error
}

// GetByEmployeeID get social account by employee id
func (s *store) GetByEmployeeID(db *gorm.DB, employeeID string) ([]*model.SocialAccount, error) {
	var accounts []*model.SocialAccount
	return accounts, db.Where("employee_id = ?", employeeID).Find(&accounts).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.SocialAccount, updatedFields ...string) (*model.SocialAccount, error) {
	sa := model.SocialAccount{}
	return &sa, db.Model(&sa).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// GetByType get social account by type
func (s *store) GetByType(db *gorm.DB, saType string) ([]model.SocialAccount, error) {
	var accounts []model.SocialAccount
	return accounts, db.Where("type = ?", saType).Find(&accounts).Error
}

```

# pkg/store/socialaccount/interface.go

```go
package socialaccount

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, sa *model.SocialAccount) (account *model.SocialAccount, err error)
	Update(db *gorm.DB, sa *model.SocialAccount) (account *model.SocialAccount, err error)
	GetByEmployeeID(db *gorm.DB, employeeID string) (accounts []*model.SocialAccount, err error)
	GetByType(db *gorm.DB, saType string) (accounts []model.SocialAccount, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.SocialAccount, updatedFields ...string) (*model.SocialAccount, error)
}

```

# pkg/store/recruitment/recruitment.go

```go
package recruitment

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct {
}

// New create new pg service
func New() IStore {
	return &store{}
}

func (s *store) Save(db *gorm.DB, cv *model.Candidate) error {
	return db.Save(&cv).Error
}

func (s *store) GetByBasecampID(db *gorm.DB, bcID int) (*model.Candidate, error) {
	var c model.Candidate
	return &c, db.Where("basecamp_todo_id = ?", bcID).First(&c).Error
}

func (s *store) GetApproachCandidateByBasecampID(db *gorm.DB, bcID int) (*model.Candidate, error) {
	var c model.Candidate
	return &c, db.Where("basecamp_todo_id = ? and status = ?", bcID, model.ApproachCandidateStatus).First(&c).Error
}

func (s *store) Update(db *gorm.DB, candidate *model.Candidate) error {
	return db.Save(&candidate).Error
}

func (s *store) GetByDuration(db *gorm.DB, from, to time.Time) ([]model.Candidate, error) {
	var c []model.Candidate
	return c, db.Where("created_at > ? AND created_at < ?", from, to).Find(&c).Error
}

func (s *store) GetAll(db *gorm.DB) ([]model.Candidate, error) {
	var c []model.Candidate
	return c, db.Find(&c).Error
}

func (s *store) GetOffered(db *gorm.DB, batchDate, dueDate time.Time) ([]model.Candidate, error) {
	var c []model.Candidate
	return c, db.Where("offer_start_date > ? AND offer_start_date < ? AND status = ?", batchDate, dueDate, model.HiredCandidateStatus).Find(&c).Error
}

```

# pkg/store/recruitment/interface.go

```go
package recruitment

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

// IStore --
type IStore interface {
	Save(db *gorm.DB, cv *model.Candidate) error
	Update(db *gorm.DB, cv *model.Candidate) error
	GetByBasecampID(db *gorm.DB, bcID int) (*model.Candidate, error)
	GetApproachCandidateByBasecampID(db *gorm.DB, bcID int) (*model.Candidate, error)
	GetByDuration(db *gorm.DB, from, to time.Time) ([]model.Candidate, error)
	GetAll(db *gorm.DB) ([]model.Candidate, error)
	GetOffered(db *gorm.DB, batchDate, dueDate time.Time) ([]model.Candidate, error)
}

```

# pkg/store/question/question.go

```go
package question

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// AllByCategory get all by category and subcategory
func (s *store) AllByCategory(db *gorm.DB, category model.EventType, subcategory model.EventSubtype) ([]*model.Question, error) {
	var questions []*model.Question
	return questions, db.Where("category = ? AND subcategory = ?", category, subcategory).Order("\"order\"").Find(&questions).Error
}

```

# pkg/store/question/interface.go

```go
package question

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	AllByCategory(db *gorm.DB, category model.EventType, subcategory model.EventSubtype) (questions []*model.Question, err error)
}

```

# pkg/store/projectslot/project_slot.go

```go
package projectslot

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Delete delete ProjectSlot by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Unscoped().Where("id = ?", id).Delete(&model.ProjectSlot{}).Error
}

// One get 1 one by id
func (s *store) One(db *gorm.DB, id string) (*model.ProjectSlot, error) {
	var slot *model.ProjectSlot
	return slot, db.Where("id = ?", id).Preload("Seniority", "deleted_at IS NULL").First(&slot).Error
}

// Create create new project slot
func (s *store) Create(db *gorm.DB, slot *model.ProjectSlot) error {
	return db.Create(&slot).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectSlot, updatedFields ...string) (*model.ProjectSlot, error) {
	slot := model.ProjectSlot{}
	return &slot, db.Model(&slot).Where("id = ?", id).Select(updatedFields).Updates(&updateModel).Error
}

// UpdateSelectedFieldByProjectID just update selected field by projectID
func (s *store) UpdateSelectedFieldByProjectID(db *gorm.DB, projectID string, updateModel model.ProjectSlot, updatedField string) error {
	return db.Model(&model.ProjectSlot{}).
		Where("project_id = ?", projectID).
		Select(updatedField).
		Updates(updateModel).Error
}

func (s *store) GetPendingSlots(db *gorm.DB, projectID string, preload bool) ([]*model.ProjectSlot, error) {
	query := db.Where("project_id = ? AND status = ?", projectID, model.ProjectMemberStatusPending).Order("created_at DESC")

	if preload {
		query = query.Preload("Seniority", "deleted_at IS NULL").
			Preload("ProjectSlotPositions", "deleted_at IS NULL").
			Preload("ProjectSlotPositions.Position", "deleted_at IS NULL")
	}

	var slots []*model.ProjectSlot
	return slots, query.Find(&slots).Error
}

```

# pkg/store/projectslot/interface.go

```go
package projectslot

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	GetPendingSlots(db *gorm.DB, projectID string, preload bool) ([]*model.ProjectSlot, error)
	One(db *gorm.DB, id string) (*model.ProjectSlot, error)
	Create(db *gorm.DB, slot *model.ProjectSlot) error
	Delete(db *gorm.DB, id string) (err error)

	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectSlot, updatedFields ...string) (*model.ProjectSlot, error)
	UpdateSelectedFieldByProjectID(db *gorm.DB, projectID string, updateModel model.ProjectSlot, updatedField string) error
}

```

# pkg/store/projectstack/project_stack.go

```go
package projectstack

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create create new one by id
func (s *store) Create(db *gorm.DB, projectStack *model.ProjectStack) (*model.ProjectStack, error) {
	return projectStack, db.Create(&projectStack).Error
}

// DeleteByProjectID delete many ProjectStacks by projectID
func (s *store) DeleteByProjectID(db *gorm.DB, projectID string) error {
	return db.Unscoped().Where("project_id = ?", projectID).Delete(&model.ProjectStack{}).Error
}

```

# pkg/store/projectstack/interface.go

```go
package projectstack

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, projectStack *model.ProjectStack) (*model.ProjectStack, error)
	DeleteByProjectID(db *gorm.DB, projectID string) (err error)
}

```

# pkg/store/projectslotposition/project_slot_position.go

```go
package projectslotposition

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) GetByProjectSlotID(db *gorm.DB, memberID string) ([]*model.ProjectSlotPosition, error) {
	var pos []*model.ProjectSlotPosition
	return pos, db.Where("project_slot_id = ?", memberID).Preload("Position").Find(&pos).Error
}

func (s *store) Create(db *gorm.DB, pos ...model.ProjectSlotPosition) error {
	return db.Create(&pos).Error
}

func (s *store) DeleteByProjectSlotID(db *gorm.DB, slotID string) error {
	return db.Unscoped().Where("project_slot_id = ?", slotID).Delete(&model.ProjectSlotPosition{}).Error
}

```

# pkg/store/projectslotposition/interface.go

```go
package projectslotposition

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type IStore interface {
	Create(db *gorm.DB, pos ...model.ProjectSlotPosition) error
	DeleteByProjectSlotID(db *gorm.DB, slotID string) error
}

```

# pkg/store/projectmember/project_member.go

```go
package projectmember

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Delete delete ProjectMember by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Unscoped().Where("id = ?", id).Delete(&model.ProjectMember{}).Error
}

// IsExist check ProjectMember existence
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	var record struct {
		Result bool
	}

	query := db.Raw("SELECT EXISTS (SELECT * FROM project_members WHERE id = ?) as result", id)
	return record.Result, query.Scan(&record).Error
}

// OneByID return a project member by id
func (s *store) OneByID(db *gorm.DB, id string) (*model.ProjectMember, error) {
	var member *model.ProjectMember
	return member, db.Where("id = ?", id).First(&member).Error
}

// OneBySlotID return a project member by slotID
func (s *store) OneBySlotID(db *gorm.DB, slotID string) (*model.ProjectMember, error) {
	var member *model.ProjectMember
	return member, db.Where("project_slot_id = ? AND status = ?", slotID, model.ProjectMemberStatusActive).
		Preload("Employee").
		First(&member).Error
}

// Create using for create new member
func (s *store) Create(db *gorm.DB, member *model.ProjectMember) error {
	return db.Create(&member).Preload("Employee").First(&member).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectMember, updatedFields ...string) (*model.ProjectMember, error) {
	member := model.ProjectMember{}
	return &member, db.Model(&member).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// UpdateSelectedFieldByProjectID just update selected field by projectID
func (s *store) UpdateSelectedFieldByProjectID(db *gorm.DB, projectID string, updateModel model.ProjectMember, updatedField string) error {
	return db.Model(&model.ProjectMember{}).
		Where("project_id = ?", projectID).
		Select(updatedField).
		Updates(updateModel).Error
}

// UpdateEndDateByProjectID just update end_date by projectID
func (s *store) UpdateEndDateByProjectID(db *gorm.DB, projectID string) error {
	now := time.Now()
	return db.Model(&model.ProjectMember{}).
		Where("project_id = ? AND (end_date IS NULL OR end_date > ?)", projectID, now).
		Select("end_date").
		Updates(model.ProjectMember{EndDate: &now}).Error
}

// IsExistsByEmployeeID check ProjectMember existence by project id and employee id
func (s *store) IsExistsByEmployeeID(db *gorm.DB, projectID string, employeeID string) (bool, error) {
	var record struct {
		Result bool
	}

	query := db.Raw("SELECT EXISTS (SELECT * FROM project_members WHERE project_id  = ? and employee_id = ?) as result", projectID, employeeID)
	return record.Result, query.Scan(&record).Error
}

// GetActiveByProjectIDs get project member by projectID list
func (s *store) GetActiveByProjectIDs(db *gorm.DB, projectIDs []string) ([]*model.ProjectMember, error) {
	var members []*model.ProjectMember
	return members, db.Joins("JOIN employees ON project_members.employee_id = employees.id").Where("(project_members.end_date IS NULL OR project_members.end_date > ?) AND project_members.status = 'active' AND employees.working_status = 'full-time' AND project_members.project_id IN ?", time.Now(), projectIDs).Preload("Employee").Find(&members).Error
}

func (s *store) GetActiveMemberInProject(db *gorm.DB, projectID string, employeeID string) (*model.ProjectMember, error) {
	var member *model.ProjectMember
	return member, db.
		Where("project_id = ?", projectID).
		Where("employee_id = ?", employeeID).
		Where("(end_date IS NULL OR end_date > now())").
		Preload("Employee").
		First(&member).Error
}

func (s *store) GetActiveMembersBySlotID(db *gorm.DB, slotID string) ([]*model.ProjectMember, error) {
	var members []*model.ProjectMember
	return members, db.Where("project_slot_id = ? AND status = ?", slotID, model.ProjectMemberStatusActive).Find(&members).Error
}

func (s *store) GetAssignedMembers(db *gorm.DB, projectID string, status string, preload bool) ([]*model.ProjectMember, error) {
	timeNow := time.Now()

	query := db.Table("project_members").
		Joins("LEFT JOIN seniorities s ON project_members.seniority_id = s.id").
		Joins(`LEFT JOIN project_heads ph ON (project_members.end_date IS NULL OR project_members.end_date > ?)
			AND project_members.project_id = ph.project_id 
			AND project_members.employee_id = ph.employee_id 
			AND ph.deleted_at IS NULL
			AND (ph.end_date IS NULL OR ph.end_date > ?)
			AND ph.position = ?
		`, timeNow, timeNow, model.HeadPositionTechnicalLead).
		Where("project_members.deleted_at IS NULL AND project_members.project_id = ?", projectID).
		Order("project_members.end_date DESC, ph.created_at, s.level DESC").
		Preload("Employee", "deleted_at IS NULL").
		Preload("Employee.Referrer", "deleted_at IS NULL")

	switch status {
	case model.ProjectMemberStatusOnBoarding.String():
		query = query.Where("project_members.start_date > ?", timeNow)

	case model.ProjectMemberStatusActive.String():
		query = query.Where("project_members.start_date <= ?", timeNow).
			Where("(project_members.end_date IS NULL OR project_members.end_date > ?)", timeNow)

	case model.ProjectMemberStatusInactive.String():
		query = query.Where("project_members.end_date <= ?", timeNow)
	}

	if preload {
		query = query.Preload("Seniority", "deleted_at IS NULL").
			Preload("UpsellPerson", "deleted_at IS NULL").
			Preload("ProjectMemberPositions", "deleted_at IS NULL").
			Preload("ProjectMemberPositions.Position", "deleted_at IS NULL")
	}

	var members []*model.ProjectMember
	return members, query.Find(&members).Error
}

// UpdateEndDateOverdueMemberToInActive just update end_date by projectID
func (s *store) UpdateEndDateOverdueMemberToInActive(db *gorm.DB) error {
	sql := `
		UPDATE project_members
		SET  status   = 'inactive'
		WHERE status = 'active' 
			AND end_date >= (NOW() AT TIME ZONE 'ICT')::DATE;
	`
	return db.Exec(sql).Error
}

// UpdateMemberInClosedProjectToInActive just update if project is closed or paused
func (s *store) UpdateMemberInClosedProjectToInActive(db *gorm.DB) error {
	sql := `
		UPDATE project_members pm
		SET
			status = 'inactive',
			end_date = p.end_date
		FROM
			projects p
		WHERE
			pm.project_id = p.id
			AND pm.status <> 'inactive'
			AND p.status IN ('closed', 'paused');
	`
	return db.Exec(sql).Error
}

// UpdateLeftMemberToInActive just update if employee is left
func (s *store) UpdateLeftMemberToInActive(db *gorm.DB) error {
	sql := `
		UPDATE project_members pm
		SET
			status = 'inactive',
			end_date = e.left_date
		FROM
			employees e
		WHERE
			pm.employee_id = e.id
			and pm.status <> 'inactive'
			AND e.working_status IN ('left');
	`
	return db.Exec(sql).Error
}

func (s *store) UpdateMemberToInActiveByID(db *gorm.DB, id string, endDate *time.Time) error {
	sql := `
		UPDATE project_members pm
		SET
			status = 'inactive',
			end_date = ?
		WHERE
			employee_id = ?
			AND (status <> 'inactive' OR end_date IS NULL OR end_date > NOW())
			
	`
	return db.Exec(sql, endDate, id).Error
}

```

# pkg/store/projectmember/interface.go

```go
package projectmember

import (
	"time"

	"gorm.io/gorm"
	
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, member *model.ProjectMember) error
	Delete(db *gorm.DB, id string) (err error)
	GetActiveByProjectIDs(db *gorm.DB, projectIDs []string) ([]*model.ProjectMember, error)
	GetActiveMemberInProject(db *gorm.DB, projectID string, employeeID string) (*model.ProjectMember, error)
	GetActiveMembersBySlotID(db *gorm.DB, slotID string) ([]*model.ProjectMember, error)
	GetAssignedMembers(db *gorm.DB, projectID string, status string, preload bool) ([]*model.ProjectMember, error)
	IsExist(db *gorm.DB, id string) (bool, error)
	IsExistsByEmployeeID(db *gorm.DB, projectID string, employeeID string) (bool, error)
	OneByID(db *gorm.DB, id string) (*model.ProjectMember, error)
	OneBySlotID(db *gorm.DB, slotID string) (*model.ProjectMember, error)
	UpdateEndDateByProjectID(db *gorm.DB, projectID string) error
	UpdateEndDateOverdueMemberToInActive(db *gorm.DB) error
	UpdateLeftMemberToInActive(db *gorm.DB) error
	UpdateMemberInClosedProjectToInActive(db *gorm.DB) error
	UpdateMemberToInActiveByID(db *gorm.DB, id string, endDate *time.Time) error
	UpdateSelectedFieldByProjectID(db *gorm.DB, projectID string, updateModel model.ProjectMember, updatedField string) error
	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectMember, updatedFields ...string) (*model.ProjectMember, error)
}

```

# pkg/store/projecthead/project_head.go

```go
package projecthead

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create using for insert new data to project head
func (s *store) Create(db *gorm.DB, projectHead *model.ProjectHead) error {
	return db.Create(projectHead).Preload("Employee").First(projectHead).Error
}

// BatchCreate create multiple project heads in one transaction
func (s *store) BatchCreate(db *gorm.DB, heads []*model.ProjectHead) ([]*model.ProjectHead, error) {
	return heads, db.Create(&heads).Error
}

// GetActiveLeadsByProjectID get active project heads by projectID
func (s *store) GetActiveLeadsByProjectID(db *gorm.DB, projectID string) ([]*model.ProjectHead, error) {
	var projectHeads []*model.ProjectHead

	now := time.Now()
	return projectHeads, db.Where("project_id = ? AND (end_date IS NULL OR end_date > ?)", projectID, now).
		Order("position").
		Preload("Employee").
		Find(&projectHeads).Error
}

func (s *store) DeleteByPositionInProject(db *gorm.DB, projectID string, employeeID string, position string) error {
	return db.Unscoped().Where("project_id = ? AND employee_id = ? AND position = ?", projectID, employeeID, position).Delete(&model.ProjectHead{}).Error
}

func (s *store) DeleteByID(db *gorm.DB, id string) error {
	return db.Unscoped().Where("id = ?", id).Delete(&model.ProjectHead{}).Error
}

func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectHead, updatedFields ...string) (*model.ProjectHead, error) {
	head := model.ProjectHead{}
	return &head, db.Model(&head).Where("id = ?", id).Select(updatedFields).Updates(&updateModel).Error
}

// One Get one head by project id and position
func (s *store) One(db *gorm.DB, projectID string, employeeID string, position model.HeadPosition) (*model.ProjectHead, error) {
	var projectHead *model.ProjectHead
	return projectHead, db.
		Where("project_id = ?", projectID).
		Where("employee_id = ?", employeeID).
		Where("position = ?", position).
		First(&projectHead).Error
}

func (s *store) UpdateDateOfEmployee(db *gorm.DB, employeeID string, projectID string, position string, startDate *time.Time, endDate *time.Time) (*model.ProjectHead, error) {
	head := model.ProjectHead{}
	return &head, db.
		Model(&head).
		Where("employee_id = ? AND project_id = ? AND position = ?", employeeID, projectID, position).
		Updates(map[string]interface{}{
			"start_date": startDate,
			"end_date":   endDate,
		}).Error
}

func (s *store) GetByProjectIDAndPosition(db *gorm.DB, projectID string, position model.HeadPosition) ([]*model.ProjectHead, error) {
	var heads []*model.ProjectHead
	return heads, db.Where("project_id = ? AND position = ?", projectID, position).Find(&heads).Error
}

```

# pkg/store/projecthead/interface.go

```go
package projecthead

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, head *model.ProjectHead) error
	BatchCreate(db *gorm.DB, heads []*model.ProjectHead) ([]*model.ProjectHead, error)
	GetActiveLeadsByProjectID(db *gorm.DB, projectID string) (projectHeads []*model.ProjectHead, err error)
	DeleteByPositionInProject(db *gorm.DB, projectID string, employeeID string, position string) (err error)
	DeleteByID(db *gorm.DB, id string) (err error)
	One(db *gorm.DB, projectID string, employeeID string, position model.HeadPosition) (projectHead *model.ProjectHead, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectHead, updatedFields ...string) (*model.ProjectHead, error)
	UpdateDateOfEmployee(db *gorm.DB, employeeID string, projectID string, position string, startDate *time.Time, endDate *time.Time) (*model.ProjectHead, error)
	GetByProjectIDAndPosition(db *gorm.DB, projectID string, position model.HeadPosition) (heads []*model.ProjectHead, err error)
}

```

# pkg/store/projectnotion/project_notion.go

```go
package projectnotion

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// OneByProjectID get projectNotion by project id
func (s *store) OneByProjectID(db *gorm.DB, projectID string) (*model.ProjectNotion, error) {
	var projectNotion *model.ProjectNotion
	return projectNotion, db.Where("project_id = ?", projectID).Preload("Project", "deleted_at IS NULL").First(&projectNotion).Error
}

// OneByAuditNotionID get projectNotion by audit notion id
func (s *store) OneByAuditNotionID(db *gorm.DB, auditNotionID string) (*model.ProjectNotion, error) {
	var projectNotion *model.ProjectNotion
	return projectNotion, db.Where("audit_notion_id = ?", auditNotionID).Preload("Project", "deleted_at IS NULL").First(&projectNotion).Error
}

// Create creates a new projectNotion
func (s *store) Create(db *gorm.DB, e *model.ProjectNotion) (projectNotion *model.ProjectNotion, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, projectNotion *model.ProjectNotion) (*model.ProjectNotion, error) {
	return projectNotion, db.Model(&projectNotion).Where("id = ?", projectNotion.ID).Updates(&projectNotion).First(&projectNotion).Error
}

// IsExistByAuditNotionID check project notion existence by audit notion id
func (s *store) IsExistByAuditNotionID(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM project_notions WHERE audit_notion_id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectNotion, updatedFields ...string) (*model.ProjectNotion, error) {
	projectNotion := model.ProjectNotion{}
	return &projectNotion, db.Model(&projectNotion).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

```

# pkg/store/projectnotion/interface.go

```go
package projectnotion

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	OneByProjectID(db *gorm.DB, projectID string) (projectNotion *model.ProjectNotion, err error)
	OneByAuditNotionID(db *gorm.DB, projectID string) (projectNotion *model.ProjectNotion, err error)
	Create(db *gorm.DB, e *model.ProjectNotion) (projectNotion *model.ProjectNotion, err error)
	Update(db *gorm.DB, projectNotion *model.ProjectNotion) (a *model.ProjectNotion, err error)
	IsExistByAuditNotionID(db *gorm.DB, id string) (exists bool, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectNotion, updatedFields ...string) (projectNotion *model.ProjectNotion, err error)
}

```

# pkg/store/project/request.go

```go
package project

type GetListProjectInput struct {
	Statuses            []string `json:"statuses"`
	Name                string   `json:"name"`
	Types               []string `json:"type"`
	AllowsSendingSurvey bool     `json:"allowsSendingSurvey"`
}

```

# pkg/store/project/project.go

```go
package project

import (
	"fmt"
	"strings"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// All get all projects by query and pagination
func (s *store) All(db *gorm.DB, input GetListProjectInput, pagination model.Pagination) ([]*model.Project, int64, error) {
	var projects []*model.Project

	query := db.Table("projects").
		Where("projects.deleted_at IS NULL")

	var total int64

	if input.Name != "" {
		query = query.Where("projects.name ILIKE ?", fmt.Sprintf("%%%s%%", input.Name))
	}

	if len(input.Statuses) > 0 {
		query = query.Where("projects.status IN ?", input.Statuses)
	}

	if len(input.Types) > 0 {
		query = query.Where("projects.type IN ?", input.Types)
	}

	if input.AllowsSendingSurvey {
		query = query.Where("projects.allows_sending_survey = ?", input.AllowsSendingSurvey)
	}

	query = query.Count(&total)

	query = query.
		Select("projects.*, COALESCE(SUM(project_members.rate)/currency_exchanges.exchange_rate, 0) as converted_monthly_revenue").
		Joins(`LEFT JOIN project_members ON project_members.project_id = projects.id
				AND project_members.deleted_at IS NULL 
				AND project_members.status = 'active' 
				AND project_members.deployment_type = 'official'
		`).
		Joins("LEFT JOIN bank_accounts on projects.bank_account_id = bank_accounts.id").
		Joins("LEFT JOIN currencies on bank_accounts.currency_id = currencies.id").
		Joins(`
			LEFT JOIN (
				SELECT *
				FROM (
					VALUES 
						('USD', 'USD', 1),
						('USD', 'CAD', 1.33420),
						('USD', 'GBP', 0.79488),
						('USD', 'EUR', 0.93030),
						('USD', 'VND', 23480),
						('USD', 'SGD', 1.34325)) AS rates(src_cur, dest_cur, exchange_rate)
			) as currency_exchanges ON currencies.name = currency_exchanges.dest_cur`).
		Group(`
			projects.id,
			projects.deleted_at,
			projects.created_at,
			projects.updated_at,
			projects.name,
			projects.type,
			projects.start_date,
			projects.end_date,
			projects.status,
			projects.country_id,
			projects.client_email,
			projects.project_email,
			projects.allows_sending_survey,
			projects.avatar,
			projects.code,
			projects.bank_account_id,
			projects.client_id,
			projects.company_info_id,
			projects.organization_id,
			account_rating,
			delivery_rating,
			lead_rating,
			important_level,
			currencies.name,
			currency_exchanges.exchange_rate
		`)

	if pagination.Sort != "" {
		query = query.Order(s.sortFieldMapping(pagination.Sort))
	} else {
		query = query.Order("converted_monthly_revenue DESC")
	}

	limit, offset := pagination.ToLimitOffset()
	if pagination.Page > 0 {
		query = query.Limit(limit)
	}

	query = query.Preload("ProjectMembers", func(db *gorm.DB) *gorm.DB {
		return db.Joins("JOIN projects ON project_members.project_id = projects.id").
			Where("project_members.deleted_at IS NULL AND (projects.status = ? OR project_members.status = ?)",
				model.ProjectStatusClosed,
				model.ProjectMemberStatusActive)
	}).
		Preload("ProjectMembers.Employee").
		Preload("ProjectNotion", "deleted_at IS NULL").
		Preload("Organization", "deleted_at IS NULL").
		Preload("Heads", `deleted_at IS NULL AND (end_date IS NULL OR end_date > now())`).
		Preload("Heads.Employee").
		Preload("BankAccount", "deleted_at IS NULL").
		Preload("BankAccount.Currency", "deleted_at IS NULL").
		Preload("CommissionConfigs", "deleted_at IS NULL").
		Offset(offset)

	return projects, total, query.Find(&projects).Error
}

// Create use to create new project to database
func (s *store) Create(db *gorm.DB, project *model.Project) error {
	return db.Create(&project).Preload("Country").Error
}

// IsExist check project existence
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM projects WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

// IsExistByCode check project existence by code
func (s *store) IsExistByCode(db *gorm.DB, code string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM projects WHERE code = ?) as result", code)

	return result.Result, query.Scan(&result).Error
}

// One get 1 project by id
func (s *store) One(db *gorm.DB, id string, preload bool) (*model.Project, error) {
	query := db
	if !model.IsUUIDFromString(id) {
		query = db.Where("code = ?", id)
	} else {
		query = db.Where("id = ?", id)
	}

	query = query.
		Preload("BankAccount", "deleted_at IS NULL").
		Preload("BankAccount.Currency", "deleted_at IS NULL")
	if preload {
		query = query.
			Preload("Heads", "deleted_at IS NULL AND (end_date IS NULL OR end_date > now())").
			Preload("Heads.Employee", "deleted_at IS NULL").
			Preload("ProjectStacks", "deleted_at IS NULL").
			Preload("ProjectStacks.Stack", "deleted_at IS NULL").
			Preload("Country", "deleted_at IS NULL").
			Preload("Client", "deleted_at IS NULL").
			Preload("Client.Contacts", "deleted_at IS NULL").
			Preload("CompanyInfo", "deleted_at IS NULL").
			Preload("ProjectNotion", "deleted_at IS NULL").
			Preload("Organization", "deleted_at IS NULL").
			Preload("ProjectMembers", func(db *gorm.DB) *gorm.DB {
				return db.Joins("JOIN seniorities s ON s.id = project_members.seniority_id").
					Joins(`LEFT JOIN project_heads ph ON ph.project_id = project_members.project_id 
						AND ph.employee_id = project_members.employee_id 
						AND ph.position = ?
						AND (ph.end_date IS NULL OR ph.end_date > now())`,
						model.HeadPositionTechnicalLead,
					).
					Where("project_members.deleted_at IS NULL").
					Where("project_members.start_date <= now()").
					Where("(project_members.end_date IS NULL OR project_members.end_date > now())").
					Order("CASE ph.position WHEN 'technical-lead' THEN 1 ELSE 2 END").
					Order("s.level DESC")
			}).
			Preload("ProjectMembers.Employee", "deleted_at IS NULL").
			Preload("ProjectMembers.ProjectMemberPositions", "deleted_at IS NULL").
			Preload("ProjectMembers.ProjectMemberPositions.Position", "deleted_at IS NULL").
			Preload("ProjectMembers.Seniority", "deleted_at IS NULL").
			Preload("ProjectMembers.UpsellPerson", "deleted_at IS NULL").
			Preload("CommissionConfigs", "deleted_at IS NULL")
	}

	var project *model.Project
	return project, query.First(&project).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Project, updatedFields ...string) (*model.Project, error) {
	project := model.Project{}
	return &project, db.Model(&project).Where("id = ?", id).Select(updatedFields).Updates(&updateModel).Error
}

// GetByEmployeeID get project list by employee id
func (s *store) GetByEmployeeID(db *gorm.DB, employeeID string) ([]*model.Project, error) {
	var projects []*model.Project

	query := db.Table("projects").
		Joins("JOIN project_members pm ON pm.project_id = projects.id").
		Where("pm.start_date <= now() AND (pm.end_date IS NULL OR pm.end_date > now())").
		Where("projects.status = ?", model.ProjectStatusActive).
		Where("projects.deleted_at IS NULL AND pm.employee_id = ?", employeeID).
		Preload("Heads", func(db *gorm.DB) *gorm.DB {
			return db.Joins("JOIN projects p ON project_heads.project_id = p.id").
				Where("(project_heads.end_date IS NULL OR project_heads.end_date > ?) AND project_heads.employee_id = ? AND project_heads.position = ?", time.Now(), employeeID, model.HeadPositionTechnicalLead)
		}).
		Preload("Heads.Employee")

	return projects, query.Find(&projects).Error
}

func (s *store) GetProjectByAlias(db *gorm.DB, alias string) (*model.Project, error) {
	res := model.Project{}
	return &res, db.Where("alias = ?", alias).Preload("ProjectInfo").Find(&res).Error
}

func (s *store) sortFieldMapping(fields string) string {
	sortFields := strings.Split(fields, ",")

	sortString := ""
	for _, field := range sortFields {
		sortField := strings.Split(field, " ")
		switch sortField[0] {
		case "monthlyChargeRate":
			sortString += fmt.Sprintf("%v %v, ", "converted_monthly_revenue", sortField[1])
		case "importantLevel":
			sortString += fmt.Sprintf("%v %v, ", "projects.important_level", sortField[1])
		case "updatedAt":
			sortString += fmt.Sprintf("%v %v, ", "projects.updated_at", sortField[1])
		}
	}

	if sortString == "" {
		return fmt.Sprintf("%v %v", "converted_monthly_revenue", "DESC")
	}

	return strings.TrimSuffix(sortString, ", ")
}

func (s *store) GetRawList(db *gorm.DB) ([]model.Project, error) {
	var projects []model.Project

	return projects, db.Find(&projects).Error
}

```

# pkg/store/project/interface.go

```go
package project

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB, input GetListProjectInput, pagination model.Pagination) ([]*model.Project, int64, error)
	Create(db *gorm.DB, project *model.Project) error
	IsExist(db *gorm.DB, id string) (bool, error)
	IsExistByCode(db *gorm.DB, code string) (bool, error)
	One(db *gorm.DB, id string, preload bool) (*model.Project, error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Project, updatedFields ...string) (*model.Project, error)
	GetByEmployeeID(db *gorm.DB, employeeID string) ([]*model.Project, error)
	GetProjectByAlias(db *gorm.DB, alias string) (*model.Project, error)
	GetRawList(db *gorm.DB) ([]model.Project, error)
}

```

# pkg/store/projectcommissionconfig/project_commission_config.go

```go
package projectcommissionconfig

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) GetByProjectID(db *gorm.DB, projectID string) (model.ProjectCommissionConfigs, error) {
	var heads model.ProjectCommissionConfigs
	return heads, db.Where("project_id = ?", projectID).Find(&heads).Error
}

```

# pkg/store/projectcommissionconfig/interface.go

```go
package projectcommissionconfig

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type IStore interface {
	GetByProjectID(db *gorm.DB, projectID string) (heads model.ProjectCommissionConfigs, err error)
}

```

# pkg/store/position/position.go

```go
package position

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// All get all positions
func (s *store) All(db *gorm.DB) ([]*model.Position, error) {
	var positions []*model.Position
	return positions, db.Find(&positions).Error
}

// One get 1 one by id
func (s *store) One(db *gorm.DB, id model.UUID) (*model.Position, error) {
	var pos *model.Position
	return pos, db.Where("id = ?", id).First(&pos).Error
}

// Update update the position
func (s *store) Update(db *gorm.DB, position *model.Position) (*model.Position, error) {
	return position, db.Model(&model.Position{}).Where("id = ?", position.ID).Updates(&position).First(&position).Error
}

// Delete delete ProjectMember by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.Position{}).Error
}

// Create create new position
func (s *store) Create(db *gorm.DB, position *model.Position) (*model.Position, error) {
	return position, db.Create(position).Error
}

```

# pkg/store/position/interface.go

```go
package position

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB) (positions []*model.Position, err error)
	One(db *gorm.DB, id model.UUID) (position *model.Position, err error)
	Update(db *gorm.DB, position *model.Position) (p *model.Position, err error)
	Create(db *gorm.DB, position *model.Position) (p *model.Position, err error)
	Delete(db *gorm.DB, id string) (err error)
}

```

# pkg/store/projectmemberposition/project_member_position.go

```go
package projectmemberposition

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create create new project member position
func (s *store) Create(db *gorm.DB, pos ...model.ProjectMemberPosition) error {
	return db.Create(&pos).Error
}

// DeleteByProjectMemberID delete project_member_positions by project_member_id
func (s *store) DeleteByProjectMemberID(db *gorm.DB, memberID string) error {
	return db.Unscoped().Where("project_member_id = ?", memberID).Delete(&model.ProjectMemberPosition{}).Error
}

```

# pkg/store/projectmemberposition/interface.go

```go
package projectmemberposition

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type IStore interface {
	Create(db *gorm.DB, pos ...model.ProjectMemberPosition) error
	DeleteByProjectMemberID(db *gorm.DB, memberID string) error
}

```

# pkg/store/physicalcheckin/physical_checkin.go

```go
package physicalcheckin

import (
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) Save(db *gorm.DB, tx *model.PhysicalCheckinTransaction) error {
	return db.Clauses(clause.OnConflict{
		Columns: []clause.Column{{Name: "employee_id"}, {Name: "date"}},
		DoUpdates: clause.Assignments(map[string]interface{}{
			"icy_amount":  tx.IcyAmount,
			"mochi_tx_id": tx.MochiTxID,
		}),
	}).Create(tx).Error
}

func (s *store) One(db *gorm.DB, id int) (*model.PhysicalCheckinTransaction, error) {
	var tx model.PhysicalCheckinTransaction
	err := db.Where("id = ?", id).First(&tx).Error
	return &tx, err
}

func (s *store) GetByEmployeeIDAndDate(db *gorm.DB, employeeID string, date string) (*model.PhysicalCheckinTransaction, error) {
	var tx model.PhysicalCheckinTransaction
	err := db.Where("employee_id = ? AND date = ?", employeeID, date).First(&tx).Error
	return &tx, err
}

```

# pkg/store/physicalcheckin/interface.go

```go
package physicalcheckin

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id int) (pc *model.PhysicalCheckinTransaction, err error)
	Save(db *gorm.DB, pc *model.PhysicalCheckinTransaction) (err error)
	GetByEmployeeIDAndDate(db *gorm.DB, employeeID string, date string) (*model.PhysicalCheckinTransaction, error)
}

```

# pkg/store/permission/permission.go

```go
package permission

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// GetByEmployeeID get list of permissions by employee id
func (s *store) GetByEmployeeID(db *gorm.DB, employeeID string) ([]*model.Permission, error) {
	var permissions []*model.Permission
	return permissions, db.
		Select("DISTINCT permissions.*").
		Joins("JOIN role_permissions rp ON permissions.id = rp.permission_id").
		Joins("JOIN employee_roles er ON er.role_id = rp.role_id").
		Where("er.employee_id = ?", employeeID).
		Order("permissions.code").
		Find(&permissions).Error
}

func (s *store) HasPermission(db *gorm.DB, employeeID string, permCode string) (bool, error) {
	var res struct {
		Result bool
	}

	query := db.Raw(`
	SELECT EXISTS (
		SELECT * 
		FROM permissions p
			JOIN role_permissions rp ON p.id = rp.permission_id
			JOIN employee_roles er ON rp.role_id = er.role_id
			JOIN employees e ON er.employee_id = e.id AND e.id = ? 
		WHERE p.code = ?
	) as result`, employeeID, permCode)

	return res.Result, query.Scan(&res).Error
}

func (s *store) GetByApiKeyID(db *gorm.DB, apiKeyID string) ([]*model.Permission, error) {
	var permissions []*model.Permission
	return permissions, db.
		Select("DISTINCT permissions.*").
		Joins("JOIN role_permissions rp ON permissions.id = rp.permission_id").
		Joins("JOIN api_key_roles ar ON ar.role_id = rp.role_id").
		Where("ar.api_key_id = ?", apiKeyID).
		Order("permissions.code").
		Find(&permissions).Error
}

```

# pkg/store/permission/interface.go

```go
package permission

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	GetByEmployeeID(db *gorm.DB, employeeID string) (permissions []*model.Permission, err error)
	GetByApiKeyID(db *gorm.DB, apiKeyID string) ([]*model.Permission, error)
	HasPermission(db *gorm.DB, employeeID string, perm string) (bool, error)
}

```

# pkg/store/operationalservice/operational_service.go

```go
package operationalservice

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}
func (s store) FindOperationByMonth(db *gorm.DB, month time.Month) ([]*model.OperationalService, error) {
	var res []*model.OperationalService
	query := db.Table("operational_services").
		Preload("Currency").
		Where("is_active is true and type = 'monthly'")

	err := query.Find(&res).Error
	if err != nil && err != gorm.ErrRecordNotFound {
		return nil, err
	}
	return res, nil
}

```

# pkg/store/operationalservice/interface.go

```go
package operationalservice

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	FindOperationByMonth(db *gorm.DB, month time.Month) ([]*model.OperationalService, error)
}

```

# pkg/store/organization/organization.go

```go
package organization

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type store struct{}

func New() IStore {
	return &store{}
}
func (s *store) One(db *gorm.DB, id string) (*model.Organization, error) {
	var organization *model.Organization
	return organization, db.Where("id = ?", id).First(&organization).Error
}

func (s *store) All(db *gorm.DB) ([]*model.Organization, error) {
	var organizations []*model.Organization
	return organizations, db.Find(&organizations).Error
}

func (s *store) OneByCode(db *gorm.DB, code string) (*model.Organization, error) {
	var organization *model.Organization
	return organization, db.Where("code = ?", code).First(&organization).Error
}

// IsExist check organization existence
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM organizations WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

```

# pkg/store/organization/interface.go

```go
package organization

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (organization *model.Organization, err error)
	OneByCode(db *gorm.DB, code string) (organization *model.Organization, err error)
	All(db *gorm.DB) ([]*model.Organization, error)
	IsExist(db *gorm.DB, id string) (exists bool, err error)
}

```

# pkg/store/payroll/payroll_test.go

```go
package payroll

// func TestGetList(t *testing.T) {
// 	db, _, close := util.GetTestDB(t)
// 	defer close()

// 	var payrolls []domain.Payroll
// 	firstDueDate, err := timeutil.ParseStringToDate("2019-15-08")
// 	if err != nil {
// 		t.Errorf("unexpected error: %v", err)
// 		return
// 	}
// 	secondDueDate, err := timeutil.ParseStringToDate("2019-01-08")
// 	if err != nil {
// 		t.Errorf("unexpected error: %v", err)
// 		return
// 	}
// 	firstUser := domain.User{
// 		Model: domain.Model{
// 			ID: domain.MustGetUUIDFromString("63d163a7-e9f5-4210-a685-151061fe9c29"),
// 		},
// 		BaseSalary: domain.BaseSalary{
// 			Model: domain.Model{
// 				ID: domain.MustGetUUIDFromString("e8ccf0b5-f325-43f2-bc0f-717e9e8e0506"),
// 			},
// 		},
// 	}
// 	// secondUser := domain.User{
// 	// 	Model: domain.Model{
// 	// 		ID: domain.MustGetUUIDFromString("d8a6af04-9e0a-4724-97c4-a78ecd5e9bc4"),
// 	// 	},
// 	// 	BaseSalary: domain.BaseSalary{
// 	// 		Model: domain.Model{
// 	// 			ID: domain.MustGetUUIDFromString("118c36e5-5cd7-4984-a82d-4ad0eb05fee9"),
// 	// 		},
// 	// 	},
// 	// }
// 	payrolls = append(payrolls, domain.Payroll{
// 		ID:                 domain.MustGetUUIDFromString("0c64d4da-ab09-41db-9045-fa42ee35682a"),
// 		UserID:             domain.MustGetUUIDFromString("63d163a7-e9f5-4210-a685-151061fe9c29"),
// 		Total:              20000,
// 		Month:              8,
// 		Year:               2019,
// 		CommissionAmount:   0,
// 		ProjectBonusAmount: 0,
// 		DueDate:            secondDueDate,
// 		User:               firstUser,
// 	}, domain.Payroll{
// 		ID:                 domain.MustGetUUIDFromString("7744a878-3cc1-4290-8aef-13bca71a22a5"),
// 		UserID:             domain.MustGetUUIDFromString("63d163a7-e9f5-4210-a685-151061fe9c29"),
// 		Total:              0,
// 		Month:              8,
// 		Year:               2019,
// 		CommissionAmount:   0,
// 		ProjectBonusAmount: 0,
// 		DueDate:            firstDueDate,
// 		User:               firstUser,
// 	})

// 	testcases := []struct {
// 		name    string
// 		q       Query
// 		wantRes []domain.Payroll
// 		wantErr error
// 	}{
// 		{
// 			name:    "case success",
// 			wantRes: payrolls,
// 		},
// 	}
// 	for _, tc := range testcases {
// 		t.Run(tc.name, func(t *testing.T) {
// 			s := &payrollService{}
// 			res, err := s.GetList(db, tc.q)
// 			if err != nil && err != tc.wantErr {
// 				t.Errorf("[payrollStore].GetList() want error: %v, got error: %v", tc.wantErr, err)
// 				return
// 			}
// 			t.Log(len(res))
// 			for i := 0; i < 2; i++ {
// 				if res[i].Total != tc.wantRes[i].Total {
// 					t.Errorf("[payrollStore].GetList() want total response: %v, got total response: %v", tc.wantRes[i].Total, res[i].Total)
// 					return
// 				}
// 				if res[i].CommissionAmount != tc.wantRes[i].CommissionAmount {
// 					t.Errorf("[payrollStore].GetList() want commission amount response: %v, got commission amount response: %v", tc.wantRes[i].CommissionAmount, res[i].CommissionAmount)
// 					return
// 				}
// 				if res[i].ProjectBonusAmount != tc.wantRes[i].ProjectBonusAmount {
// 					t.Errorf("[payrollStore].GetList() want project bonus response: %v, got project bonus response: %v", tc.wantRes[i].ProjectBonusAmount, res[i].ProjectBonusAmount)
// 					return
// 				}
// 				if reflect.DeepEqual(tc.wantRes[i].DueDate, res[i].DueDate) {
// 					t.Errorf("[payrollStore].GetList() want due_date response: %v, got due_date response: %v", tc.wantRes[i].DueDate, res[i].DueDate)
// 					return
// 				}
// 				if res[i].User.ID != tc.wantRes[i].User.ID {
// 					t.Errorf("[payrollStore].GetList() want user ID response: %v, got user ID response: %v", tc.wantRes[i].User.ID, res[i].User.ID)
// 				}
// 				if res[i].User.BaseSalary.ID != tc.wantRes[i].User.BaseSalary.ID {
// 					t.Errorf("[payrollStore].GetList() want base salary ID response: %v, got base salary ID response: %v", tc.wantRes[i].User.BaseSalary.ID, res[i].User.BaseSalary.ID)
// 				}
// 			}
// 		})
// 	}
// }

// func TestUpdateSpecificFields(t *testing.T) {
// 	db, _, close := util.GetTestDB(t)
// 	defer close()

// 	fields := map[string]interface{}{
// 		"total": 10000000000,
// 	}
// 	testcases := []struct {
// 		name    string
// 		id      string
// 		wantErr error
// 		fields  map[string]interface{}
// 	}{
// 		{
// 			name:   "case success",
// 			id:     "7744a878-3cc1-4290-8aef-13bca71a22a5",
// 			fields: fields,
// 		},
// 		{
// 			name:    "case not found",
// 			id:      "7744a878-3cc1-4290-8aef-13bca71a22a4",
// 			fields:  fields,
// 			wantErr: gorm.ErrRecordNotFound,
// 		},
// 	}
// 	for _, tc := range testcases {
// 		t.Run(tc.name, func(t *testing.T) {
// 			s := &payrollService{}
// 			err := s.UpdateSpecificFields(db, tc.id, tc.fields)
// 			if err != nil && err != tc.wantErr {
// 				t.Errorf("[payrollStore].UpdateSpecificFields() want error: %v, got error: %v", tc.wantErr, err)
// 				return
// 			}
// 			if err != nil && tc.wantErr == nil {
// 				t.Error("[payrollStore].UpdateSpecificFields() want error not nil, got error nil")
// 			}
// 		})
// 	}

// }

```

# pkg/store/payroll/payroll.go

```go
package payroll

import (
	"fmt"
	"strings"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

// New create new pg service
func New() IStore {
	return &store{}
}

func (s *store) GetSalary(db *gorm.DB, year int, month int) ([]model.Employee, error) {
	var employees []model.Employee

	return employees, db.Table("employee").
		Where("status = <> ?", model.WorkingStatusLeft).
		Preload("Expense", func(db *gorm.DB) *gorm.DB {
			return db.Where("date_part('year', issued_date) = ? AND date_part('month', issued_date) = ?", year, month)
		}).
		Group("employee.id").
		Find(&employees).
		Error
}

func (s *store) Create(db *gorm.DB, p *model.Payroll) error {
	return db.Create(p).Error
}

func (s *store) Get(db *gorm.DB, employeeId string, month, year int) (*model.Payroll, error) {
	res := &model.Payroll{}
	return res, db.Where("employee_id = ? AND year = ? AND month = ?", employeeId, year, month).First(&res).Error
}

func (s *store) GetList(db *gorm.DB, q GetListPayrollInput) ([]model.Payroll, error) {
	var res []model.Payroll
	payrollQuery := db.
		Preload("Employee", func(db *gorm.DB) *gorm.DB {
			return db.Order("display_name asc")
		}).
		Preload("Employee.BaseSalary.Currency")

	if q.ID != "" {
		payrollQuery = payrollQuery.Where("payrolls.id = ?", q.ID)
	}
	if q.UserID != "" {
		payrollQuery = payrollQuery.Where("payrolls.employee_id = ?", q.UserID)
	}
	if q.Month != 0 {
		payrollQuery = payrollQuery.Where("payrolls.month = ?", q.Month)
	}
	if q.Year != 0 {
		payrollQuery = payrollQuery.Where("payrolls.year = ?", q.Year)
	}
	if q.Day != 0 {
		payrollQuery = payrollQuery.Where("date_part('day', due_date) = ?", q.Day)
	}

	err := payrollQuery.
		Order(`
		year desc,
		month desc`).
		Find(&res).
		Error
	if err != nil {
		return nil, err
	}

	for i, v := range res {
		var baseSalary model.BaseSalary
		if err := db.
			Preload("Currency").
			Where("employee_id = ?", v.EmployeeID).
			Order("effective_date desc").
			First(&baseSalary).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				continue
			}
			return nil, err
		}
		res[i].Employee.BaseSalary = baseSalary
	}

	return res, nil
}

func (s *store) UpdateSpecificFields(db *gorm.DB, id string, fields map[string]interface{}) error {
	return db.Model(&model.Payroll{}).
		Where("id = ?", id).
		Updates(fields).Error
}

func (s *store) GetLatestCommitTime(db *gorm.DB) (time.Time, error) {
	var DueDate time.Time
	return DueDate, db.Table("payrolls").Select("max(due_date) as due_date").Row().Scan(&DueDate)
}

func (s *store) InsertList(db *gorm.DB, payrolls []model.Payroll) error {
	if len(payrolls) <= 0 {
		return fmt.Errorf("payrolls cannot be empty")
	}

	var valueStrings []string
	var valueArgs []interface{}

	for _, payroll := range payrolls {
		valueStrings = append(valueStrings, "(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)")

		valueArgs = append(valueArgs, model.NewUUID())
		valueArgs = append(valueArgs, payroll.EmployeeID)
		valueArgs = append(valueArgs, payroll.Total)
		valueArgs = append(valueArgs, payroll.Month)
		valueArgs = append(valueArgs, payroll.Year)
		valueArgs = append(valueArgs, payroll.CommissionAmount)
		valueArgs = append(valueArgs, payroll.CommissionExplain)
		valueArgs = append(valueArgs, payroll.UserRankSnapshot)
		valueArgs = append(valueArgs, payroll.TotalExplain)
		valueArgs = append(valueArgs, payroll.ProjectBonusAmount)
		valueArgs = append(valueArgs, payroll.DueDate)
		valueArgs = append(valueArgs, payroll.ProjectBonusExplain)
		valueArgs = append(valueArgs, payroll.IsPaid)
		valueArgs = append(valueArgs, payroll.ConversionAmount)
		valueArgs = append(valueArgs, payroll.BaseSalaryAmount)
		valueArgs = append(valueArgs, payroll.ContractAmount)
		valueArgs = append(valueArgs, payroll.SalaryAdvanceAmount)
	}

	smt := `INSERT INTO payrolls(id, employee_id, total, month, year, commission_amount, commission_explain, employee_rank_snapshot, total_explain, project_bonus_amount, due_date, project_bonus_explain, is_paid, conversion_amount, base_salary_amount, contract_amount, salary_advance_amount) VALUES %s`
	smt = fmt.Sprintf(smt, strings.Join(valueStrings, ","))

	tx := db.Begin()
	err := tx.Exec(smt, valueArgs...).Error
	if err != nil {
		tx.Rollback()
		return err
	}
	tx.Commit()
	return nil
}

```

# pkg/store/payroll/interface.go

```go
package payroll

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

// IStore implement operation method
type IStore interface {
	// GetSalary TODO: rename to GetList
	GetSalary(db *gorm.DB, year int, month int) ([]model.Employee, error)
	Get(db *gorm.DB, userId string, year, month int) (*model.Payroll, error)
	Create(db *gorm.DB, p *model.Payroll) error
	InsertList(db *gorm.DB, payrolls []model.Payroll) error

	// GetList payroll row, the result included: User,
	// Role, Rank, Base Salary and Commission
	GetList(db *gorm.DB, q GetListPayrollInput) ([]model.Payroll, error)

	// UpdateSpecificFields for a payroll row
	// fields that will be update will be declared
	// as string match with column name in table payroll
	UpdateSpecificFields(db *gorm.DB, id string, fields map[string]interface{}) error
	GetLatestCommitTime(db *gorm.DB) (time.Time, error)
}

```

# pkg/store/payroll/input.go

```go
package payroll

type GetListPayrollInput struct {
	ID     string
	UserID string
	Day    int
	Month  int
	Year   int
}

```

# pkg/store/onleaverequest/onleave_request.go

```go
package onleaverequest

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

type GetOnLeaveInput struct {
	Date string
}

// Create creates an on-leave request record in the database
func (s *store) Create(db *gorm.DB, r *model.OnLeaveRequest) (request *model.OnLeaveRequest, err error) {
	return r, db.Create(r).Error
}

func (s *store) All(db *gorm.DB, input GetOnLeaveInput) ([]*model.OnLeaveRequest, error) {
	var chapters []*model.OnLeaveRequest
	query := db.
		Preload("Creator").
		Preload("Creator.DiscordAccount").
		Preload("Approver").
		Preload("Approver.DiscordAccount")

	if input.Date != "" {
		query = query.Where("start_date <= ? AND ? <= end_date", input.Date, input.Date)
	}

	return chapters, query.Find(&chapters).Error
}

```

# pkg/store/onleaverequest/interface.go

```go
package onleaverequest

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, r *model.OnLeaveRequest) (request *model.OnLeaveRequest, err error)
	All(db *gorm.DB, input GetOnLeaveInput) ([]*model.OnLeaveRequest, error)
}

```

# pkg/store/memolog/memo_log.go

```go
package memolog

import (
	"fmt"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create creates a memo log record in the database
func (s *store) Create(db *gorm.DB, b []model.MemoLog) ([]model.MemoLog, error) {
	return b, db.Table("memo_logs").Create(b).Error
}

// GetLimitByTimeRange gets memo logs in a specific time range, with limit
func (s *store) GetLimitByTimeRange(db *gorm.DB, start, end *time.Time, limit int) ([]model.MemoLog, error) {
	var logs []model.MemoLog
	return logs, db.Preload("Authors").Preload("Authors.Employee").Where("published_at BETWEEN ? AND ?", start, end).Limit(limit).Order("published_at DESC").Find(&logs).Error
}

// ListFilter is a filter for List function
type ListFilter struct {
	From      *time.Time
	To        *time.Time
	DiscordID string
}

// List gets all memo logs
func (s *store) List(db *gorm.DB, filter ListFilter) ([]model.MemoLog, error) {
	var logs []model.MemoLog
	query := db.Preload("Authors").Preload("Authors.Employee").Order("published_at DESC")
	if filter.From != nil {
		query = query.Where("published_at >= ?", *filter.From)
	}
	if filter.To != nil {
		query = query.Where("published_at <= ?", *filter.To)
	}

	if filter.DiscordID != "" {
		query = query.Joins("JOIN memo_authors ma ON ma.memo_log_id = memo_logs.id").
			Joins("JOIN discord_accounts da ON da.id = ma.discord_account_id AND da.discord_id = ?", filter.DiscordID)
	}

	return logs, query.Find(&logs).Error
}

// ListNonAuthor gets all memo logs that have no author info
func (s *store) ListNonAuthor(db *gorm.DB) ([]model.MemoLog, error) {
	var logs []model.MemoLog
	query := `
		SELECT 
			memo_logs.*
		FROM 
			memo_logs
		LEFT JOIN 
			memo_authors ON memo_authors.memo_log_id = memo_logs.id
		GROUP BY 
			memo_logs.id
		HAVING 
			STRING_AGG(memo_authors.discord_account_id::text, ', ') IS NULL OR 
			STRING_AGG(memo_authors.discord_account_id::text, ', ') = ''
	`

	return logs, db.Raw(query).Scan(&logs).Error
}

func (s *store) GetRankByDiscordID(db *gorm.DB, discordID string) (*model.DiscordAccountMemoRank, error) {
	query := `
		WITH memo_count AS (
			SELECT
				da.discord_id,
				COUNT(ml.id) AS total_memos
			FROM
				public.memo_authors ma
			JOIN
				public.memo_logs ml ON ma.memo_log_id = ml.id
			JOIN
				public.discord_accounts da ON ma.discord_account_id = da.id
			WHERE
				ml.deleted_at IS NULL
			GROUP BY
				da.discord_id
		),
		ranked_memos AS (
			SELECT
				discord_id,
				total_memos,
				RANK() OVER (ORDER BY total_memos DESC) AS rank
			FROM
				memo_count
		)
		SELECT
			rm.discord_id,
			rm.total_memos,
			rm.rank
		FROM
			ranked_memos rm
		WHERE
			rm.discord_id = ?
	`
	var memoRank model.DiscordAccountMemoRank
	result := db.Raw(query, discordID).Scan(&memoRank)

	if result.Error != nil {
		return nil, result.Error
	}

	if result.RowsAffected == 0 {
		return nil, fmt.Errorf("no records found for discord_id: %s", discordID)
	}

	return &memoRank, nil
}

// CreateMemoAuthor creates a memo author record in the database
func (s *store) CreateMemoAuthor(db *gorm.DB, memoAuthor *model.MemoAuthor) error {
	return db.Create(memoAuthor).Error
}

// GetTopAuthors gets the top authors by memo count
func (s *store) GetTopAuthors(db *gorm.DB, limit int) ([]model.DiscordAccountMemoRank, error) {
	query := `
		WITH memo_count AS (
			SELECT
				da.discord_id,
				da.discord_username,
				da.memo_username,
				COUNT(ml.id) AS total_memos
			FROM
				public.memo_authors ma
			JOIN
				public.memo_logs ml ON ma.memo_log_id = ml.id
			JOIN
				public.discord_accounts da ON ma.discord_account_id = da.id
			WHERE
				ml.deleted_at IS NULL -- Exclude deleted memos if necessary
			GROUP BY
				da.discord_id, 
				da.discord_username,
				da.memo_username
		)
		SELECT
			discord_id,
			discord_username,
			memo_username,
			total_memos,
			RANK() OVER (ORDER BY total_memos DESC) AS rank
		FROM
			memo_count
		ORDER BY
			total_memos DESC
		LIMIT ?;
	`
	var topAuthors []model.DiscordAccountMemoRank
	return topAuthors, db.Raw(query, limit).Scan(&topAuthors).Error
}

```

# pkg/store/memolog/interface.go

```go
package memolog

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, b []model.MemoLog) ([]model.MemoLog, error)
	GetLimitByTimeRange(db *gorm.DB, start, end *time.Time, limit int) ([]model.MemoLog, error)
	List(db *gorm.DB, filter ListFilter) ([]model.MemoLog, error)
	GetRankByDiscordID(db *gorm.DB, discordID string) (*model.DiscordAccountMemoRank, error)
	ListNonAuthor(db *gorm.DB) ([]model.MemoLog, error)
	CreateMemoAuthor(db *gorm.DB, memoAuthor *model.MemoAuthor) error
	GetTopAuthors(db *gorm.DB, limit int) ([]model.DiscordAccountMemoRank, error)
}

```

# pkg/store/invoicenumbercaching/invoice_number_caching.go

```go
package invoicenumbercaching

import (
	"fmt"
	"strings"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) get(db *gorm.DB, key string) (next int, err error) {
	var maxNumber model.InvoiceNumberCaching
	err = db.Where(&model.InvoiceNumberCaching{Key: key}).Find(&maxNumber).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return 0, nil
		}
		return 0, err
	}
	return maxNumber.Number + 1, nil
}

func (s *store) GetNext(db *gorm.DB, key string) (int, error) {
	return s.get(db, key)
}

func (s *store) Set(db *gorm.DB, key string) error {
	var maxNumber model.InvoiceNumberCaching
	err := db.Where(&model.InvoiceNumberCaching{Key: key}).FirstOrCreate(&maxNumber).Error
	if err != nil {
		return err
	}

	maxNumber.Number++
	return db.Model(&maxNumber).Update("number", maxNumber.Number).Error
}

func (s *store) NextProjectTemplateNumber(db *gorm.DB, pid string) (next int, err error) {
	key := fmt.Sprintf("%s%s", model.InvoiceCachingKey.ProjectTemplateNumberPrefix, pid)
	return s.GetNext(db, key)
}

func (s *store) Decrease(db *gorm.DB, key string) error {
	var maxNumber model.InvoiceNumberCaching
	err := db.Where(&model.InvoiceNumberCaching{Key: key}).FirstOrCreate(&maxNumber).Error
	if err != nil {
		return err
	}

	maxNumber.Number--
	return db.Model(&maxNumber).Update("number", maxNumber.Number).Error
}

func (s *store) UpdateInvoiceCachingNumber(db *gorm.DB, issuedAt time.Time, alias string) error {
	year := issuedAt.Year()
	err := s.Set(db, fmt.Sprintf("%s_%d", model.InvoiceCachingKey.YearInvoiceNumberPrefix, year))
	if err != nil {
		return err
	}

	err = s.Set(db, fmt.Sprintf("%s_%s_%d", model.InvoiceCachingKey.ProjectInvoiceNumberPrefix, strings.ToUpper(alias), year))
	if err != nil {
		return err
	}

	return nil
}

func (s *store) UnCountErrorInvoice(db *gorm.DB, issuedAt time.Time) error {
	year := issuedAt.Year()
	return s.Decrease(db, fmt.Sprint(model.InvoiceCachingKey.YearInvoiceNumberPrefix, year))
}

```

# pkg/store/invoicenumbercaching/interface.go

```go
package invoicenumbercaching

import (
	"time"

	"gorm.io/gorm"
)

type IStore interface {
	Set(db *gorm.DB, key string) error
	Decrease(db *gorm.DB, key string) error
	GetNext(db *gorm.DB, key string) (int, error)

	// NextProjectTemplateNumber TODO: (hnh), might be we just need GetNext(key) fn to get these things ?
	NextProjectTemplateNumber(db *gorm.DB, pid string) (int, error)

	UpdateInvoiceCachingNumber(db *gorm.DB, issuedAt time.Time, projectAlias string) error
	UnCountErrorInvoice(db *gorm.DB, issuedAt time.Time) error
}

```

# pkg/store/invoice/invoice.go

```go
package invoice

import (
	"fmt"
	"strings"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One getNext invoice by id
func (s *store) One(db *gorm.DB, query *Query) (*model.Invoice, error) {
	var invoice *model.Invoice
	if query.ID != "" {
		db = db.Where("id = ?", query.ID)
	}
	if query.Number != "" {
		db = db.Where("number = ?", query.Number)
	}
	return invoice, db.
		Preload("Project").
		Preload("Project.Heads", "deleted_at IS NULL AND (end_date IS NULL OR end_date > now())").
		Preload("Project.Heads.Employee", "deleted_at IS NULL").
		Preload("Project.BankAccount", "deleted_at IS NULL").
		Preload("Project.BankAccount.Currency", "deleted_at IS NULL").
		Preload("Project.Organization", "deleted_at IS NULL").
		First(&invoice).Error
}

// IsExist check the existence of invoice
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM invoices WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

func (s *store) GetLatestInvoiceByProject(db *gorm.DB, projectID string) (*model.Invoice, error) {
	iv := model.Invoice{}
	return &iv, db.Where("project_id = ? AND status != ? AND status != ?", projectID, model.InvoiceStatusDraft, model.InvoiceStatusError).Order("created_at DESC").First(&iv).Error
}

// All getNext all invoice
func (s *store) All(db *gorm.DB, filter GetInvoicesFilter, pagination model.Pagination) ([]*model.Invoice, int64, error) {
	var total int64
	var invoices []*model.Invoice
	query := db.Table("invoices")

	if len(filter.ProjectIDs) > 0 {
		query = query.Where("project_id IN (?)", filter.ProjectIDs)
	}

	if len(filter.Statuses) > 0 {
		query = query.Where("status IN (?)", filter.Statuses)
	}

	err := db.Raw("SELECT COUNT(*) FROM (?) res", query).Scan(&total).Error
	if err != nil {
		return nil, 0, err
	}

	if filter.Preload {
		query = query.
			Preload("Bank").
			Preload("Bank.Currency").
			Preload("Project").
			Preload("Project.Client", "deleted_at IS NULL").
			Preload("Project.Client.Contacts", "deleted_at IS NULL").
			Preload("Project.CompanyInfo", "deleted_at IS NULL")
	}

	limit, offset := pagination.ToLimitOffset()
	if pagination.Page > 0 {
		query = query.Limit(limit)
	}

	return invoices, total, query.
		Limit(limit).
		Offset(offset).
		Find(&invoices).Error
}

// Delete delete 1 invoice by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.Invoice{}).Error
}

// Create creates a new invoice
func (s *store) Create(db *gorm.DB, e *model.Invoice) (invoice *model.Invoice, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, invoice *model.Invoice) (*model.Invoice, error) {
	return invoice, db.Model(&invoice).Where("id = ?", invoice.ID).Updates(&invoice).First(&invoice).Error
}

func (s *store) Save(db *gorm.DB, invoice *model.Invoice) (*model.Invoice, error) {
	return invoice, db.Save(&invoice).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Invoice, updatedFields ...string) (*model.Invoice, error) {
	invoice := model.Invoice{}
	return &invoice, db.Model(&invoice).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

func (s *store) GetNextInvoiceNumber(db *gorm.DB, year int, projectCode string) (*string, error) {
	yearComInvoiceKey := fmt.Sprintf("%s_%d", model.InvoiceCachingKey.YearInvoiceNumberPrefix, year)
	nextCompIvn, err := s.getNext(db, yearComInvoiceKey)
	if err != nil {
		return nil, err
	}

	key := fmt.Sprintf("%s_%s_%d", model.InvoiceCachingKey.ProjectInvoiceNumberPrefix, strings.ToUpper(projectCode), time.Now().Year())
	nextProjectIvn, err := s.getNext(db, key)
	if err != nil {
		return nil, err
	}
	invoiceNumberText := fmt.Sprintf("%d%d-%s-%03d",
		year,
		nextCompIvn,
		strings.ToUpper(projectCode),
		nextProjectIvn)

	return &invoiceNumberText, err
}

func (s *store) getNext(db *gorm.DB, key string) (next int, err error) {
	var maxNumber model.InvoiceNumberCaching
	err = db.Where(&model.InvoiceNumberCaching{Key: key}).Find(&maxNumber).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return 0, nil
		}
		return 0, err
	}
	return maxNumber.Number + 1, nil
}

```

# pkg/store/invoice/interface.go

```go
package invoice

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB, filter GetInvoicesFilter, pagination model.Pagination) (invoices []*model.Invoice, total int64, err error)
	Create(db *gorm.DB, e *model.Invoice) (invoice *model.Invoice, err error)
	Delete(db *gorm.DB, id string) (err error)
	GetLatestInvoiceByProject(db *gorm.DB, projectID string) (invoice *model.Invoice, err error)
	GetNextInvoiceNumber(db *gorm.DB, year int, projectCode string) (*string, error)
	IsExist(db *gorm.DB, id string) (exists bool, err error)
	One(db *gorm.DB, query *Query) (invoice *model.Invoice, err error)
	Save(db *gorm.DB, e *model.Invoice) (invoice *model.Invoice, err error)
	Update(db *gorm.DB, invoice *model.Invoice) (a *model.Invoice, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, invoice model.Invoice, updatedFields ...string) (a *model.Invoice, err error)
}

// Query present invoice query from user
type Query struct {
	ID          string
	Alias       string
	Month       int64
	Year        int64
	ProjectName string
	Statuses    []model.InvoiceStatus
	Number      string
}

type GetInvoicesFilter struct {
	Preload    bool
	ProjectIDs []string
	Statuses   []string
}

```

# pkg/store/icytransaction/interface.go

```go
package icytransaction

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, model []model.IcyTransaction) error
}

```

# pkg/store/icytransaction/icy_transaction.go

```go
package icytransaction

import (
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) Create(db *gorm.DB, model []model.IcyTransaction) error {
	return db.Clauses(clause.OnConflict{
		Columns: []clause.Column{
			{Name: "sender"},
			{Name: "target"},
			{Name: "category"},
			{Name: "amount"},
			{Name: "txn_time"},
		},
		UpdateAll: true,
	}).Create(&model).Error
}

```

# pkg/store/feedbackevent/interface.go

```go
package feedbackevent

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	IsExist(db *gorm.DB, id string) (bool, error)
	One(db *gorm.DB, id string, preload bool) (event *model.FeedbackEvent, err error)
	OneByTypeInTimeRange(db *gorm.DB, eventType model.EventType, eventSubtype model.EventSubtype, from, to *time.Time) (*model.FeedbackEvent, error)
	GetBySubtype(db *gorm.DB, subtype string, pagination model.Pagination) (events []*model.FeedbackEvent, total int64, err error)
	Create(db *gorm.DB, feedbackEvent *model.FeedbackEvent) (*model.FeedbackEvent, error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.FeedbackEvent, updatedFields ...string) (event *model.FeedbackEvent, err error)
	DeleteByID(db *gorm.DB, id string) error
	GetLatestEventByType(db *gorm.DB, eventType model.EventType, eventSubtype model.EventSubtype, num int) ([]*model.FeedbackEvent, error)
}

```

# pkg/store/feedbackevent/feedback_event.go

```go
package feedbackevent

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// IsExist check the existence of FeedbackEvent
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM feedback_events WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

// GetBySubtype return list of FeedbackEvent by subtype
func (s *store) GetBySubtype(db *gorm.DB, subtype string, pagination model.Pagination) ([]*model.FeedbackEvent, int64, error) {
	var events []*model.FeedbackEvent
	var total int64

	// query for total
	query := db.Table("feedback_events").
		Where("subtype = ? AND deleted_at IS NULL", subtype).
		Count(&total).
		Order(pagination.Sort)

	// add pagination
	if pagination.Sort == "" {
		query = query.Order("created_at DESC")
	}

	limit, offset := pagination.ToLimitOffset()
	if pagination.Page > 0 {
		query = query.Limit(limit)
	}

	query = query.Offset(offset)

	return events, total, query.
		Preload("Employee", "deleted_at IS NULL").
		Preload("Topics", "deleted_at IS NULL").
		Preload("Topics.EmployeeEventReviewers", "deleted_at IS NULL").
		Find(&events).Error
}

// Create create new one
func (s *store) Create(db *gorm.DB, feedbackEvent *model.FeedbackEvent) (*model.FeedbackEvent, error) {
	return feedbackEvent, db.Create(&feedbackEvent).Error
}

// One get 1 by id
func (s *store) One(db *gorm.DB, id string, preload bool) (*model.FeedbackEvent, error) {
	var event *model.FeedbackEvent

	query := db.Where("id = ?", id)
	if preload {
		query = query.Preload("Employee", "deleted_at IS NULL").Preload("Topics", "deleted_at IS NULL")
	}

	return event, query.First(&event).Error
}

// OneByTypeInTimeRange get 1 by type in time range
func (s *store) OneByTypeInTimeRange(db *gorm.DB, eventType model.EventType, eventSubtype model.EventSubtype, from, to *time.Time) (*model.FeedbackEvent, error) {
	var event *model.FeedbackEvent
	return event, db.Where("type = ?", eventType).
		Where("subtype = ?", eventSubtype).
		Where("start_date <= ? AND end_date >= ?", to, from).
		First(&event).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.FeedbackEvent, updatedFields ...string) (*model.FeedbackEvent, error) {
	feedbackEvent := model.FeedbackEvent{}
	return &feedbackEvent, db.Model(&feedbackEvent).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// DeleteByID delete FeedbackEvent by id
func (s *store) DeleteByID(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.FeedbackEvent{}).Error
}

// GetLatestEventByType get FeedbackEvent by type with limit
func (s *store) GetLatestEventByType(db *gorm.DB, eventType model.EventType, eventSubtype model.EventSubtype, num int) ([]*model.FeedbackEvent, error) {
	var feedbackEvents []*model.FeedbackEvent
	return feedbackEvents, db.Where("type = ? AND subtype = ?", eventType, eventSubtype).Order("start_date DESC").Limit(num).Find(&feedbackEvents).Error
}

```

# pkg/store/icydistribution/interface.go

```go
package icydistribution

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

// IStore is an interface for icydistribution store
type IStore interface {
	GetWeekly(db *gorm.DB) ([]model.IcyDistribution, error)
}

```

# pkg/store/icydistribution/icy_distribution.go

```go
package icydistribution

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

// New implements IStore.
func New() IStore {
	return &store{}
}

// GetWeekly implements IStore.
func (*store) GetWeekly(db *gorm.DB) ([]model.IcyDistribution, error) {
	res := []model.IcyDistribution{}
	return res, db.Raw(`SELECT
	Team,
	SUM(Amount) AS Total_Amount
FROM
	vw_icy_earning_by_team_weekly
WHERE
	Period >= to_char(date_trunc('week', CURRENT_DATE), 'yyyy-mm-dd')
	AND Period <= to_char(date_trunc('week', CURRENT_DATE) + '6 days'::interval, 'yyyy-mm-dd')
GROUP BY
	Team
ORDER BY
	Total_Amount DESC;`).Find(&res).Error
}

```

# pkg/store/eventspeaker/interface.go

```go
package eventspeaker

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, s *model.EventSpeaker) (ep *model.EventSpeaker, err error)
	DeleteAllByEventID(db *gorm.DB, eventID string) error
	List(db *gorm.DB, discordID string, after *time.Time, topic string) ([]model.EventSpeaker, error)
	GetSpeakerStats(db *gorm.DB, discordID string, after *time.Time, topic string) (SpeakerStats, error)
	Count(db *gorm.DB, discordID string, after *time.Time, topic string) (int64, error)
	GetLeaderboard(db *gorm.DB, after *time.Time, limit int, topic string) ([]model.OgifLeaderboardRecord, error)
}

```

# pkg/store/eventspeaker/event_speaker.go

```go
package eventspeaker

import (
	"time"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create creates a new e
func (s *store) Create(db *gorm.DB, e *model.EventSpeaker) (*model.EventSpeaker, error) {
	return e, db.Clauses(
		clause.OnConflict{
			Columns:   []clause.Column{{Name: "topic"}},
			DoNothing: true,
		},
	).Create(e).Error
}

// DeleteAllByEventID deletes all event speakers by event id
func (s *store) DeleteAllByEventID(db *gorm.DB, eventID string) error {
	return db.Table("event_speakers").Where("event_id = ?", eventID).Delete(&model.EventSpeaker{}).Error
}

// List returns a lit of event speaker with loaded event info
func (s *store) List(db *gorm.DB, discordID string, after *time.Time, topic string) ([]model.EventSpeaker, error) {
	var eventSpeakers []model.EventSpeaker
	query := db.Table("event_speakers").
		Joins("JOIN discord_accounts ON event_speakers.discord_account_id = discord_accounts.id").
		Joins("JOIN events ON events.id = event_speakers.event_id").
		Order("events.date DESC")

	if after != nil {
		query = query.Where("events.date > ?", after)
	}

	if topic != "" {
		query = query.Where("LOWER(event_speakers.topic) LIKE LOWER(?)", "%"+topic+"%")
	}

	if discordID != "" {
		query = query.Where("discord_accounts.discord_id = ?", discordID)
	}

	err := query.Preload("Event").
		Find(&eventSpeakers).Error
	if err != nil {
		return nil, err
	}
	return eventSpeakers, nil
}

// Count returns the total count of event speakers with the same filtering criteria as List
func (s *store) Count(db *gorm.DB, discordID string, after *time.Time, topic string) (int64, error) {
	var count int64
	query := db.Table("event_speakers").
		Joins("JOIN discord_accounts ON event_speakers.discord_account_id = discord_accounts.id").
		Joins("JOIN events ON events.id = event_speakers.event_id")

	if after != nil {
		query = query.Where("events.date > ?", after)
	}

	if topic != "" {
		query = query.Where("LOWER(event_speakers.topic) LIKE LOWER(?)", "%"+topic+"%")
	}

	if discordID != "" {
		query = query.Where("discord_accounts.discord_id = ?", discordID)
	}

	err := query.Count(&count).Error
	if err != nil {
		return 0, err
	}
	return count, nil
}

// SpeakerStats
type SpeakerStats struct {
	TotalSpeakCount int64 `gorm:"column:total_speak_count"`
	SpeakRank       int64 `gorm:"column:speak_rank"`
}

// GetSpeakerStats returns the total speak count and rank for a given discord_id
func (s *store) GetSpeakerStats(db *gorm.DB, discordID string, after *time.Time, topic string) (SpeakerStats, error) {
	var stats SpeakerStats

	query := db.Table("event_speakers").
		Select("discord_accounts.discord_id, COUNT(event_speakers.topic) as total_speak_count, RANK() OVER (ORDER BY COUNT(event_speakers.topic) DESC) as speak_rank").
		Joins("JOIN discord_accounts ON event_speakers.discord_account_id = discord_accounts.id").
		Joins("JOIN events ON events.id = event_speakers.event_id")

	if after != nil {
		query = query.Where("events.date > ?", after)
	}
	if topic != "" {
		query = query.Where("LOWER(event_speakers.topic) LIKE LOWER(?)", "%"+topic+"%")
	}

	query = query.Group("discord_accounts.discord_id")

	err := db.Table("(?) as speaker_counts", query).
		Select("total_speak_count, speak_rank").
		Where("discord_id = ?", discordID).
		Scan(&stats).Error

	if err != nil {
		return SpeakerStats{}, err
	}

	return stats, nil
}

// GetLeaderboard returns the top speakers ordered by the count of events with a topic containing 'ogif' (case insensitive)
func (s *store) GetLeaderboard(db *gorm.DB, after *time.Time, limit int, topic string) ([]model.OgifLeaderboardRecord, error) {
	leaderboard := make([]model.OgifLeaderboardRecord, 0)

	query := db.Table("event_speakers").
		Select("discord_accounts.discord_id, COUNT(DISTINCT event_speakers.event_id) as speak_count").
		Joins("JOIN discord_accounts ON event_speakers.discord_account_id = discord_accounts.id").
		Joins("JOIN events ON events.id = event_speakers.event_id").
		Joins("LEFT JOIN employees ON employees.discord_account_id = discord_accounts.id").
		Where("LOWER(event_speakers.topic) LIKE LOWER(?)", "%"+topic+"%")

	if after != nil {
		query = query.Where("events.date > ?", after)
	}

	err := query.Group("discord_accounts.discord_id").
		Order("speak_count DESC").
		Limit(limit).
		Scan(&leaderboard).Error

	if err != nil {
		return nil, err
	}

	return leaderboard, nil
}

```

# pkg/store/engagementsrollup/interface.go

```go
package engagementsrollup

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type IStore interface {
	Upsert(db *gorm.DB, record *model.EngagementsRollup) (*model.EngagementsRollup, error)
	GetLastMessageID(db *gorm.DB, channelID string) (string, error)
}

```

# pkg/store/engagementsrollup/engagements_rollup.go

```go
package engagementsrollup

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) Upsert(db *gorm.DB, record *model.EngagementsRollup) (*model.EngagementsRollup, error) {
	return record, db.
		Table("engagements_rollup").
		Clauses(
			clause.OnConflict{
				Columns: []clause.Column{
					{Name: "discord_user_id"},
					{Name: "channel_id"},
				},
				DoUpdates: clause.Assignments(
					map[string]interface{}{
						// COALESCE is needed since anything can be null
						"message_count":   gorm.Expr("engagements_rollup.message_count + excluded.message_count"),
						"reaction_count":  gorm.Expr("engagements_rollup.reaction_count + excluded.reaction_count"),
						"last_message_id": gorm.Expr("GREATEST(engagements_rollup.last_message_id, excluded.last_message_id)"),
					},
				),
			},
		).
		Create(record).
		Error
}

func (s *store) GetLastMessageID(db *gorm.DB, channelID string) (string, error) {
	lastMessageID := ""
	err := db.
		Raw(
			"SELECT COALESCE(MAX(last_message_id), 0) FROM engagements_rollup WHERE channel_id = ?",
			channelID,
		).
		Scan(&lastMessageID).
		Error
	return lastMessageID, err
}

```

# pkg/store/employeestack/interface.go

```go
package employeestack

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, employeeStack *model.EmployeeStack) (*model.EmployeeStack, error)
	DeleteByEmployeeID(db *gorm.DB, employeeID string) error
}

```

# pkg/store/employeestack/employee_stack.go

```go
package employeestack

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create create new one by id
func (s *store) Create(db *gorm.DB, employeeStack *model.EmployeeStack) (*model.EmployeeStack, error) {
	return employeeStack, db.Create(&employeeStack).Error
}

// DeleteByEmployeeID delete many EmployeeStaks by employeeID
func (s *store) DeleteByEmployeeID(db *gorm.DB, employeeID string) error {
	return db.Unscoped().Where("employee_id = ?", employeeID).Delete(&model.EmployeeStack{}).Error
}

```

# pkg/store/expense/interface.go

```go
package expense

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, e *model.Expense) (*model.Expense, error)
	Delete(db *gorm.DB, e *model.Expense) (*model.Expense, error)
	Update(db *gorm.DB, e *model.Expense) (*model.Expense, error)
	GetValuation(db *gorm.DB, y int) (*model.CurrencyView, error)
	GetByQuery(db *gorm.DB, q *ExpenseQuery) (*model.Expense, error)
}

type ExpenseQuery struct {
	BasecampID int
}

```

# pkg/store/expense/expense.go

```go
package expense

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct {
}

func New() IStore {
	return &store{}
}

func (s *store) Create(db *gorm.DB, e *model.Expense) (*model.Expense, error) {
	return e, db.Create(&e).Error
}

func (s *store) Delete(db *gorm.DB, e *model.Expense) (*model.Expense, error) {
	return e, db.Delete(&e).Error
}

func (s *store) Update(db *gorm.DB, e *model.Expense) (*model.Expense, error) {
	return e, db.Model(&model.Expense{}).Where("id = ?", e.ID).Updates(&e).First(&e).Error
}

func (s *store) GetValuation(db *gorm.DB, y int) (*model.CurrencyView, error) {
	res := &model.CurrencyView{}
	return res, db.Raw("select * from vw_expense where year = ?", y).Find(&res).Error
}

func (s *store) GetByQuery(db *gorm.DB, q *ExpenseQuery) (*model.Expense, error) {
	e := &model.Expense{}
	if q.BasecampID != 0 {
		db = db.Where("basecamp_id = ?", q.BasecampID)
	}

	return e, db.First(e).Error
}

```

# pkg/store/employeerole/interface.go

```go
package employeerole

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, er *model.EmployeeRole) (employeeRole *model.EmployeeRole, err error)
	HardDeleteByEmployeeID(db *gorm.DB, employeeID string) (err error)
}

```

# pkg/store/employeerole/employee_role.go

```go
package employeerole

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct {
}

func New() IStore {
	return &store{}
}

// Create using fore create new Employee role
func (s *store) Create(db *gorm.DB, er *model.EmployeeRole) (*model.EmployeeRole, error) {
	return er, db.Create(&er).Error
}

// HardDeleteByEmployeeID hard delete employeeRole by employeeID
func (s *store) HardDeleteByEmployeeID(db *gorm.DB, employeeID string) error {
	return db.Unscoped().Where("employee_id = ?", employeeID).Delete(&model.EmployeeRole{}).Error
}

```

# pkg/store/employeeposition/interface.go

```go
package employeeposition

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, employeePosition *model.EmployeePosition) (*model.EmployeePosition, error)
	DeleteByEmployeeID(db *gorm.DB, employeeID string) (err error)
}

```

# pkg/store/employeeposition/employee_position.go

```go
package employeeposition

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create create new one by id
func (s *store) Create(db *gorm.DB, employeePosition *model.EmployeePosition) (*model.EmployeePosition, error) {
	return employeePosition, db.Create(&employeePosition).Error
}

// Delete delete many EmployeePositions by employeeID
func (s *store) DeleteByEmployeeID(db *gorm.DB, employeeID string) error {
	return db.Unscoped().Where("employee_id = ?", employeeID).Delete(&model.EmployeePosition{}).Error
}

```

# pkg/store/employeeinvitation/interface.go

```go
package employeeinvitation

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, employeeOrganization *model.EmployeeInvitation) (*model.EmployeeInvitation, error)
	OneByEmployeeID(db *gorm.DB, employeeID string) (*model.EmployeeInvitation, error)
	Save(db *gorm.DB, employeeInvitation *model.EmployeeInvitation) error
}

```

# pkg/store/employeeinvitation/employee_invitation.go

```go
package employeeinvitation

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create generate new one
func (s *store) Create(db *gorm.DB, employeeInvitation *model.EmployeeInvitation) (*model.EmployeeInvitation, error) {
	return employeeInvitation, db.Create(&employeeInvitation).Error
}

// OneByEmployeeID get one by employeeID
func (s *store) OneByEmployeeID(db *gorm.DB, employeeID string) (*model.EmployeeInvitation, error) {
	var rs *model.EmployeeInvitation
	return rs, db.Preload("Employee").
		Where("employee_id = ?", employeeID).First(&rs).Error
}

func (s *store) Save(db *gorm.DB, employeeInvitation *model.EmployeeInvitation) error {
	return db.Save(&employeeInvitation).Error
}

```

# pkg/store/employeeorganization/interface.go

```go
package employeeorganization

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, employeeOrganization *model.EmployeeOrganization) (*model.EmployeeOrganization, error)
	DeleteByEmployeeID(db *gorm.DB, employeeID string) (err error)
}

```

# pkg/store/employeeorganization/employee_organization.go

```go
package employeeorganization

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create create new one by id
func (s *store) Create(db *gorm.DB, employeeOrganization *model.EmployeeOrganization) (*model.EmployeeOrganization, error) {
	return employeeOrganization, db.Create(&employeeOrganization).Error
}

// Delete delete many EmployeePositions by employeeID
func (s *store) DeleteByEmployeeID(db *gorm.DB, employeeID string) error {
	return db.Unscoped().Where("employee_id = ?", employeeID).Delete(&model.EmployeeOrganization{}).Error
}

```

# pkg/store/employeeeventtopic/request.go

```go
package employeeeventtopic

type GetByEmployeeIDInput struct {
	Status string
}

type GetByEventIDInput struct {
	EventID  string
	Keyword  string
	Status   string
	Projects []string
	Preload  bool
	Paging   bool
}

```

# pkg/store/employeeeventtopic/interface.go

```go
package employeeeventtopic

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string, eventID string, preload bool) (topic *model.EmployeeEventTopic, err error)
	All(db *gorm.DB, input GetByEventIDInput, pagination *model.Pagination) (topics []*model.EmployeeEventTopic, total int64, err error)
	GetByEmployeeID(db *gorm.DB, employeeID string, input GetByEmployeeIDInput, pagination model.Pagination) (eTopics []*model.EmployeeEventTopic, total int64, err error)
	BatchCreate(db *gorm.DB, employeeEventTopics []model.EmployeeEventTopic) ([]model.EmployeeEventTopic, error)
	DeleteByEventID(db *gorm.DB, eventID string) error
	DeleteByID(db *gorm.DB, ID string) error
	CountUnreadFeedbackByEmployeeID(db *gorm.DB, employeeID string) (count int64, err error)
}

```

# pkg/store/employeeeventtopic/employee_event_topic.go

```go
package employeeeventtopic

import (
	"fmt"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get topic by id
func (s *store) One(db *gorm.DB, id string, eventID string, preload bool) (*model.EmployeeEventTopic, error) {
	query := db.Where("id = ? AND event_id = ?", id, eventID)

	if preload {
		query = query.
			Preload("Employee", "deleted_at IS NULL").
			Preload("Event", "deleted_at IS NULL").
			Preload("EmployeeEventReviewers", "deleted_at IS NULL").
			Preload("EmployeeEventReviewers.Reviewer", "deleted_at IS NULL")
	}

	var topic *model.EmployeeEventTopic
	return topic, query.First(&topic).Error
}

// GetByEmployeeID return list of EmployeeEventTopic by employeeID and pagination
func (s *store) GetByEmployeeID(db *gorm.DB, employeeID string, input GetByEmployeeIDInput, pagination model.Pagination) ([]*model.EmployeeEventTopic, int64, error) {
	var eTopics []*model.EmployeeEventTopic
	var total int64

	query := db.
		Table("employee_event_topics").
		Joins("JOIN employee_event_reviewers eer ON employee_event_topics.id = eer.employee_event_topic_id AND eer.deleted_at IS NULL").
		Joins("JOIN feedback_events fe ON employee_event_topics.event_id = fe.id").
		Where("((eer.reviewer_id = ? AND fe.type = ?) OR (employee_event_topics.employee_id = ? AND fe.type = ?)) AND eer.author_status <> ? AND eer.reviewer_status <> ?",
			employeeID,
			model.EventTypeSurvey,
			employeeID,
			model.EventTypeFeedback,
			model.EventAuthorStatusDraft,
			model.EventReviewerStatusNone,
		)

	if input.Status != "" {
		query = query.Where("eer.reviewer_status = ?", input.Status)
	}

	query = query.Count(&total)
	if pagination.Sort != "" {
		query = query.Order(pagination.Sort)
	} else {
		query = query.Order("created_at DESC")
	}

	limit, offset := pagination.ToLimitOffset()
	if pagination.Page > 0 {
		query = query.Limit(limit)
	}

	query = query.Offset(offset)

	return eTopics, total, query.
		Preload("Event", "deleted_at IS NULL").
		Preload("Event.Employee", "deleted_at IS NULL").
		Preload("EmployeeEventReviewers", func(db *gorm.DB) *gorm.DB {
			return db.Joins("JOIN employee_event_topics  ON employee_event_topics.id = employee_event_reviewers.employee_event_topic_id").
				Joins("JOIN feedback_events fe ON employee_event_topics.event_id = fe.id").
				Where("((employee_event_reviewers.reviewer_id = ? AND fe.type = ?) OR (employee_event_topics.employee_id = ? AND fe.type = ?)) AND employee_event_reviewers.reviewer_status <> ?",
					employeeID,
					model.EventTypeSurvey,
					employeeID,
					model.EventTypeFeedback,
					model.EventReviewerStatusNone,
				)
		}).
		Preload("EmployeeEventReviewers.Reviewer", "deleted_at IS NULL").
		Find(&eTopics).Error
}

// CountUnreadFeedbackByEmployeeID return total of unread inbox of the employee
func (s *store) CountUnreadFeedbackByEmployeeID(db *gorm.DB, employeeID string) (int64, error) {
	var total int64

	query := db.
		Table("employee_event_topics").
		Joins("JOIN employee_event_reviewers eer ON employee_event_topics.id = eer.employee_event_topic_id AND eer.deleted_at IS NULL").
		Joins("JOIN feedback_events fe ON employee_event_topics.event_id = fe.id").
		Where("((eer.reviewer_id = ? AND fe.type = ?) OR (employee_event_topics.employee_id = ? AND fe.type = ?)) AND eer.author_status <> ? AND eer.reviewer_status <> ? AND eer.is_read = false",
			employeeID,
			model.EventTypeSurvey,
			employeeID,
			model.EventTypeFeedback,
			model.EventAuthorStatusDraft,
			model.EventReviewerStatusNone,
		)

	return total, query.Count(&total).Error
}

// All return list of EmployeeEventTopic by input and pagination
func (s *store) All(db *gorm.DB, input GetByEventIDInput, pagination *model.Pagination) ([]*model.EmployeeEventTopic, int64, error) {
	var topics []*model.EmployeeEventTopic
	var total int64

	query := db.Table("employee_event_topics")
	if input.Keyword != "" {
		query = query.Where("title ILIKE ?", fmt.Sprintf("%%%s%%", input.Keyword))
	}

	if input.Status != "" {
		query = query.Where(`employee_event_topics.id IN (
			SELECT eer.employee_event_topic_id
			FROM employee_event_reviewers eer
			WHERE eer.event_id = ? AND eer.author_status = ?
		)`, input.EventID, input.Status)
	}

	if len(input.Projects) > 0 {
		query = query.Where(`project_id IN (
			SELECT p.id 
			FROM projects p
			WHERE p.code IN ? AND p.deleted_at IS NULL
		)`, input.Projects)
	}

	query = query.Where("event_id = ? AND deleted_at IS NULL", input.EventID).Count(&total)

	// sort by comments
	query = query.Joins(`JOIN (
			SELECT eet.id, COUNT(*) AS comments
			FROM employee_event_topics eet
				LEFT JOIN employee_event_reviewers eer ON eet.id = eer.employee_event_topic_id AND eer.reviewer_status = ?
				LEFT JOIN employee_event_questions eeq ON eer.id = eeq.employee_event_reviewer_id
			WHERE eet.deleted_at IS NULL
				AND eer.deleted_at IS NULL
				AND eeq.deleted_at IS NULL
			GROUP BY eet.id
		) as eet_comments ON employee_event_topics.id = eet_comments.id
	`, model.EventReviewerStatusDone)

	if pagination != nil && pagination.Sort != "" {
		query = query.Order(pagination.Sort)
	} else {
		query = query.Order("eet_comments.comments")
	}

	if input.Paging {
		limit, offset := pagination.ToLimitOffset()
		if pagination.Page > 0 {
			query = query.Limit(limit)
		}

		query = query.Offset(offset)
	}

	if input.Preload {
		query = query.
			Preload("Event", "deleted_at IS NULL").
			Preload("Employee", "deleted_at IS NULL").
			Preload("Project", "deleted_at IS NULL").
			Preload("EmployeeEventReviewers", "deleted_at IS NULL").
			Preload("EmployeeEventReviewers.Reviewer", "deleted_at IS NULL").
			Preload("EmployeeEventReviewers.EmployeeEventQuestions", "deleted_at IS NULL")
	}

	return topics, total, query.Find(&topics).Error
}

// BatchCreate create new one
func (s *store) BatchCreate(db *gorm.DB, employeeEventTopics []model.EmployeeEventTopic) ([]model.EmployeeEventTopic, error) {
	return employeeEventTopics, db.Create(&employeeEventTopics).Error
}

// DeleteByEventID delete by Event ID
func (s *store) DeleteByEventID(db *gorm.DB, eventID string) error {
	return db.Where("event_id = ?", eventID).Delete(&model.EmployeeEventTopic{}).Error
}

// DeleteByID delete by topic ID
func (s *store) DeleteByID(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.EmployeeEventTopic{}).Error
}

```

# pkg/store/employeeeventreviewer/interface.go

```go
package employeeeventreviewer

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (employeeeventreviewer *model.EmployeeEventReviewer, err error)
	OneByReviewerID(db *gorm.DB, reviewerID string, topicID string) (*model.EmployeeEventReviewer, error)
	GetByTopicID(db *gorm.DB, topicID string) ([]*model.EmployeeEventReviewer, error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.EmployeeEventReviewer, updatedFields ...string) (employeeEventReviewer *model.EmployeeEventReviewer, err error)
	BatchCreate(db *gorm.DB, employeeEventReviewers []model.EmployeeEventReviewer) ([]model.EmployeeEventReviewer, error)
	Create(tx *gorm.DB, eventReviewer *model.EmployeeEventReviewer) (employeeEventReviewer *model.EmployeeEventReviewer, err error)
	DeleteByEventID(db *gorm.DB, eventID string) (err error)
	DeleteByTopicID(db *gorm.DB, topicID string) (err error)
	DeleteByID(db *gorm.DB, id string) (err error)
}

```

# pkg/store/employeeeventreviewer/employee_event_reviewer.go

```go
package employeeeventreviewer

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get one record by ID
func (s *store) One(db *gorm.DB, id string) (*model.EmployeeEventReviewer, error) {
	var eer *model.EmployeeEventReviewer
	return eer, db.Where("id = ?", id).
		Preload("Reviewer", "deleted_at IS NULL").
		First(&eer).Error
}

// OneByReviewerID get one record by reviewerID and topicID
func (s *store) OneByReviewerID(db *gorm.DB, reviewerID string, topicID string) (*model.EmployeeEventReviewer, error) {
	var eer *model.EmployeeEventReviewer
	return eer, db.Where("reviewer_id = ? AND employee_event_topic_id = ? ", reviewerID, topicID).First(&eer).Error
}

// GetByTopicID get record by topicID
func (s *store) GetByTopicID(db *gorm.DB, topicID string) ([]*model.EmployeeEventReviewer, error) {
	var employeeeventreviewer []*model.EmployeeEventReviewer
	return employeeeventreviewer, db.Where("employee_event_topic_id = ? ", topicID).Find(&employeeeventreviewer).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.EmployeeEventReviewer, updatedFields ...string) (*model.EmployeeEventReviewer, error) {
	eventReviewer := model.EmployeeEventReviewer{}
	return &eventReviewer, db.Model(&eventReviewer).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// BatchCreate create a list of event reviewer
func (s *store) BatchCreate(db *gorm.DB, eers []model.EmployeeEventReviewer) ([]model.EmployeeEventReviewer, error) {
	return eers, db.Create(&eers).Error
}

// Create a employee event reviewer
func (s *store) Create(tx *gorm.DB, eer *model.EmployeeEventReviewer) (*model.EmployeeEventReviewer, error) {
	return eer, tx.Create(&eer).Error
}

// DeleteByEventID delete EmployeeEventReviewer by eventID
func (s *store) DeleteByEventID(db *gorm.DB, eventID string) error {
	return db.Where("event_id = ?", eventID).Delete(&model.EmployeeEventReviewer{}).Error
}

// DeleteByTopicID delete EmployeeEventReviewer by topicID
func (s *store) DeleteByTopicID(db *gorm.DB, topicID string) error {
	return db.Where("employee_event_topic_id = ?", topicID).Delete(&model.EmployeeEventReviewer{}).Error
}

// DeleteByID delete EmployeeEventReviewer by id
func (s *store) DeleteByID(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.EmployeeEventReviewer{}).Error
}

```

# pkg/store/employeeeventquestion/request.go

```go
package employeeeventquestion

type BasicEventQuestion struct {
	EventQuestionID string
	Answer          string
	Note            string
}

```

# pkg/store/employeeeventquestion/interface.go

```go
package employeeeventquestion

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	GetByEventReviewerID(db *gorm.DB, reviewID string) (eventQuestions []*model.EmployeeEventQuestion, err error)
	UpdateAnswers(db *gorm.DB, data BasicEventQuestion) (err error)
	BatchCreate(db *gorm.DB, employeeEventQuestions []model.EmployeeEventQuestion) ([]model.EmployeeEventQuestion, error)
	Create(tx *gorm.DB, eventQuestion *model.EmployeeEventQuestion) (employeeEventQuestion *model.EmployeeEventQuestion, err error)
	DeleteByEventID(db *gorm.DB, eventID string) error
	DeleteByEventReviewerIDList(db *gorm.DB, reviewerIDList []string) error
	DeleteByEventReviewerID(db *gorm.DB, eventReviewerID string) error
	CountLikertScaleByEventIDAndDomain(db *gorm.DB, eventID string, domain string) (*model.LikertScaleCount, error)
	GetAverageAnswerEngagementByTime(db *gorm.DB, times []time.Time) ([]*model.StatisticEngagementDashboard, error)
	GetAverageAnswerEngagementByFilter(db *gorm.DB, filter model.EngagementDashboardFilter, time *time.Time) ([]*model.StatisticEngagementDashboard, error)
}

```

# pkg/store/employeeeventquestion/employee_event_question.go

```go
package employeeeventquestion

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// GetByEventReviewerID return list EmployeeEventQuestion by eventReviewerID
func (s *store) GetByEventReviewerID(db *gorm.DB, reviewID string) ([]*model.EmployeeEventQuestion, error) {
	var eventQuestions []*model.EmployeeEventQuestion
	return eventQuestions, db.Where("employee_event_reviewer_id = ?", reviewID).Order("\"order\"").Find(&eventQuestions).Error
}

// UpdateAnswers update answer and note by table id
func (s *store) UpdateAnswers(db *gorm.DB, data BasicEventQuestion) error {
	return db.Table("employee_event_questions").
		Where("id = ?", data.EventQuestionID).
		Updates(map[string]interface{}{"answer": data.Answer, "note": data.Note}).Error
}

// Create create new one
func (s *store) BatchCreate(db *gorm.DB, employeeEventQuestions []model.EmployeeEventQuestion) ([]model.EmployeeEventQuestion, error) {
	return employeeEventQuestions, db.Create(&employeeEventQuestions).Error
}

// Create a employee event question
func (s *store) Create(tx *gorm.DB, eventQuestion *model.EmployeeEventQuestion) (*model.EmployeeEventQuestion, error) {
	return eventQuestion, tx.Create(&eventQuestion).Error
}

// DeleteByEventID delete EmployeeEventQuestion by eventID
func (s *store) DeleteByEventID(db *gorm.DB, eventID string) error {
	return db.Where("event_id = ?", eventID).Delete(&model.EmployeeEventQuestion{}).Error
}

// DeleteByEventReviewerIDList delete EmployeeEventQuestion by reviewerID list
func (s *store) DeleteByEventReviewerIDList(db *gorm.DB, reviewerIDList []string) error {
	return db.Where("employee_event_reviewer_id IN ?", reviewerIDList).Delete(&model.EmployeeEventQuestion{}).Error
}

// DeleteByEventReviewerID delete EmployeeEventQuestion by eventReviewerID
func (s *store) DeleteByEventReviewerID(db *gorm.DB, eventReviewerID string) error {
	return db.Where("employee_event_reviewer_id = ?", eventReviewerID).Delete(&model.EmployeeEventQuestion{}).Error
}

// CountLikertScaleByEventIDAndDomain return LikertScaleCount by eventID and domain
func (s *store) CountLikertScaleByEventIDAndDomain(db *gorm.DB, eventID string, domain string) (*model.LikertScaleCount, error) {
	var count *model.LikertScaleCount

	query := db.Raw(`
	WITH q0 AS (
			SELECT *
			FROM employee_event_questions
			WHERE event_id = ? AND domain = ? AND deleted_at IS NULL
		),
		q1 AS (
			SELECT COUNT(*) AS "strongly_disagree"
			FROM q0
			WHERE q0.answer = ?
		), 
		q2 AS (
			SELECT COUNT(*) AS disagree
			FROM q0
			WHERE q0.answer = ?
		), 
		q3 AS (
			SELECT COUNT(*) AS mixed
			FROM q0
			WHERE q0.answer = ?
			), 
		q4 AS (
			SELECT COUNT(*) AS agree
			FROM q0
			WHERE q0.answer = ?
		), 
		q5 AS (
			SELECT COUNT(*) AS "strongly_agree"
			FROM q0
			WHERE q0.answer = ?
		)
		SELECT *
		FROM q1, q2, q3, q4, q5
	`,
		eventID,
		domain,
		model.AgreementLevelMap[model.AgreementLevelStronglyDisagree],
		model.AgreementLevelMap[model.AgreementLevelDisagree],
		model.AgreementLevelMap[model.AgreementLevelMixed],
		model.AgreementLevelMap[model.AgreementLevelAgree],
		model.AgreementLevelMap[model.AgreementLevelStronglyAgree])

	return count, query.Scan(&count).Error
}

// GetAverageAnswerEngagementByTime return average answer of engagement dashboard by time
func (s *store) GetAverageAnswerEngagementByTime(db *gorm.DB, times []time.Time) ([]*model.StatisticEngagementDashboard, error) {
	var result []*model.StatisticEngagementDashboard

	query := db.Table("feedback_events fe").
		Select("DISTINCT q.content, eq.question_id, fe.title, fe.start_date, avg( CASE WHEN answer = '' THEN 0 ELSE cast(answer AS DECIMAL) END) AS point").
		Joins("JOIN employee_event_questions eq ON fe.id = eq.event_id").
		Joins("JOIN employee_event_reviewers er ON eq.employee_event_reviewer_id = er.id").
		Joins("JOIN questions q ON eq.question_id = q.id").
		Where("eq.domain = 'engagement'").
		Where("er.reviewer_status = 'done' AND is_forced_done = FALSE").
		Where("fe.start_date IN ?", times).
		Group("q.content, eq.question_id, fe.title, fe.start_date").
		Order("q.content asc")

	return result, query.Find(&result).Error
}

// GetAverageAnswerEngagementByFilter return average answer of engagement dashboard by filter
func (s *store) GetAverageAnswerEngagementByFilter(db *gorm.DB, filter model.EngagementDashboardFilter, time *time.Time) ([]*model.StatisticEngagementDashboard, error) {
	var result []*model.StatisticEngagementDashboard

	query := db.Table("feedback_events fe").
		Select("DISTINCT f.name, eq.question_id, fe.title, fe.start_date, avg( CASE WHEN answer = '' THEN 0 ELSE cast(answer AS DECIMAL) END) AS point").
		Joins("JOIN employee_event_questions eq ON fe.id = eq.event_id").
		Joins("JOIN employee_event_reviewers er ON eq.employee_event_reviewer_id = er.id").
		Where("eq.domain = 'engagement'").
		Where("er.reviewer_status = 'done' AND is_forced_done = FALSE").
		Where("fe.start_date = ?", time).
		Group("eq.question_id, fe.title, fe.start_date")

	if filter == model.EngagementDashboardFilterChapter {
		query = query.
			Joins("JOIN employee_chapters ec ON er.reviewer_id = ec.employee_id").
			Joins("JOIN chapters f ON ec.chapter_id = f.id").
			Group("f.name")
	}
	if filter == model.EngagementDashboardFilterSeniority {
		query = query.
			Joins("JOIN employees e ON er.reviewer_id = e.id").
			Joins("JOIN seniorities f ON e.seniority_id = f.id").
			Group("f.name")
	}
	if filter == model.EngagementDashboardFilterProject {
		query = query.
			Joins("JOIN project_members pm ON er.reviewer_id = pm.employee_id").
			Joins("JOIN projects f ON pm.project_id = f.id").
			Where("f.status = ?", model.ProjectStatusActive).
			Group("f.name")
	}

	return result, query.Find(&result).Error
}

```

# pkg/store/employeecommission/interface.go

```go
package employeecommission

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

// IStore is an interface that abstract database method for commission
type IStore interface {
	// Create new row for table user_commissions, save the commission
	// for an user for specific invoice
	Create(db *gorm.DB, employeeCommissions []model.EmployeeCommission) ([]model.EmployeeCommission, error)
	Get(db *gorm.DB, q Query) ([]model.EmployeeCommission, error)
	MarkPaid(db *gorm.DB, ids model.UUID) error
}

type Query struct {
	EmployeeID string
	FromDate   *time.Time
	ToDate     *time.Time
	IsPaid     bool
}

```

# pkg/store/employeecommission/employee_commission_test.go

```go
package employeecommission

// func TestCreate(t *testing.T) {
// 	t.Parallel()

// 	db, _, close := util.GetTestDB(t)
// 	defer close()

// 	var cs []domain.UserCommission
// 	cs = append(cs, domain.UserCommission{
// 		UserID:    domain.NewUUID(),
// 		InvoiceID: domain.NewUUID(),
// 		Amount:    1000,
// 	})
// 	testcases := []struct {
// 		name    string
// 		cs      []domain.UserCommission
// 		wantErr error
// 	}{
// 		{
// 			name: "case success",
// 			cs: cs,
// 			wantErr: nil,
// 		},
// 	}
// 	for _, tc := range testcases {
// 		t.Run(tc.name, func(t *testing.T) {
// 			s := &pgStore{}
// 			err := s.Create(db, tc.cs)
// 			if err == nil && tc.wantErr != nil {
// 				t.Errorf("[CommissionStore].Create() want error not nil, got error: %v", err)
// 				return
// 			}
// 			if err != nil && err != tc.wantErr {
// 				t.Errorf("[CommissionStore].Create() want error: %v, got error: %v", tc.wantErr, err)
// 			}
// 		})
// 	}
// }

// func TestGet(t *testing.T) {
// 	db, _, close := util.GetTestDB(t)
// 	defer close()

// 	fromDate := time.Date(2019, 1, 1, 0, 0, 0, 0, time.UTC)
// 	toDate := time.Date(2019, 2, 15, 0, 0, 0, 0, time.UTC)

// 	var res []domain.UserCommission
// 	res = append(res, domain.UserCommission{
// 		Model: domain.Model{
// 			ID: domain.MustGetUUIDFromString("a8d67ba6-50ae-45f3-9a67-56469dadc2c3"),
// 		},
// 		Amount:    0,
// 		UserID:    domain.MustGetUUIDFromString("d8a6af04-9e0a-4724-97c4-a78ecd5e9bc4"),
// 		InvoiceID: domain.MustGetUUIDFromString("be0d0584-867e-44e6-b7b7-366e4704e7cb"),
// 		Project:   "Example",
// 	})
// 	testcases := []struct {
// 		name    string
// 		q       Query
// 		wantRes []domain.UserCommission
// 		wantErr error
// 	}{
// 		{
// 			name: "case success",
// 			q: Query{
// 				UserID:   "",
// 				FromDate: &fromDate,
// 				ToDate:   &toDate,
// 			},
// 			wantRes: res,
// 		},
// 	}
// 	for _, tc := range testcases {
// 		t.Run(tc.name, func(t *testing.T) {
// 			s := &pgStore{}
// 			res, err := s.Get(db, tc.q)
// 			if err != nil && err != tc.wantErr {
// 				t.Errorf("[commissionStore].Get() want error: %v, got error: %v", tc.wantErr, err)
// 				return
// 			}
// 			if err == nil {
// 				for i := range res {
// 					if res[i].Amount != tc.wantRes[i].Amount {
// 						t.Errorf("[commissionStore].Get() want amount: %v, got amount: %v", tc.wantRes[i].Amount, res[i].Amount)
// 						return
// 					}
// 					if res[i].UserID != tc.wantRes[i].UserID {
// 						t.Errorf("[commissionStore].Get() want user ID: %v, got user ID: %v", tc.wantRes[i].UserID, res[i].UserID)
// 						return
// 					}
// 					if res[i].InvoiceID != tc.wantRes[i].InvoiceID {
// 						t.Errorf("[commissionStore].Get() want invoice ID: %v, got invoice ID: %v", tc.wantRes[i].InvoiceID, res[i].InvoiceID)
// 						return
// 					}
// 					if res[i].Project != tc.wantRes[i].Project {
// 						t.Errorf("[commissionStore].Get() want project: %v, got project: %v", tc.wantRes[i].Project, res[i].Project)
// 						return
// 					}
// 					if res[i].ID != tc.wantRes[i].ID {
// 						t.Errorf("[commissionStore].Get() want ID: %v, got ID: %v", tc.wantRes[i].ID, res[i].ID)
// 					}
// 				}
// 			}
// 		})
// 	}
// }

```

# pkg/store/employeecommission/employee_commission.go

```go
package employeecommission

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

// New initialize new store for commission
func New() IStore {
	return &store{}
}

func (s *store) Create(db *gorm.DB, employeeCommissions []model.EmployeeCommission) ([]model.EmployeeCommission, error) {
	return employeeCommissions, db.Create(&employeeCommissions).Error
}

func (s *store) Get(db *gorm.DB, q Query) ([]model.EmployeeCommission, error) {
	var res []model.EmployeeCommission
	if q.EmployeeID != "" {
		db = db.Where("employee_id = ?", q.EmployeeID)
	}
	if q.FromDate != nil {
		db = db.Where("created_at > ?", q.FromDate)
	}
	if q.ToDate != nil {
		db = db.Where("created_at < ?", q.ToDate)
	}
	return res, db.Preload("Invoice").Where("is_paid = ?", q.IsPaid).Find(&res).Error
}

func (s *store) MarkPaid(db *gorm.DB, id model.UUID) error {
	var cms model.EmployeeCommission
	err := db.Where("id = ?", id).Find(&cms).Error
	if err != nil {
		return err
	}
	return db.Model(&cms).Updates(map[string]interface{}{"is_paid": true, "paid_at": time.Now()}).Error
}

```

# pkg/store/employeechapter/interface.go

```go
package employeechapter

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, employeeChapter *model.EmployeeChapter) (*model.EmployeeChapter, error)
	DeleteByEmployeeID(db *gorm.DB, employeeID string) error
}

```

# pkg/store/employeechapter/employee_chapter.go

```go
package employeechapter

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create make new one by id
func (s *store) Create(db *gorm.DB, employeeChapter *model.EmployeeChapter) (*model.EmployeeChapter, error) {
	return employeeChapter, db.Create(&employeeChapter).Error
}

// DeleteByEmployeeID delete many EmployeeChapters by employeeID
func (s *store) DeleteByEmployeeID(db *gorm.DB, employeeID string) error {
	return db.Unscoped().Where("employee_id = ?", employeeID).Delete(&model.EmployeeChapter{}).Error
}

```

# pkg/store/employeebonus/interface.go

```go
package employeebonus

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

// IStore is an interface that abstract database method for bonus
type IStore interface {
	GetByUserID(db *gorm.DB, id model.UUID) ([]model.EmployeeBonus, error)
}

```

# pkg/store/employeebonus/employee_bonus.go

```go
package employeebonus

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

// New initialize new store for bonus
func New() IStore {
	return &store{}
}

func (s *store) GetByUserID(db *gorm.DB, id model.UUID) ([]model.EmployeeBonus, error) {
	var res []model.EmployeeBonus
	return res, db.Where("is_active = true AND employee_id = ?", id).Find(&res).Error
}

```

# pkg/store/discordtemplate/interface.go

```go
package discordtemplate

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	GetTemplateByType(db *gorm.DB, templateType string) (*model.DiscordLogTemplate, error)
}

```

# pkg/store/discordtemplate/discord_template.go

```go
package discordtemplate

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct {
}

func New() IStore {
	return &store{}
}

func (s *store) GetTemplateByType(db *gorm.DB, templateType string) (*model.DiscordLogTemplate, error) {
	var template *model.DiscordLogTemplate
	return template, db.Where("type = ?", templateType).First(&template).Error
}

```

# pkg/store/employee/util.go

```go
package employee

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

func getByWhereConditions(query *gorm.DB, filter EmployeeFilter) *gorm.DB {
	if len(filter.WorkingStatuses) > 0 {
		query = query.Where("working_status IN ?", filter.WorkingStatuses)
	}

	if len(filter.Positions) > 0 {
		if len(filter.Positions) == 1 {
			if filter.Positions[0] == "-" {
				query = query.Joins(`LEFT JOIN employee_positions ep ON employees.id = ep.employee_id`).Where("ep.id IS NULL")
			} else {
				query = query.Joins(`JOIN employee_positions ep ON employees.id = ep.employee_id`).Joins(`JOIN positions po ON ep.position_id = po.id`).
					Where("po.code = ? AND ep.deleted_at IS NULL", filter.Positions[0])
			}
		}
		if len(filter.Positions) > 1 {
			if filter.Positions[0] == "-" {
				query = query.Joins(`LEFT JOIN employee_positions ep ON employees.id = ep.employee_id`).
					Joins(`LEFT JOIN positions po ON ep.position_id = po.id`).
					Where(`ep.id IS NULL OR (po.code IN ? AND ep.deleted_at IS NULL)`, filter.Positions[1:])
			} else {
				query = query.Joins(`JOIN employee_positions ep ON employees.id = ep.employee_id`).
					Joins(`JOIN positions po ON ep.position_id = po.id`).
					Where(`po.code IN ? AND ep.deleted_at IS NULL`, filter.Positions)
			}
		}
	}

	if len(filter.Stacks) > 0 {
		if len(filter.Stacks) == 1 {
			if filter.Stacks[0] == "-" {
				query = query.Joins(`LEFT JOIN employee_stacks es ON employees.id = es.employee_id`).Where("es.id IS NULL")
			} else {
				query = query.Joins(`JOIN employee_stacks es ON employees.id = es.employee_id`).Joins(`JOIN stacks s ON es.stack_id = s.id`).
					Where("s.code = ? AND es.deleted_at IS NULL", filter.Stacks[0])
			}
		}
		if len(filter.Stacks) > 1 {
			if filter.Stacks[0] == "-" {
				query = query.Joins(`LEFT JOIN employee_stacks es ON employees.id = es.employee_id`).
					Joins(`LEFT JOIN stacks s ON es.project_id = s.id`).
					Where(`es.id IS NULL OR (s.code IN ? AND es.deleted_at IS NULL)`, filter.Stacks[1:])
			} else {
				query = query.Joins(`JOIN employee_stacks es ON employees.id = es.employee_id`).
					Joins(`JOIN stacks s ON es.stack_id = s.id`).
					Where(`s.code IN ? AND es.deleted_at IS NULL`, filter.Stacks)
			}
		}
	}

	if len(filter.Projects) > 0 {
		if len(filter.Projects) == 1 {
			if filter.Projects[0] == "-" {
				query = query.Where(`employees.id NOT IN (SELECT DISTINCT employee_id FROM project_members WHERE 
					deleted_at IS NULL AND start_date <= now() AND (end_date IS NULL OR end_date > now()))`)
			} else {
				query = query.Joins(`JOIN project_members pm ON employees.id = pm.employee_id`).Joins(`JOIN projects p ON pm.project_id = p.id`).
					Where("p.code = ? AND pm.deleted_at IS NULL AND pm.start_date <= now() AND (pm.end_date IS NULL OR pm.end_date > now())", filter.Projects[0])
			}
		}
		if len(filter.Projects) > 1 {
			if filter.Projects[0] == "-" {
				query = query.Joins(`LEFT JOIN project_members pm ON employees.id = pm.employee_id`).
					Joins(`LEFT JOIN projects p ON pm.project_id = p.id`).
					Where(`(p.code IN ? AND pm.deleted_at IS NULL AND pm.start_date <= now() AND 
							(pm.end_date IS NULL OR pm.end_date > now())) OR 
							(employees.id NOT IN (SELECT DISTINCT employee_id FROM project_members WHERE deleted_at IS NULL AND
							start_date <= now() AND (end_date IS NULL OR end_date > now())))`, filter.Projects[1:])
			} else {
				query = query.Joins(`JOIN project_members pm ON employees.id = pm.employee_id`).
					Joins(`JOIN projects p ON pm.project_id = p.id`).
					Where(`p.code IN ? AND pm.deleted_at IS NULL AND pm.start_date <= now() AND (pm.end_date IS NULL OR pm.end_date > now())`, filter.Projects)
			}
		}
	}

	if len(filter.LineManagers) > 0 {
		if len(filter.LineManagers) == 1 {
			if filter.LineManagers[0] == "-" {
				query = query.Where("employees.line_manager_id IS NULL")
			} else {
				query = query.Where("employees.line_manager_id = ?", filter.LineManagers[0])
			}
		} else {
			if filter.LineManagers[0] == "-" {
				query = query.Where(`employees.line_manager_id IS NULL AND employees.line_manager_id IN ?`, filter.LineManagers[1:])
			} else {
				query = query.Where("employees.line_manager_id IN ?", filter.LineManagers)
			}
		}
	}

	if len(filter.Chapters) > 0 {
		if len(filter.Chapters) == 1 {
			if filter.Chapters[0] == "-" {
				query = query.Joins(`LEFT JOIN employee_chapters ec ON employees.id = ec.employee_id`).Where("ec.id IS NULL")
			} else {
				query = query.Joins(`JOIN employee_chapters ec ON employees.id = ec.employee_id`).Joins(`JOIN chapters c ON ec.chapter_id = c.id`).
					Where("c.code = ? AND ec.deleted_at IS NULL", filter.Chapters[0])
			}
		}
		if len(filter.Chapters) > 1 {
			if filter.Chapters[0] == "-" {
				query = query.Joins(`LEFT JOIN employee_chapters ec ON employees.id = ec.employee_id`).
					Joins(`LEFT JOIN chapters c ON ec.chapter_id = c.id`).
					Where(`ec.id IS NULL OR (c.code IN ? AND ec.deleted_at IS NULL)`, filter.Chapters[1:])
			} else {
				query = query.Joins(`JOIN employee_chapters ec ON employees.id = ec.employee_id`).
					Joins(`JOIN chapters c ON ec.chapter_id = c.id`).
					Where(`c.code IN ? AND ec.deleted_at IS NULL`, filter.Chapters)
			}
		}
	}

	if len(filter.Seniorities) > 0 {
		query = query.Joins("JOIN seniorities ON employees.seniority_id = seniorities.id AND seniorities.code IN ?",
			filter.Seniorities)
	}

	if len(filter.Organizations) > 0 {
		if filter.Organizations[0] == "-" {
			query = query.Where(`employees.id NOT IN (SELECT DISTINCT employee_id FROM employee_organizations)`)
		} else {
			query = query.Joins(`JOIN employee_organizations ON employees.id = employee_organizations.employee_id JOIN organizations ON employee_organizations.organization_id = organizations.id AND organizations.code IN ?`,
				filter.Organizations)
		}
	}

	if filter.IsLeft != nil {
		if *filter.IsLeft {
			query = query.Where("employees.left_date IS NOT NULL")
		} else {
			from := time.Now()
			if filter.BatchDate != nil {
				from = *filter.BatchDate
			}
			query = query.Where("(employees.left_date IS NULL OR employees.left_date > ?)", from)
		}
	}

	if filter.Keyword != "" {
		query = query.Where("employees.keyword_vector @@ plainto_tsquery('english_nostop', fn_remove_vietnamese_accents(LOWER(?)))", filter.Keyword)
	}
	return query
}

func getByFieldSort(db *gorm.DB, query *gorm.DB, field string, sortOrder model.SortOrder) *gorm.DB {
	if len(sortOrder) > 0 {
		if sortOrder == model.SortOrderASC {
			return db.Table("(?) as employees", query).Order(field + " asc")
		} else {
			return db.Table("(?) as employees", query).Order(field + " desc")
		}
	}
	return query
}

```

# pkg/store/employee/request.go

```go
package employee

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type EmployeeFilter struct {
	WorkingStatuses []string
	Preload         bool
	Positions       []string
	Stacks          []string
	Projects        []string
	Chapters        []string
	Seniorities     []string
	Organizations   []string
	LineManagers    []string
	Keyword         string
	IsLeft          *bool
	BatchDate       *time.Time
	//field sort
	JoinedDateSort model.SortOrder
}

type DiscordRequestFilter struct {
	DiscordID []string
	Email     string
	Keyword   string
}

```

# pkg/store/employee/interface.go

```go
package employee

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB, input EmployeeFilter, pagination model.Pagination) (employees []*model.Employee, total int64, err error)
	Create(db *gorm.DB, e *model.Employee) (employee *model.Employee, err error)

	One(db *gorm.DB, id string, preload bool) (employee *model.Employee, err error)
	OneByEmail(db *gorm.DB, email string) (*model.Employee, error)
	OneByNotionID(db *gorm.DB, notionID string) (employee *model.Employee, err error)
	OneByBasecampID(db *gorm.DB, basecampID int) (employee *model.Employee, err error)
	GetByIDs(db *gorm.DB, ids []model.UUID) (employees []*model.Employee, err error)
	GetByEmails(db *gorm.DB, emails []string) (employees []*model.Employee, err error)
	GetByBasecampIDs(db *gorm.DB, basecampIDs []int) (employees []*model.Employee, err error)
	GetByWorkingStatus(db *gorm.DB, workingStatus model.WorkingStatus) ([]*model.Employee, error)
	GetLineManagers(db *gorm.DB) ([]*model.Employee, error)
	GetLineManagersOfPeers(db *gorm.DB, employeeID string) ([]*model.Employee, error)
	GetMenteesByID(db *gorm.DB, employeeID string) ([]*model.Employee, error)
	GetByDiscordID(db *gorm.DB, discordID string, preload bool) (*model.Employee, error)
	GetByDiscordUsername(db *gorm.DB, discordUsername string) (*model.Employee, error)
	ListByDiscordRequest(db *gorm.DB, in DiscordRequestFilter, preload bool) ([]model.Employee, error)
	ListWithMMAScore(db *gorm.DB) ([]model.EmployeeMMAScoreData, error)
	SimpleList(db *gorm.DB) ([]*model.Employee, error)
	GetRawList(db *gorm.DB, filter EmployeeFilter) ([]model.Employee, error)

	IsExist(db *gorm.DB, id string) (bool, error)

	Update(db *gorm.DB, employee *model.Employee) (*model.Employee, error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Employee, updatedFields ...string) (*model.Employee, error)
}

```

# pkg/store/employee/employee.go

```go
package employee

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get 1 employee by id
func (s *store) One(db *gorm.DB, id string, preload bool) (*model.Employee, error) {
	query := db
	if !model.IsUUIDFromString(id) {
		query = db.Where("username = ?", id)
	} else {
		query = db.Where("id = ?", id)
	}

	query = query.Preload("EmployeeRoles", func(db *gorm.DB) *gorm.DB {
		return db.Joins("employee_roles JOIN roles ON roles.id = employee_roles.role_id").
			Where("employee_roles.deleted_at IS NULL").
			Order("roles.level")
	}).
		Preload("EmployeeRoles.Role", "deleted_at IS NULL").
		Preload("SocialAccounts", "deleted_at IS NULL").
		Preload("DiscordAccount", "deleted_at IS NULL").
		Preload("Referrer", "deleted_at IS NULL")

	if preload {
		query = query.
			Preload("ProjectMembers", "deleted_at IS NULL").
			Preload("ProjectMembers.Project", "deleted_at IS NULL").
			Preload("ProjectMembers.ProjectMemberPositions", "deleted_at IS NULL").
			Preload("ProjectMembers.ProjectMemberPositions.Position", "deleted_at IS NULL").
			Preload("EmployeePositions", "deleted_at IS NULL").
			Preload("EmployeePositions.Position", "deleted_at IS NULL").
			Preload("EmployeeStacks", "deleted_at IS NULL").
			Preload("EmployeeStacks.Stack", "deleted_at IS NULL").
			Preload("EmployeeChapters", "deleted_at IS NULL").
			Preload("EmployeeChapters.Chapter", "deleted_at IS NULL").
			Preload("EmployeeOrganizations", "deleted_at IS NULL").
			Preload("EmployeeOrganizations.Organization", "deleted_at IS NULL").
			Preload("Seniority").
			Preload("LineManager").
			Preload("BaseSalary").
			Preload("BaseSalary.Currency")
	}

	var employee *model.Employee
	return employee, query.First(&employee).Error
}

// OneByEmail get 1 employee by team email or personal email
func (s *store) OneByEmail(db *gorm.DB, email string) (*model.Employee, error) {
	var employee *model.Employee

	return employee, db.Where("NULLIF(TRIM(team_email), '') = ? OR NULLIF(TRIM(personal_email), '') = ?", email, email).First(&employee).Error
}

// OneByNotionID get 1 employee by notion id
func (s *store) OneByNotionID(db *gorm.DB, notionID string) (*model.Employee, error) {
	var employee *model.Employee
	return employee, db.Where(`id IN (
			SELECT sa.employee_id
			FROM social_accounts sa
			WHERE sa.account_id = ? AND sa.type = ?
		)`, notionID, model.SocialAccountTypeNotion).First(&employee).Error
}

// OneByBasecampID get 1 employee by basecampID
func (s *store) OneByBasecampID(db *gorm.DB, basecampID int) (*model.Employee, error) {
	var employee *model.Employee
	return employee, db.Where("basecamp_id = ?", basecampID).First(&employee).Error
}

// All get employees by query and pagination
func (s *store) All(db *gorm.DB, filter EmployeeFilter, pagination model.Pagination) ([]*model.Employee, int64, error) {
	var total int64
	var employees []*model.Employee

	query := db.Table("employees").Distinct("ON(employees.id) employees.*")

	query = getByWhereConditions(query, filter)
	err := db.Raw("SELECT COUNT(*) FROM (?) res", query).Scan(&total).Error
	if err != nil {
		return nil, 0, err
	}

	query = getByFieldSort(db, query, "employees.joined_date", filter.JoinedDateSort).
		Preload("SocialAccounts", "deleted_at IS NULL").
		Preload("DiscordAccount", "deleted_at IS NULL")

	if filter.Preload {
		query = query.
			Preload("LineManager", "deleted_at IS NULL").
			Preload("Referrer", "deleted_at IS NULL").
			Preload("Seniority", "deleted_at IS NULL").
			Preload("ProjectMembers", func(db *gorm.DB) *gorm.DB {
				return db.Joins("JOIN projects ON projects.id = project_members.project_id").
					Where("project_members.deleted_at IS NULL").
					Where("project_members.start_date <= now()").
					Where("(project_members.end_date IS NULL OR project_members.end_date > now())").
					Where("projects.status IN ?", []string{
						model.ProjectStatusOnBoarding.String(),
						model.ProjectStatusActive.String(),
					}).
					Order("projects.name")
			}).
			Preload("ProjectMembers.Project", "deleted_at IS NULL").
			Preload("ProjectMembers.Project.Heads", "deleted_at IS NULL").
			Preload("EmployeePositions", "deleted_at IS NULL").
			Preload("EmployeePositions.Position", "deleted_at IS NULL").
			Preload("EmployeeRoles", "deleted_at IS NULL").
			Preload("EmployeeRoles.Role", "deleted_at IS NULL").
			Preload("EmployeeChapters", "deleted_at IS NULL").
			Preload("EmployeeChapters.Chapter", "deleted_at IS NULL").
			Preload("EmployeeStacks", "deleted_at IS NULL").
			Preload("EmployeeStacks.Stack", "deleted_at IS NULL").
			Preload("EmployeeOrganizations", func(db *gorm.DB) *gorm.DB {
				return db.Joins("JOIN organizations ON organizations.id = employee_organizations.organization_id").
					Where("employee_organizations.deleted_at IS NULL").
					Order("organizations.code DESC")
			}).
			Preload("EmployeeOrganizations.Organization", "deleted_at IS NULL").
			Preload("BaseSalary").
			Preload("BaseSalary.Currency")
	}

	limit, offset := pagination.ToLimitOffset()
	if pagination.Page > 0 {
		query = query.Limit(limit)
	}

	return employees, total, query.
		Limit(limit).
		Offset(offset).
		Find(&employees).Error
}

func (s *store) Create(db *gorm.DB, e *model.Employee) (employee *model.Employee, err error) {
	return e, db.Create(e).Error
}

// IsExist check the existence of employee
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM employees WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, employee *model.Employee) (*model.Employee, error) {
	return employee, db.Model(&employee).Where("id = ?", employee.ID).Updates(&employee).First(&employee).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Employee, updatedFields ...string) (*model.Employee, error) {
	employee := model.Employee{}
	return &employee, db.Model(&employee).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// GetByIDs return list employee by IDs
func (s *store) GetByIDs(db *gorm.DB, ids []model.UUID) ([]*model.Employee, error) {
	var employees []*model.Employee
	return employees, db.Where("id IN ?", ids).Order("created_at").Find(&employees).Error
}

// GetByWorkingStatus return list employee by working status
func (s *store) GetByWorkingStatus(db *gorm.DB, workingStatus model.WorkingStatus) ([]*model.Employee, error) {
	var employees []*model.Employee
	return employees, db.Where("working_status = ?", workingStatus).
		Preload("Organizations", "deleted_at IS NULL").
		Find(&employees).Error
}

func (s *store) GetLineManagers(db *gorm.DB) ([]*model.Employee, error) {
	var employees []*model.Employee
	return employees, db.Where(`id IN (
		SELECT e.line_manager_id
		FROM employees e
		WHERE e.deleted_at IS NULL
			AND e.working_status != ?
			AND (e.left_date IS NULL OR e.left_date >= now())
	)`, model.WorkingStatusLeft).Find(&employees).Error
}

func (s *store) GetLineManagersOfPeers(db *gorm.DB, employeeID string) ([]*model.Employee, error) {
	var employees []*model.Employee
	return employees, db.Where(`id IN (
		SELECT e.line_manager_id
		FROM employees e JOIN project_members pm ON pm.employee_id = e.id
		WHERE e.deleted_at IS NULL
			AND e.working_status != ?
			AND (e.left_date IS NULL OR e.left_date >= now())
			AND pm.project_id IN (
				SELECT pm2.project_id
				FROM project_members pm2
				WHERE pm2.employee_id = employees.id
			)
	)`, model.WorkingStatusLeft).Find(&employees).Error
}

func (s *store) GetMenteesByID(db *gorm.DB, employeeID string) ([]*model.Employee, error) {
	var employees []*model.Employee
	return employees, db.Where(`id IN (
		SELECT e.id
		FROM employees e
		WHERE e.deleted_at IS NULL
			AND e.line_manager_id = ?
			AND e.working_status <> ?
			AND (e.left_date IS NULL OR e.left_date >= now())
	)`, employeeID, model.WorkingStatusLeft).
		Preload("EmployeePositions", "deleted_at IS NULL").
		Preload("EmployeePositions.Position", "deleted_at IS NULL").
		Preload("Seniority").
		Find(&employees).Error
}

func (s *store) GetByEmails(db *gorm.DB, emails []string) ([]*model.Employee, error) {
	var employees []*model.Employee

	return employees, db.Where("NULLIF(TRIM(team_email), '') IN ? OR NULLIF(TRIM(personal_email), '') IN ?", emails, emails).Find(&employees).Error
}

func (s *store) GetByBasecampIDs(db *gorm.DB, basecampIDs []int) ([]*model.Employee, error) {
	var employees []*model.Employee

	return employees, db.Where("basecamp_id IN ?", basecampIDs).Find(&employees).Error
}

func (s *store) GetByDiscordID(db *gorm.DB, discordID string, preload bool) (*model.Employee, error) {
	var employee *model.Employee
	query := db.Joins("JOIN discord_accounts ON discord_accounts.id = employees.discord_account_id AND discord_accounts.discord_id = ?", discordID).
		Where("employees.deleted_at IS NULL AND employees.working_status <> ?", model.WorkingStatusLeft)

	if preload {
		query = query.
			Preload("Roles").
			Preload("SocialAccounts", "deleted_at IS NULL").
			Preload("DiscordAccount", "deleted_at IS NULL").
			Preload("ProjectMembers", "deleted_at IS NULL").
			Preload("ProjectMembers.Project", "deleted_at IS NULL").
			Preload("EmployeePositions", "deleted_at IS NULL").
			Preload("EmployeePositions.Position", "deleted_at IS NULL").
			Preload("EmployeeStacks", "deleted_at IS NULL").
			Preload("EmployeeStacks.Stack", "deleted_at IS NULL").
			Preload("EmployeeMMAScores", func(db *gorm.DB) *gorm.DB {
				return db.Order("rated_at DESC").Limit(1)
			}).
			Preload("Seniority")
	}
	return employee, query.First(&employee).Error
}

func (s *store) GetByDiscordUsername(db *gorm.DB, discordUsername string) (*model.Employee, error) {
	var employee *model.Employee
	query := db.Joins("JOIN discord_accounts ON discord_accounts.id = employees.discord_account_id AND discord_accounts.username = ?", discordUsername).
		Where("employees.deleted_at IS NULL AND employees.working_status <> ?", model.WorkingStatusLeft).
		Preload("SocialAccounts", "deleted_at IS NULL").
		Preload("DiscordAccount", "deleted_at IS NULL")
	err := query.First(&employee).Error
	if err != nil {
		return nil, err
	}
	return employee, nil
}

func (s *store) ListByDiscordRequest(db *gorm.DB, in DiscordRequestFilter, preload bool) ([]model.Employee, error) {
	var employee []model.Employee
	query := db.Where("employees.deleted_at IS NULL AND employees.working_status <> ?", model.WorkingStatusLeft).Order("employees.joined_date DESC")
	if len(in.DiscordID) > 0 {
		query = query.Joins("JOIN discord_accounts ON discord_accounts.id = employees.discord_account_id AND discord_accounts.discord_id IN (?)", in.DiscordID)
	}

	if in.Email != "" {
		query = query.Where("employees.team_email = ? OR employees.personal_email = ?", in.Email, in.Email)
	}

	if in.Keyword != "" {
		query = query.Where(`employees.keyword_vector @@ plainto_tsquery('english_nostop', fn_remove_vietnamese_accents(LOWER(?))) OR 
			employees.id IN (
				SELECT sa.employee_id
				FROM social_accounts sa
				WHERE sa.account_id = ? AND sa.type = ?)
		`, in.Keyword, in.Keyword, model.SocialAccountTypeGitHub)
	}

	if preload {
		query = query.
			Preload("SocialAccounts", "deleted_at IS NULL").
			Preload("DiscordAccount", "deleted_at IS NULL").
			Preload("ProjectMembers", "deleted_at IS NULL").
			Preload("ProjectMembers.Project", "deleted_at IS NULL").
			Preload("EmployeePositions", "deleted_at IS NULL").
			Preload("EmployeePositions.Position", "deleted_at IS NULL").
			Preload("EmployeeStacks", "deleted_at IS NULL").
			Preload("EmployeeStacks.Stack", "deleted_at IS NULL").
			Preload("EmployeeMMAScores", func(db *gorm.DB) *gorm.DB {
				return db.Order("rated_at DESC").Limit(1)
			}).
			Preload("Seniority")
	}

	return employee, query.Find(&employee).Error
}

// SimpleList get employees by query and pagination
func (s *store) SimpleList(db *gorm.DB) ([]*model.Employee, error) {
	var employees []*model.Employee

	query := db.Where("deleted_at IS NULL AND working_status <> ?", model.WorkingStatusLeft).
		Order("created_at").
		Preload("DiscordAccount", "deleted_at IS NULL").
		Preload("EmployeeChapters", "deleted_at IS NULL").
		Preload("EmployeeChapters.Chapter", "deleted_at IS NULL")

	return employees, query.Find(&employees).Error
}

func (s *store) GetRawList(db *gorm.DB, filter EmployeeFilter) ([]model.Employee, error) {
	var employees []model.Employee

	query := db
	if filter.WorkingStatuses != nil {
		query = query.Where("working_status IN ?", filter.WorkingStatuses)
	}

	return employees, query.Find(&employees).Error
}

// ListWithMMAScore get employees with latest mma score
func (s *store) ListWithMMAScore(db *gorm.DB) ([]model.EmployeeMMAScoreData, error) {
	var employees []model.EmployeeMMAScoreData
	query := `
		SELECT e.id AS employee_id, e.full_name, m.id AS mma_id, m.mastery_score, m.autonomy_score, m.meaning_score, m.rated_at
		FROM employees e
		LEFT JOIN (
			SELECT id, employee_id, mastery_score, autonomy_score, meaning_score, rated_at
			FROM employee_mma_scores
			WHERE (employee_id, rated_at) IN (
				SELECT employee_id, MAX(rated_at) AS rated_at
				FROM employee_mma_scores
				GROUP BY employee_id
			)
		) m ON e.id = m.employee_id
		WHERE e.deleted_at IS NULL AND e.working_status <> ?
		ORDER BY e.joined_date DESC 
	`

	return employees, db.Raw(query, model.WorkingStatusLeft).Scan(&employees).Error
}

```

# pkg/store/discordevent/interface.go

```go
package discordevent

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, query *Query) (e *model.Event, err error)
	All(db *gorm.DB, query *Query, preload bool) ([]*model.Event, error)
	Create(db *gorm.DB, e *model.Event) (de *model.Event, err error)
	SetSpeakers(db *gorm.DB, e *model.Event) error
}

// Query present invoice query from user
type Query struct {
	ID              string
	DiscordEventID  string   // For querying by single ID
	DiscordEventIDs []string // For filter by multiple IDs
	EventTypes      []model.EventType
	Limit           int
	Offset          int
	After           *time.Time
}

```

# pkg/store/discordevent/discord_event.go

```go
package discordevent

import (
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get client by id
func (s *store) One(db *gorm.DB, query *Query) (*model.Event, error) {
	var e *model.Event
	if query.ID != "" {
		db = db.Where("id = ?", query.ID)
	}
	if query.DiscordEventID != "" {
		db = db.Where("discord_event_id = ?", query.DiscordEventID)
	}
	return e, db.Preload("EventSpeakers").First(&e).Error
}

// All get all client
func (s *store) All(db *gorm.DB, q *Query, preload bool) ([]*model.Event, error) {
	var e []*model.Event

	if q.Limit == 0 {
		q.Limit = 10
	}

	query := db.Order("date desc").Limit(q.Limit)

	if q.After != nil {
		query = query.Where("date > ?", q.After)
	}

	if len(q.DiscordEventIDs) > 0 {
		query = query.Where("discord_event_id IN (?)", q.DiscordEventIDs)
	}

	if !preload {
		return e, query.Find(&e).Error
	}

	return e, query.Preload("EventSpeakers").Find(&e).Order("date desc").Error
}

// Create creates a new e
func (s *store) Create(db *gorm.DB, e *model.Event) (*model.Event, error) {
	return e, db.Create(e).Error
}

func (s *store) SetSpeakers(db *gorm.DB, e *model.Event) error {
	for _, es := range e.EventSpeakers {
		if es.DiscordAccountID.String() == "" {
			continue
		}
		// upsert speaker
		if err := db.Clauses(
			clause.OnConflict{
				Columns: []clause.Column{
					{Name: "discord_account_id"},
					{Name: "event_id"},
				},
				DoUpdates: clause.Assignments(
					map[string]interface{}{
						"topic": es.Topic,
					},
				),
			},
		).Create(es).Error; err != nil {
			return err
		}
	}
	return nil
}

```

# pkg/store/deliverymetricweekly/interface.go

```go
package deliverymetricweekly

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	GetLast(db *gorm.DB, num int) ([]model.WeeklyDeliveryMetric, error)
	Avg(db *gorm.DB) (model.AvgWeeklyDeliveryMetric, error)
	AvgWithoutLatestWeek(db *gorm.DB) (model.AvgWeeklyDeliveryMetric, error)
	AvgByMonth(db *gorm.DB, month time.Time) ([]model.AvgMonthWeeklyDeliveryMetric, error)
}

```

# pkg/store/deliverymetricweekly/get.go

```go
package deliverymetricweekly

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get delivery metrict by id
func (s *store) One(db *gorm.DB, id string) (*model.DeliveryMetric, error) {
	var rs *model.DeliveryMetric
	return rs, db.Where("id = ?", id).First(&rs).Error
}

func (s *store) GetLast(db *gorm.DB, num int) ([]model.WeeklyDeliveryMetric, error) {
	var rs []model.WeeklyDeliveryMetric
	return rs, db.Table("vw_weekly_delivery_metrics").Order("date desc").Limit(num).Find(&rs).Error
}

func (s *store) Avg(db *gorm.DB) (model.AvgWeeklyDeliveryMetric, error) {
	var rs model.AvgWeeklyDeliveryMetric
	return rs, db.Raw(`SELECT AVG(sum_weight) AS weight, 
						AVG(sum_effort) AS effort
					FROM vw_weekly_delivery_metrics;`).Scan(&rs).Error
}

func (s *store) AvgWithoutLatestWeek(db *gorm.DB) (model.AvgWeeklyDeliveryMetric, error) {
	var rs model.AvgWeeklyDeliveryMetric
	return rs, db.Raw(`SELECT AVG(sum_weight) AS weight, 
											AVG(sum_effort) AS effort
										FROM vw_weekly_delivery_metrics
										WHERE date != (SELECT MAX(date) FROM delivery_metrics);`).Scan(&rs).Error
}

func (s *store) AvgByMonth(db *gorm.DB, month time.Time) ([]model.AvgMonthWeeklyDeliveryMetric, error) {
	var rs []model.AvgMonthWeeklyDeliveryMetric
	return rs, db.Raw(`SELECT 
											DATE_TRUNC('month', date) AS "month",
											AVG(sum_weight) AS "weight",
											AVG(sum_effort) AS "effort"
										FROM vw_weekly_delivery_metrics
										GROUP BY DATE_TRUNC('month', date)
										HAVING DATE_TRUNC('month', date) = ?
										ORDER BY "month" DESC;`, month).Scan(&rs).Error
}

// Create creates a new delivery metric
func (s *store) Create(db *gorm.DB, e *model.DeliveryMetric) (rs *model.DeliveryMetric, err error) {
	return e, db.Create(e).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.DeliveryMetric, updatedFields ...string) (*model.DeliveryMetric, error) {
	rs := model.DeliveryMetric{}
	return &rs, db.Model(&rs).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

```

# pkg/store/deliverymetricmonthly/interface.go

```go
package deliverymetricmonthly

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	GetLast(db *gorm.DB, num int) ([]model.MonthlyDeliveryMetric, error)
	AvgTo(db *gorm.DB, maxMonth *time.Time) (model.AvgMonthlyDeliveryMetric, error)
}

```

# pkg/store/deliverymetricmonthly/get.go

```go
package deliverymetricmonthly

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get delivery metrict by id
func (s *store) One(db *gorm.DB, id string) (*model.DeliveryMetric, error) {
	var rs *model.DeliveryMetric
	return rs, db.Where("id = ?", id).First(&rs).Error
}

func (s *store) GetLast(db *gorm.DB, num int) ([]model.MonthlyDeliveryMetric, error) {
	var rs []model.MonthlyDeliveryMetric
	return rs, db.Table("vw_monthly_delivery_metrics").Order("month desc").Limit(num).Find(&rs).Error
}

func (s *store) AvgTo(db *gorm.DB, maxMonth *time.Time) (model.AvgMonthlyDeliveryMetric, error) {
	var rs model.AvgMonthlyDeliveryMetric
	return rs, db.Raw(`SELECT AVG(sum_weight) AS weight, 
						AVG(sum_effort) AS effort
					FROM vw_monthly_delivery_metrics
					WHERE "month" <= ?;`, maxMonth).Scan(&rs).Error
}

// Create creates a new delivery metric
func (s *store) Create(db *gorm.DB, e *model.DeliveryMetric) (rs *model.DeliveryMetric, err error) {
	return e, db.Create(e).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.DeliveryMetric, updatedFields ...string) (*model.DeliveryMetric, error) {
	rs := model.DeliveryMetric{}
	return &rs, db.Model(&rs).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

```

# pkg/store/deliverymetric/interface.go

```go
package deliverymetric

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (client *model.DeliveryMetric, err error)
	GetLatest(db *gorm.DB) (*model.DeliveryMetric, error)
	GetLatestWeek(db *gorm.DB) (*time.Time, error)
	GetLatestMonth(db *gorm.DB) (*time.Time, error)
	GetTopWeighMetrics(db *gorm.DB, w *time.Time, limit int) ([]model.TopWeightMetric, error)
	GetTopMonthlyWeighMetrics(db *gorm.DB, m *time.Time, limit int) ([]model.DeliveryMetric, error)

	Create(db *gorm.DB, e []model.DeliveryMetric) (rs []model.DeliveryMetric, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, client model.DeliveryMetric, updatedFields ...string) (a *model.DeliveryMetric, err error)
}

```

# pkg/store/deliverymetric/delivery_metric.go

```go
package deliverymetric

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get delivery metrict by id
func (s *store) One(db *gorm.DB, id string) (*model.DeliveryMetric, error) {
	var rs *model.DeliveryMetric
	return rs, db.Where("id = ?", id).First(&rs).Error
}

// Create creates a new delivery metric
func (s *store) Create(db *gorm.DB, e []model.DeliveryMetric) (rs []model.DeliveryMetric, err error) {
	return e, db.Create(&e).Error
}

func (s *store) GetLatestWeek(db *gorm.DB) (*time.Time, error) {
	var rs *time.Time
	return rs, db.Model(&model.DeliveryMetric{}).Select("date").Order("date DESC").Limit(1).First(&rs).Error
}

func (s *store) GetLatestMonth(db *gorm.DB) (*time.Time, error) {
	var rs *time.Time
	return rs, db.Model(&model.DeliveryMetric{}).Select("DATE_TRUNC('month', date)").Order("date DESC").Limit(1).First(&rs).Error
}

func (s *store) GetTopWeighMetrics(db *gorm.DB, w *time.Time, limit int) ([]model.TopWeightMetric, error) {
	var rs []model.TopWeightMetric
	return rs, db.Raw(`SELECT 
											employee_id,
											"date",
											SUM(weight) AS sum_weight,
											SUM(effort) AS sum_effort
										FROM delivery_metrics
										WHERE "date" = ?
										GROUP BY employee_id, "date"
										ORDER BY sum_weight DESC, sum_effort ASC
										LIMIT ?;`, w, limit).Find(&rs).Error
}

func (s *store) GetTopMonthlyWeighMetrics(db *gorm.DB, month *time.Time, limit int) ([]model.DeliveryMetric, error) {
	var rs []model.DeliveryMetric
	return rs, db.Raw(`SELECT 
											DATE_TRUNC('month', m.date) AS "date",
											m.employee_id, 
											SUM(m.weight) AS "weight",
											SUM(m.effort) AS "effort",
											AVG(m.effectiveness) AS "effectiveness"
										FROM delivery_metrics m
										WHERE DATE_TRUNC('month', m.date) = ?
										GROUP BY employee_id, DATE_TRUNC('month', m.date)
										ORDER BY "date" DESC, "weight" DESC, "effort" DESC
										LIMIT ?;`, month, limit).Find(&rs).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.DeliveryMetric, updatedFields ...string) (*model.DeliveryMetric, error) {
	rs := model.DeliveryMetric{}
	return &rs, db.Model(&rs).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// GetLatest get latest delivery metric by id
func (s *store) GetLatest(db *gorm.DB) (*model.DeliveryMetric, error) {
	var rs *model.DeliveryMetric
	return rs, db.Order("ref DESC").Limit(1).First(&rs).Error
}

```

# pkg/store/dashboard/interface.go

```go
package dashboard

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	GetProjectSizes(db *gorm.DB) (res []*model.ProjectSize, err error)
	GetWorkSurveysByProjectID(db *gorm.DB, projectID string) ([]*model.WorkSurvey, error)
	GetAllWorkSurveys(db *gorm.DB) ([]*model.WorkSurvey, error)
	GetActionItemReportsByProjectNotionID(db *gorm.DB, projectID string) ([]*model.ActionItemReport, error)
	GetAllActionItemReports(db *gorm.DB) ([]*model.ActionItemReport, error)
	AverageEngineeringHealth(db *gorm.DB) ([]*model.AverageEngineeringHealth, error)
	GroupEngineeringHealth(db *gorm.DB) ([]*model.GroupEngineeringHealth, error)
	AverageEngineeringHealthByProjectNotionID(db *gorm.DB, projectID string) ([]*model.AverageEngineeringHealth, error)
	GroupEngineeringHealthByProjectNotionID(db *gorm.DB, projectID string) ([]*model.GroupEngineeringHealth, error)
	GetAverageAudit(db *gorm.DB) ([]*model.AverageAudit, error)
	GetGroupAudit(db *gorm.DB) ([]*model.GroupAudit, error)
	GetActionItemSquashReportsByProjectID(db *gorm.DB, projectID string) ([]*model.ActionItemSquashReport, error)
	GetAllActionItemSquashReports(db *gorm.DB) ([]*model.ActionItemSquashReport, error)
	GetAverageAuditByProjectNotionID(db *gorm.DB, projectID string) ([]*model.AverageAudit, error)
	GetGroupAuditByProjectNotionID(db *gorm.DB, projectID string) ([]*model.GroupAudit, error)
	GetAuditSummaries(db *gorm.DB) ([]*model.AuditSummary, error)
	GetProjectSizesByStartTime(db *gorm.DB, curr time.Time) ([]*model.ProjectSize, error)
	GetPendingSlots(db *gorm.DB) ([]*model.ProjectSlot, error)
	GetAvailableEmployees(db *gorm.DB) ([]*model.Employee, error)
	GetResourceUtilization(db *gorm.DB, currentDate time.Time) ([]*model.ResourceUtilization, error)
	TotalWorkUnitDistribution(db *gorm.DB) (*model.TotalWorkUnitDistribution, error)
	GetAllWorkReviews(db *gorm.DB, keyword string, pagination model.Pagination) ([]*model.EmployeeEventReviewer, error)
	GetProjectHeadByEmployeeID(db *gorm.DB, employeeID string) ([]*model.ManagementInfo, error)
	GetWorkUnitDistributionEmployees(db *gorm.DB, keyword string, workUnitType string) ([]*model.Employee, error)
}

```

# pkg/store/dashboard/dashboard.go

```go
package dashboard

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) GetProjectSizes(db *gorm.DB) ([]*model.ProjectSize, error) {
	var ru []*model.ProjectSize

	query := `
		SELECT projects.id, projects.name, projects.code, projects.avatar, count(*) AS size 
			FROM (projects 
				JOIN project_members pm ON projects.id = pm.project_id
				JOIN organizations ON projects.organization_id = organizations.id)
			WHERE projects.function = 'development' 
				AND organizations.code = 'dwarves-foundation' 
				AND pm.status = 'active' AND (pm.status = 'active' OR pm.status='on-boarding') AND projects.deleted_at IS NULL
			GROUP BY projects.id
			ORDER BY size DESC
	`

	return ru, db.Raw(query).Scan(&ru).Error
}

func (s *store) GetWorkSurveysByProjectID(db *gorm.DB, projectID string) ([]*model.WorkSurvey, error) {
	var rs []*model.WorkSurvey

	query := `
		SELECT feedback_events.end_date,
			AVG(
				CASE
					WHEN "order" = 1 THEN 
						CASE
							When length(answer) = 0 THEN null
							ELSE cast(answer AS integer)
							END
					END) as workload,
			AVG(
				CASE
					WHEN "order" = 2 THEN 
						CASE
							When length(answer) = 0 THEN null
							ELSE cast(answer AS integer)
							END
					END) as deadline,
			AVG(
				CASE
					WHEN "order" = 3 THEN
						CASE
							When length(answer) = 0 THEN null
							ELSE cast(answer AS integer)
							END
					END) as learning
		FROM feedback_events
				JOIN employee_event_topics eet ON feedback_events.id = eet.event_id
				JOIN employee_event_questions eeq ON feedback_events.id = eeq.event_id
		WHERE eet.project_id = ? AND feedback_events.subtype='work' AND feedback_events.deleted_at IS NULL AND eet.deleted_at IS NULL AND eeq.deleted_at IS NULL
		GROUP BY feedback_events.end_date
		ORDER BY feedback_events.end_date
		LIMIT 6
	`

	return rs, db.Raw(query, projectID).Scan(&rs).Error
}

func (s *store) GetAllWorkSurveys(db *gorm.DB) ([]*model.WorkSurvey, error) {
	var rs []*model.WorkSurvey

	query := `
		SELECT feedback_events.end_date,
			AVG(
				CASE
					WHEN "order" = 1 THEN
						CASE
							When length(answer) = 0 THEN null
							ELSE cast(answer AS integer)
							END
					END) as workload,
			AVG(
				CASE
					WHEN "order" = 2 THEN
						CASE
							When length(answer) = 0 THEN null
							ELSE cast(answer AS integer)
							END
					END) as deadline,
			AVG(
				CASE
					WHEN "order" = 3 THEN
						CASE
							When length(answer) = 0 THEN null
							ELSE cast(answer AS integer)
							END
					END) as learning
		FROM feedback_events
			JOIN employee_event_topics eet ON feedback_events.id = eet.event_id
			JOIN projects p ON eet.project_id = p.id
			JOIN organizations ON p.organization_id = organizations.id
			JOIN employee_event_questions eeq ON feedback_events.id = eeq.event_id
		WHERE p.function = 'development' AND organizations.code = 'dwarves-foundation' AND feedback_events.subtype='work' AND feedback_events.deleted_at IS NULL AND eet.deleted_at IS NULL AND eeq.deleted_at IS NULL
		GROUP BY feedback_events.end_date
		ORDER BY feedback_events.end_date
		LIMIT 6
	`

	return rs, db.Raw(query).Scan(&rs).Error
}

func (s *store) GetAllActionItemReports(db *gorm.DB) ([]*model.ActionItemReport, error) {
	var rs []*model.ActionItemReport

	query := `
		SELECT sum(action_item_high) AS high, sum(action_item_medium) AS medium, sum(action_item_low) AS low, quarter AS quarter
		FROM audit_cycles
		WHERE audit_cycles.deleted_at IS NULL
		GROUP BY quarter 
		ORDER BY quarter desc 
		LIMIT 4
	`

	return rs, db.Raw(query).Scan(&rs).Error
}

func (s *store) GetActionItemReportsByProjectNotionID(db *gorm.DB, projectID string) ([]*model.ActionItemReport, error) {
	var rs []*model.ActionItemReport

	query := `
		SELECT sum(audit_cycles.action_item_high) AS high, sum(audit_cycles.action_item_medium) AS medium, sum(audit_cycles.action_item_low) AS low, audit_cycles.quarter AS quarter
		FROM audit_cycles
		WHERE audit_cycles.project_id = ? AND audit_cycles.deleted_at IS NULL
		GROUP BY quarter
		ORDER BY quarter desc
		LIMIT 4
	`

	return rs, db.Raw(query, projectID).Scan(&rs).Error
}

func (s *store) AverageEngineeringHealth(db *gorm.DB) ([]*model.AverageEngineeringHealth, error) {
	var rs []*model.AverageEngineeringHealth

	query := `
		SELECT audit_cycles.quarter,
			avg(CASE
					When a.score = 0 THEN NULL
					ELSE a.score
				END) as avg
		FROM audit_cycles
				LEFT JOIN audits AS a ON audit_cycles.health_audit_id = a.id
		WHERE audit_cycles.deleted_at IS NULL AND a.deleted_at IS NULL
		GROUP BY audit_cycles.quarter
		ORDER BY audit_cycles.quarter DESC
		LIMIT 4
	`

	return rs, db.Raw(query).Scan(&rs).Error
}

func (s *store) GroupEngineeringHealth(db *gorm.DB) ([]*model.GroupEngineeringHealth, error) {
	var rs []*model.GroupEngineeringHealth

	query := `
		SELECT audit_cycles.quarter, ai.area,
			avg(CASE
					When ai.grade = 0 THEN NULL
					ELSE ai.grade
				END) as avg
		FROM audit_cycles
				LEFT JOIN audits AS a ON audit_cycles.health_audit_id = a.id
				LEFT JOIN audit_items AS ai ON a.id = ai.audit_id
		WHERE audit_cycles.deleted_at IS NULL AND a.deleted_at IS NULL AND ai.deleted_at IS NULL
		GROUP BY audit_cycles.quarter, ai.area
		ORDER BY audit_cycles.quarter DESC
		LIMIT 16
	`

	return rs, db.Raw(query).Scan(&rs).Error
}

func (s *store) AverageEngineeringHealthByProjectNotionID(db *gorm.DB, projectID string) ([]*model.AverageEngineeringHealth, error) {
	var rs []*model.AverageEngineeringHealth

	query := `
		SELECT audit_cycles.quarter,
			avg(CASE
					When a.score = 0 THEN NULL
					ELSE a.score
				END) as avg
		FROM audit_cycles
				LEFT JOIN audits AS a ON audit_cycles.health_audit_id = a.id
		WHERE audit_cycles.project_id = ? AND audit_cycles.deleted_at IS NULL AND a.deleted_at IS NULL
		GROUP BY audit_cycles.quarter
		ORDER BY audit_cycles.quarter DESC
		LIMIT 4
	`

	return rs, db.Raw(query, projectID).Scan(&rs).Error
}

func (s *store) GroupEngineeringHealthByProjectNotionID(db *gorm.DB, projectID string) ([]*model.GroupEngineeringHealth, error) {
	var rs []*model.GroupEngineeringHealth

	query := `
		SELECT audit_cycles.quarter, ai.area,
			avg(CASE
					When ai.grade = 0 THEN NULL
					ELSE ai.grade
				END) as avg
		FROM audit_cycles
				LEFT JOIN audits AS a ON audit_cycles.health_audit_id = a.id
				LEFT JOIN audit_items AS ai ON a.id = ai.audit_id
		WHERE audit_cycles.project_id = ? AND audit_cycles.deleted_at IS NULL AND a.deleted_at IS NULL AND ai.deleted_at IS NULL
		GROUP BY audit_cycles.quarter, ai.area
		ORDER BY audit_cycles.quarter DESC
		LIMIT 16
	`

	return rs, db.Raw(query, projectID).Scan(&rs).Error
}

func (s *store) GetAverageAudit(db *gorm.DB) ([]*model.AverageAudit, error) {
	var rs []*model.AverageAudit

	query := `
		SELECT audit_cycles.quarter,
			avg(CASE
					When audit_cycles.average_score = 0 THEN null
					ELSE audit_cycles.average_score
				END) AS avg
		FROM audit_cycles
		WHERE audit_cycles.deleted_at IS NULL
		GROUP BY audit_cycles.quarter
		ORDER BY audit_cycles.quarter DESC
		LIMIT 4
	`

	return rs, db.Raw(query).Scan(&rs).Error
}

func (s *store) GetGroupAudit(db *gorm.DB) ([]*model.GroupAudit, error) {
	var rs []*model.GroupAudit

	query := `
		SELECT audit_cycles.quarter,
			avg(CASE
					When asy.score = 0 THEN null
					ELSE asy.score
				END) as system,
			avg(CASE
					When afe.score = 0 THEN null
					ELSE afe.score
				END) as frontend,
			avg(CASE
					When abe.score = 0 THEN null
					ELSE abe.score
				END) as backend,
			avg(CASE
					When ap.score = 0 THEN null
					ELSE ap.score
				END) as process,
			avg(CASE
					When ab.score = 0 THEN null
					ELSE ab.score
				END) as blockchain,
			avg(CASE
					When am.score = 0 THEN null
					ELSE am.score
				END) as mobile
		FROM audit_cycles
				LEFT JOIN audits AS afe ON audit_cycles.frontend_audit_id = afe.id
				LEFT JOIN audits AS abe ON audit_cycles.backend_audit_id = abe.id
				LEFT JOIN audits AS ap ON audit_cycles.process_audit_id = ap.id
				LEFT JOIN audits AS asy ON audit_cycles.system_audit_id = asy.id
				LEFT JOIN audits AS ab ON audit_cycles.blockchain_audit_id = ab.id
				LEFT JOIN audits AS am ON audit_cycles.mobile_audit_id = am.id
		WHERE audit_cycles.deleted_at IS NULL AND afe.deleted_at IS NULL AND 
			abe.deleted_at IS NULL AND ap.deleted_at IS NULL AND 
			asy.deleted_at IS NULL AND ab.deleted_at IS NULL AND am.deleted_at IS NULL
		GROUP BY audit_cycles.quarter
		ORDER BY audit_cycles.quarter DESC
		LIMIT 4
	`

	return rs, db.Raw(query).Scan(&rs).Error
}

func (s *store) GetAverageAuditByProjectNotionID(db *gorm.DB, projectID string) ([]*model.AverageAudit, error) {
	var rs []*model.AverageAudit

	query := `
		SELECT audit_cycles.quarter,
			avg(CASE
					When audit_cycles.average_score = 0 THEN null
					ELSE audit_cycles.average_score
				END) AS avg
		FROM audit_cycles
		WHERE audit_cycles.project_id = ? AND audit_cycles.deleted_at IS NULL
		GROUP BY audit_cycles.quarter
		ORDER BY audit_cycles.quarter DESC
		LIMIT 4
	`

	return rs, db.Raw(query, projectID).Scan(&rs).Error
}

func (s *store) GetGroupAuditByProjectNotionID(db *gorm.DB, projectID string) ([]*model.GroupAudit, error) {
	var rs []*model.GroupAudit

	query := `
		SELECT audit_cycles.quarter,
			avg(CASE
					When asy.score = 0 THEN null
					ELSE asy.score
				END) as system,
			avg(CASE
					When afe.score = 0 THEN null
					ELSE afe.score
				END) as frontend,
			avg(CASE
					When abe.score = 0 THEN null
					ELSE abe.score
				END) as backend,
			avg(CASE
					When ap.score = 0 THEN null
					ELSE ap.score
				END) as process,
			avg(CASE
					When ab.score = 0 THEN null
					ELSE ab.score
				END) as blockchain,
			avg(CASE
					When am.score = 0 THEN null
					ELSE am.score
				END) as mobile
		FROM audit_cycles
				LEFT JOIN audits AS afe ON audit_cycles.frontend_audit_id = afe.id
				LEFT JOIN audits AS abe ON audit_cycles.backend_audit_id = abe.id
				LEFT JOIN audits AS ap ON audit_cycles.process_audit_id = ap.id
				LEFT JOIN audits AS asy ON audit_cycles.system_audit_id = asy.id
				LEFT JOIN audits AS ab ON audit_cycles.blockchain_audit_id = ab.id
				LEFT JOIN audits AS am ON audit_cycles.mobile_audit_id = am.id
		WHERE audit_cycles.project_id = ? AND audit_cycles.deleted_at IS NULL AND afe.deleted_at IS NULL AND
			abe.deleted_at IS NULL AND ap.deleted_at IS NULL AND
			asy.deleted_at IS NULL AND ab.deleted_at IS NULL AND am.deleted_at IS NULL
		GROUP BY audit_cycles.quarter
		ORDER BY audit_cycles.quarter DESC
		LIMIT 4
	`

	return rs, db.Raw(query, projectID).Scan(&rs).Error
}

func (s *store) GetAllActionItemSquashReports(db *gorm.DB) ([]*model.ActionItemSquashReport, error) {
	var rs []*model.ActionItemSquashReport

	query := `
		WITH days AS (SELECT date_trunc('DAY', end_date) AS day
					FROM feedback_events
					WHERE subtype = 'work'
					GROUP BY date_trunc('DAY', end_date))
		SELECT (sum(high) + sum(medium) + sum(low)) as all,
			sum(high)                            as high,
			sum(medium)                          as medium,
			sum(low)                             as low,
			date_trunc('DAY', action_item_snapshots.created_at)     as snap_date
		FROM action_item_snapshots
				JOIN project_notions ON action_item_snapshots.project_id = project_notions.audit_notion_id
				JOIN projects ON project_notions.project_id = projects.id
				JOIN organizations ON projects.organization_id = organizations.id
				JOIN days ON date_trunc('DAY', action_item_snapshots.created_at) = date_trunc('DAY', days.day)
		WHERE projects.function = 'development'
			AND organizations.code = 'dwarves-foundation'
			AND action_item_snapshots.deleted_at IS NULL
			AND projects.deleted_at IS NULL
		GROUP BY snap_date
		ORDER BY snap_date desc
		LIMIT 12
	`

	return rs, db.Raw(query).Scan(&rs).Error
}

func (s *store) GetActionItemSquashReportsByProjectID(db *gorm.DB, projectID string) ([]*model.ActionItemSquashReport, error) {
	var rs []*model.ActionItemSquashReport

	query := `
		WITH days AS (SELECT date_trunc('DAY', end_date) AS day
					FROM feedback_events
					WHERE subtype = 'work'
					GROUP BY date_trunc('DAY', end_date))
		SELECT (sum(high) + sum(medium) + sum(low)) as all,
			sum(high)                            					as high,
			sum(medium)                          					as medium,
			sum(low)                             					as low,
			date_trunc('DAY', action_item_snapshots.created_at )    as snap_date
		FROM action_item_snapshots
				LEFT JOIN project_notions ON action_item_snapshots.project_id = project_notions.audit_notion_id
				JOIN projects ON project_notions.project_id = projects.id
				JOIN organizations ON projects.organization_id = organizations.id
				JOIN days ON date_trunc('DAY', action_item_snapshots.created_at) = date_trunc('DAY', days.day)
		WHERE projects.function = 'development'
			AND organizations.code = 'dwarves-foundation'
			AND action_item_snapshots.deleted_at IS NULL
			AND projects.deleted_at IS NULL
			AND projects.id = ?
		GROUP BY snap_date
		ORDER BY snap_date desc
		LIMIT 12
	`

	return rs, db.Raw(query, projectID).Scan(&rs).Error
}

func (s *store) GetAuditSummaries(db *gorm.DB) ([]*model.AuditSummary, error) {
	var rs []*model.AuditSummary

	query := `
		SELECT audit_cycles.quarter, p.id, p.name, p.code, p.avatar, SUM(audit_cycles.action_item_high) AS high, SUM(audit_cycles.action_item_medium) AS medium, SUM(audit_cycles.action_item_low) AS low,
			(SELECT count(*) FROM action_items WHERE status = 'done' AND audit_cycle_id = audit_cycles.id) as done,
			count(DISTINCT pm.id) as size,
			avg(CASE
					When a.score = 0 THEN NULL
					ELSE a.score
				END) as health,
			avg(CASE
					When audit_cycles.average_score = 0 THEN null
					ELSE audit_cycles.average_score
				END) AS audit
		FROM audit_cycles
				LEFT JOIN audits AS a ON audit_cycles.health_audit_id = a.id
				JOIN project_notions ON audit_cycles.project_id = project_notions.audit_notion_id
				JOIN projects AS p ON project_notions.project_id = p.id
				JOIN organizations ON p.organization_id = organizations.id
				JOIN project_members pm ON p.id = pm.project_id
		WHERE (pm.status = 'active' OR pm.status='on-boarding') AND audit_cycles.deleted_at IS NULL AND 
			a.deleted_at IS NULL AND pm.deleted_at IS NULL AND p.deleted_at IS NULL AND organizations.code = 'dwarves-foundation'
		GROUP BY audit_cycles.id,audit_cycles.quarter, p.id
		ORDER BY audit_cycles.quarter DESC`

	return rs, db.Raw(query).Scan(&rs).Error
}

func (s *store) GetProjectSizesByStartTime(db *gorm.DB, curr time.Time) ([]*model.ProjectSize, error) {
	var ru []*model.ProjectSize

	query := `
		SELECT projects.id, projects.name, projects.code, count(*) AS size
			FROM (projects 
				JOIN project_members pm ON projects.id = pm.project_id
				JOIN organizations ON projects.organization_id = organizations.id)
			WHERE projects.function = 'development' AND 
				organizations.code = 'dwarves-foundation' AND 
				pm.status = 'active' AND 
				projects.deleted_at IS NULL AND pm.deleted_at IS NULL AND
				(pm.status = 'active' OR pm.status='on-boarding') AND pm.start_date <= ?
			GROUP BY projects.id
	`

	return ru, db.Raw(query, curr.UTC()).Scan(&ru).Error
}

func (s *store) GetPendingSlots(db *gorm.DB) ([]*model.ProjectSlot, error) {
	var slots []*model.ProjectSlot
	return slots, db.
		Where(`id NOT IN (
			SELECT pm.project_slot_id
			FROM project_members pm
			WHERE (pm.end_date IS NULL OR pm.end_date > now()) AND pm.deleted_at IS NULL
		) AND project_id NOT IN (
			SELECT p.id
			FROM projects p
			WHERE p.status = ? AND p.deleted_at IS NULL
		) AND status = ?`, model.ProjectStatusClosed, model.ProjectMemberStatusPending).
		Order("updated_at").
		Preload("Seniority", "deleted_at IS NULL").
		Preload("Project", "deleted_at IS NULL").
		Preload("ProjectSlotPositions", "deleted_at IS NULL").
		Preload("ProjectSlotPositions.Position", "deleted_at IS NULL").
		Find(&slots).Error
}

func (s *store) GetAvailableEmployees(db *gorm.DB) ([]*model.Employee, error) {
	var employees []*model.Employee
	return employees, db.
		Where("working_status != ? ", model.WorkingStatusLeft).
		Where(`id IN (
			SELECT eo.employee_id
			FROM employee_organizations eo JOIN organizations o ON eo.organization_id = o.id
			WHERE o.deleted_at IS NULL AND eo.deleted_at IS NULL AND o.code = ?
		)`, model.OrganizationCodeDwarves).
		Where(`id NOT IN (
			SELECT pm.employee_id
			FROM project_members pm JOIN projects p ON pm.project_id = p.id
			WHERE p.type <> ?
				AND pm.deployment_type = ?
				AND p.status IN ?
				AND (pm.end_date IS NULL OR pm.end_date > now() + INTERVAL '2 months') 
				AND p.deleted_at IS NULL
				AND pm.deleted_at IS NULL
		)`,
			model.ProjectTypeDwarves,
			model.MemberDeploymentTypeOfficial,
			[]string{
				model.ProjectStatusOnBoarding.String(),
				model.ProjectStatusActive.String(),
			}).
		Where(`id IN (
			SELECT e2.id 
			FROM employees e2
				LEFT JOIN employee_chapters ec ON ec.employee_id = e2.id
				LEFT JOIN chapters c ON ec.chapter_id = c.id 
			WHERE ec.deleted_at IS NULL
				AND c.deleted_at IS NULL
				AND e2.deleted_at IS NULL
				AND (c.code IS NULL OR (c.code <> 'sales' AND c.code <> 'operations'))
		)`).
		Order("created_at, display_name").
		Preload("Seniority", "deleted_at IS NULL").
		Preload("EmployeePositions", "deleted_at IS NULL").
		Preload("EmployeePositions.Position", "deleted_at IS NULL").
		Preload("EmployeeStacks", "deleted_at IS NULL").
		Preload("EmployeeStacks.Stack", "deleted_at IS NULL").
		Preload("ProjectMembers", func(db *gorm.DB) *gorm.DB {
			return db.Joins("JOIN projects ON projects.id = project_members.project_id").
				Where("project_members.deleted_at IS NULL").
				Where("project_members.start_date <= now()").
				Where("(project_members.end_date IS NULL OR project_members.end_date > now())").
				Where("projects.status IN ?", []string{
					model.ProjectStatusOnBoarding.String(),
					model.ProjectStatusActive.String(),
				}).
				Order("projects.name")
		}).
		Preload("ProjectMembers.Project", "deleted_at IS NULL").
		Find(&employees).Error
}

func (s *store) GetResourceUtilization(db *gorm.DB, currentDate time.Time) ([]*model.ResourceUtilization, error) {
	var ru []*model.ResourceUtilization

	query := `
	WITH resource_utilization AS (
		SELECT d.d AS "date",
				e.id AS employee_id,
				p.id AS project_id,
				p."type" AS "project_type",
				pm.deployment_type,
				pm.start_date,
				pm.end_date AS pm_end_date,
				p.end_date AS p_end_date,
				e.left_date
		FROM employees e
			LEFT JOIN project_members pm ON pm.employee_id = e.id
			LEFT JOIN projects p ON pm.project_id = p.id,
			generate_series(
				date_trunc('month', TO_DATE(?, 'YYYY-MM-DD')) - INTERVAL '3 month',
				date_trunc('month', TO_DATE(?, 'YYYY-MM-DD')) + INTERVAL '3 month',
				'1 month'
			) d
		WHERE e.deleted_at IS NULL
			AND pm.deleted_at IS NULL
			AND p.deleted_at IS NULL
			AND e.id IN (
				SELECT e2.id
				FROM employees e2
					LEFT JOIN employee_chapters ec ON ec.employee_id = e2.id
					LEFT JOIN chapters c ON ec.chapter_id = c.id
				WHERE ec.deleted_at IS NULL
					AND c.deleted_at IS NULL
					AND e2.deleted_at IS NULL
					AND (c.code IS NULL OR (c.code <> 'sales' AND c.code <> 'operations'))
			)
			AND e.id IN (
				SELECT eo.employee_id 
				FROM employee_organizations eo JOIN organizations o ON eo.organization_id = o.id 
				WHERE o.code = ? 
					AND eo.deleted_at IS NULL 
					AND o.deleted_at IS NULL 
			)
		ORDER BY d.d
	)

	SELECT "date" ,
		COUNT(DISTINCT(employee_id)) FILTER (
			WHERE deployment_type = 'official'
				AND "project_type" != 'dwarves'
				AND start_date <= "date"
				AND (pm_end_date IS NULL OR pm_end_date > "date")
				AND (p_end_date IS NULL OR p_end_date > "date")
				AND (left_date IS NULL OR left_date > "date")
		) AS staffed,

		COUNT(DISTINCT(employee_id)) FILTER (
			WHERE start_date <= "date"
				AND (pm_end_date IS NULL OR pm_end_date > "date")
				AND employee_id NOT IN (
					SELECT ru2.employee_id
					FROM resource_utilization ru2
					WHERE ru2.deployment_type = 'official'
						AND ru2."project_type" != 'dwarves'
						AND ru2.start_date <= ru."date"
						AND (ru2.pm_end_date IS NULL OR ru2.pm_end_date > ru."date")
						AND (ru2.p_end_date IS NULL OR ru2.p_end_date > ru."date")
						AND (ru2.left_date IS NULL OR ru2.left_date > ru."date")
				)
				AND (left_date IS NULL OR left_date > "date")
		) AS internal,

		COUNT(DISTINCT(employee_id)) FILTER (
			WHERE (project_id IS NULL
				OR employee_id NOT IN (
					SELECT ru3.employee_id
					FROM resource_utilization ru3
					WHERE ru3.start_date <= ru."date"
						AND (ru3.pm_end_date IS NULL OR ru3.pm_end_date > ru."date")
						AND (ru3.p_end_date IS NULL OR ru3.p_end_date > ru."date")
						AND (ru3.left_date IS NULL OR ru3.left_date > ru."date")
				))
				AND (left_date IS NULL OR left_date > "date")
		) AS available
	FROM resource_utilization ru
	GROUP BY "date"
	`

	return ru, db.Raw(query, currentDate, currentDate, model.OrganizationCodeDwarves).Scan(&ru).Error
}

func (s *store) TotalWorkUnitDistribution(db *gorm.DB) (*model.TotalWorkUnitDistribution, error) {
	var rs *model.TotalWorkUnitDistribution

	query := `
		WITH
		employee_data AS (
			SELECT
				e.id,
				e.full_name,
				e.display_name,
				e.username,
				e.avatar,
				e.line_manager_id,
				o.code as organization_code
			FROM employees e
				LEFT JOIN employee_organizations eo on e.id = eo.employee_id
				LEFT JOIN organizations o on eo.organization_id = o.id
			WHERE
				e.deleted_at IS NULL AND o.code = 'dwarves-foundation'
		),
		work_unit_info AS (
			SELECT
				wum.employee_id,
				wu.type,
				COUNT(*) AS work_unit_count
			FROM work_units wu
					JOIN work_unit_members wum ON wu.id = wum.work_unit_id
			WHERE
				wum.status = 'active'
				AND wu.status = 'active'
				AND wum.deleted_at IS NULL
				AND wu.deleted_at IS NULL
			GROUP BY wum.employee_id, wu.type),
			count_work_unit_distribution AS (
				SELECT
					e.id,
					e.full_name,
					e.display_name,
					e.username,
					e.avatar,
					(SELECT COUNT(*)
					FROM employee_data
					WHERE line_manager_id = e.id)                   AS line_manager_count,
					(SELECT COUNT(*)
					FROM project_heads ph
					WHERE (ph.position = 'technical-lead' OR
							ph.position = 'delivery-manager' OR
							ph.position = 'account-manager')
						AND ph.employee_id = e.id
						AND ph.end_date IS NULL)                 AS project_head_count,
					COALESCE(wui_learning.work_unit_count, 0)    AS learning,
					COALESCE(wui_development.work_unit_count, 0) AS development,
					COALESCE(wui_management.work_unit_count, 0)  AS management,
					COALESCE(wui_training.work_unit_count, 0)    AS training
				FROM
					employee_data e
					LEFT JOIN work_unit_info wui_learning
								ON e.id = wui_learning.employee_id AND wui_learning.type = 'learning'
					LEFT JOIN work_unit_info wui_development
								ON e.id = wui_development.employee_id AND
									wui_development.type = 'development'
					LEFT JOIN work_unit_info wui_management
								ON e.id = wui_management.employee_id AND wui_management.type = 'management'
					LEFT JOIN work_unit_info wui_training
								ON e.id = wui_training.employee_id AND wui_training.type = 'training')
		SELECT
			SUM(line_manager_count) AS total_line_manager,
			SUM(project_head_count) AS total_project_head,
			SUM(learning)           AS total_learning,
			SUM(development)        AS total_development,
			SUM(management)         AS total_management,
			SUM(training)           AS total_training
		FROM count_work_unit_distribution
	`
	return rs, db.Raw(query).Scan(&rs).Error
}

func (s *store) GetAllWorkReviews(db *gorm.DB, keyword string, pagination model.Pagination) ([]*model.EmployeeEventReviewer, error) {
	var eer []*model.EmployeeEventReviewer

	query := db.Table("employee_event_reviewers").
		Joins(`JOIN feedback_events fe ON employee_event_reviewers.event_id = fe.id 
			AND fe.deleted_at IS NULL
			AND fe.subtype = ?
			AND fe.start_date > now() - INTERVAL '70 DAYS'`, model.EventSubtypeWork). // last 10 weeks
		Joins("JOIN employee_event_topics eet ON employee_event_reviewers.employee_event_topic_id = eet.id").
		Joins("JOIN employees e ON employee_event_reviewers.reviewer_id = e.id AND e.deleted_at IS NULL")

	limit, offset := pagination.ToLimitOffset()

	if keyword != "" {
		query = query.Where("e.keyword_vector @@ plainto_tsquery('english_nostop', fn_remove_vietnamese_accents(LOWER(?)))", keyword)
	}

	query = query.Where("employee_event_reviewers.reviewer_status = ?", model.EventReviewerStatusDone)

	return eer, query.Order("fe.end_date, employee_event_reviewers.reviewer_id, eet.project_id").
		Preload("Event", "deleted_at IS NULL").
		Preload("Reviewer", "deleted_at IS NULL").
		Preload("EmployeeEventQuestions", "deleted_at IS NULL").
		Preload("EmployeeEventTopic", "deleted_at IS NULL").
		Preload("EmployeeEventTopic.Project", "deleted_at IS NULL").
		Limit(limit).
		Offset(offset).
		Find(&eer).Error
}

func (s *store) GetProjectHeadByEmployeeID(db *gorm.DB, employeeID string) ([]*model.ManagementInfo, error) {
	var rs []*model.ManagementInfo

	query := `
		SELECT projects.id, projects.name, projects.code, projects.type, projects.status, projects.avatar, ph.position
		FROM projects
				JOIN project_heads AS ph ON projects.id = ph.project_id
		WHERE ph.employee_id = ? AND projects.status IN (?, ?)
	`

	return rs, db.Raw(query, employeeID, model.ProjectStatusActive, model.ProjectStatusOnBoarding).Scan(&rs).Error
}

func (s *store) GetWorkUnitDistributionEmployees(db *gorm.DB, keyword string, workUnitType string) ([]*model.Employee, error) {
	var employees []*model.Employee

	query := db.Table("employees")

	if keyword != "" {
		query = query.Where("keyword_vector @@ plainto_tsquery('english_nostop', fn_remove_vietnamese_accents(LOWER(?)))", keyword)
	}

	query = query.Where("deleted_at IS NULL").
		Where("working_status IN ?", []string{
			model.WorkingStatusFullTime.String(),
			model.WorkingStatusContractor.String(),
		}).
		Order("display_name ASC")

	// preload mentees
	if workUnitType == "" || workUnitType == model.WorkUnitTypeTraining.String() {
		query = query.Preload("Mentees", "deleted_at IS NULL AND working_status IN ?", []string{
			model.WorkingStatusFullTime.String(),
			model.WorkingStatusContractor.String(),
		})
	}

	// preload project heads
	if workUnitType == "" || workUnitType == model.WorkUnitTypeManagement.String() {
		query = query.Preload("Heads", func(db *gorm.DB) *gorm.DB {
			return db.Joins("JOIN projects p ON project_heads.project_id = p.id").
				Where("(project_heads.start_date IS NULL OR project_heads.start_date <= now())").
				Where("(project_heads.end_date IS NULL OR project_heads.end_date > now())").
				Where("p.status IN ?", []string{
					model.ProjectStatusActive.String(),
					model.ProjectStatusOnBoarding.String(),
				}).
				Where("project_heads.deleted_at IS NULL").
				Where("p.deleted_at IS NULL")
		}).Preload("Heads.Project", "deleted_at IS NULL")
	}

	// preload work units
	query = query.Preload("WorkUnitMembers", func(db *gorm.DB) *gorm.DB {
		db = db.
			Joins("JOIN work_units wu ON wu.id = work_unit_members.work_unit_id").
			Joins("JOIN projects p ON p.id = wu.project_id").
			Joins("JOIN project_members pm ON pm.project_id = work_unit_members.project_id AND pm.employee_id = work_unit_members.employee_id").
			Where("wu.status = ?", model.WorkUnitStatusActive).
			Where("p.status IN ?", []string{
				model.ProjectStatusActive.String(),
				model.ProjectStatusOnBoarding.String(),
			}).
			Where("pm.start_date <= now() AND (pm.end_date IS NULL OR pm.end_date > now())").
			Where("p.deleted_at IS NULL").
			Where("pm.deleted_at IS NULL").
			Where("wu.deleted_at IS NULL").
			Where("work_unit_members.deleted_at IS NULL")

		if workUnitType != "" {
			db = db.Where("wu.type = ?", workUnitType)
		}

		return db
	}).
		Preload("WorkUnitMembers.WorkUnit").
		Preload("WorkUnitMembers.WorkUnit.Project")

	return employees, query.Find(&employees).Error
}

```

# pkg/store/currency/interface.go

```go
package currency

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	GetByName(db *gorm.DB, name string) (*model.Currency, error)
	GetList(db *gorm.DB) ([]model.Currency, error)
}

```

# pkg/store/currency/currency.go

```go
package currency

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type currencyService struct{}

// New create new pg service
func New() IStore {
	return &currencyService{}
}

func (c currencyService) GetByName(db *gorm.DB, name string) (*model.Currency, error) {
	currency := &model.Currency{}
	return currency, db.Where("name = ?", name).First(currency).Error
}

func (c currencyService) GetList(db *gorm.DB) ([]model.Currency, error) {
	var currencies []model.Currency
	return currencies, db.Find(&currencies).Error
}

```

# pkg/store/country/interface.go

```go
package country

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB) (countries []*model.Country, err error)
	One(db *gorm.DB, id string) (countries *model.Country, err error)
	OneByName(db *gorm.DB, name string) (countries *model.Country, err error)
	IsExist(db *gorm.DB, id string) (bool, error)
}

```

# pkg/store/country/country.go

```go
package country

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// All get all countries
func (s *store) All(db *gorm.DB) ([]*model.Country, error) {
	var countries []*model.Country
	return countries, db.Find(&countries).Error
}

// One get 1 country by id
func (s *store) One(db *gorm.DB, id string) (*model.Country, error) {
	var country *model.Country
	return country, db.Where("id = ?", id).First(&country).Error
}

// OneByName get 1 country by name
func (s *store) OneByName(db *gorm.DB, name string) (*model.Country, error) {
	var country *model.Country
	return country, db.Where("name = ?", name).First(&country).Error
}

// IsExist check country existence
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM countries WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

```

# pkg/store/conversionrate/interface.go

```go
package conversionrate

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	GetByCurrencyID(db *gorm.DB, id string) (*model.ConversionRate, error)
	GetList(db *gorm.DB) ([]model.ConversionRate, error)
	Update(db *gorm.DB, cr *model.ConversionRate) error
}

```

# pkg/store/conversionrate/conversion_rate.go

```go
package conversionrate

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

// New create new pg service
func New() IStore {
	return &store{}
}

func (c *store) GetByCurrencyID(db *gorm.DB, id string) (*model.ConversionRate, error) {
	rs := &model.ConversionRate{}
	return rs, db.Where("id = ?", id).Preload("Currency").First(rs).Error
}

func (c *store) GetList(db *gorm.DB) ([]model.ConversionRate, error) {
	var rs []model.ConversionRate
	return rs, db.Preload("Currency").Find(&rs).Error
}

func (s *store) Update(db *gorm.DB, cr *model.ConversionRate) error {
	return db.Model(&cr).Where("currency_id = ?", cr.CurrencyID).Updates(&cr).Error
}

```

# pkg/store/discordaccount/interface.go

```go
package discordaccount

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB) (discordAccounts []*model.DiscordAccount, err error)
	One(db *gorm.DB, id string) (*model.DiscordAccount, error)
	OneByDiscordID(db *gorm.DB, discordID string) (*model.DiscordAccount, error)

	Upsert(db *gorm.DB, da *model.DiscordAccount) (*model.DiscordAccount, error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, client model.DiscordAccount, updatedFields ...string) (a *model.DiscordAccount, err error)

	// ListByMemoUsername gets a list of discord accounts by memo usernames
	ListByMemoUsername(db *gorm.DB, usernames []string) ([]model.DiscordAccount, error)
}

```

# pkg/store/discordaccount/discord_account.go

```go
package discordaccount

import (
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct {
}

func New() IStore {
	return &store{}
}

func (r *store) Upsert(db *gorm.DB, da *model.DiscordAccount) (*model.DiscordAccount, error) {
	return da, db.
		Table("discord_accounts").
		Clauses(
			clause.OnConflict{
				Columns: []clause.Column{
					{Name: "discord_id"},
				},
				DoUpdates: clause.Assignments(
					map[string]interface{}{
						"discord_username": da.DiscordUsername,
						"roles":            da.Roles,
						"github_username":  da.GithubUsername,
						"personal_email":   da.PersonalEmail,
					},
				),
			},
		).
		Create(da).
		Error
}

func (r *store) All(db *gorm.DB) ([]*model.DiscordAccount, error) {
	var res []*model.DiscordAccount
	return res, db.Find(&res).Error
}

func (r *store) One(db *gorm.DB, id string) (*model.DiscordAccount, error) {
	res := model.DiscordAccount{}
	return &res, db.Where("id = ?", id).First(&res).Error
}

func (r *store) OneByDiscordID(db *gorm.DB, discordID string) (*model.DiscordAccount, error) {
	res := model.DiscordAccount{}
	return &res, db.Where("discord_id = ?", discordID).First(&res).Error
}

func (r *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.DiscordAccount, updatedFields ...string) (a *model.DiscordAccount, err error) {
	discordAccount := model.DiscordAccount{}
	return &discordAccount, db.Model(&discordAccount).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// ListByMemoUsername gets a list of discord accounts by memo usernames, if memo username is not found, it will try to find by discord username
func (r *store) ListByMemoUsername(db *gorm.DB, usernames []string) ([]model.DiscordAccount, error) {
	var cms []model.DiscordAccount
	err := db.Where("memo_username IN (?) OR discord_username IN (?)", usernames, usernames).Find(&cms).Error
	return cms, err
}

```

# pkg/store/content/interface.go

```go
package content

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type IStore interface {
	Create(tx *gorm.DB, content model.Content) (*model.Content, error)
	OneByPath(tx *gorm.DB, path string) (*model.Content, error)
}

```

# pkg/store/content/content.go

```go
package content

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct {
}

func New() IStore {
	return &store{}
}

// Create a content record
func (s *store) Create(tx *gorm.DB, content model.Content) (*model.Content, error) {
	return &content, tx.Create(&content).Error
}

// OneByPath get content by name
func (s *store) OneByPath(tx *gorm.DB, path string) (*model.Content, error) {
	content := model.Content{}
	return &content, tx.
		Where("LOWER(path) = LOWER(?)", path).First(&content).Error
}

```

# pkg/store/companyinfo/interface.go

```go
package companyinfo

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (companyInfo *model.CompanyInfo, err error)
	IsExist(db *gorm.DB, id string) (exists bool, err error)
	All(db *gorm.DB) (companyInfos []*model.CompanyInfo, err error)
}

```

# pkg/store/companyinfo/companyinfo.go

```go
package companyinfo

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get companyInfo by id
func (s *store) One(db *gorm.DB, id string) (*model.CompanyInfo, error) {
	var companyInfo *model.CompanyInfo
	return companyInfo, db.Where("id = ?", id).First(&companyInfo).Error
}

// IsExist check client contact existence
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM company_infos WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

// All get all companyInfo
func (s *store) All(db *gorm.DB) ([]*model.CompanyInfo, error) {
	var companyInfo []*model.CompanyInfo
	return companyInfo, db.Find(&companyInfo).Error
}

```

# pkg/store/config/interface.go

```go
package config

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (config *model.Config, err error)
	OneByKey(db *gorm.DB, key string) (config *model.Config, err error)
	Save(db *gorm.DB, salaryAdvance *model.Config) (err error)
}

```

# pkg/store/config/config.go

```go
package config

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) One(db *gorm.DB, id string) (*model.Config, error) {
	var config *model.Config
	return config, db.Where("id = ?", id).
		First(&config).Error
}

func (s *store) OneByKey(db *gorm.DB, key string) (*model.Config, error) {
	var config *model.Config
	return config, db.Where("key = ?", key).
		First(&config).Error
}

func (s *store) Save(db *gorm.DB, config *model.Config) (err error) {
	return db.Save(&config).Error
}

```

# pkg/store/clientcontact/interface.go

```go
package clientcontact

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (clientContact *model.ClientContact, err error)
	IsExist(db *gorm.DB, id string) (exists bool, err error)
	All(db *gorm.DB) (clientContacts []*model.ClientContact, err error)
	Delete(db *gorm.DB, id string) (err error)
	DeleteByClientID(db *gorm.DB, clientID string) (err error)
	Create(db *gorm.DB, e *model.ClientContact) (clientContact *model.ClientContact, err error)
	Update(db *gorm.DB, clientContact *model.ClientContact) (a *model.ClientContact, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, clientContact model.ClientContact, updatedFields ...string) (a *model.ClientContact, err error)
}

```

# pkg/store/clientcontact/clientcontact.go

```go
package clientcontact

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get clientContact by id
func (s *store) One(db *gorm.DB, id string) (*model.ClientContact, error) {
	var clientContact *model.ClientContact
	return clientContact, db.Where("id = ?", id).First(&clientContact).Error
}

// IsExist check client contact existence
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM client_contacts WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

// All get all clientContact
func (s *store) All(db *gorm.DB) ([]*model.ClientContact, error) {
	var clientContact []*model.ClientContact
	return clientContact, db.Find(&clientContact).Error
}

// Delete delete 1 clientContact by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.ClientContact{}).Error
}

// Delete delete 1 clientContact by id
func (s *store) DeleteByClientID(db *gorm.DB, clientID string) error {
	return db.Where("client_id = ?", clientID).Delete(&model.ClientContact{}).Error
}

// Create creates a new clientContact
func (s *store) Create(db *gorm.DB, e *model.ClientContact) (clientContact *model.ClientContact, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, clientContact *model.ClientContact) (*model.ClientContact, error) {
	return clientContact, db.Model(&clientContact).Where("id = ?", clientContact.ID).Updates(&clientContact).First(&clientContact).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ClientContact, updatedFields ...string) (*model.ClientContact, error) {
	clientContact := model.ClientContact{}
	return &clientContact, db.Model(&clientContact).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

```

# pkg/store/client/interface.go

```go
package client

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (client *model.Client, err error)
	IsExist(db *gorm.DB, id string) (exists bool, err error)
	All(db *gorm.DB, public bool, preload bool) ([]*model.Client, error)
	Delete(db *gorm.DB, id string) (err error)
	Create(db *gorm.DB, e *model.Client) (client *model.Client, err error)
	Update(db *gorm.DB, client *model.Client) (a *model.Client, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, client model.Client, updatedFields ...string) (a *model.Client, err error)
}

```

# pkg/store/client/client.go

```go
package client

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get client by id
func (s *store) One(db *gorm.DB, id string) (*model.Client, error) {
	var client *model.Client
	return client, db.Where("id = ?", id).Preload("Contacts", "deleted_at IS NULL").First(&client).Error
}

// IsExist check client existence
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM clients WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

// All get all client
func (s *store) All(db *gorm.DB, public bool, preload bool) ([]*model.Client, error) {
	var client []*model.Client

	query := db.Preload("Contacts", "deleted_at IS NULL")

	if preload {
		query = query.
			Preload("Projects").
			Preload("Projects.ProjectStacks").
			Preload("Projects.ProjectStacks.Stack")
	}

	if public {
		query = query.Where("is_public = ?", true)
	}

	return client, query.Find(&client).Error
}

// Delete delete 1 client by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.Client{}).Error
}

// Create creates a new client
func (s *store) Create(db *gorm.DB, e *model.Client) (client *model.Client, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, client *model.Client) (*model.Client, error) {
	return client, db.Model(&client).Where("id = ?", client.ID).Updates(&client).First(&client).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Client, updatedFields ...string) (*model.Client, error) {
	client := model.Client{}
	return &client, db.Model(&client).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

```

# pkg/store/chapter/interface.go

```go
package chapter

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB) (chapters []*model.Chapter, err error)
	IsExist(db *gorm.DB, id string) (isExist bool, err error)
	UpdateChapterLead(db *gorm.DB, id string, lead *model.UUID) (err error)
	GetAllByLeadID(db *gorm.DB, leadID string) (chapters []*model.Chapter, err error)
}

```

# pkg/store/chapter/chapter.go

```go
package chapter

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// All get all chapters
func (s *store) All(db *gorm.DB) ([]*model.Chapter, error) {
	var chapters []*model.Chapter
	return chapters, db.Find(&chapters).Error
}

// IsExist check existence of a chapter
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM chapters WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

func (s *store) UpdateChapterLead(db *gorm.DB, id string, lead *model.UUID) error {
	return db.Table("chapters").Where("id = ?", id).Update("lead_id", lead).Error
}

// GetAllByLeadID get all chapters by lead_id
func (s *store) GetAllByLeadID(db *gorm.DB, leadID string) ([]*model.Chapter, error) {
	var chapters []*model.Chapter
	return chapters, db.Where("lead_id = ?", leadID).Find(&chapters).Error
}

```

# pkg/store/cachedpayroll/interface.go

```go
package cachedpayroll

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type IStore interface {
	Set(db *gorm.DB, cachedPayroll *model.CachedPayroll) error
	Get(db *gorm.DB, month, year, batch int) (*model.CachedPayroll, error)
}

```

# pkg/store/cachedpayroll/cached_payroll.go

```go
package cachedpayroll

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

// New create new pg service
func New() IStore {
	return &store{}
}

func (s *store) Set(db *gorm.DB, cachedPayroll *model.CachedPayroll) error {
	return db.Save(cachedPayroll).Error
}

func (s *store) Get(db *gorm.DB, month, year, batch int) (*model.CachedPayroll, error) {
	p := model.CachedPayroll{}
	return &p, db.Where("month = ? AND year = ? AND batch = ?", month, year, batch).First(&p).Error
}

```

# pkg/store/bankaccount/interface.go

```go
package bankaccount

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (bankAccount *model.BankAccount, err error)
	All(db *gorm.DB) (bankAccounts []*model.BankAccount, err error)
	IsExist(db *gorm.DB, id string) (exists bool, err error)
}

```

# pkg/store/bankaccount/bank_account.go

```go
package bankaccount

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get bank account by id
func (s *store) One(db *gorm.DB, id string) (*model.BankAccount, error) {
	var bankAccount *model.BankAccount
	return bankAccount, db.Where("id = ?", id).
		Preload("Currency").
		First(&bankAccount).Error
}

// All get all bank account
func (s *store) All(db *gorm.DB) ([]*model.BankAccount, error) {
	var bankAccounts []*model.BankAccount
	return bankAccounts, db.Preload("Currency").Find(&bankAccounts).Error
}

// IsExist check bank account existence
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM bank_accounts WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

```

# pkg/store/basesalary/interface.go

```go
package basesalary

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (baseSalary *model.BaseSalary, err error)
	OneByEmployeeID(db *gorm.DB, employeeID string) (baseSalary *model.BaseSalary, err error)
	Save(db *gorm.DB, baseSalary *model.BaseSalary) (err error)
}

```

# pkg/store/basesalary/base_salary.go

```go
package basesalary

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) One(db *gorm.DB, id string) (*model.BaseSalary, error) {
	var baseSalary *model.BaseSalary
	return baseSalary, db.Where("id = ?", id).
		Preload("Currency").
		First(&baseSalary).Error
}

func (s *store) OneByEmployeeID(db *gorm.DB, employeeID string) (*model.BaseSalary, error) {
	var baseSalary *model.BaseSalary
	return baseSalary, db.Where("employee_id = ?", employeeID).
		Preload("Currency").
		First(&baseSalary).Error
}

func (s *store) Save(db *gorm.DB, baseSalary *model.BaseSalary) (err error) {
	return db.Save(&baseSalary).Preload("Currency").Error
}

```

# pkg/store/brainerylog/interface.go

```go
package brainerylog

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, b []model.BraineryLog) ([]model.BraineryLog, error)
	GetLimitByTimeRange(db *gorm.DB, start, end *time.Time, limit int) ([]*model.BraineryLog, error)
	GetNewContributorDiscordIDs(db *gorm.DB, start, end *time.Time) ([]string, error)
}

```

# pkg/store/brainerylog/brainery_log.go

```go
package brainerylog

import (
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// Create creates a brainery log record in the database
func (s *store) Create(db *gorm.DB, b []model.BraineryLog) (braineryLog []model.BraineryLog, err error) {
	return b, db.Create(b).Error
}

// GetLimitByTimeRange gets brainery logs in a specific time range, with limit
func (s *store) GetLimitByTimeRange(db *gorm.DB, start, end *time.Time, limit int) ([]*model.BraineryLog, error) {
	var logs []*model.BraineryLog
	return logs, db.Where("published_at BETWEEN ? AND ?", start, end).Limit(limit).Order("published_at DESC").Find(&logs).Error
}

// GetNewContributorDiscordIDs gets list of discord IDs from new contributors in a specific time range
func (s *store) GetNewContributorDiscordIDs(db *gorm.DB, start, end *time.Time) ([]string, error) {
	var discordIDs []string
	subQuery := db.Select("DISTINCT(discord_id)").Where("published_at <= ?", start).Table("brainery_logs")
	return discordIDs, db.Table("brainery_logs").
		Where("published_at BETWEEN ? AND ? AND discord_id NOT IN (?)", start, end, subQuery).
		Distinct().
		Pluck("discord_id", &discordIDs).Error
}

```

# pkg/store/bank/interface.go

```go
package bank

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (bank *model.Bank, err error)
	OneByBin(db *gorm.DB, bin string) (bank *model.Bank, err error)
	OneBySwiftCode(db *gorm.DB, code string) (bank *model.Bank, err error)
	All(db *gorm.DB, in GetBanksInput) ([]*model.Bank, error)
	IsExist(db *gorm.DB, id string) (exists bool, err error)
}

```

# pkg/store/bank/bank.go

```go
package bank

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get bank account by id
func (s *store) One(db *gorm.DB, id string) (*model.Bank, error) {
	var bankAccount *model.Bank
	return bankAccount, db.Where("id = ?", id).First(&bankAccount).Error
}

type GetBanksInput struct {
	ID        string
	Bin       string
	SwiftCode string
}

// All get all bank account
func (s *store) All(db *gorm.DB, in GetBanksInput) ([]*model.Bank, error) {
	var banks []*model.Bank

	query := db.Where("deleted_at IS NULL")
	if in.ID != "" {
		query = query.Where("id = ?", in.ID)
	}
	if in.Bin != "" {
		query = query.Where("bin = ?", in.Bin)
	}
	if in.SwiftCode != "" {
		query = query.Where("swift_code = ?", in.SwiftCode)
	}

	return banks, query.Find(&banks).Error
}

// IsExist check bank account existence
func (s *store) IsExist(db *gorm.DB, id string) (bool, error) {
	type res struct {
		Result bool
	}

	result := res{}
	query := db.Raw("SELECT EXISTS (SELECT * FROM banks WHERE id = ?) as result", id)

	return result.Result, query.Scan(&result).Error
}

// OneByBin get bank account by bin
func (s *store) OneByBin(db *gorm.DB, bin string) (bank *model.Bank, err error) {
	var bankAccount *model.Bank
	return bankAccount, db.Where("bin = ?", bin).First(&bankAccount).Error
}

// OneBySwiftCode get bank account by swift code
func (s *store) OneBySwiftCode(db *gorm.DB, code string) (bank *model.Bank, err error) {
	var bankAccount *model.Bank
	return bankAccount, db.Where("swift_code = ?", code).First(&bankAccount).Error
}

```

# pkg/store/audititem/interface.go

```go
package audititem

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (auditItem *model.AuditItem, err error)
	All(db *gorm.DB) (auditItems []*model.AuditItem, err error)
	AllByAuditID(db *gorm.DB, auditID string) (auditItems []*model.AuditItem, err error)
	Delete(db *gorm.DB, id string) (err error)
	DeleteByAuditID(db *gorm.DB, auditID string) (err error)
	Create(db *gorm.DB, e *model.AuditItem) (auditItem *model.AuditItem, err error)
	Update(db *gorm.DB, auditItem *model.AuditItem) (ac *model.AuditItem, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, auditItem model.AuditItem, updatedFields ...string) (ac *model.AuditItem, err error)
}

```

# pkg/store/audititem/audit_item.go

```go
package audititem

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get audit item by id
func (s *store) One(db *gorm.DB, id string) (*model.AuditItem, error) {
	var auditItem *model.AuditItem
	return auditItem, db.Where("id = ?", id).First(&auditItem).Error
}

// All get all audit item
func (s *store) All(db *gorm.DB) ([]*model.AuditItem, error) {
	var auditItems []*model.AuditItem
	return auditItems, db.Find(&auditItems).Error
}

// All get all audit item by audit id
func (s *store) AllByAuditID(db *gorm.DB, auditID string) ([]*model.AuditItem, error) {
	var auditItems []*model.AuditItem
	return auditItems, db.Where("audit_id = ?", auditID).Find(&auditItems).Error
}

// Delete delete 1 audit item by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.AuditItem{}).Error
}

// DeleteByAuditID delete 1 audit item by audit id
func (s *store) DeleteByAuditID(db *gorm.DB, auditID string) error {
	return db.Where("audit_id = ?", auditID).Delete(&model.AuditItem{}).Error
}

// Create creates a new audit item
func (s *store) Create(db *gorm.DB, e *model.AuditItem) (auditItem *model.AuditItem, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, auditItem *model.AuditItem) (*model.AuditItem, error) {
	return auditItem, db.Model(&auditItem).Where("id = ?", auditItem.ID).Updates(&auditItem).First(&auditItem).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.AuditItem, updatedFields ...string) (*model.AuditItem, error) {
	auditItem := model.AuditItem{}
	return &auditItem, db.Model(&auditItem).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

```

# pkg/store/auditparticipant/interface.go

```go
package auditparticipant

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB) (auditParticipants []*model.AuditParticipant, err error)
	AllByAuditID(db *gorm.DB, auditID string) (auditParticipants []*model.AuditParticipant, err error)
	Delete(db *gorm.DB, id string) (err error)
	DeleteByAuditID(db *gorm.DB, auditID string) (err error)
	Create(db *gorm.DB, e *model.AuditParticipant) (auditParticipant *model.AuditParticipant, err error)
	Update(db *gorm.DB, auditParticipant *model.AuditParticipant) (ac *model.AuditParticipant, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, auditParticipant model.AuditParticipant, updatedFields ...string) (ac *model.AuditParticipant, err error)
}

```

# pkg/store/auditparticipant/audit_participant.go

```go
package auditparticipant

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// All get all audit participant
func (s *store) All(db *gorm.DB) ([]*model.AuditParticipant, error) {
	var auditParticipants []*model.AuditParticipant
	return auditParticipants, db.Find(&auditParticipants).Error
}

// All get all audit participant
func (s *store) AllByAuditID(db *gorm.DB, auditID string) ([]*model.AuditParticipant, error) {
	var auditParticipants []*model.AuditParticipant
	return auditParticipants, db.Where("audit_id = ?", auditID).Find(&auditParticipants).Error
}

// Delete delete 1 audit participant by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.AuditParticipant{}).Error
}

// DeleteByAuditID delete 1 audit participant by audit id
func (s *store) DeleteByAuditID(db *gorm.DB, auditID string) error {
	return db.Where("id = ?", auditID).Delete(&model.AuditParticipant{}).Error
}

// Create creates a new audit participant
func (s *store) Create(db *gorm.DB, e *model.AuditParticipant) (auditParticipant *model.AuditParticipant, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, auditParticipant *model.AuditParticipant) (*model.AuditParticipant, error) {
	return auditParticipant, db.Model(&auditParticipant).Where("id = ?", auditParticipant.ID).Updates(&auditParticipant).First(&auditParticipant).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.AuditParticipant, updatedFields ...string) (*model.AuditParticipant, error) {
	auditParticipant := model.AuditParticipant{}
	return &auditParticipant, db.Model(&auditParticipant).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

```

# pkg/store/auditactionitem/interface.go

```go
package auditactionitem

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	All(db *gorm.DB) (auditActionItems []*model.AuditActionItem, err error)
	AllByAuditID(db *gorm.DB, auditID string) (auditActionItems []*model.AuditActionItem, err error)
	Delete(db *gorm.DB, id string) (err error)
	DeleteByAuditID(db *gorm.DB, auditID string) (err error)
	Create(db *gorm.DB, e *model.AuditActionItem) (auditActionItem *model.AuditActionItem, err error)
	Update(db *gorm.DB, auditActionItem *model.AuditActionItem) (ac *model.AuditActionItem, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, auditActionItem model.AuditActionItem, updatedFields ...string) (ac *model.AuditActionItem, err error)
}

```

# pkg/store/auditactionitem/audit_action_item.go

```go
package auditactionitem

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// All get all audit action item
func (s *store) All(db *gorm.DB) ([]*model.AuditActionItem, error) {
	var auditActionItems []*model.AuditActionItem
	return auditActionItems, db.Find(&auditActionItems).Error
}

// All get all audit action item
func (s *store) AllByAuditID(db *gorm.DB, auditID string) ([]*model.AuditActionItem, error) {
	var auditActionItems []*model.AuditActionItem
	return auditActionItems, db.Where("audit_id = ?", auditID).Find(&auditActionItems).Error
}

// Delete delete 1 audit action item by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.AuditActionItem{}).Error
}

// DeleteByAuditID delete 1 audit action item by id
func (s *store) DeleteByAuditID(db *gorm.DB, auditID string) error {
	return db.Where("id = ?", auditID).Delete(&model.AuditActionItem{}).Error
}

// Create creates a new audit action item
func (s *store) Create(db *gorm.DB, e *model.AuditActionItem) (auditActionItem *model.AuditActionItem, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, auditActionItem *model.AuditActionItem) (*model.AuditActionItem, error) {
	return auditActionItem, db.Model(&auditActionItem).Where("id = ?", auditActionItem.ID).Updates(&auditActionItem).First(&auditActionItem).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.AuditActionItem, updatedFields ...string) (*model.AuditActionItem, error) {
	auditActionItem := model.AuditActionItem{}
	return &auditActionItem, db.Model(&auditActionItem).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

```

# pkg/store/auditcycle/interface.go

```go
package auditcycle

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (auditCycle *model.AuditCycle, err error)
	All(db *gorm.DB) (auditCycles []*model.AuditCycle, err error)
	Delete(db *gorm.DB, id string) (err error)
	Create(db *gorm.DB, e *model.AuditCycle) (auditCycle *model.AuditCycle, err error)
	Update(db *gorm.DB, auditCycle *model.AuditCycle) (ac *model.AuditCycle, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, auditCycle model.AuditCycle, updatedFields ...string) (ac *model.AuditCycle, err error)
	ResetActionItem(db *gorm.DB) (err error)
}

```

# pkg/store/auditcycle/audit_cycle.go

```go
package auditcycle

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get audit cycle by id
func (s *store) One(db *gorm.DB, id string) (*model.AuditCycle, error) {
	var auditCycle *model.AuditCycle
	return auditCycle, db.Where("id = ?", id).First(&auditCycle).Error
}

// All get all audit cycle
func (s *store) All(db *gorm.DB) ([]*model.AuditCycle, error) {
	var auditCycles []*model.AuditCycle
	return auditCycles, db.Preload("Project", "deleted_at IS NULL").Find(&auditCycles).Error
}

// Delete delete 1 audit cycle by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.AuditCycle{}).Error
}

// Create creates a new audit cycle
func (s *store) Create(db *gorm.DB, e *model.AuditCycle) (auditCycle *model.AuditCycle, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, auditCycle *model.AuditCycle) (*model.AuditCycle, error) {
	return auditCycle, db.Model(&auditCycle).Where("id = ?", auditCycle.ID).Updates(&auditCycle).First(&auditCycle).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.AuditCycle, updatedFields ...string) (*model.AuditCycle, error) {
	auditCycle := model.AuditCycle{}
	return &auditCycle, db.Model(&auditCycle).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// ResetActionItem reset action_item high medium low to 0 in audit_cycle table
func (s *store) ResetActionItem(db *gorm.DB) error {
	return db.Model(&model.AuditCycle{}).Where("deleted_at IS NULL").Updates(map[string]interface{}{"action_item_high": 0, "action_item_medium": 0, "action_item_low": 0}).Error
}

```

# pkg/store/apikeyrole/interface.go

```go
package apikeyrole

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	Create(db *gorm.DB, e *model.APIKeyRole) (*model.APIKeyRole, error)
}

```

# pkg/store/apikeyrole/api_key_role.go

```go
package apikeyrole

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) Create(db *gorm.DB, e *model.APIKeyRole) (*model.APIKeyRole, error) {
	return e, db.Create(e).Error
}

```

# pkg/store/actionitemsnapshot/interface.go

```go
package actionitemsnapshot

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (actionItemSnapshot *model.ActionItemSnapshot, err error)
	All(db *gorm.DB) (actionItemSnapshots []*model.ActionItemSnapshot, err error)
	Delete(db *gorm.DB, id string) (err error)
	Create(db *gorm.DB, e *model.ActionItemSnapshot) (actionItemSnapshot *model.ActionItemSnapshot, err error)
	Update(db *gorm.DB, actionItemSnapshot *model.ActionItemSnapshot) (ac *model.ActionItemSnapshot, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, actionItemSnapshot model.ActionItemSnapshot, updatedFields ...string) (ac *model.ActionItemSnapshot, err error)
	OneByAuditCycleIDAndTime(db *gorm.DB, auditCycleID string, today string) (actionItemSnapshot *model.ActionItemSnapshot, err error)
}

```

# pkg/store/actionitemsnapshot/action_item_snapshot.go

```go
package actionitemsnapshot

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get action item snapshot by id
func (s *store) One(db *gorm.DB, id string) (*model.ActionItemSnapshot, error) {
	var actionItemSnapshot *model.ActionItemSnapshot
	return actionItemSnapshot, db.Where("id = ?", id).First(&actionItemSnapshot).Error
}

// All get all action item snapshot
func (s *store) All(db *gorm.DB) ([]*model.ActionItemSnapshot, error) {
	var actionItemSnapshots []*model.ActionItemSnapshot
	return actionItemSnapshots, db.Find(&actionItemSnapshots).Error
}

// Delete delete 1 action item snapshot by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.ActionItemSnapshot{}).Error
}

// Create creates a new action item snapshot
func (s *store) Create(db *gorm.DB, e *model.ActionItemSnapshot) (actionItemSnapshot *model.ActionItemSnapshot, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, actionItemSnapshot *model.ActionItemSnapshot) (*model.ActionItemSnapshot, error) {
	return actionItemSnapshot, db.Model(&actionItemSnapshot).Where("id = ?", actionItemSnapshot.ID).Updates(&actionItemSnapshot).First(&actionItemSnapshot).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ActionItemSnapshot, updatedFields ...string) (*model.ActionItemSnapshot, error) {
	actionItemSnapshot := model.ActionItemSnapshot{}
	return &actionItemSnapshot, db.Model(&actionItemSnapshot).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// OneByAuditCycleIDAndTime get one snapshot by audit cycle id and time
func (s *store) OneByAuditCycleIDAndTime(db *gorm.DB, auditCycleID string, today string) (*model.ActionItemSnapshot, error) {
	var actionItemSnapshot *model.ActionItemSnapshot
	return actionItemSnapshot, db.Where("audit_cycle_id = ? AND created_at >= ? AND created_at < ?", auditCycleID, today, today+" 24:00:00").First(&actionItemSnapshot).Error
}

```

# pkg/store/apikey/interface.go

```go
package apikey

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	GetByClientID(db *gorm.DB, id string) (*model.APIKey, error)
	Create(db *gorm.DB, e *model.APIKey) (apiKey *model.APIKey, err error)
}

```

# pkg/store/apikey/api_key.go

```go
package apikey

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

func (s *store) GetByClientID(db *gorm.DB, id string) (*model.APIKey, error) {
	var apikey *model.APIKey
	return apikey, db.Where("client_id = ?", id).
		First(&apikey).Error
}

func (s *store) Create(db *gorm.DB, e *model.APIKey) (apiKey *model.APIKey, err error) {
	return e, db.Create(e).Error
}

```

# pkg/store/audit/interface.go

```go
package audit

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (audit *model.Audit, err error)
	All(db *gorm.DB) (audits []*model.Audit, err error)
	Delete(db *gorm.DB, id string) (err error)
	Create(db *gorm.DB, e *model.Audit) (audit *model.Audit, err error)
	Update(db *gorm.DB, audit *model.Audit) (a *model.Audit, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, audit model.Audit, updatedFields ...string) (a *model.Audit, err error)
	ResetActionItem(db *gorm.DB) (err error)
}

```

# pkg/store/audit/audit.go

```go
package audit

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get audit by id
func (s *store) One(db *gorm.DB, id string) (*model.Audit, error) {
	var audit *model.Audit
	return audit, db.Where("id = ?", id).First(&audit).Error
}

// All get all audit
func (s *store) All(db *gorm.DB) ([]*model.Audit, error) {
	var audit []*model.Audit
	return audit, db.Find(&audit).Error
}

// Delete delete 1 audit by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.Audit{}).Error
}

// Create creates a new audit
func (s *store) Create(db *gorm.DB, e *model.Audit) (audit *model.Audit, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, audit *model.Audit) (*model.Audit, error) {
	return audit, db.Model(&audit).Where("id = ?", audit.ID).Updates(&audit).First(&audit).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Audit, updatedFields ...string) (*model.Audit, error) {
	audit := model.Audit{}
	return &audit, db.Model(&audit).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

// ResetActionItem reset action item in audit table
func (s *store) ResetActionItem(db *gorm.DB) error {
	return db.Model(&model.Audit{}).Where("deleted_at IS NULL").Updates(map[string]interface{}{"action_item": 0}).Error
}

```

# pkg/store/actionitem/interface.go

```go
package actionitem

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IStore interface {
	One(db *gorm.DB, id string) (actionItem *model.ActionItem, err error)
	All(db *gorm.DB) (actionItems []*model.ActionItem, err error)
	Delete(db *gorm.DB, id string) (err error)
	Create(db *gorm.DB, e *model.ActionItem) (actionItem *model.ActionItem, err error)
	Update(db *gorm.DB, actionItem *model.ActionItem) (ac *model.ActionItem, err error)
	UpdateSelectedFieldsByID(db *gorm.DB, id string, actionItem model.ActionItem, updatedFields ...string) (ac *model.ActionItem, err error)
}

```

# pkg/store/actionitem/action_item.go

```go
package actionitem

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type store struct{}

func New() IStore {
	return &store{}
}

// One get action item by id
func (s *store) One(db *gorm.DB, id string) (*model.ActionItem, error) {
	var actionItem *model.ActionItem
	return actionItem, db.Where("id = ?", id).First(&actionItem).Error
}

// All get all action item
func (s *store) All(db *gorm.DB) ([]*model.ActionItem, error) {
	var actionItems []*model.ActionItem
	return actionItems, db.Find(&actionItems).Error
}

// Delete delete 1 action item by id
func (s *store) Delete(db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&model.ActionItem{}).Error
}

// Create creates a new action item
func (s *store) Create(db *gorm.DB, e *model.ActionItem) (actionItem *model.ActionItem, err error) {
	return e, db.Create(e).Error
}

// Update update all value (including nested model)
func (s *store) Update(db *gorm.DB, actionItem *model.ActionItem) (*model.ActionItem, error) {
	return actionItem, db.Model(&actionItem).Where("id = ?", actionItem.ID).Updates(&actionItem).First(&actionItem).Error
}

// UpdateSelectedFieldsByID just update selected fields by id
func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ActionItem, updatedFields ...string) (*model.ActionItem, error) {
	actionItem := model.ActionItem{}
	return &actionItem, db.Model(&actionItem).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error
}

```

# pkg/store/accounting/interface.go

```go
package accounting

import (
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

// IStore implement calendar method
type IStore interface {
	CreateTransaction(db *gorm.DB, transaction *model.AccountingTransaction) error
	GetAccountingTransactions(db *gorm.DB) ([]model.AccountingTransaction, error)
	GetAccountingCategories(db *gorm.DB) ([]model.AccountingCategory, error)
	DeleteTransaction(db *gorm.DB, t *model.AccountingTransaction) error
	CreateMultipleTransaction(db *gorm.DB, transactions []*model.AccountingTransaction) error
}

```

# pkg/store/accounting/accounting.go

```go
package accounting

import (
	"fmt"
	"strings"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type accountingService struct {
}

// New create new pg service
func New() IStore {
	return &accountingService{}
}

func (s *accountingService) GetAccountingTransactions(db *gorm.DB) ([]model.AccountingTransaction, error) {
	var transactions []model.AccountingTransaction
	return transactions, db.
		Joins(`left join accounting_categories on accounting_transactions.category = accounting_categories.name`).
		Preload("CurrencyInfo").
		Preload("AccountingCategory").
		Order(`date DESC`).
		Order(`
		CASE accounting_categories.type
		WHEN 'IN' THEN 1
		WHEN 'SE' THEN 2
		WHEN 'OP' THEN 3
		WHEN 'OV' THEN 4
		WHEN 'CA' THEN 5
		ELSE 6
		END`).
		Find(&transactions).
		Error
}

func (s *accountingService) CreateTransaction(db *gorm.DB, transaction *model.AccountingTransaction) error {
	return db.Create(transaction).Error
}

func (s *accountingService) DeleteTransaction(db *gorm.DB, t *model.AccountingTransaction) error {
	return db.Delete(&t).Error
}

func (s *accountingService) GetAccountingCategories(db *gorm.DB) ([]model.AccountingCategory, error) {
	var categories []model.AccountingCategory
	return categories, db.Find(&categories).Error
}

func (s *accountingService) CreateMultipleTransaction(db *gorm.DB, transactions []*model.AccountingTransaction) error {
	if len(transactions) == 0 {
		return nil
	}

	var valueStrings []string
	var valueArgs []interface{}

	for _, v := range transactions {
		valueStrings = append(valueStrings, "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")

		valueArgs = append(valueArgs, v.Name)
		valueArgs = append(valueArgs, v.Amount)
		valueArgs = append(valueArgs, v.Category)
		valueArgs = append(valueArgs, v.Currency)
		valueArgs = append(valueArgs, v.CurrencyID)
		valueArgs = append(valueArgs, v.Date)
		valueArgs = append(valueArgs, v.ConversionAmount)
		valueArgs = append(valueArgs, v.Organization)
		valueArgs = append(valueArgs, v.ConversionRate)
		valueArgs = append(valueArgs, v.Type)
		valueArgs = append(valueArgs, v.Metadata)
	}

	smt := `
		INSERT INTO accounting_transactions(name,amount,category,currency,currency_id,date,conversion_amount,organization,conversion_rate, type, metadata)
		VALUES %s
		ON CONFLICT ON CONSTRAINT transaction_info_unique
		DO UPDATE SET
		amount = EXCLUDED.amount,
		category = EXCLUDED.category,
		currency_id = EXCLUDED.currency_id,
		currency = EXCLUDED.currency,
		conversion_amount = EXCLUDED.conversion_amount,
		type = EXCLUDED.type,
		metadata = EXCLUDED.metadata`

	smt = fmt.Sprintf(smt, strings.Join(valueStrings, ","))

	tx := db.Begin()
	if err := tx.Exec(smt, valueArgs...).Error; err != nil {
		tx.Rollback()
		return err
	}

	tx.Commit()
	return nil
}

```

# pkg/handler/youtube/youtube.go

```go
package youtube

import (
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/service/git"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	controller *controller.Controller
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
}

func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		controller: controller,
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
	}
}

func (h *handler) LatestBroadcast(c *gin.Context) {
	broadcast, err := h.service.Youtube.GetLatestBroadcast()
	if err != nil {
		h.logger.Error(err, "failed to get latest broadcast")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}
	c.JSON(http.StatusOK, view.CreateResponse[any](broadcast, nil, nil, nil, ""))
}

func (h *handler) TranscribeBroadcast(c *gin.Context) {
	broadcast, err := h.service.Youtube.GetLatestBroadcast()
	if err != nil {
		h.logger.Error(err, "failed to get latest broadcast")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	link := "https://www.youtube.com/live/" + broadcast.Id

	broadCastTime := strings.Split(broadcast.Snippet.ActualStartTime, "T")
	broadCastDate := time.Now().Format("2006-01-02")
	if len(broadCastTime) == 2 {
		broadCastDate = broadCastTime[0]
		broadCastDate = strings.ReplaceAll(broadCastDate, "-", "")
	}

	content, err := h.service.Dify.SummarizeOGIFMemo(link)
	if err != nil {
		h.logger.Error(err, "failed to summarize OGIF memo")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	gitSvc := git.New("https://github.com/dwarvesf/brainery", "lmquang", h.config.Github.Token)
	branch := fmt.Sprintf("docs/ogif-memo-summary-%v", time.Now().Format("20060102"))
	if err := gitSvc.CreateBranch(branch); err != nil {
		h.logger.Error(err, "failed to create branch")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	fileNum := 1
	// check the latest file
	path := gitSvc.Dest() + "/updates/ogif"
	// walk through the directory to get the latest file
	// if the file is not exist, create the first file
	if _, err := os.Stat(path); os.IsNotExist(err) {
		if err := os.MkdirAll(path, os.ModePerm); err != nil {
			h.logger.Error(err, "failed to create directory")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	} else {
		files, err := os.ReadDir(path)
		if err != nil {
			h.logger.Error(err, "failed to read directory")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
		// get the latest file number follow this format: 1-ogif-office-hours-20210101.md
		for _, file := range files {
			if file.IsDir() {
				continue
			}
			name := file.Name()
			if strings.Contains(name, "ogif-office-hours") {
				num := strings.Split(name, "-")[0]
				if n, err := strconv.Atoi(num); err == nil {
					if n > fileNum {
						fileNum = n
					}
				}
			}
		}
		fileNum++
	}

	if err := h.createFile(gitSvc.Dest()+"/updates/ogif", fmt.Sprintf("%v-ogif-office-hours-%v.md", fileNum, broadCastDate), content); err != nil {
		h.logger.Error(err, "failed to create file")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	if err := gitSvc.Commit(fmt.Sprintf("docs: ogif memo summary %v", broadCastDate)); err != nil {
		h.logger.Error(err, "failed to commit")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}
	if err := gitSvc.Push(); err != nil {
		h.logger.Error(err, "failed to push")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}
	prNumber, err := gitSvc.CreatePullRequest("dwarvesf", "brainery", branch, "main", fmt.Sprintf("docs: ogif memo summary %v", broadCastDate), "")
	if err != nil {
		h.logger.Error(err, "failed to create PR")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}
	if err := gitSvc.RequestReview(
		"dwarvesf",
		"brainery",
		*prNumber,
		h.config.Github.BraineryReviewers,
	); err != nil {
		h.logger.Error(err, "failed to request review")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// remove the directory after finish
	if err := os.RemoveAll(gitSvc.Dest()); err != nil {
		h.logger.Error(err, "failed to remove directory")
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

```

# pkg/handler/youtube/interface.go

```go
package youtube

import "github.com/gin-gonic/gin"

type IHandler interface {
	LatestBroadcast(c *gin.Context)
	TranscribeBroadcast(c *gin.Context)
}

```

# pkg/handler/youtube/file.go

```go
package youtube

import (
	"os"
)

func (h *handler) createFile(path, fileName, content string) error {
	if _, err := os.Stat(path); os.IsNotExist(err) {
		if err := os.MkdirAll(path, os.ModePerm); err != nil {
			return err
		}
	}

	newFile := path + "/" + fileName
	file, err := os.Create(newFile)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(content)
	return err
}

```

# pkg/handler/vault/vault.go

```go
package vault

import (
	"errors"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/service/mochi"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

// New returns a handler
func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

// StoreVaultTransaction godoc
// @Summary Store vault tx as icy tx from Mochi service
// @Description Store vault tx as icy tx from Mochi service
// @Tags Vault
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /cron-jobs/store-vault-transaction [post]
func (h *handler) StoreVaultTransaction(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "vault",
		"method":  "StoreVaultTransaction",
	})

	// currently support
	supportedVaults := []string{"18", "19", "20"}

	startOfTheWeek := timeutil.FormatDateForCurl(timeutil.GetStartDayOfWeek(time.Now().Local()).Format(time.RFC3339))
	endOfTheWeek := timeutil.FormatDateForCurl(timeutil.GetEndDayOfWeek(time.Now().Local()).Format(time.RFC3339))

	icyTxs := make([]model.IcyTransaction, 0)
	for _, vaultID := range supportedVaults {
		req := &mochi.VaultTransactionRequest{
			VaultID:   vaultID,
			StartTime: startOfTheWeek,
			EndTime:   endOfTheWeek,
		}
		res, err := h.service.Mochi.GetVaultTransaction(req)
		if err != nil {
			l.Error(err, "failed to get GetVaultTransaction")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		for _, transaction := range res.Data {
			// skip case transfer through wallet address
			if transaction.Target == "" {
				continue
			}

			txnTime, err := time.Parse("2006-01-02T15:04:05Z", transaction.CreatedAt)
			if err != nil {
				continue
			}

			icyTx := model.IcyTransaction{
				Category: strings.ToLower(transaction.VaultName),
				TxnTime:  txnTime,
				Amount:   transaction.Amount,
				Sender:   transaction.Sender,
				Target:   transaction.Target,
			}

			srcEmployee, err := h.store.Employee.GetByDiscordID(h.repo.DB(), transaction.Sender, false)
			if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
				l.Error(err, "failed to get src employee by discord account ID")
				c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
				return
			}

			if !errors.Is(err, gorm.ErrRecordNotFound) {
				icyTx.SrcEmployeeID = srcEmployee.ID
			}

			destEmployee, err := h.store.Employee.GetByDiscordID(h.repo.DB(), transaction.Target, false)
			if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
				l.Error(err, "failed to get dest employee by discord account ID")
				c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
				return
			}

			if !errors.Is(err, gorm.ErrRecordNotFound) {
				icyTx.DestEmployeeID = destEmployee.ID
			}

			icyTxs = append(icyTxs, icyTx)
		}
	}

	// case no tx from mochi
	if len(icyTxs) == 0 {
		l.Info("There is no transaction in this week")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, nil, nil, "there is no transaction in this week"))
		return
	}

	tx, done := h.repo.NewTransaction()
	if err := h.store.IcyTransaction.Create(tx.DB(), icyTxs); err != nil {
		l.Error(done(err), "failed to Create IcyTransaction")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

```

# pkg/handler/vault/interface.go

```go
package vault

import "github.com/gin-gonic/gin"

type IHandler interface {
	StoreVaultTransaction(c *gin.Context)
}

```

# pkg/handler/valuation/valuation.go

```go
// please edit this file only with approval from hnh
package valuation

import (
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/gin-gonic/gin"
)

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

// New returns a handler
func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

// One godoc
// @Summary Get valuation by year
// @Description Get valuation
// @Tags valuation
// @Accept  json
// @Produce  json
// @Param year path int true "Year"
// @Success 200 {object} Valuation
// @Failure 400 {object} ErrorResponse
func (h *handler) One(c *gin.Context) {
	// parse params & prepare logger
	year := c.Param("year")
	if !utils.IsNumber(year) {
		c.JSON(400, gin.H{"message": "year must be number"})
		return
	}

	// we convert all number to usd
	convertTo := "USD"

	l := h.logger.Fields(logger.Fields{
		"handler": "valuation",
		"method":  "Details",
		"year":    year,
	})

	// account receivable is a number of money that company has to receive from customer
	// in our case, receivable is an amount of unpaid invoice
	receivable, err := h.store.Valuation.GetAccountReceivable(h.repo.DB(), year)
	if err != nil {
		l.Error(err, "can't get account receivable from this year")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get account receivable from this year"))
		return
	}

	// revenue equal all paid invoice, yield from investment & bank interest
	revenue, err := h.store.Valuation.GetRevenue(h.repo.DB(), year)
	if err != nil {
		l.Error(err, "can't get revenue from this year")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get revenue from this year"))
		return
	}

	// liabilities is a money that company has to pay in the future
	liabilities, amount, err := h.store.Valuation.GetLiabilities(h.repo.DB(), year)
	if err != nil {
		l.Error(err, "can't get liabilities from this year")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get liabilities from this year"))
		return
	}

	items := make([]model.AccountingItem, 0)
	for i := range liabilities {
		items = append(items, model.AccountingItem{
			Name:   liabilities[i].Name,
			Amount: liabilities[i].Total,
		})
	}

	// get investment
	investment, err := h.store.Valuation.GetInvestment(h.repo.DB(), year)
	if err != nil {
		l.Error(err, "can't get investment from this year")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get investment from this year"))
		return
	}

	// assets is a total worth of assets that company holds
	assets, err := h.store.Valuation.GetAssetAmount(h.repo.DB(), year)
	if err != nil {
		l.Error(err, "can't get liabilities from this year")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get liabilities from this year"))
		return
	}

	// expenses is a total amount we spent for operation expenses
	expenses, err := h.store.Valuation.GetExpense(h.repo.DB(), year)
	if err != nil {
		l.Error(err, "can't get expense from this year")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get expense from this year"))
		return
	}

	// payroll is a total amount we spent for salary
	payroll, err := h.store.Valuation.GetPayroll(h.repo.DB(), year)
	if err != nil {
		l.Error(err, "can't get expense from this year")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get expense from this year"))
		return
	}

	// build up response
	var valuation view.Valuation

	valuation.Year = year
	valuation.Currency = convertTo

	valuation.Assets = assets
	// we temporary doesn't need to return detail item for this rn
	valuation.AccountReceivable.Total = h.convertCurrency(receivable, convertTo)
	valuation.Liabilities.Total = h.convertCurrency(amount, convertTo)
	viewItems := make([]view.AccountingItem, 0)
	for _, item := range items {
		viewItems = append(viewItems, view.AccountingItem{
			Name:   item.Name,
			Amount: h.convertCurrency(&model.CurrencyView{VND: item.Amount}, convertTo),
		})
	}
	valuation.Liabilities.Items = viewItems

	valuation.Income.Total = h.convertCurrency(revenue, convertTo)

	valuation.Outcome.Detail.Expense = h.convertCurrency(expenses, convertTo)
	valuation.Outcome.Detail.Payroll = h.convertCurrency(payroll, convertTo)
	valuation.Outcome.Detail.Investment = h.convertCurrency(investment, convertTo)
	valuation.Outcome.Total = valuation.Outcome.Detail.Expense + valuation.Outcome.Detail.Payroll + valuation.Outcome.Detail.Investment

	// return
	c.JSON(http.StatusOK, view.CreateResponse[any](valuation, nil, nil, year, "get valuation successfully"))
}

func (h *handler) convertCurrency(currency *model.CurrencyView, convertTo string) (convertedAmount float64) {
	if currency == nil {
		h.logger.Warn("currency struct is nil")
		return 0
	}

	// convert currency
	vndSource, _, _ := h.service.Wise.Convert(currency.VND, "VND", convertTo)
	usdSource, _, _ := h.service.Wise.Convert(currency.USD, "USD", convertTo)
	gbpSource, _, _ := h.service.Wise.Convert(currency.GBP, "GBP", convertTo)
	eurSource, _, _ := h.service.Wise.Convert(currency.EUR, "EUR", convertTo)
	sgdSource, _, _ := h.service.Wise.Convert(currency.SGD, "SGD", convertTo)

	return vndSource + usdSource + gbpSource + eurSource + sgdSource
}

```

# pkg/handler/valuation/interface.go

```go
package valuation

import "github.com/gin-gonic/gin"

type IHandler interface {
	One(c *gin.Context)
}

```

# pkg/handler/webhook/webhook.go

```go
package webhook

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/worker"
)

type handler struct {
	store      *store.Store
	service    *service.Service
	controller *controller.Controller
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
	worker     *worker.Worker
}

// New returns a handler
func New(ctrl *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config, worker *worker.Worker) IHandler {
	return &handler{
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
		worker:     worker,
		controller: ctrl,
	}
}

```

# pkg/handler/webhook/request.go

```go
package webhook

import "time"

type n8nCalendarEvent struct {
	ID      string    `json:"id"`
	Kind    string    `json:"kind"`
	Created time.Time `json:"created"`
	Updated time.Time `json:"updated"`
	Summary string    `json:"summary"`
	Creator struct {
		Email string `json:"email"`
	} `json:"creator"`
	Description string `json:"description"`
	HangoutLink string `json:"hangoutLink"`
	Organizer   struct {
		Email       string `json:"email"`
		DisplayName string `json:"displayName"`
		Self        bool   `json:"self"`
	} `json:"organizer"`
	Start struct {
		DateTime time.Time `json:"dateTime"`
		Timezone string    `json:"timezone"`
	} `json:"start"`
	End struct {
		DateTime time.Time `json:"dateTime"`
		Timezone string    `json:"timezone"`
	} `json:"end"`
	Attendees []struct {
		Email          string `json:"email"`
		ResponseStatus string `json:"responseStatus"`
	} `json:"attendees"`
	ShouldSyncDiscord string `json:"shouldSyncDiscord"`
}

type n8nEvent struct {
	Kind              string            `json:"kind"`
	CalendarData      *n8nCalendarEvent `json:"calendarData"`
	ShouldSyncDiscord string            `json:"shouldSyncDiscord"`
}

```

# pkg/handler/webhook/onleave.go

```go
package webhook

import (
	"fmt"
	"strings"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
)

type OnLeaveData struct {
	ParentID                int64
	Name                    string
	Type                    string
	StartDate               time.Time
	EndDate                 time.Time
	Shift                   string
	Title                   string
	Description             string
	AssigneeIDs             []int
	CreatorBasecampID       int
	ApproverBasecampID      int
	AssigneeBasecampIDs     []int
	CompletionSubscriberIDs []int
}

func parseOnLeaveDataFromMessage(todo *bcModel.Todo, msg model.BasecampWebhookMessage) (OnLeaveData, error) {
	data := OnLeaveData{}
	data.ParentID = msg.Recording.Parent.ID
	data.Title = msg.Recording.Title

	split := strings.Split(msg.Recording.Title, "|")
	if len(split) < 3 {
		return data, nil
	}

	// set name and off type
	data.Name = strings.TrimSpace(split[0])
	data.Type = strings.TrimSpace(split[1])

	// set start and end date
	times, err := timeutil.GetTimeRange(strings.TrimSpace(split[2]))
	if err != nil {
		return data, err
	}

	data.StartDate = *times[0]
	data.EndDate = *times[0]
	if len(times) == 2 {
		data.EndDate = *times[1]
	}

	// set shift
	if len(split) > 3 {
		data.Shift = strings.TrimSpace(split[3])
	}

	// set email infos
	data.CreatorBasecampID = msg.Recording.Creator.ID
	data.ApproverBasecampID = msg.Creator.ID

	assigneeIds := []int{
		msg.Creator.ID,
		msg.Recording.Creator.ID,
		consts.AutoBotID,
	}

	if todo != nil {
		data.Description = strings.TrimSuffix(strings.TrimPrefix(todo.Description, "<div>"), "</div>")
		data.CompletionSubscriberIDs = getSubscriberIDs(todo.CompletionSubscribers)

		for _, v := range todo.Assignees {
			assigneeIds = append(assigneeIds, v.ID)
		}
	}

	data.AssigneeIDs = assigneeIds

	return data, nil
}

func (h *handler) handleOnLeaveValidation(msg model.BasecampWebhookMessage) error {
	if h.config.Env == "prod" {
		if msg.Recording.Bucket.Name != "Woodland" {
			return nil
		}
	}

	projectID := msg.Recording.Bucket.ID
	recordingID := msg.Recording.ID
	var commentMsg bcModel.BasecampCommentMessage

	defer func() {
		h.worker.Enqueue(bcModel.BasecampCommentMsg, commentMsg)
	}()

	err := h.validateOnLeaveData(msg)
	if err != nil {
		errMsg := fmt.Sprintf(
			`   Your request has encountered an error: %v
    
                Your Name | Off | Date (in range, format dd/mm/yyyy) | Shift (if any)
    
                e.g:
                Huy Nguyen | Off | 29/01/2019 | Morning
                Nam Nguyen | Off | 29/01/2019 - 01/02/2020`, err.Error())

		commentMsg = h.service.Basecamp.BuildCommentMessage(projectID, recordingID, errMsg, "")
		return err
	}

	commentMsg = h.service.Basecamp.BuildCommentMessage(projectID, recordingID, "Your format looks good to go 👍", "")
	return nil
}

func (h *handler) validateOnLeaveData(msg model.BasecampWebhookMessage) error {
	data, err := parseOnLeaveDataFromMessage(nil, msg)
	if err != nil {
		return err
	}

	// Validate if request belongs to the onLeave group
	onLeaveID := consts.OnleavePlaygroundID
	if h.config.Env == "prod" {
		onLeaveID = consts.OnleaveID
	}

	if data.ParentID != int64(onLeaveID) {
		list, err := h.service.Basecamp.Todo.GetList(msg.Recording.Parent.URL)
		if err != nil {
			return fmt.Errorf("cannot get todo list: %v", err.Error())
		}
		if list.Parent.ID != onLeaveID {
			return fmt.Errorf("invalid group id: %v %v", list.Parent.ID, list.Parent.Title)
		}
	}

	// Validate title format
	split := strings.Split(msg.Recording.Title, "|")
	if len(split) < 3 {
		return fmt.Errorf("invalid title format: %v", msg.Recording.Title)
	}

	// Validate off type
	offtype := strings.ToLower(data.Type)
	if offtype != "off" && offtype != "remote" {
		return fmt.Errorf("invalid off type: %v (needs to be off or remote)", offtype)
	}

	// Validate time range
	if data.StartDate.Before(time.Now()) && !timeutil.IsSameDay(data.StartDate, time.Now()) {
		return fmt.Errorf("start date cannot be in the past: %v", timeutil.ParseTimeToDateFormat(&data.StartDate))
	}

	if data.EndDate.Before(data.StartDate) {
		return fmt.Errorf("end date must be after start date: start date is %v - end date is %v", timeutil.ParseTimeToDateFormat(&data.StartDate), timeutil.ParseTimeToDateFormat(&data.EndDate))
	}

	return nil
}

func (h *handler) handleApproveOnLeaveRequest(msg model.BasecampWebhookMessage) error {
	todo, err := h.service.Basecamp.Todo.Get(msg.Recording.URL)
	if err != nil {
		h.logger.Errorf(err, "failed to get basecamp todo: %v", err.Error())
		return fmt.Errorf("failed to get basecamp todo: %v", err.Error())
	}

	data, err := parseOnLeaveDataFromMessage(todo, msg)
	if err != nil {
		return err
	}

	r := model.OnLeaveRequest{
		Type:        data.Type,
		StartDate:   &data.StartDate,
		EndDate:     &data.EndDate,
		Shift:       data.Shift,
		Title:       data.Title,
		Description: data.Description,
	}

	// assign assignees id
	for _, assignee := range todo.Assignees {
		data.AssigneeBasecampIDs = append(data.AssigneeBasecampIDs, assignee.ID)
	}

	assignees, err := h.store.Employee.GetByBasecampIDs(h.repo.DB(), data.AssigneeBasecampIDs)
	if err != nil {
		h.logger.Errorf(err, "failed to get assignees with basecamp_ids", err.Error())
		return fmt.Errorf("failed to get assignees with basecamp_ids %v: %v", data.AssigneeBasecampIDs, err.Error())
	}

	for _, assignee := range assignees {
		r.AssigneeIDs = append(r.AssigneeIDs, assignee.ID.String())
	}

	// assign creator id
	creator, err := h.store.Employee.OneByBasecampID(h.repo.DB(), data.CreatorBasecampID)
	if err != nil {
		h.logger.Errorf(err, "failed to get creator with basecamp_id", err.Error())
		return fmt.Errorf("failed to get creator with basecamp_id %v: %v", data.CreatorBasecampID, err.Error())
	}
	r.CreatorID = creator.ID

	// assign approver id
	approver, err := h.store.Employee.OneByBasecampID(h.repo.DB(), data.ApproverBasecampID)
	if err != nil {
		h.logger.Errorf(err, "failed to get approver with basecamp_id", err.Error())
		return fmt.Errorf("failed to get approver with basecamp_id %v: %v", data.ApproverBasecampID, err.Error())
	}
	r.ApproverID = approver.ID

	_, err = h.store.OnLeaveRequest.Create(h.repo.DB(), &r)
	if err != nil {
		h.logger.Errorf(err, "failed to create onLeaveRequest", err.Error())
		return fmt.Errorf("failed to create onLeaveRequest: %v", err.Error())
	}

	dateChunks := timeutil.ChunkDateRange(data.StartDate, data.EndDate)
	for _, dateChunk := range dateChunks {
		startDate := dateChunk[0]
		endDate := dateChunk[1]

		basecampSchedule := bcModel.ScheduleEntry{
			Summary:     fmt.Sprintf("⚠️ %s", data.Title),
			StartsAt:    startDate.Format(time.RFC3339),
			EndsAt:      endDate.Format(time.RFC3339),
			AllDay:      true,
			Description: r.Description,
		}

		woodlandID := consts.PlaygroundID
		woodlandScheduleID := consts.PlaygroundScheduleID

		opsTeamIDs := []int{consts.NamNguyenBasecampID}
		if h.config.Env == "prod" {
			woodlandID = consts.WoodlandID
			woodlandScheduleID = consts.WoodlandScheduleID
			opsTeamIDs = []int{consts.HuyNguyenBasecampID, consts.GiangThanBasecampID}
			if msg.Recording.Bucket.Name != "Woodland" {
				return nil
			}
		}
		var subscriberIDs []int
		subscriberIDs = append(subscriberIDs, data.AssigneeIDs...)
		subscriberIDs = append(subscriberIDs, data.CompletionSubscriberIDs...)
		subscriberIDs = append(subscriberIDs, opsTeamIDs...)

		se, err := h.service.Basecamp.Schedule.CreateScheduleEntry(int64(woodlandID), woodlandScheduleID, basecampSchedule)
		if err != nil {
			h.logger.Errorf(err, "failed to  create basecamp schedule", err.Error())
			return fmt.Errorf("failed to create basecamp schedule: %v", err.Error())
		}

		if len(data.AssigneeIDs) > 0 {
			err = h.service.Basecamp.Subscription.Subscribe(
				se.SubscriptionUrl,
				&bcModel.SubscriptionList{Subscriptions: subscriberIDs},
			)
			if err != nil {
				h.logger.Errorf(err, "failed to set basecamp event subscriber", err.Error())
				return err
			}
		}
	}

	return nil
}

// Get list IDs from list subscribers
func getSubscriberIDs(list []bcModel.Subscriber) []int {
	res := make([]int, len(list))
	for i := range list {
		res[i] = list[i].ID
	}
	return res
}

```

# pkg/handler/webhook/n8n.go

```go
package webhook

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

func (h *handler) N8n(c *gin.Context) {
	var req n8nEvent

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, ""))
		return
	}

	req.CalendarData.ShouldSyncDiscord = req.ShouldSyncDiscord

	var err error
	switch req.Kind {
	case KindGcalEvent:
		err = h.handleGcalEvent(req.CalendarData)
	}
	if err != nil {
		h.logger.Fields(logger.Fields{
			"kind": req.Kind,
			"data": req,
		}).Error(err, "can't execute webhook")
	}
}

func (h *handler) handleGcalEvent(event *n8nCalendarEvent) error {
	// first, we get event from db
	existedEv, err := h.store.Schedule.GetOneByGcalID(h.repo.DB(), event.ID)
	if err != nil {
		if err != gorm.ErrRecordNotFound {
			h.logger.Error(err, "can't get schedule from db")
			return err
		}
		// if the schedule doesn't exists in db, we create a new one
		return h.handleNewEvent(event)
	}

	// in case the event already exists, we check if the event is updated
	if existedEv.GoogleCalendar.HangoutLink != event.HangoutLink ||
		existedEv.Name != event.Summary ||
		*existedEv.StartTime != event.Start.DateTime ||
		*existedEv.EndTime != event.End.DateTime {
		return h.handleUpdateEvent(existedEv, event)
	}

	return nil
}

func (h *handler) handleUpdateEvent(existedEv *model.Schedule, event *n8nCalendarEvent) error {
	// update schedule
	existedEv.Name = event.Summary
	existedEv.StartTime = &event.Start.DateTime
	existedEv.EndTime = &event.End.DateTime
	existedEv.GoogleCalendar.Description = event.Description
	existedEv.GoogleCalendar.HangoutLink = event.HangoutLink

	schedule, err := h.store.Schedule.Update(h.repo.DB(), existedEv)
	if err != nil {
		h.logger.Error(err, "can't update schedule")
		return err
	}

	// update discord event
	if schedule.DiscordEvent != nil {
		_, err = h.service.Discord.UpdateEvent(schedule)
		if err != nil {
			h.logger.Error(err, "can't update discord event")
			// return err
		}
	}

	return nil
}

func (h *handler) handleNewEvent(event *n8nCalendarEvent) error {
	// first, we create a schedule record in db
	sch := &model.Schedule{
		GoogleCalendar: &model.ScheduleGoogleCalendar{
			GoogleCalendarID: event.ID,
			Description:      event.Description,
			HangoutLink:      event.HangoutLink,
		},
		Name:      event.Summary,
		StartTime: &event.Start.DateTime,
		EndTime:   &event.End.DateTime,
	}
	schedule, err := h.store.Schedule.Create(h.repo.DB(), sch)
	if err != nil {
		h.logger.Error(err, "can't create schedule")
		return err
	}

	// this case, we create a discord event
	// check if time in the past
	if event.ShouldSyncDiscord == "true" {
		if !schedule.StartTime.Before(time.Now()) {
			discordEvent, err := h.service.Discord.CreateEvent(schedule)
			if err != nil {
				h.logger.Error(err, "can't create discord event")
				// return err
			} else {
				_, err = h.store.Schedule.CreateDiscord(h.repo.DB(), &model.ScheduleDiscordEvent{
					ScheduleID:     schedule.ID,
					DiscordEventID: discordEvent.ID,
					VoiceChannelID: discordEvent.ChannelID,
				})
				if err != nil {
					h.logger.Error(err, "can't create discord event")
				}
			}
		}
	}

	return nil
}

```

# pkg/handler/webhook/interface.go

```go
package webhook

import "github.com/gin-gonic/gin"

type IHandler interface {
	N8n(c *gin.Context)
	CreateBasecampExpense(c *gin.Context)
	MarkInvoiceAsPaidViaBasecamp(c *gin.Context)
	StoreAccountingTransaction(c *gin.Context)
	UncheckBasecampExpense(c *gin.Context)
	ValidateBasecampExpense(c *gin.Context)
	ValidateOnLeaveRequest(c *gin.Context)
	ApproveOnLeaveRequest(c *gin.Context)
}

```

# pkg/handler/webhook/constant.go

```go
package webhook

const (
	KindGcalEvent = "google#calendar#event"
)

```

# pkg/handler/webhook/basecamp_invoice.go

```go
package webhook

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	"github.com/dwarvesf/fortress-api/pkg/store/invoice"
)

func (h *handler) GetInvoiceViaBasecampTitle(msg *model.BasecampWebhookMessage) (*model.Invoice, error) {
	if msg.Creator.ID == consts.AutoBotID {
		return nil, nil
	}

	reTitle := regexp.MustCompile(`.*([1-9]|0[1-9]|1[0-2])/(20[0-9]{2}) - #(20[0-9]+-[A-Z]+-[0-9]+)`)
	invoiceInfo := reTitle.FindStringSubmatch(msg.Recording.Title)
	if len(invoiceInfo) != 4 {
		return nil, fmt.Errorf(`Todo title have wrong format`)
	}

	invoiceNumber := invoiceInfo[3]

	invoice, err := h.store.Invoice.One(h.repo.DB(), &invoice.Query{Number: invoiceNumber})
	if err != nil {
		return nil, fmt.Errorf(`Can't get invoice %v`, err.Error())
	}

	if invoice.Status != model.InvoiceStatusSent && invoice.Status != model.InvoiceStatusOverdue {
		return nil, fmt.Errorf(`Update invoice failed, invoice has status %s`, invoice.Status)
	}

	comments, err := h.service.Basecamp.Comment.Gets(msg.Recording.Bucket.ID, msg.Recording.ID)
	if err != nil {
		return nil, fmt.Errorf(`can't get basecamp comment %v`, err.Error())
	}

	reCmt := regexp.MustCompile(fmt.Sprintf(`(^Paid|^<div>Paid).*#%s`, invoiceNumber))
	for i := range comments {
		// TODO: wtf
		if reCmt.MatchString(strings.ReplaceAll(comments[i].Content, "\n", "")) &&
			!(!(msg.Creator.ID == consts.HanBasecampID) && h.config.Env == "prod") {
			return invoice, nil
		}
	}

	return nil, fmt.Errorf("missing confirm comment")
}

```

# pkg/handler/webhook/basecamp_expense.go

```go
package webhook

import (
	"errors"
	"fmt"
	"strings"

	"github.com/dwarvesf/fortress-api/pkg/model"
	bc "github.com/dwarvesf/fortress-api/pkg/service/basecamp"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

func (h *handler) basecampExpenseValidate(msg model.BasecampWebhookMessage) error {
	recordingBucketName := consts.BucketNameWoodLand
	assigneeIDs := []int{consts.HanBasecampID}
	projectID := consts.WoodlandID

	if h.config.Env != "prod" {
		recordingBucketName = consts.BucketNamePlayGround
		assigneeIDs = []int{consts.NamNguyenBasecampID}
		projectID = consts.PlaygroundID
	}

	if msg.Recording.Bucket.Name != recordingBucketName {
		return nil
	}
	// Todo ref: https://3.basecamp.com/4108948/buckets/9410372/todos/3204666678
	// Assign HanNgo whenever expense todo was created
	if msg.Kind == consts.TodoCreate {
		todo, err := h.service.Basecamp.Todo.Get(msg.Recording.URL)
		if err != nil {
			return err
		}

		todo.AssigneeIDs = assigneeIDs
		_, err = h.service.Basecamp.Todo.Update(projectID, *todo)
		if err != nil {
			return err
		}
	}

	_, err := h.extractExpenseData(msg)
	if err != nil {
		m, err := h.service.Basecamp.BasecampMention(msg.Creator.ID)
		if err != nil {
			return err
		}

		errMsg := fmt.Sprintf(
			`Hi %v, I'm not smart enough to understand your expense submission. Please ensure the following format 😊

			Title: < Reason > | < Amount > | < VND/USD >
			Assign To: Han Ngo, < payee >

			Example:
			Title: Tiền mèo | 400.000 | VND
			Assign To: Han Ngo, < payee >`, m)

		h.worker.Enqueue(bcModel.BasecampCommentMsg, h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, errMsg, ""))
		return nil
	}

	commentMessage := h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID,
		msg.Recording.ID,
		"Your format looks good 👍",
		"",
	)

	h.worker.Enqueue(bcModel.BasecampCommentMsg, commentMessage)

	return nil
}

func (h *handler) createBasecampExpense(msg model.BasecampWebhookMessage, rawData []byte) error {
	commentMessage := h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, consts.CommentCreateExpenseFailed, bcModel.CommentMsgTypeFailed)

	defer func() {
		h.worker.Enqueue(bcModel.BasecampCommentMsg, commentMessage)
	}()

	obj, err := h.extractExpenseData(msg)
	if err != nil {
		return err
	}

	if obj == nil {
		return nil
	}

	err = obj.MetaData.UnmarshalJSON(rawData)
	if err != nil {
		return err
	}

	err = h.service.Basecamp.CreateBasecampExpense(*obj)
	if err != nil {
		return err
	}

	commentMessage = h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, consts.CommentCreateExpenseSuccessfully, bcModel.CommentMsgTypeCompleted)

	return nil
}

func (h *handler) UncheckBasecampExpenseHandler(msg model.BasecampWebhookMessage, rawData []byte) error {
	commentMsg := h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, consts.CommentDeleteExpenseFailed, bcModel.CommentMsgTypeFailed)

	defer func() {
		h.worker.Enqueue(bcModel.BasecampCommentMsg, commentMsg)
	}()

	obj, err := h.extractExpenseData(msg)
	if err != nil {
		return err
	}
	err = obj.MetaData.UnmarshalJSON(rawData)
	if err != nil {
		return err
	}

	if obj == nil {
		return nil
	}

	err = h.service.Basecamp.UncheckBasecampExpenseHandler(*obj)
	if err != nil {
		return err
	}

	commentMsg = h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, consts.CommentDeleteExpenseSuccessfully, bcModel.CommentMsgTypeCompleted)

	return nil
}

// extractExpenseData takes a webhook message and parse it into BasecampExpenseData structure
func (h *handler) extractExpenseData(msg model.BasecampWebhookMessage) (*bc.BasecampExpenseData, error) {
	res := &bc.BasecampExpenseData{BasecampID: msg.Recording.ID}

	parts := strings.Split(msg.Recording.Title, "|")
	if len(parts) < 3 {
		err := errors.New("invalid expense format")
		return nil, err
	}

	// extract reason
	datetime := fmt.Sprintf(" %s %v", msg.Recording.UpdatedAt.Month().String(), msg.Recording.UpdatedAt.Year())
	res.Reason = strings.TrimSpace(parts[0])
	res.Reason += datetime

	// extract amount
	amount := h.service.Basecamp.ExtractBasecampExpenseAmount(strings.TrimSpace(parts[1]))
	if amount == 0 {
		err := errors.New("invalid amount section of expense format")
		return nil, err
	}
	res.Amount = amount

	// extract currency type
	t := strings.ToLower(strings.TrimSpace(parts[2]))
	if t != "vnd" && t != "usd" {
		return nil, errors.New("invalid format in currency type section (VND or USD) of expense format")
	}
	url, err := h.service.Basecamp.Recording.TryToGetInvoiceImageURL(msg.Recording.URL)
	if err != nil {
		return nil, fmt.Errorf("failed to get image url by error %v", err)
	}

	res.CurrencyType = strings.ToUpper(t)

	list, err := h.service.Basecamp.Todo.GetList(msg.Recording.Parent.URL)
	if err != nil {
		return nil, err
	}
	msg.Recording.Parent.Title = list.Parent.Title
	if msg.IsExpenseComplete() {
		res.CreatorEmail = msg.Recording.Creator.Email
		res.CreatorID = msg.Recording.Creator.ID
	}
	if msg.IsOperationComplete() {
		res.CreatorEmail = msg.Creator.Email
	}
	res.InvoiceImageURL = url

	return res, nil
}

```

# pkg/handler/webhook/basecamp_accounting.go

```go
package webhook

import (
	"encoding/json"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	"github.com/dwarvesf/fortress-api/pkg/service/currency"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
)

func (h *handler) StoreAccountingTransactionFromBasecamp(msg model.BasecampWebhookMessage) error {
	operationInfo, err := h.getManagementTodoInfo(&msg)
	if err != nil {
		return err
	}

	data := regexp.
		MustCompile(`[S|s]alary\s*(1st|15th)|(.*)\|\s*([0-9\.]+)\s*\|\s*([a-zA-Z]{3})`).
		FindStringSubmatch(msg.Recording.Title)

	if len(data) == 0 {
		return fmt.Errorf(`unknown title format`)
	}

	err = h.storeAccountingTransaction(operationInfo, data, msg.Recording.ID)
	if err != nil {
		return err
	}

	return nil
}

type managementTodoInfo struct {
	month int
	year  int
}

func (h *handler) getManagementTodoInfo(msg *model.BasecampWebhookMessage) (*managementTodoInfo, error) {
	todoList, err := h.service.Basecamp.Todo.GetList(msg.Recording.Parent.URL)
	if err != nil {
		return nil, err
	}
	if todoList == nil || todoList.Parent == nil {
		return nil, nil
	}
	managementInfo := regexp.
		MustCompile(`Accounting \| (.+) ([0-9]{4})`).
		FindStringSubmatch(todoList.Parent.Title)

	accountingID := consts.PlaygroundID
	if h.config.Env == "prod" {
		accountingID = consts.AccountingID
	}
	if len(managementInfo) != 3 && msg.Recording.Bucket.ID == accountingID {
		return nil, nil
	}

	month, err := timeutil.GetMonthFromString(managementInfo[1])
	if err != nil {
		return nil, fmt.Errorf(`format of operation todolist title got wrong %s`, err.Error())
	}
	year, err := strconv.Atoi(managementInfo[2])
	if err != nil {
		return nil, fmt.Errorf(`format of operation todolist title got wrong %d is not a year number`, year)
	}

	return &managementTodoInfo{month, year}, nil
}

func (h *handler) storeAccountingTransaction(date *managementTodoInfo, data []string, id int) error {
	amount, err := strconv.Atoi(strings.ReplaceAll(data[3], ".", ""))
	if err != nil {
		return err
	}

	c, err := h.store.Currency.GetByName(h.repo.DB(), data[4])
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return fmt.Errorf(`unknown currency`)
		}
		return err
	}
	now := time.Now()

	m := model.AccountingMetadata{
		Source: "basecamp_accounting",
		ID:     fmt.Sprintf("%v", id),
	}
	bonusBytes, err := json.Marshal(&m)
	if err != nil {
		return err
	}
	temp, rate, err := h.service.Wise.Convert(float64(amount), c.Name, currency.VNDCurrency)
	if err != nil {
		return nil
	}
	am := model.NewVietnamDong(int64(temp))

	transaction := &model.AccountingTransaction{
		Name:             data[2],
		Amount:           float64(amount),
		Date:             &now,
		CurrencyID:       &c.ID,
		Currency:         c.Name,
		Category:         checkCategory(strings.ToLower(data[2])),
		Type:             model.AccountingOP,
		ConversionAmount: am.Format(),
		ConversionRate:   rate,
		Metadata:         bonusBytes,
	}

	err = h.StoreOperationAccountingTransaction(transaction)
	if err != nil {
		return err
	}

	return nil
}

func (h *handler) StoreOperationAccountingTransaction(t *model.AccountingTransaction) error {
	if err := h.store.Accounting.CreateTransaction(h.repo.DB(), t); err != nil {
		return err
	}
	return nil
}

func checkCategory(content string) string {
	switch {
	case strings.Contains(content, "office rental") || strings.Contains(content, "cbre"):
		return model.AccountingOfficeSpace
	default:
		return model.AccountingOfficeServices
	}
}

```

# pkg/handler/webhook/basecamp.go

```go
package webhook

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

func basecampWebhookMessageFromCtx(c *gin.Context) (model.BasecampWebhookMessage, error) {
	var msg model.BasecampWebhookMessage
	err := msg.Decode(msg.Read(c.Request.Body))
	if err != nil {
		return msg, err
	}
	return msg, nil
}

// ValidateBasecampExpense dry-run expense request for validation
func (h *handler) ValidateBasecampExpense(c *gin.Context) {
	msg, err := basecampWebhookMessageFromCtx(c)
	if err != nil {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, ""))
		return
	}

	err = h.basecampExpenseValidate(msg)
	if err != nil {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, ""))
}

// CreateBasecampExpense runs expense process in basecamp
func (h *handler) CreateBasecampExpense(c *gin.Context) {
	msg, err := basecampWebhookMessageFromCtx(c)
	if err != nil {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, ""))
		return
	}

	err = h.createBasecampExpense(msg, msg.Read(c.Request.Body))
	if err != nil {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, ""))
}

// UncheckBasecampExpense will remove expesne record after expense todo complete
func (h *handler) UncheckBasecampExpense(c *gin.Context) {
	msg, err := basecampWebhookMessageFromCtx(c)
	if err != nil {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, ""))
		return
	}

	err = h.UncheckBasecampExpenseHandler(msg, msg.Read(c.Request.Body))
	if err != nil {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, ""))
}

// StoreAccountingTransaction run commpany accouting expense process
func (h *handler) StoreAccountingTransaction(c *gin.Context) {
	msg, err := basecampWebhookMessageFromCtx(c)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	err = h.StoreAccountingTransactionFromBasecamp(msg)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, ""))
}

// MarkInvoiceAsPaidViaBasecamp --
func (h *handler) MarkInvoiceAsPaidViaBasecamp(c *gin.Context) {
	msg, err := basecampWebhookMessageFromCtx(c)
	if err != nil {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, ""))
		return
	}

	if err := h.markInvoiceAsPaid(&msg); err != nil {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, ""))
}

func (h *handler) markInvoiceAsPaid(msg *model.BasecampWebhookMessage) error {
	invoice, err := h.GetInvoiceViaBasecampTitle(msg)
	if err != nil {
		h.worker.Enqueue(bcModel.BasecampCommentMsg, h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, err.Error(), bcModel.CommentMsgTypeFailed))
		return err
	}

	if invoice == nil {
		return nil
	}

	if _, err := h.controller.Invoice.MarkInvoiceAsPaidByBasecampWebhookMessage(invoice, msg); err != nil {
		return err
	}

	// log discord as audit log
	_ = h.controller.Discord.Log(model.LogDiscordInput{
		Type: "invoice_paid",
		Data: map[string]interface{}{
			"invoice_number": invoice.Number,
		},
	})

	return nil
}

// ValidateOnLeaveRequest validates on-leave request and give feedback comments
func (h *handler) ValidateOnLeaveRequest(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "basecamp",
		"method":  "ValidateOnLeaveRequest",
	})

	var msg model.BasecampWebhookMessage
	err := msg.Decode(msg.Read(c.Request.Body))
	if err != nil {
		l.Error(err, "decode Basecamp msg failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	err = h.handleOnLeaveValidation(msg)
	if err != nil {
		l.Error(err, "onleave validation failed")
	}
	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, ""))
}

// ApproveOnLeaveRequest saves on-leave request in a database
func (h *handler) ApproveOnLeaveRequest(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "basecamp",
		"method":  "ApproveOnLeaveRequest",
	})

	var msg model.BasecampWebhookMessage
	err := msg.Decode(msg.Read(c.Request.Body))
	if err != nil {
		l.Error(err, "failed to decode basecamp message")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	err = h.handleApproveOnLeaveRequest(msg)
	if err != nil {
		l.Error(err, "failed to handle approve on leave request")
	}
	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, ""))
}

```

# pkg/handler/survey/survey_test.go

```go
package survey

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/require"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/survey/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils/testhelper"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

const testToken = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M"

func TestHandler_ListSurvey(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		query            string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "empty_query",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/list_survey/400_empty_query.json",
		},
		{
			name:             "get_peer_review",
			query:            "subtype=peer-review",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list_survey/200_get_peer_review.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/list_survey/list_survey.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/surveys?%s", tt.query), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.URL.RawQuery = tt.query

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.ListSurvey(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.ListSurvey] response mismatched")
			})
		})
	}
}

func TestHandler_GetSurveyDetail(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		id               string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "happy_case",
			id:               "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_survey_detail/200_happy_case.json",
		},
		{
			name:             "ok_engagement",
			id:               "53546ea4-1d9d-4216-96b2-75f84ec6d750",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_survey_detail/200_engagement.json",
		},
		{
			name:             "ok_work",
			id:               "d97ee823-f7d5-418b-b281-711cb1d8e947",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_survey_detail/200_work.json",
		},
		{
			name:             "event_id_not_found",
			id:               "8a5bfedb-6e11-4f5c-82d9-2635cfcce123",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/get_survey_detail/404_event_id_not_found.json",
		},
		{
			name:             "empty_event_id",
			id:               "",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_survey_detail/invalid_event_id.json",
		},
		{
			name:             "invalid_event_id_format",
			id:               "8a5bfedb-6e11-4f5c-82d9-2635cfcce1234",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_survey_detail/invalid_event_id.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_survey_detail/get_survey_detail.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/surveys/%s", tt.id), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.id)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.GetSurveyDetail(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.GetSurveyDetail] response mismatched")
			})
		})
	}
}

func TestHandler_SendPerformanceReview(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		id               string
		wantCode         int
		wantResponsePath string
		body             request.SendSurveyInput
	}{
		{
			name:             "happy_case",
			id:               "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/send_survey/200_performance_review.json",
			body: request.SendSurveyInput{
				TopicIDs: []view.UUID{
					view.MustGetUUIDFromString("e4a33adc-2495-43cf-b816-32feb8d5250d"),
				},
				Type: model.EventSubtypePeerReview.String(),
			},
		},
		{
			name:             "ok_send_engagement",
			id:               "53546ea4-1d9d-4216-96b2-75f84ec6d750",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/send_survey/200_send_engagement.json",
			body: request.SendSurveyInput{
				Type: model.EventSubtypeEngagement.String(),
			},
		},
		{
			name:             "not_found_case",
			id:               "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e1",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/send_survey/404.json",
			body: request.SendSurveyInput{
				TopicIDs: []view.UUID{
					view.MustGetUUIDFromString("e4a33adc-2495-43cf-b816-32feb8d5250d"),
				},
				Type: model.EventSubtypePeerReview.String(),
			},
		},
		{
			name:             "empty_event_id",
			id:               "",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/send_survey/invalid_event_id.json",
		},
		{
			name:             "invalid_event_id_format",
			id:               "8a5bfedb-6e11-4f5c-82d9-2635cfcce1234",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/send_survey/invalid_event_id.json",
		},
		{
			name:             "invalid_subtype",
			id:               "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/send_survey/invalid_subtype.json",
			body: request.SendSurveyInput{
				TopicIDs: []view.UUID{
					view.MustGetUUIDFromString("e4a33adc-2495-43cf-b816-32feb8d5250d"),
				},
				Type: "a",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/send_survey/send_survey.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				byteReq, _ := json.Marshal(tt.body)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/surveys/%s/send", tt.id), bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.id)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.SendSurvey(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.SendSurvey] response mismatched")
			})
		})
	}
}

func TestHandler_DeleteSurvey(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		id               string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "valid_id",
			id:               "163fdda2-2dce-4618-9849-7c8475dcc9c1",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/delete_survey/200_valid_id.json",
		},
		{
			name:             "event_not_found",
			id:               "163fdda2-2dce-4618-9849-7c8475dcc123",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/delete_survey/404_event_not_found.json",
		},
		{
			name:             "empty_event_id",
			id:               "",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_survey/invalid_event_id.json",
		},
		{
			name:             "invalid_event_id_format",
			id:               "8a5bfedb-6e11-4f5c-82d9-2635cfcce1234",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_survey/invalid_event_id.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/delete_survey/delete_survey.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodDelete, fmt.Sprintf("/api/v1/surveys/%s", tt.id), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.id)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.DeleteSurvey(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.DeleteSurvey] response mismatched")
			})
		})
	}
}

func TestHandler_GetPeerReviewDetail(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		feedbackID       string
		topicID          string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_peer_review_detail/200.json",
			feedbackID:       "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
		},
		{
			name:             "failed_topic_not_found",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/get_peer_review_detail/404.json",
			feedbackID:       "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250e",
		},
		{
			name:             "empty_feedback_id",
			feedbackID:       "",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_peer_review_detail/invalid_feedback_id.json",
		},
		{
			name:             "invalid_feedback_id_format",
			feedbackID:       "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e23",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_peer_review_detail/invalid_feedback_id.json",
		},
		{
			name:             "empty_topic_id",
			feedbackID:       "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_peer_review_detail/invalid_topic_id.json",
		},
		{
			name:             "invalid_topic_id_format",
			feedbackID:       "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250de",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_peer_review_detail/invalid_topic_id.json",
		},
		{
			name:             "topic_not_found",
			feedbackID:       "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250e",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/get_peer_review_detail/topic_not_found.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_peer_review_detail/get_peer_review_detail.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.feedbackID}, gin.Param{Key: "topicID", Value: tt.topicID}}
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/surveys/%s/topics/%s", tt.feedbackID, tt.topicID), nil)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.GetSurveyTopicDetail(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.GetSurveyTopicDetail] response mismatched")
			})
		})
	}
}

func TestHandler_UpdateTopicReviewers(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		input            request.UpdateTopicReviewersInput
		wantCode         int
		wantResponsePath string
	}{
		{
			name: "happy_case",
			input: request.UpdateTopicReviewersInput{
				EventID: "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
				TopicID: "e4a33adc-2495-43cf-b816-32feb8d5250d",
				Body: request.UpdateTopicReviewersBody{
					ReviewerIDs: []view.UUID{
						view.MustGetUUIDFromString("d42a6fca-d3b8-4a48-80f7-a95772abda56"),
						view.MustGetUUIDFromString("dcfee24b-306d-4609-9c24-a4021639a11b"),
						view.MustGetUUIDFromString("3f705527-0455-4e67-a585-6c1f23726fff"),
						view.MustGetUUIDFromString("a1f25e3e-cf40-4d97-a4d5-c27ee566b8c5"),
						view.MustGetUUIDFromString("498d5805-dd64-4643-902d-95067d6e5ab5"),
						view.MustGetUUIDFromString("f6ce0d0f-5794-463b-ad0b-8240ab9c49be"),
						view.MustGetUUIDFromString("7bcf4b45-0279-4da2-84e4-eec5d9d05ba3"),
					},
				},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/update_topic_participants/200_happy_case.json",
		},
		{
			name: "participant_not_ready",
			input: request.UpdateTopicReviewersInput{
				EventID: "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
				TopicID: "e4a33adc-2495-43cf-b816-32feb8d5250d",
				Body: request.UpdateTopicReviewersBody{
					ReviewerIDs: []view.UUID{
						view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("d389d35e-c548-42cf-9f29-2a599969a8f2"),
						view.MustGetUUIDFromString("f7c6016b-85b5-47f7-8027-23c2db482197"),
						view.MustGetUUIDFromString("d42a6fca-d3b8-4a48-80f7-a95772abda56"),
						view.MustGetUUIDFromString("dcfee24b-306d-4609-9c24-a4021639a11b"),
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_topic_participants/400_participant_not_ready.json",
		},
		{
			name: "empty_event_id",
			input: request.UpdateTopicReviewersInput{
				EventID: "",
				TopicID: "e4a33adc-2495-43cf-b816-32feb8d5250d",
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_topic_participants/invalid_event_id.json",
		},
		{
			name: "invalid_event_id_format",
			input: request.UpdateTopicReviewersInput{
				EventID: "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e23",
				TopicID: "e4a33adc-2495-43cf-b816-32feb8d5250d",
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_topic_participants/invalid_event_id.json",
		},
		{
			name: "empty_topic_id",
			input: request.UpdateTopicReviewersInput{
				EventID: "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
				TopicID: "",
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_topic_participants/invalid_topic_id.json",
		},
		{
			name: "invalid_topic_id_format",
			input: request.UpdateTopicReviewersInput{
				EventID: "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
				TopicID: "e4a33adc-2495-43cf-b816-32feb8d5250de",
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_topic_participants/invalid_topic_id.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_topic_participants/update_topic_participants.sql")
				body, err := json.Marshal(tt.input.Body)
				require.NoError(t, err)

				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPut,
					fmt.Sprintf("/api/v1/surveys/%s/topics/%s/employees", tt.input.EventID, tt.input.TopicID),
					bytes.NewBuffer(body))
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.input.EventID)
				ctx.AddParam("topicID", tt.input.TopicID)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.UpdateTopicReviewers(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.UpdateTopicReviewers] response mismatched")
			})
		})
	}
}

func TestHandler_MarkDone(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		eventID          string
	}{
		{
			name:             "happy_case",
			eventID:          "9b3480be-86a2-4ff9-84d8-545a4146122b",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/mark_done/200.json",
		},
		{
			name:             "not_found",
			eventID:          "9b3480be-86a2-4ff9-84d8-545a4146122a",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/mark_done/404.json",
		},
		{
			name:             "empty_event_id",
			eventID:          "",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/mark_done/invalid_event_id.json",
		},
		{
			name:             "invalid_event_id_format",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e23",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/mark_done/invalid_event_id.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/mark_done/mark_done.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPut, fmt.Sprintf("/api/v1/surveys/%s/done", tt.eventID), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.eventID)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.MarkDone(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.MarkDone] response mismatched")
			})
		})
	}
}

func TestHandler_DeleteTopicReviewers(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		input            request.DeleteTopicReviewersInput
		wantCode         int
		wantResponsePath string
	}{
		{
			name: "happy_case",
			input: request.DeleteTopicReviewersInput{
				EventID: "53546ea4-1d9d-4216-96b2-75f84ec6d750",
				TopicID: "11121775-118f-4896-8246-d88023b22c7a",
				Body: request.DeleteTopicReviewersBody{
					ReviewerIDs: []view.UUID{
						view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
					},
				},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/delete_topic_participants/200.json",
		},
		{
			name: "not_found_employee",
			input: request.DeleteTopicReviewersInput{
				EventID: "53546ea4-1d9d-4216-96b2-75f84ec6d750",
				TopicID: "11121775-118f-4896-8246-d88023b22c7a",
				Body: request.DeleteTopicReviewersBody{
					ReviewerIDs: []view.UUID{
						view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98cd"),
					},
				},
			},
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/delete_topic_participants/404.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/delete_topic_participants/delete_topic_participants.sql")
				body, err := json.Marshal(tt.input.Body)
				require.NoError(t, err)

				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPut,
					fmt.Sprintf("/api/v1/surveys/%s/topics/%s/employees", tt.input.EventID, tt.input.TopicID),
					bytes.NewBuffer(body))
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.input.EventID)
				ctx.AddParam("topicID", tt.input.TopicID)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.DeleteTopicReviewers(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.DeleteTopicReviewers] response mismatched")
			})
		})
	}
}

func TestHandler_DeleteSurveyTopic(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		eventID          string
		topicID          string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "valid_id",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e1",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250e",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/delete_survey/200_valid_id.json",
		},
		{
			name:             "event_not_found",
			eventID:          "163fdda2-2dce-4618-9849-7c8475dcc999",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d52999",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_survey/404_event_not_found.json",
		},
		{
			name:             "empty_event_id",
			eventID:          "",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_survey/invalid_event_id.json",
		},
		{
			name:             "invalid_event_id_format",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e23",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_survey/invalid_event_id.json",
		},
		{
			name:             "empty_topic_id",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_survey/invalid_topic_id.json",
		},
		{
			name:             "invalid_topic_id_format",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250de",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_survey/invalid_topic_id.json",
		},
		{
			name:             "topic_not_found",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250e",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/delete_survey/topic_not_found.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/delete_survey/delete_survey.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodDelete, fmt.Sprintf("/api/v1/surveys/%s/topics/%s", tt.eventID, tt.topicID), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.eventID)
				ctx.AddParam("topicID", tt.topicID)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.DeleteSurveyTopic(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.DeleteSurveyTopic] response mismatched")
			})
		})
	}
}

func TestHandler_GetSurveyReviewDetail(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		eventID          string
		topicID          string
		reviewerID       string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "valid_id",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e1",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250e",
			reviewerID:       "bc9a5715-9723-4a2f-ad42-0d0f19a80b4d",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/get_survey_review_detail/404_not_found.json",
		},
		{
			name:             "happy_case",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
			reviewerID:       "bc9a5715-9723-4a2f-ad42-0d0f19a80b4d",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_survey_review_detail/200_happy_case.json",
		},
		{
			name:             "ok_work",
			eventID:          "d97ee823-f7d5-418b-b281-711cb1d8e947",
			topicID:          "9cf93fc1-5a38-4e2a-87de-41634b65fc87",
			reviewerID:       "789f1163-f157-4df3-9764-8100277cacba",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_survey_review_detail/200_work.json",
		},
		{
			name:             "empty_event_id",
			eventID:          "",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
			reviewerID:       "bc9a5715-9723-4a2f-ad42-0d0f19a80b4d",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_survey_review_detail/invalid_event_id.json",
		},
		{
			name:             "invalid_event_id_format",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e23",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
			reviewerID:       "bc9a5715-9723-4a2f-ad42-0d0f19a80b4d",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_survey_review_detail/invalid_event_id.json",
		},
		{
			name:             "empty_topic_id",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "",
			reviewerID:       "bc9a5715-9723-4a2f-ad42-0d0f19a80b4d",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_survey_review_detail/invalid_topic_id.json",
		},
		{
			name:             "invalid_topic_id_format",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250de",
			reviewerID:       "bc9a5715-9723-4a2f-ad42-0d0f19a80b4d",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_survey_review_detail/invalid_topic_id.json",
		},
		{
			name:             "empty_reviewer_id",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
			reviewerID:       "",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_survey_review_detail/invalid_review_id.json",
		},
		{
			name:             "empty_reviewer_id",
			eventID:          "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
			reviewerID:       "e4a33adc-2495-43cf-b816-32feb8d5250de",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_survey_review_detail/invalid_review_id.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_survey_review_detail/get_survey_review_detail.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodDelete, fmt.Sprintf("/api/v1/surveys/%s/topics/%s/reviews/%s", tt.eventID, tt.topicID, tt.reviewerID), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.eventID)
				ctx.AddParam("topicID", tt.topicID)
				ctx.AddParam("reviewID", tt.reviewerID)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.GetSurveyReviewDetail(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.GetSurveyReviewDetail] response mismatched")
			})
		})
	}
}

func TestHandler_CreateSurvey(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		id               string
		wantCode         int
		wantResponsePath string
		body             request.CreateSurveyFeedbackInput
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/create_survey/200_work.json",
			body: request.CreateSurveyFeedbackInput{
				Quarter:  "q3,q4",
				Year:     2023,
				Type:     "peer-review",
				FromDate: "2023-11-28",
				ToDate:   "2023-11-29",
			},
		},
		{
			name:             "invalid_range_date",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create_survey/400.json",
			body: request.CreateSurveyFeedbackInput{
				Quarter:  "q3,q4",
				Year:     2023,
				Type:     "work",
				FromDate: "2023-11-30",
				ToDate:   "2023-11-29",
			},
		},
		{
			name:             "invalid_subtype",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create_survey/invalid_subtype.json",
			body: request.CreateSurveyFeedbackInput{
				Quarter:  "q3,q4",
				Year:     2023,
				Type:     "peer-revieww",
				FromDate: "2023-11-28",
				ToDate:   "2023-11-29",
			},
		},
		{
			name:             "invalid_date",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create_survey/invalid_date.json",
			body: request.CreateSurveyFeedbackInput{
				Quarter:  "q3,q4",
				Year:     2023,
				Type:     "work",
				FromDate: "2023-13-28",
				ToDate:   "2023-11-29",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/create_survey/create_survey.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				byteReq, _ := json.Marshal(tt.body)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Request = httptest.NewRequest(http.MethodGet, "/api/v1/surveys", bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.CreateSurvey(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Survey.SendSurvey] response mismatched")
			})
		})
	}
}

```

# pkg/handler/survey/survey.go

```go
package survey

import (
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/survey/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/survey/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/store/employeeeventtopic"
	"github.com/dwarvesf/fortress-api/pkg/store/project"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

// New returns a handler
func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

// ListSurvey godoc
// @Summary Get list event
// @Description Get list event
// @id ListSurvey
// @Tags Survey
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param subtype query string true "Event Subtype"
// @Param page query string false "Page"
// @Param size query string false "Size"
// @Param sort query string false "Sort"
// @Param subtype query string true "Event Subtype"
// @Success 200 {object} ListSurveyResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys [get]
func (h *handler) ListSurvey(c *gin.Context) {
	input := request.GetListSurveyInput{}
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	pagination := model.Pagination{
		Page: input.Page,
		Size: input.Size,
		Sort: input.Sort,
	}

	pagination.Standardize()

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "ListSurvey",
		"input":   pagination,
	})

	events, total, err := h.store.FeedbackEvent.GetBySubtype(h.repo.DB(), input.Subtype, pagination)
	if err != nil {
		l.Error(err, "failed to get feedback events by subtype")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// count likert-scale question by event and projects
	if input.Subtype == model.EventSubtypeWork.String() {
		for i := range events {
			counts, err := h.getQuestionDomainCountsByEvent(h.repo.DB(), events[i].ID.String())
			if err != nil {
				l.AddField("eventID", events[i].ID).Error(err, "failed to get QuestionDomainCounts by event")
				c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
				return
			}

			events[i].QuestionDomainCounts = counts
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListSurvey(events),
		&view.PaginationResponse{Pagination: view.Pagination{Size: pagination.Size, Page: pagination.Page, Sort: pagination.Sort}, Total: total}, nil, nil, ""))
}

func (h *handler) getQuestionDomainCountsByEvent(db *gorm.DB, eventID string) ([]model.QuestionDomainCount, error) {
	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "GetQuestionDomainCountByEvent",
		"eventID": eventID,
	})

	// count likert-scale questions
	wlCount, err := h.store.EmployeeEventQuestion.
		CountLikertScaleByEventIDAndDomain(h.repo.DB(), eventID, model.QuestionDomainWorkload.String())
	if err != nil {
		l.Error(err, "failed to count workload questions by eventID and domain")
		return nil, err
	}

	dlCount, err := h.store.EmployeeEventQuestion.
		CountLikertScaleByEventIDAndDomain(h.repo.DB(), eventID, model.QuestionDomainDeadline.String())
	if err != nil {
		l.Error(err, "failed to count deadline questions by eventID and domain")
		return nil, err
	}

	lnCount, err := h.store.EmployeeEventQuestion.
		CountLikertScaleByEventIDAndDomain(h.repo.DB(), eventID, model.QuestionDomainLearning.String())
	if err != nil {
		l.Error(err, "failed to count learning questions by eventID and domain")
		return nil, err
	}

	counts := []model.QuestionDomainCount{
		{
			Domain:           model.QuestionDomainWorkload,
			LikertScaleCount: *wlCount,
		},
		{
			Domain:           model.QuestionDomainDeadline,
			LikertScaleCount: *dlCount,
		},
		{
			Domain:           model.QuestionDomainLearning,
			LikertScaleCount: *lnCount,
		},
	}

	return counts, nil
}

// GetSurveyDetail godoc
// @Summary Get survey detail
// @Description Get survey detail
// @id GetSurveyDetail
// @Tags Survey
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Feedback Event ID"
// @Param page query string false "Page"
// @Param size query string false "Size"
// @Param keyword query string false "Keyword"
// @Param status query string false "Status"
// @Param projects query []string false "Projects"
// @Success 200 {object} ListSurveyDetailResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys/{id} [get]
func (h *handler) GetSurveyDetail(c *gin.Context) {
	input := request.GetSurveyDetailInput{
		EventID: c.Param("id"),
	}
	if err := c.ShouldBindQuery(&input.Query); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	pagination := model.Pagination{
		Page: input.Query.Page,
		Size: input.Query.Size,
		Sort: input.Query.Sort,
	}

	pagination.Standardize()

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "GetSurveyDetail",
		"input":   input,
	})

	// check feedback event existence
	event, err := h.store.FeedbackEvent.One(h.repo.DB(), input.EventID, true)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(err, "event not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEventNotFound, input, ""))
		return
	}
	if err != nil {
		l.Error(err, "failed to get feedback event")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	topics, total, err := h.store.EmployeeEventTopic.All(h.repo.DB(),
		employeeeventtopic.GetByEventIDInput{
			EventID:  input.EventID,
			Keyword:  input.Query.Keyword,
			Status:   input.Query.Status,
			Projects: input.Query.Projects,
			Preload:  true,
			Paging:   true,
		},
		&pagination)
	if err != nil {
		l.Error(err, "failed to get employee event topic by eventID")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	event.Topics = topics

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToSurveyDetail(event),
		&view.PaginationResponse{Pagination: view.Pagination{Size: pagination.Size, Page: pagination.Page, Sort: pagination.Sort}, Total: total}, nil, nil, ""))
}

// CreateSurvey godoc
// @Summary Create new survey
// @Description Create new survey
// @id CreateSurvey
// @Tags Survey
// @Accept  json
// @Produce  json
// @Param Body body request.CreateSurveyFeedbackInput true "Body"
// @Security BearerAuth
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys [post]
func (h *handler) CreateSurvey(c *gin.Context) {
	// 1. parse request
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	var req request.CreateSurveyFeedbackInput

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "CreateSurvey",
		"input":   req,
	})

	if err := req.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	switch model.EventSubtype(req.Type) {
	case model.EventSubtypePeerReview:
		status, err := h.createPeerReview(tx.DB(), req, userID)
		if err != nil {
			l.Error(err, "failed to create new survey peer review")
			c.JSON(status, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
	case model.EventSubtypeEngagement:
		status, err := h.createEngagement(tx.DB(), req, userID)
		if err != nil {
			l.Error(err, "failed to create new survey engagement")
			c.JSON(status, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
	case model.EventSubtypeWork:
		status, err := h.createWorkEvent(tx.DB(), req, userID)
		if err != nil {
			l.Error(err, "failed to create new survey work")
			c.JSON(status, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

func (h *handler) createPeerReview(db *gorm.DB, req request.CreateSurveyFeedbackInput, userID string) (int, error) {
	//1. convert data
	var startTime, endTime time.Time
	var title string

	if req.Year < time.Now().Year()-1 {
		return http.StatusBadRequest, errs.ErrInvalidYear
	}

	switch strings.ToLower(strings.ReplaceAll(req.Quarter, " ", "")) {
	case "q1,q2":
		startTime = time.Date(req.Year, 1, 1, 0, 0, 0, 0, time.UTC)
		endTime = time.Date(req.Year, 6, 30, 23, 59, 59, 59, time.UTC)
		title = fmt.Sprintf("Q1/Q2, %d", req.Year)
	case "q3,q4":
		startTime = time.Date(req.Year, 7, 1, 0, 0, 0, 0, time.UTC)
		endTime = time.Date(req.Year, 12, 31, 23, 59, 59, 59, time.UTC)
		title = fmt.Sprintf("Q3/Q4, %d", req.Year)
	default:
		return http.StatusBadRequest, errs.ErrInvalidQuarter
	}

	//1.2 check event existed
	_, err := h.store.FeedbackEvent.OneByTypeInTimeRange(db, model.EventTypeSurvey, model.EventSubtypePeerReview, &startTime, &endTime)
	if err == nil {
		return http.StatusBadRequest, errs.ErrEventAlreadyExisted
	} else {
		if !errors.Is(err, gorm.ErrRecordNotFound) {
			return http.StatusInternalServerError, err
		}
	}

	//1.3 check employee existed
	createdBy, err := h.store.Employee.One(db, userID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return http.StatusNotFound, errs.ErrEmployeeNotFound
		}
		return http.StatusInternalServerError, err
	}

	//2. Create FeedbackEvent
	event, err := h.store.FeedbackEvent.Create(db, &model.FeedbackEvent{
		BaseModel: model.BaseModel{
			ID: model.NewUUID(),
		},
		Title:     title,
		Type:      model.EventTypeSurvey,
		Subtype:   model.EventSubtype(req.Type),
		Status:    model.EventStatusDraft,
		CreatedBy: createdBy.ID,
		StartDate: &startTime,
		EndDate:   &endTime,
	})
	if err != nil {
		return http.StatusInternalServerError, err
	}

	//3. create EmployeeEventTopic
	employees, err := h.store.Employee.GetByWorkingStatus(db, model.WorkingStatusFullTime)
	if err != nil {
		return http.StatusInternalServerError, err
	}

	eets := make([]model.EmployeeEventTopic, 0)
	for _, e := range employees {
		isDwarves := false
		for _, o := range e.Organizations {
			if o.Code == model.OrganizationCodeDwarves {
				isDwarves = true
				break
			}
		}
		if isDwarves {
			topicTitle := fmt.Sprintf("Peer Performance Review: %s - %s", e.DisplayName, title)
			eets = append(eets, model.EmployeeEventTopic{
				BaseModel: model.BaseModel{
					ID: model.NewUUID(),
				},
				Title:      topicTitle,
				EventID:    event.ID,
				EmployeeID: e.ID,
				Employee:   e,
			})
		}
	}

	i := 0
	for i < len(eets) {
		to := i + 100
		if to > len(eets) {
			to = len(eets)
		}
		_, err = h.store.EmployeeEventTopic.BatchCreate(db, eets[i:to])
		if err != nil {
			return http.StatusInternalServerError, err
		}
		i = to
	}

	//4. create EmployeeEventReviewer
	employeeEventMapper := make(map[model.UUID]model.UUID)
	for _, e := range eets {
		employeeEventMapper[e.EmployeeID] = e.ID
	}

	reviewers := make([]model.EmployeeEventReviewer, 0)

	//TODO: will reused this function later
	// peers, err := h.store.WorkUnitMember.GetPeerReviewerInTimeRange(db, &startTime, &endTime)
	// if err != nil {
	// 	return http.StatusInternalServerError, err
	// }

	peers, err := h.store.WorkUnitMember.GetActivePeerReviewer(db)
	if err != nil {
		return http.StatusInternalServerError, err
	}

	reviewerMap := make(map[model.UUID]model.UUID)
	for _, p := range peers {
		canReview := false
		for _, e := range eets {
			if e.EmployeeID == p.EmployeeID {
				canReview = true
				break
			}
		}
		if canReview && !p.ReviewerID.IsZero() {
			reviewerMap[p.ReviewerID] = p.EmployeeID
			reviewers = append(reviewers, model.EmployeeEventReviewer{
				BaseModel: model.BaseModel{
					ID: model.NewUUID(),
				},
				EventID:              event.ID,
				EmployeeEventTopicID: employeeEventMapper[p.EmployeeID],
				ReviewerID:           p.ReviewerID,
				Relationship:         model.RelationshipPeer,
				AuthorStatus:         model.EventAuthorStatusDraft,
				ReviewerStatus:       model.EventReviewerStatusNone,
				IsShared:             false,
				IsRead:               false,
			})
		}
	}

	for _, e := range eets {
		if !e.Employee.LineManagerID.IsZero() {
			_, ok := reviewerMap[e.Employee.LineManagerID]
			if ok {
				continue
			}

			reviewers = append(reviewers, model.EmployeeEventReviewer{
				BaseModel: model.BaseModel{
					ID: model.NewUUID(),
				},
				EventID:              event.ID,
				EmployeeEventTopicID: e.ID,
				ReviewerID:           e.Employee.LineManagerID,
				Relationship:         model.RelationshipLineManager,
				AuthorStatus:         model.EventAuthorStatusDraft,
				ReviewerStatus:       model.EventReviewerStatusNone,
				IsShared:             false,
				IsRead:               false,
			})
		}
	}

	i = 0
	for i < len(reviewers) {
		to := i + 100
		if to > len(reviewers) {
			to = len(reviewers)
		}
		_, err = h.store.EmployeeEventReviewer.BatchCreate(db, reviewers[i:to])
		if err != nil {
			return http.StatusInternalServerError, err
		}
		i = to
	}

	//4. create EmployeeEventQuestion
	questions, err := h.store.Question.AllByCategory(db, model.EventTypeSurvey, model.EventSubtypePeerReview)
	if err != nil {
		return http.StatusInternalServerError, err
	}

	eventQuestions := make([]model.EmployeeEventQuestion, 0)

	for _, r := range reviewers {
		for _, q := range questions {
			eventQuestions = append(eventQuestions, model.EmployeeEventQuestion{
				BaseModel: model.BaseModel{
					ID: model.NewUUID(),
				},
				EmployeeEventReviewerID: r.ID,
				QuestionID:              q.ID,
				EventID:                 r.EventID,
				Content:                 q.Content,
				Type:                    q.Type.String(),
				Order:                   q.Order,
				Domain:                  q.Domain,
			})
		}
	}

	i = 0
	for i < len(eventQuestions) {
		to := i + 100
		if to > len(eventQuestions) {
			to = len(eventQuestions)
		}
		_, err = h.store.EmployeeEventQuestion.BatchCreate(db, eventQuestions[i:to])
		if err != nil {
			return http.StatusInternalServerError, err
		}
		i = to
	}

	return http.StatusOK, nil
}

func (h *handler) createEngagement(db *gorm.DB, req request.CreateSurveyFeedbackInput, userID string) (int, error) {
	//1. convert data
	var startTime, endTime time.Time
	var title string

	if req.Year < time.Now().Year()-1 {
		return http.StatusBadRequest, errs.ErrInvalidYear
	}

	switch strings.ToLower(strings.ReplaceAll(req.Quarter, " ", "")) {
	case "q1":
		startTime = time.Date(req.Year, 1, 1, 0, 0, 0, 0, time.UTC)
		endTime = time.Date(req.Year, 3, 31, 23, 59, 59, 59, time.UTC)
		title = fmt.Sprintf("Q1, %d", req.Year)
	case "q2":
		startTime = time.Date(req.Year, 4, 1, 0, 0, 0, 0, time.UTC)
		endTime = time.Date(req.Year, 6, 30, 23, 59, 59, 59, time.UTC)
		title = fmt.Sprintf("Q2, %d", req.Year)
	case "q3":
		startTime = time.Date(req.Year, 7, 1, 0, 0, 0, 0, time.UTC)
		endTime = time.Date(req.Year, 9, 30, 23, 59, 59, 59, time.UTC)
		title = fmt.Sprintf("Q3, %d", req.Year)
	case "q4":
		startTime = time.Date(req.Year, 10, 1, 0, 0, 0, 0, time.UTC)
		endTime = time.Date(req.Year, 12, 31, 23, 59, 59, 59, time.UTC)
		title = fmt.Sprintf("Q4, %d", req.Year)
	default:
		return http.StatusBadRequest, errs.ErrInvalidQuarter
	}

	//1.2 check event existed
	_, err := h.store.FeedbackEvent.OneByTypeInTimeRange(db, model.EventTypeSurvey, model.EventSubtypeEngagement, &startTime, &endTime)
	if err == nil {
		return http.StatusBadRequest, errs.ErrEventAlreadyExisted
	} else {
		if !errors.Is(err, gorm.ErrRecordNotFound) {
			return http.StatusInternalServerError, err
		}
	}

	//1.3 check employee existed
	createdBy, err := h.store.Employee.One(db, userID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return http.StatusNotFound, errs.ErrEmployeeNotFound
		}
		return http.StatusInternalServerError, err
	}

	//2. Create FeedbackEvent
	event, err := h.store.FeedbackEvent.Create(db, &model.FeedbackEvent{
		BaseModel: model.BaseModel{
			ID: model.NewUUID(),
		},
		Title:     title,
		Type:      model.EventTypeSurvey,
		Subtype:   model.EventSubtype(req.Type),
		Status:    model.EventStatusDraft,
		CreatedBy: createdBy.ID,
		StartDate: &startTime,
		EndDate:   &endTime,
	})
	if err != nil {
		return http.StatusInternalServerError, err
	}

	//3. create EmployeeEventTopic
	employees, err := h.store.Employee.GetByWorkingStatus(db, model.WorkingStatusFullTime)
	if err != nil {
		return http.StatusInternalServerError, err
	}

	eets := make([]model.EmployeeEventTopic, 0)
	for _, e := range employees {
		isDwarves := false
		for _, o := range e.Organizations {
			if o.Code == model.OrganizationCodeDwarves {
				isDwarves = true
				break
			}
		}
		if isDwarves {
			topicTitle := fmt.Sprintf("Engagement Survey: %s - %s", e.DisplayName, title)
			eets = append(eets, model.EmployeeEventTopic{
				BaseModel: model.BaseModel{
					ID: model.NewUUID(),
				},
				Title:      topicTitle,
				EventID:    event.ID,
				EmployeeID: e.ID,
			})
		}
	}

	i := 0
	for i < len(eets) {
		to := i + 100
		if to > len(eets) {
			to = len(eets)
		}
		_, err = h.store.EmployeeEventTopic.BatchCreate(db, eets[i:to])
		if err != nil {
			return http.StatusInternalServerError, err
		}
		i = to
	}

	//4. create EmployeeEventReviewer
	employeeEventMapper := make(map[model.UUID]model.UUID)
	for _, e := range eets {
		employeeEventMapper[e.EmployeeID] = e.ID
	}

	reviewers := make([]model.EmployeeEventReviewer, 0)

	for _, e := range eets {
		reviewers = append(reviewers, model.EmployeeEventReviewer{
			BaseModel: model.BaseModel{
				ID: model.NewUUID(),
			},
			EventID:              event.ID,
			EmployeeEventTopicID: e.ID,
			ReviewerID:           e.EmployeeID,
			Relationship:         model.RelationshipSelf,
			AuthorStatus:         model.EventAuthorStatusDraft,
			ReviewerStatus:       model.EventReviewerStatusNone,
			IsShared:             false,
			IsRead:               false,
		})
	}

	i = 0
	for i < len(reviewers) {
		to := i + 100
		if to > len(reviewers) {
			to = len(reviewers)
		}
		_, err = h.store.EmployeeEventReviewer.BatchCreate(db, reviewers[i:to])
		if err != nil {
			return http.StatusInternalServerError, err
		}
		i = to
	}

	//5. create EmployeeEventQuestion
	questions, err := h.store.Question.AllByCategory(db, model.EventTypeSurvey, model.EventSubtypeEngagement)
	if err != nil {
		return http.StatusInternalServerError, err
	}

	eventQuestions := make([]model.EmployeeEventQuestion, 0)

	for _, r := range reviewers {
		for _, q := range questions {
			eventQuestions = append(eventQuestions, model.EmployeeEventQuestion{
				BaseModel: model.BaseModel{
					ID: model.NewUUID(),
				},
				EmployeeEventReviewerID: r.ID,
				QuestionID:              q.ID,
				EventID:                 r.EventID,
				Content:                 q.Content,
				Type:                    q.Type.String(),
				Order:                   q.Order,
				Domain:                  q.Domain,
			})
		}
	}

	i = 0
	for i < len(eventQuestions) {
		to := i + 100
		if to > len(eventQuestions) {
			to = len(eventQuestions)
		}
		_, err = h.store.EmployeeEventQuestion.BatchCreate(db, eventQuestions[i:to])
		if err != nil {
			return http.StatusInternalServerError, err
		}
		i = to
	}

	return 200, nil
}

func (h *handler) createWorkEvent(db *gorm.DB, req request.CreateSurveyFeedbackInput, userID string) (int, error) {
	//1.1 convert data
	fromDate, err := time.Parse("2006-01-02", req.FromDate)
	if err != nil {
		return http.StatusBadRequest, errs.ErrInvalidDate
	}
	toDate, err := time.Parse("2006-01-02", req.ToDate)
	if err != nil {
		return http.StatusBadRequest, errs.ErrInvalidDate
	}
	if fromDate.Add(time.Hour * 24 * 14).Before(toDate) {
		return http.StatusBadRequest, errs.ErrInvalidDateRange
	}

	title := fromDate.Format("Jan 02, 2006") + " - " + toDate.Format("Jan 02, 2006")

	//1.2 check event existed
	_, err = h.store.FeedbackEvent.OneByTypeInTimeRange(db, model.EventTypeSurvey, model.EventSubtypeWork, &fromDate, &toDate)
	if err == nil {
		return http.StatusBadRequest, errs.ErrEventAlreadyExisted
	} else {
		if !errors.Is(err, gorm.ErrRecordNotFound) {
			return http.StatusInternalServerError, err
		}
	}

	//1.3 check employee existed
	createdBy, err := h.store.Employee.One(db, userID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return http.StatusNotFound, errs.ErrEmployeeNotFound
		}
		return http.StatusInternalServerError, err
	}

	//2. Create FeedbackEvent
	event, err := h.store.FeedbackEvent.Create(db, &model.FeedbackEvent{
		BaseModel: model.BaseModel{
			ID: model.NewUUID(),
		},
		Title:     title,
		Type:      model.EventTypeSurvey,
		Subtype:   model.EventSubtype(req.Type),
		Status:    model.EventStatusDraft,
		CreatedBy: createdBy.ID,
		StartDate: &fromDate,
		EndDate:   &toDate,
	})
	if err != nil {
		return http.StatusInternalServerError, err
	}

	projects, _, err := h.store.Project.All(db, project.GetListProjectInput{
		Statuses:            []string{model.ProjectStatusActive.String()},
		AllowsSendingSurvey: true,
	}, model.Pagination{})
	if err != nil {
		return http.StatusInternalServerError, err
	}

	if len(projects) < 1 {
		return http.StatusNotFound, errs.ErrNoValidProjectForEvent
	}

	projectIDs := make([]string, 0)
	for _, p := range projects {
		projectIDs = append(projectIDs, p.ID.String())
	}

	//3. create EmployeeEventTopic
	employees, err := h.store.ProjectMember.GetActiveByProjectIDs(db, projectIDs)
	if err != nil {
		return http.StatusInternalServerError, err
	}

	eets := make([]model.EmployeeEventTopic, 0)
	for _, e := range employees {
		p, err := h.store.Project.One(db, e.ProjectID.String(), false)
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return http.StatusNotFound, errs.ErrProjectNotFound
			}
			return http.StatusInternalServerError, err
		}

		eets = append(eets, model.EmployeeEventTopic{
			BaseModel: model.BaseModel{
				ID: model.NewUUID(),
			},
			Title:      fmt.Sprintf("%s Survey: %s - %s", p.Name, title, e.Employee.DisplayName),
			EventID:    event.ID,
			EmployeeID: e.EmployeeID,
			ProjectID:  e.ProjectID,
		})
	}

	i := 0
	for i < len(eets) {
		to := i + 100
		if to > len(eets) {
			to = len(eets)
		}
		_, err = h.store.EmployeeEventTopic.BatchCreate(db, eets[i:to])
		if err != nil {
			return http.StatusInternalServerError, err
		}
		i = to
	}

	//4. create EmployeeEventReviewer
	employeeEventMapper := make(map[model.UUID]model.UUID)
	for _, e := range eets {
		employeeEventMapper[e.EmployeeID] = e.ID
	}

	reviewers := make([]model.EmployeeEventReviewer, 0)

	for _, e := range eets {
		reviewers = append(reviewers, model.EmployeeEventReviewer{
			BaseModel: model.BaseModel{
				ID: model.NewUUID(),
			},
			EventID:              event.ID,
			EmployeeEventTopicID: e.ID,
			ReviewerID:           e.EmployeeID,
			Relationship:         model.RelationshipSelf,
			AuthorStatus:         model.EventAuthorStatusSent,
			ReviewerStatus:       model.EventReviewerStatusNew,
			IsShared:             false,
			IsRead:               false,
		})
	}

	i = 0
	for i < len(reviewers) {
		to := i + 100
		if to > len(reviewers) {
			to = len(reviewers)
		}
		_, err = h.store.EmployeeEventReviewer.BatchCreate(db, reviewers[i:to])
		if err != nil {
			return http.StatusInternalServerError, err
		}
		i = to
	}

	//5. create EmployeeEventQuestion
	questions, err := h.store.Question.AllByCategory(db, model.EventTypeSurvey, model.EventSubtypeWork)
	if err != nil {
		return http.StatusInternalServerError, err
	}

	eventQuestions := make([]model.EmployeeEventQuestion, 0)

	for _, r := range reviewers {
		for _, q := range questions {
			eventQuestions = append(eventQuestions, model.EmployeeEventQuestion{
				BaseModel: model.BaseModel{
					ID: model.NewUUID(),
				},
				EmployeeEventReviewerID: r.ID,
				QuestionID:              q.ID,
				EventID:                 r.EventID,
				Content:                 q.Content,
				Type:                    q.Type.String(),
				Order:                   q.Order,
				Domain:                  q.Domain,
			})
		}
	}

	i = 0
	for i < len(eventQuestions) {
		to := i + 100
		if to > len(eventQuestions) {
			to = len(eventQuestions)
		}
		_, err = h.store.EmployeeEventQuestion.BatchCreate(db, eventQuestions[i:to])
		if err != nil {
			return http.StatusInternalServerError, err
		}
		i = to
	}

	return http.StatusOK, nil
}

// SendSurvey godoc
// @Summary Send the survey
// @Description Send the survey
// @id SendSurvey
// @Tags Survey
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Feedback Event ID"
// @Param Body body SendSurveyInput true "Body"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys/{id}/send [post]
func (h *handler) SendSurvey(c *gin.Context) {
	eventID := c.Param("id")
	if eventID == "" || !model.IsUUIDFromString(eventID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventID, nil, ""))
		return
	}

	var input request.SendSurveyInput
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if !model.EventSubtype(input.Type).IsValid() {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventSubType, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "SendSurvey",
		"eventID": eventID,
		"input":   input,
	})

	// Begin transaction
	tx, done := h.repo.NewTransaction()

	event, err := h.store.FeedbackEvent.One(h.repo.DB(), eventID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrEventNotFound, "feedback event not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrEventNotFound), input, ""))
			return
		}

		l.Error(err, "failed to get feedback event")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	switch input.Type {
	case model.EventSubtypeEngagement.String():
		topicIDs := make([]model.UUID, 0)
		for _, topic := range event.Topics {
			topicIDs = append(topicIDs, topic.ID)
		}

		for _, data := range topicIDs {
			errCode, err := h.updateEventReviewer(tx.DB(), l, data, eventID)
			if err != nil {
				l.Error(err, "error when running function updateEventReviewer")
				c.JSON(errCode, view.CreateResponse[any](nil, nil, done(err), input, ""))
				return
			}
		}

	default:
		for _, data := range input.TopicIDs {
			errCode, err := h.updateEventReviewer(tx.DB(), l, model.UUID(data), eventID)
			if err != nil {
				l.Error(err, "error when running function updateEventReviewer")
				c.JSON(errCode, view.CreateResponse[any](nil, nil, done(err), input, ""))
				return
			}
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, done(nil), "ok"))
}

func (h *handler) updateEventReviewer(db *gorm.DB, l logger.Logger, topicID model.UUID, eventID string) (int, error) {
	// Get all reviewers by topicID
	reviewers, err := h.store.EmployeeEventReviewer.GetByTopicID(db, topicID.String())
	if err != nil {
		l.Error(err, "failed to get employee event reviewers")
		return http.StatusInternalServerError, err
	}

	// Validate EventID and TopicID
	_, err = h.store.EmployeeEventTopic.One(db, topicID.String(), eventID, false)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(errs.ErrTopicNotFound, "topic not found")
		return http.StatusNotFound, errs.ErrTopicNotFound
	}
	if err != nil {
		l.Error(err, "failed to get employee event topic")
		return http.StatusInternalServerError, err
	}

	// Update Event status to inprogress
	event, err := h.store.FeedbackEvent.One(db, eventID, true)
	if err != nil {
		l.Error(err, "failed to get feedback event")
		return http.StatusInternalServerError, err
	}

	if event.Status == model.EventStatusDraft {
		event.Status = model.EventStatusInProgress

		_, err = h.store.FeedbackEvent.UpdateSelectedFieldsByID(db, eventID, *event, "status")
		if err != nil {
			l.Error(err, "failed to update status of feedback event")
			return http.StatusInternalServerError, err
		}
	}

	// Update status for employee reviewers
	for _, eventReviewer := range reviewers {
		if eventReviewer.ReviewerStatus == model.EventReviewerStatusNone {
			eventReviewer.ReviewerStatus = model.EventReviewerStatusNew
			eventReviewer.AuthorStatus = model.EventAuthorStatusSent

			_, err = h.store.EmployeeEventReviewer.UpdateSelectedFieldsByID(db, eventReviewer.ID.String(), *eventReviewer, "reviewer_status", "author_status")
			if err != nil {
				l.Errorf(err, "failed to update employee reviewer for reviewer ", eventReviewer.ID.String())
				return http.StatusInternalServerError, err
			}
		}
	}

	return http.StatusOK, nil
}

// DeleteSurvey godoc
// @Summary Delete survey by id
// @Description Delete survey by id
// @id DeleteSurvey
// @Tags Survey
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Feedback Event ID"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys/{id} [delete]
func (h *handler) DeleteSurvey(c *gin.Context) {
	eventID := c.Param("id")
	if eventID == "" || !model.IsUUIDFromString(eventID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventID, eventID, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "DeleteSurvey",
		"eventID": eventID,
	})

	tx, done := h.repo.NewTransaction()

	if statusCode, err := h.doSurveyDelete(tx.DB(), eventID); err != nil {
		l.Error(err, "failed to delete survey")
		c.JSON(statusCode, view.CreateResponse[any](nil, nil, done(err), eventID, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

func (h *handler) doSurveyDelete(db *gorm.DB, eventID string) (int, error) {
	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "deleteSurvey",
		"eventID": eventID,
	})

	// check feedback event existence
	exists, err := h.store.FeedbackEvent.IsExist(db, eventID)
	if err != nil {
		l.Error(err, "failed to check feedback event existence")
		return http.StatusInternalServerError, err
	}
	if !exists {
		l.Error(err, "feedback event not found")
		return http.StatusNotFound, errs.ErrEventNotFound
	}

	if err := h.store.EmployeeEventQuestion.DeleteByEventID(db, eventID); err != nil {
		l.Error(err, "failed to delete feedback events")
		return http.StatusInternalServerError, err
	}

	if err := h.store.EmployeeEventReviewer.DeleteByEventID(db, eventID); err != nil {
		l.Error(err, "failed to delete event reviewers")
		return http.StatusInternalServerError, err
	}

	if err := h.store.EmployeeEventTopic.DeleteByEventID(db, eventID); err != nil {
		l.Error(err, "failed to delete event topics")
		return http.StatusInternalServerError, err
	}

	if err := h.store.FeedbackEvent.DeleteByID(db, eventID); err != nil {
		l.Error(err, "failed to delete event")
		return http.StatusInternalServerError, err
	}

	return http.StatusOK, nil
}

// GetSurveyReviewDetail godoc
// @Summary Get survey review detail
// @Description Get survey review detail
// @id GetSurveyReviewDetail
// @Tags Survey
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} FeedbackReviewDetailResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys/{id}/topics/{topicID}/reviews/{reviewID} [get]
func (h *handler) GetSurveyReviewDetail(c *gin.Context) {
	eventID := c.Param("id")
	if eventID == "" || !model.IsUUIDFromString(eventID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventID, nil, ""))
		return
	}

	topicID := c.Param("topicID")
	if topicID == "" || !model.IsUUIDFromString(topicID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidTopicID, nil, ""))
		return
	}

	reviewID := c.Param("reviewID")
	if reviewID == "" || !model.IsUUIDFromString(reviewID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidReviewerID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "GetSurveyReviewDetail",
	})

	topic, err := h.store.EmployeeEventTopic.One(h.repo.DB(), topicID, eventID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("topic not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrTopicNotFound, nil, ""))
			return
		}
		l.Error(err, "failed when getting topic")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	review, err := h.store.EmployeeEventReviewer.One(h.repo.DB(), reviewID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("review not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEventReviewerNotFound, nil, ""))
			return
		}
		l.Error(err, "failed when getting review")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	if review.EmployeeEventTopicID != topic.ID {
		l.Info("review not belong topic")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrEventReviewerNotFound, nil, ""))
		return
	}

	questions, err := h.store.EmployeeEventQuestion.GetByEventReviewerID(h.repo.DB(), review.ID.String())
	if err != nil {
		l.Error(err, "failed when getting questions")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	var project *model.Project
	if !topic.ProjectID.IsZero() {
		project, err = h.store.Project.One(h.repo.DB(), topic.ProjectID.String(), false)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrProjectNotFound, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}

		if err != nil {
			l.Error(err, "failed to get project")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToFeedbackReviewDetail(questions, topic, review, project), nil, nil, nil, ""))
}

// DeleteSurveyTopic godoc
// @Summary delete survey topic
// @Description delete survey topic
// @id DeleteSurveyTopic
// @Tags Survey
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys/{id}/topics/{topicID} [delete]
func (h *handler) DeleteSurveyTopic(c *gin.Context) {
	eventID := c.Param("id")
	if eventID == "" || !model.IsUUIDFromString(eventID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventID, nil, ""))
		return
	}

	topicID := c.Param("topicID")
	if topicID == "" || !model.IsUUIDFromString(topicID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidTopicID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "DeleteSurveyTopic",
	})

	tx, done := h.repo.NewTransaction()

	// check feedback event existence
	exists, err := h.store.FeedbackEvent.IsExist(tx.DB(), eventID)
	if err != nil {
		l.Error(err, "failed to check feedback event existence")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}
	if !exists {
		l.Error(err, "feedback event not found")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, done(errs.ErrEventNotFound), nil, ""))
		return
	}

	_, err = h.store.EmployeeEventTopic.One(tx.DB(), topicID, eventID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("topic not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrTopicNotFound), nil, ""))
			return
		}
		l.Error(err, "failed when getting topic")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	reviews, err := h.store.EmployeeEventReviewer.GetByTopicID(tx.DB(), topicID)
	if err != nil {
		l.Error(err, "failed when getting reviews")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	reviewIDList := make([]string, 0)
	for _, r := range reviews {
		if r.AuthorStatus != model.EventAuthorStatusDraft {
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrReviewAlreadySent), nil, ""))
			return
		}
		reviewIDList = append(reviewIDList, r.ID.String())
	}

	if err := h.store.EmployeeEventQuestion.DeleteByEventReviewerIDList(tx.DB(), reviewIDList); err != nil {
		l.Error(err, "failed to delete feedback events")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	if err := h.store.EmployeeEventReviewer.DeleteByTopicID(tx.DB(), topicID); err != nil {
		l.Error(err, "failed to delete event reviewers")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	if err := h.store.EmployeeEventTopic.DeleteByID(tx.DB(), topicID); err != nil {
		l.Error(err, "failed to delete event topics")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

// GetSurveyTopicDetail godoc
// @Summary Get detail for peer review
// @Description Get detail for peer review
// @id GetSurveyTopicDetail
// @Tags Survey
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Feedback Event ID"
// @Param topicID path string true "Employee Event Topic ID"
// @Success 200 {object} view.SurveyTopicDetailResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys/{id}/topics/{topicID} [get]
func (h *handler) GetSurveyTopicDetail(c *gin.Context) {
	input := request.PeerReviewDetailInput{
		EventID: c.Param("id"),
		TopicID: c.Param("topicID"),
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "GetSurveyTopicDetail",
		"input":   input,
	})

	// Check topic and feedback existence
	topic, err := h.store.EmployeeEventTopic.One(h.repo.DB(), input.TopicID, input.EventID, true)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(errs.ErrTopicNotFound, "topic not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrTopicNotFound, input, ""))
		return
	}

	if err != nil {
		l.Error(err, "failed when getting topic")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToPeerReviewDetail(topic), nil, nil, nil, ""))
}

// UpdateTopicReviewers godoc
// @Summary Update reviewers in a topic
// @Description Update reviewers in a topic
// @id UpdateTopicReviewers
// @Tags Survey
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param Body body UpdateTopicReviewersBody true "Body"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys/{id}/topics/{topicID}/employees [put]
func (h *handler) UpdateTopicReviewers(c *gin.Context) {
	input := request.UpdateTopicReviewersInput{
		EventID: c.Param("id"),
		TopicID: c.Param("topicID"),
	}
	if err := c.ShouldBindJSON(&input.Body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "UpdateTopicReviewers",
		"input":   input,
	})

	if err := input.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	// check feedback event existence
	event, err := h.store.FeedbackEvent.One(h.repo.DB(), input.EventID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrEventNotFound, "feedback event not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEventNotFound, input, ""))
			return
		}
		l.Error(err, "failed to check feedback event existence")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if event.Subtype != model.EventSubtypePeerReview {
		l.Error(errs.ErrCanNotUpdateParticipants, "event does not allow updating participants")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrCanNotUpdateParticipants, input, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	if code, err := h.updateTopicReviewer(tx.DB(), input.EventID, input.TopicID, input.Body); err != nil {
		l.Error(err, "failed to update topic reviewers")
		c.JSON(code, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

func (h *handler) updateTopicReviewer(db *gorm.DB, eventID string, topicID string, body request.UpdateTopicReviewersBody) (int, error) {
	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "updateTopicReviewer",
		"eventID": eventID,
		"topicID": topicID,
		"body":    body,
	})

	employees, err := h.store.Employee.GetByWorkingStatus(db, model.WorkingStatusFullTime)
	if err != nil {
		l.Error(err, "failed to get employees by working status")
		return http.StatusInternalServerError, err
	}

	eventReviewers, err := h.store.EmployeeEventReviewer.GetByTopicID(db, topicID)
	if err != nil {
		l.Error(err, "failed to get event reviewers")
		return http.StatusInternalServerError, err
	}

	// check reviewer existence
	employeeMap := model.ToEmployeeMap(employees)
	mustCreateReviewerIDMap := map[model.UUID]bool{}
	for _, reviewerID := range body.ReviewerIDs {
		if _, ok := employeeMap[model.UUID(reviewerID)]; !ok {
			l.Errorf(errs.ErrEmployeeNotReady, "employee %v not ready", reviewerID)
			return http.StatusBadRequest, errs.ErrEmployeeNotReady
		}

		mustCreateReviewerIDMap[model.UUID(reviewerID)] = true
	}

	// delete event question and event topic if reviewerID is not exists in request
	for _, eventReviewer := range eventReviewers {
		if isExists := mustCreateReviewerIDMap[eventReviewer.ReviewerID]; isExists {
			mustCreateReviewerIDMap[eventReviewer.ReviewerID] = false
			continue
		}

		if err := h.store.EmployeeEventQuestion.DeleteByEventReviewerID(db, eventReviewer.ID.String()); err != nil {
			l.Error(err, "failed to delete event questions")
			return http.StatusInternalServerError, err
		}

		if err := h.store.EmployeeEventReviewer.DeleteByID(db, eventReviewer.ID.String()); err != nil {
			l.Error(err, "failed to delete event reviewer")
			return http.StatusInternalServerError, err
		}
	}

	eventTopic, err := h.store.EmployeeEventTopic.One(db, topicID, eventID, false)
	if err != nil {
		l.Error(err, "failed to get event topic")
		return http.StatusInternalServerError, err
	}

	// create event reviewer and event question if reviewerID not exist in database
	newEventReviewers := make([]model.EmployeeEventReviewer, 0)
	for reviewerID, mustCreate := range mustCreateReviewerIDMap {
		if mustCreate {
			relationship := model.RelationshipPeer
			if employeeMap[eventTopic.EmployeeID].LineManagerID == reviewerID ||
				employeeMap[reviewerID].LineManagerID == eventTopic.EmployeeID {
				relationship = model.RelationshipLineManager
			}

			newEventReviewers = append(newEventReviewers, model.EmployeeEventReviewer{
				EmployeeEventTopicID: model.MustGetUUIDFromString(topicID),
				ReviewerID:           reviewerID,
				AuthorStatus:         model.EventAuthorStatusDraft,
				ReviewerStatus:       model.EventReviewerStatusNone,
				Relationship:         relationship,
				EventID:              model.MustGetUUIDFromString(eventID),
			})
		}
	}

	if len(newEventReviewers) > 0 {
		newEventReviewers, err = h.store.EmployeeEventReviewer.BatchCreate(db, newEventReviewers)
		if err != nil {
			l.Error(err, "failed to batch create event reviews")
			return http.StatusInternalServerError, err
		}
	}

	if err := h.createEventQuestions(db, model.EventTypeSurvey, model.EventSubtypePeerReview, newEventReviewers); err != nil {
		l.Error(err, "failed to create event questions")
		return http.StatusInternalServerError, err
	}

	return http.StatusOK, nil
}

func (h *handler) createEventQuestions(db *gorm.DB, eventType model.EventType, eventSubtype model.EventSubtype, reviewers []model.EmployeeEventReviewer) error {
	l := h.logger.Fields(logger.Fields{
		"handler":      "survey",
		"method":       "createEventQuestions",
		"eventType":    eventType,
		"eventSubtype": eventSubtype,
	})

	questions, err := h.store.Question.AllByCategory(db, eventType, eventSubtype)
	if err != nil {
		l.Error(err, "failed to get all questions by category")
		return err
	}

	eventQuestions := make([]model.EmployeeEventQuestion, 0)

	for _, r := range reviewers {
		for _, q := range questions {
			eventQuestions = append(eventQuestions, model.EmployeeEventQuestion{
				BaseModel: model.BaseModel{
					ID: model.NewUUID(),
				},
				EmployeeEventReviewerID: r.ID,
				QuestionID:              q.ID,
				EventID:                 r.EventID,
				Content:                 q.Content,
				Type:                    q.Type.String(),
				Order:                   q.Order,
			})
		}
	}

	i := 0
	for i < len(eventQuestions) {
		to := i + 100
		if to > len(eventQuestions) {
			to = len(eventQuestions)
		}
		_, err = h.store.EmployeeEventQuestion.BatchCreate(db, eventQuestions[i:to])
		if err != nil {
			l.Error(err, "failed to batch create event questions")
			return err
		}
		i = to
	}

	return nil
}

// MarkDone godoc
// @Summary Mark done feedback event
// @Description Mark done feedback event
// @id MarkDone
// @Tags Survey
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Feedback Event ID"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys/{id}/done [put]
func (h *handler) MarkDone(c *gin.Context) {
	eventID := c.Param("id")

	if eventID == "" || !model.IsUUIDFromString(eventID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "MarkDone",
		"eventID": eventID,
	})

	// check feedback event existence
	exists, err := h.store.FeedbackEvent.IsExist(h.repo.DB(), eventID)
	if err != nil {
		l.Error(err, "failed to check feedback event existence")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, eventID, ""))
		return
	}
	if !exists {
		l.Error(errs.ErrEventNotFound, "feedback event not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEventNotFound, eventID, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	// Update event status
	event, err := h.store.FeedbackEvent.One(tx.DB(), eventID, true)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(errs.ErrEventNotFound, "feedback event not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEventNotFound, eventID, ""))
		return
	}

	if err != nil {
		l.Error(err, "failed to get feedback event")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, eventID, ""))
		return
	}

	if event.Status == model.EventStatusDone {
		l.Error(errs.ErrEventHasBeenDone, "event has been done")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrEventHasBeenDone, eventID, ""))
		return
	}

	event.Status = model.EventStatusDone

	_, err = h.store.FeedbackEvent.UpdateSelectedFieldsByID(tx.DB(), eventID, *event, "status")
	if err != nil {
		l.Error(err, "failed to update feedback event")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, eventID, ""))
		return
	}

	// Get all topics
	topics, _, err := h.store.EmployeeEventTopic.All(tx.DB(), employeeeventtopic.GetByEventIDInput{EventID: eventID}, nil)
	if err != nil {
		l.Error(err, "failed to get all topics")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), eventID, ""))
		return
	}

	// Check done for each topic: all user have to done
	for _, topic := range topics {
		if code, err := h.forceEventReviewersToDone(tx.DB(), l, topic.ID.String()); err != nil {
			l.Errorf(err, "failed to force event reviewers of topic %s to done", topic.ID.String())
			c.JSON(code, view.CreateResponse[any](nil, nil, done(err), eventID, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

func (h *handler) forceEventReviewersToDone(db *gorm.DB, l logger.Logger, topicID string) (int, error) {
	// Get all reviewers
	reviewers, err := h.store.EmployeeEventReviewer.GetByTopicID(db, topicID)
	if err != nil {
		l.Errorf(err, "failed to get all reviewers with topic ID %s", topicID)
		return http.StatusInternalServerError, err
	}

	for _, reviewer := range reviewers {
		if reviewer.AuthorStatus != model.EventAuthorStatusDone ||
			reviewer.ReviewerStatus != model.EventReviewerStatusDone {
			reviewer.AuthorStatus = model.EventAuthorStatusDone
			reviewer.ReviewerStatus = model.EventReviewerStatusDone
			reviewer.IsForcedDone = true
		}

		_, err := h.store.EmployeeEventReviewer.UpdateSelectedFieldsByID(db, reviewer.ID.String(), *reviewer,
			"author_status",
			"reviewer_status",
			"is_forced_done")
		if err != nil {
			l.AddField("eventReviewerID", reviewer.ID).Error(err, "failed to update event reviewer status")
			return http.StatusInternalServerError, err
		}
	}

	return http.StatusOK, nil
}

// DeleteTopicReviewers godoc
// @Summary Delete reviewers in a topic
// @Description Delete reviewers in a topic
// @id DeleteTopicReviewers
// @Tags Survey
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Feedback Event ID"
// @Param topicID path string true "Employee Event Topic ID"
// @Param Body body DeleteTopicReviewersBody true "Body"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /surveys/{id}/topics/{topicID}/employees [delete]
func (h *handler) DeleteTopicReviewers(c *gin.Context) {
	input := request.DeleteTopicReviewersInput{
		EventID: c.Param("id"),
		TopicID: c.Param("topicID"),
	}
	if err := c.ShouldBindJSON(&input.Body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "survey",
		"method":  "DeleteTopicReviewers",
		"input":   input,
	})

	if err := input.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	// Check topic and feedback existence
	_, err := h.store.EmployeeEventTopic.One(h.repo.DB(), input.TopicID, input.EventID, false)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(errs.ErrTopicNotFound, "topic not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrTopicNotFound, input, ""))
		return
	}

	if err != nil {
		l.Error(err, "failed when getting topic")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	tx, done := h.repo.NewTransaction()
	reviewerIDs := make([]model.UUID, 0)
	for _, id := range input.Body.ReviewerIDs {
		reviewerIDs = append(reviewerIDs, model.UUID(id))
	}

	if code, err := h.deleteTopicReviewer(tx.DB(), input.EventID, input.TopicID, reviewerIDs); err != nil {
		l.Error(err, "failed to delete topic reviewers")
		c.JSON(code, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

func (h *handler) deleteTopicReviewer(db *gorm.DB, eventID string, topicID string, reviewerIDs []model.UUID) (int, error) {
	l := h.logger.Fields(logger.Fields{
		"handler":     "survey",
		"method":      "deleteTopicReviewer",
		"eventID":     eventID,
		"topicID":     topicID,
		"reviewerIDs": reviewerIDs,
	})

	for _, reviewer := range reviewerIDs {
		eventReviewer, err := h.store.EmployeeEventReviewer.OneByReviewerID(db, reviewer.String(), topicID)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Errorf(errs.ErrEventReviewerNotFound, "reviewer not found with reviewerID ", reviewer)
			return http.StatusNotFound, errs.ErrEventReviewerNotFound
		}
		if err != nil {
			l.Errorf(err, "failed when get employee event reviewer with reviewerID ", reviewer)
			return http.StatusNotFound, errs.ErrEventReviewerNotFound
		}

		// Delete employee question
		if err := h.store.EmployeeEventQuestion.DeleteByEventReviewerID(db, eventReviewer.ID.String()); err != nil {
			l.Error(err, "failed to delete employee event question")
			return http.StatusInternalServerError, err
		}

		// Delete employee reviewer
		if err := h.store.EmployeeEventReviewer.DeleteByID(db, eventReviewer.ID.String()); err != nil {
			l.Error(err, "failed to delete employee event reviewer")
			return http.StatusInternalServerError, err
		}
	}

	return http.StatusOK, nil
}

```

# pkg/handler/survey/interface.go

```go
package survey

import "github.com/gin-gonic/gin"

type IHandler interface {
	ListSurvey(c *gin.Context)
	GetSurveyDetail(c *gin.Context)
	GetSurveyReviewDetail(c *gin.Context)
	SendSurvey(c *gin.Context)
	CreateSurvey(c *gin.Context)
	DeleteSurvey(c *gin.Context)
	DeleteSurveyTopic(c *gin.Context)
	GetSurveyTopicDetail(c *gin.Context)
	UpdateTopicReviewers(c *gin.Context)
	MarkDone(c *gin.Context)
	DeleteTopicReviewers(c *gin.Context)
}

```

# pkg/handler/project/project_test.go

```go
package project

import (
	"bytes"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"github.com/dwarvesf/fortress-api/pkg/controller"

	"github.com/dwarvesf/fortress-api/pkg/handler/project/request"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils/testhelper"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/shopspring/decimal"

	"github.com/gin-gonic/gin"
	"github.com/goccy/go-json"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/require"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils"
)

const testToken = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M"

func TestHandler_Detail(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		id               string
		query            string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "happy_case_slug",
			id:               "fortress",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_project/200.json",
		},
		{
			name:             "happy_case",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_project/200.json",
		},
		{
			name:             "not_found",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b11",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/get_project/404.json",
		},
		{
			name:             "not_found_slug",
			id:               "a",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/get_project/404.json",
		},
		{
			name:             "empty_project_id",
			id:               "",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_project/invalid_project_id.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_project/get_project.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/projects/%v", tt.id), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.URL.RawQuery = tt.query
				ctx.AddParam("id", tt.id)

				h := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.Details(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res := w.Body.Bytes()
				res, _ = utils.RemoveFieldInResponse(res, "createdAt")
				res, _ = utils.RemoveFieldInResponse(res, "updatedAt")

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Project.Details] response mismatched")
			})
		})
	}
}

func TestHandler_List(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
		query            string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_projects/200.json",
			query:            "sort=-updatedAt",
		},
		{
			name:             "happy_case_with_pagination",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_projects/200_with_paging.json",
			query:            "page=1&size=1&sort=-updatedAt",
		},
		{
			name:             "invalid_project_type",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_projects/invalid_project_type.json",
			query:            "type=a",
		},
		{
			name:             "invalid_project_status",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_projects/invalid_project_status.json",
			query:            "status=a",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_projects/get_projects.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/projects?%s", tt.query), nil)
				ctx.Request.URL.RawQuery = tt.query
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.List(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res := w.Body.Bytes()
				res, _ = utils.RemoveFieldInResponse(res, "createdAt")
				res, _ = utils.RemoveFieldInResponse(res, "updatedAt")

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Project.List] response mismatched")
			})
		})
	}
}

func TestHandler_UpdateProjectStatus(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          bool
		wantResponsePath string
		request          request.UpdateProjectStatusBody
		id               string
	}{
		{
			name:             "ok_update_project_status",
			wantCode:         http.StatusOK,
			wantErr:          false,
			wantResponsePath: "testdata/update_project_status/200.json",
			request: request.UpdateProjectStatusBody{
				ProjectStatus: "active",
			},
			id: "8dc3be2e-19a4-4942-8a79-56db391a0b15",
		},
		{
			name:             "failed_invalid_project_id",
			wantCode:         http.StatusNotFound,
			wantErr:          true,
			wantResponsePath: "testdata/update_project_status/404.json",
			request: request.UpdateProjectStatusBody{
				ProjectStatus: "active",
			},
			id: "8dc3be2e-19a4-4942-8a79-56db391a0b11",
		},
		{
			name:             "failed_invalid_value_for_status",
			wantCode:         http.StatusBadRequest,
			wantErr:          true,
			wantResponsePath: "testdata/update_project_status/400.json",
			request: request.UpdateProjectStatusBody{
				ProjectStatus: "activee",
			},
			id: "8dc3be2e-19a4-4942-8a79-56db391a0b15",
		},
		{
			name:             "empty_project_id",
			wantCode:         http.StatusBadRequest,
			wantErr:          true,
			wantResponsePath: "testdata/update_project_status/invalid_project_id.json",
			request: request.UpdateProjectStatusBody{
				ProjectStatus: "activee",
			},
			id: "",
		},
		{
			name:             "wrong_format_project_id",
			wantCode:         http.StatusBadRequest,
			wantErr:          true,
			wantResponsePath: "testdata/update_project_status/invalid_project_id.json",
			request: request.UpdateProjectStatusBody{
				ProjectStatus: "activee",
			},
			id: "8dc3be2e-19a4-4942-8a79-56db391a0b15a",
		},
	}

	for _, tt := range tests {
		testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
			testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_project_status/update_project_status.sql")
			byteReq, err := json.Marshal(tt.request)
			require.Nil(t, err)

			t.Run(tt.name, func(t *testing.T) {
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}}
				ctx.Request = httptest.NewRequest("POST", fmt.Sprintf("/api/v1/projects/%s/status", tt.id), bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)
				metadataHandler := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.UpdateProjectStatus(ctx)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.Equal(t, tt.wantCode, w.Code)
				res, err := utils.RemoveFieldInResponse(w.Body.Bytes(), "updatedAt")
				require.Nil(t, err)
				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.UpdateProjectStatus] response mismatched")
			})
		})
	}
}

func TestHandler_Create(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		args             request.CreateProjectRequest
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name: "happy_case",
			args: request.CreateProjectRequest{
				Name:      "Project1",
				Status:    string(model.ProjectStatusOnBoarding),
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:      view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail:   "a@gmail.com",
				ClientEmail:    []string{"b@gmail.com", "c@gmail.com"},
				Function:       model.ProjectFunctionLearning.String(),
				BankAccountID:  view.MustGetUUIDFromString("e79eb5b3-e2cb-4d7f-9273-46f4be88cb20"),
				ClientID:       view.MustGetUUIDFromString("afb9cf05-9517-4fb9-a4f2-66e6d90ad215"),
				OrganizationID: view.MustGetUUIDFromString("31fdf38f-77c0-4c06-b530-e2be8bc297e0"),
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/create/200.json",
		},
		{
			name: "duplicate_slug",
			args: request.CreateProjectRequest{
				Name:      "Lorem Ipsum",
				Status:    string(model.ProjectStatusOnBoarding),
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"b@gmail.com"},
				Code:         "lorem-ipsum",
				Function:     model.ProjectFunctionLearning.String(),
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_duplicate_slug.json",
		},
		{
			name: "invalid_status",
			args: request.CreateProjectRequest{
				Name:      "project1",
				Status:    "something",
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"b@gmail.com"},
				Function:     model.ProjectFunctionLearning.String(),
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_invalid_status.json",
		},
		{
			name: "missing_status",
			args: request.CreateProjectRequest{
				Name:      "project1",
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"b@gmail.com"},
				Function:     model.ProjectFunctionLearning.String(),
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_misssing_status.json",
		},
		{
			name: "missing_account_manager",
			args: request.CreateProjectRequest{
				Name:      "Project1",
				Status:    string(model.ProjectStatusOnBoarding),
				StartDate: "2022-11-14",
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"b@gmail.com", "c@gmail.com"},
				Function:     model.ProjectFunctionLearning.String(),
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_missing_account_manager.json",
		},
		{
			name: "invalid_email_domain",
			args: request.CreateProjectRequest{
				Name:      "Project1",
				Status:    string(model.ProjectStatusOnBoarding),
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"bgmail.com", "c@gmail.com"},
				Function:     model.ProjectFunctionLearning.String(),
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_invalid_email.json",
		},
		{
			name: "invalid_function",
			args: request.CreateProjectRequest{
				Name:      "Project1",
				Status:    string(model.ProjectStatusOnBoarding),
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"b@gmail.com", "c@gmail.com"},
				Function:     "a",
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_invalid_function.json",
		},
		{
			name: "400_invalid_deployment_type",
			args: request.CreateProjectRequest{
				Name:      "project1",
				Status:    string(model.ProjectStatusOnBoarding),
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"b@gmail.com"},
				Function:     model.ProjectFunctionDevelopment.String(),
				Members: []request.AssignMemberRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						SeniorityID:    view.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5"),
						Positions:      []view.UUID{view.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5")},
						DeploymentType: "a",
						Status:         model.ProjectMemberStatusOnBoarding.String(),
						Rate:           decimal.NewFromInt(10),
						StartDate:      "2022-11-14",
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_invalid_deployment_type.json",
		},
		{
			name: "invalid_project_member_status",
			args: request.CreateProjectRequest{
				Name:      "project1",
				Status:    string(model.ProjectStatusOnBoarding),
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"b@gmail.com"},
				Function:     model.ProjectFunctionDevelopment.String(),
				Members: []request.AssignMemberRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						SeniorityID:    view.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5"),
						Positions:      []view.UUID{view.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5")},
						DeploymentType: model.MemberDeploymentTypeOfficial.String(),
						Status:         "a",
						Rate:           decimal.NewFromInt(10),
						StartDate:      "2022-11-14",
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_project_member_status.json",
		},
		{
			name: "empty_project_position",
			args: request.CreateProjectRequest{
				Name:      "project1",
				Status:    string(model.ProjectStatusOnBoarding),
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"b@gmail.com"},
				Function:     model.ProjectFunctionDevelopment.String(),
				Members: []request.AssignMemberRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						SeniorityID:    view.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5"),
						Positions:      []view.UUID{},
						DeploymentType: model.MemberDeploymentTypeOfficial.String(),
						Status:         model.ProjectMemberStatusOnBoarding.String(),
						Rate:           decimal.NewFromInt(10),
						StartDate:      "2022-11-14",
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_project_position_empty.json",
		},
		{
			name: "invalid_member_start_date",
			args: request.CreateProjectRequest{
				Name:      "project1",
				Status:    string(model.ProjectStatusOnBoarding),
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"b@gmail.com"},
				Function:     model.ProjectFunctionDevelopment.String(),
				Members: []request.AssignMemberRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						SeniorityID:    view.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5"),
						Positions:      []view.UUID{view.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5")},
						DeploymentType: model.MemberDeploymentTypeOfficial.String(),
						Status:         model.ProjectMemberStatusOnBoarding.String(),
						Rate:           decimal.NewFromInt(10),
						StartDate:      "2022-13-14",
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_invalid_start_date_member.json",
		},
		{
			name: "invalid_member_end_date",
			args: request.CreateProjectRequest{
				Name:      "project1",
				Status:    string(model.ProjectStatusOnBoarding),
				StartDate: "2022-11-14",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				CountryID:    view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				ProjectEmail: "a@gmail.com",
				ClientEmail:  []string{"b@gmail.com"},
				Function:     model.ProjectFunctionDevelopment.String(),
				Members: []request.AssignMemberRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						SeniorityID:    view.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5"),
						Positions:      []view.UUID{view.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5")},
						DeploymentType: model.MemberDeploymentTypeOfficial.String(),
						Status:         model.ProjectMemberStatusOnBoarding.String(),
						Rate:           decimal.NewFromInt(10),
						StartDate:      "2022-11-14",
						EndDate:        "2022-13-13",
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create/400_invalid_end_date_member.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/create/create.sql")
				body, err := json.Marshal(tt.args)
				if err != nil {
					t.Error(err)
					return
				}

				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPost, "/api/v1/projects", bytes.NewBuffer(body))
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.Header.Set("Content-Type", gin.MIMEJSON)

				h := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.Create(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res := w.Body.Bytes()
				res, _ = utils.RemoveFieldInResponse(res, "id")
				res, _ = utils.RemoveFieldInResponse(res, "createdAt")
				res, _ = utils.RemoveFieldInResponse(res, "updatedAt")

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Project.Create] response mismatched")
			})
		})
	}
}

func TestHandler_GetMembers(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		id               string
		query            string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "happy_case",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			query:            "status=active",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_members/200.json",
		},
		{
			name:             "happy_case_without_preload",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			query:            "preload=false",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_members/without_preload.json",
		},
		{
			name:             "happy_case_with_unique",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			query:            "preload=false&distinct=true",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_members/distinct.json",
		},
		{
			name:             "invalid_project_id_format",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b156",
			query:            "preload=false",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_members/invalid_project_id.json",
		},
		{
			name:             "invalid_project_member_status",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			query:            "preload=false&status=invalid",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_members/invalid_project_member_status.json",
		},
		{
			name:             "project_not_found",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b16",
			query:            "preload=false",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/get_members/project_not_found.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_members/get_members.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPost, fmt.Sprintf("/api/v1/projects/%v/members", tt.id), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.URL.RawQuery = tt.query
				ctx.AddParam("id", tt.id)

				h := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.GetMembers(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res := w.Body.Bytes()
				res, _ = utils.RemoveFieldInResponse(res, "id")
				res, _ = utils.RemoveFieldInResponse(res, "createdAt")
				res, _ = utils.RemoveFieldInResponse(res, "updatedAt")

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Project.GetMembers] response mismatched")
			})
		})
	}
}

func TestHandler_UpdateMember(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		id               string
		args             request.UpdateMemberRequest
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name: "happy_case",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			args: request.UpdateMemberRequest{
				ProjectSlotID: view.MustGetUUIDFromString("f32d08ca-8863-4ab3-8c84-a11849451eb7"),
				EmployeeID:    view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
				SeniorityID:   view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusActive.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         true,
				Note:           "",
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/update_member/200_success.json",
		},

		{
			name: "invalid_start_date",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			args: request.UpdateMemberRequest{
				ProjectSlotID: view.MustGetUUIDFromString("f32d08ca-8863-4ab3-8c84-a11849451eb7"),
				EmployeeID:    view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
				SeniorityID:   view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusActive.String(),
				StartDate:      "2022-13-01",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         true,
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_member/400_invalid_start_date.json",
		},
		{
			name: "project_not_found",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b16",
			args: request.UpdateMemberRequest{
				ProjectSlotID: view.MustGetUUIDFromString("f32d08ca-8863-4ab3-8c84-a11849451eb7"),
				EmployeeID:    view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
				SeniorityID:   view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusActive.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         true,
			},
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_member/404_project_not_found.json",
		},
		{
			name: "empty_project_id",
			id:   "",
			args: request.UpdateMemberRequest{
				ProjectSlotID: view.MustGetUUIDFromString("f32d08ca-8863-4ab3-8c84-a11849451eb7"),
				EmployeeID:    view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
				SeniorityID:   view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusActive.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         true,
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_member/invalid_project_id.json",
		},
		{
			name: "invalid_project_id_format",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b168",
			args: request.UpdateMemberRequest{
				ProjectSlotID: view.MustGetUUIDFromString("f32d08ca-8863-4ab3-8c84-a11849451eb7"),
				EmployeeID:    view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
				SeniorityID:   view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusActive.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         true,
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_member/invalid_project_id.json",
		},
		{
			name: "invalid_deployment_type",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			args: request.UpdateMemberRequest{
				ProjectSlotID: view.MustGetUUIDFromString("f32d08ca-8863-4ab3-8c84-a11849451eb7"),
				EmployeeID:    view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
				SeniorityID:   view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: "invalid",
				Status:         model.ProjectMemberStatusActive.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         true,
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_member/invalid_deployment_type.json",
		},
		{
			name: "invalid_status",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			args: request.UpdateMemberRequest{
				ProjectSlotID: view.MustGetUUIDFromString("f32d08ca-8863-4ab3-8c84-a11849451eb7"),
				EmployeeID:    view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
				SeniorityID:   view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         "invalid",
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         true,
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_member/invalid_status.json",
		},
		{
			name: "seniority_not_found",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			args: request.UpdateMemberRequest{
				ProjectSlotID: view.MustGetUUIDFromString("f32d08ca-8863-4ab3-8c84-a11849451eb7"),
				EmployeeID:    view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
				SeniorityID:   view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732f9"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusOnBoarding.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         true,
			},
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_member/seniority_not_found.json",
		},
		{
			name: "position_not_found",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			args: request.UpdateMemberRequest{
				ProjectSlotID: view.MustGetUUIDFromString("f32d08ca-8863-4ab3-8c84-a11849451eb7"),
				EmployeeID:    view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
				SeniorityID:   view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec9"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusOnBoarding.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         true,
			},
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_member/position_not_found.json",
		},
		{
			name: "project_slot_not_found",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			args: request.UpdateMemberRequest{
				ProjectSlotID: view.MustGetUUIDFromString("f32d08ca-8863-4ab3-8c84-a11849451eb8"),
				EmployeeID:    view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
				SeniorityID:   view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusOnBoarding.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         true,
			},
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_member/project_slot_not_found.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_member/update_member.sql")
				body, err := json.Marshal(tt.args)
				if err != nil {
					t.Error(err)
					return
				}

				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPut, fmt.Sprintf("/api/v1/projects/%v/members", tt.id), bytes.NewBuffer(body))
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.Header.Set("Content-Type", gin.MIMEJSON)
				ctx.AddParam("id", tt.id)

				h := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.UpdateMember(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res := w.Body.Bytes()
				res, _ = utils.RemoveFieldInResponse(res, "projectSlotID")
				res, _ = utils.RemoveFieldInResponse(res, "projectMemberID")

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Project.UpdateMember] response mismatched")
			})
		})
	}
}

func TestHandler_AssignMember(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		id               string
		args             request.AssignMemberRequest
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name: "happy_case",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			args: request.AssignMemberRequest{
				EmployeeID:  view.MustGetUUIDFromString("fae443f8-e8ff-4eec-b86c-98216d7662d8"),
				SeniorityID: view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusActive.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         false,
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/assign_member/200_success.json",
		},
		{
			name: "empty_project_id",
			id:   "",
			args: request.AssignMemberRequest{
				EmployeeID:  view.MustGetUUIDFromString("fae443f8-e8ff-4eec-b86c-98216d7662d8"),
				SeniorityID: view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusActive.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         false,
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/assign_member/invalid_project_id.json",
		},
		{
			name: "invalid_project_id_format",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b156",
			args: request.AssignMemberRequest{
				EmployeeID:  view.MustGetUUIDFromString("fae443f8-e8ff-4eec-b86c-98216d7662d8"),
				SeniorityID: view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusActive.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         false,
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/assign_member/invalid_project_id.json",
		},
		{
			name: "project_not_found",
			id:   "8dc3be2e-19a4-4942-8a79-56db391a0b16",
			args: request.AssignMemberRequest{
				EmployeeID:  view.MustGetUUIDFromString("fae443f8-e8ff-4eec-b86c-98216d7662d8"),
				SeniorityID: view.MustGetUUIDFromString("01fb6322-d727-47e3-a242-5039ea4732fc"),
				Positions: []view.UUID{
					view.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					view.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				DeploymentType: model.MemberDeploymentTypeOfficial.String(),
				Status:         model.ProjectMemberStatusActive.String(),
				StartDate:      "2022-11-15",
				Rate:           decimal.NewFromInt(10),
				Discount:       decimal.NewFromInt(1),
				IsLead:         false,
			},
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/assign_member/404_project_not_found.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/assign_member/assign_member.sql")
				body, err := json.Marshal(tt.args)
				if err != nil {
					t.Error(err)
					return
				}

				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPost, fmt.Sprintf("/api/v1/projects/%v/members", tt.id), bytes.NewBuffer(body))
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.Header.Set("Content-Type", gin.MIMEJSON)
				ctx.AddParam("id", tt.id)
				ctrl := controller.New(storeMock, txRepo, serviceMock, nil, loggerMock, &cfg)
				h := New(ctrl, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.AssignMember(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res := w.Body.Bytes()
				res, _ = utils.RemoveFieldInResponse(res, "projectSlotID")
				res, _ = utils.RemoveFieldInResponse(res, "projectMemberID")

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Project.AssignMember] response mismatched")
			})
		})
	}
}

func TestHandler_DeleteProjectMember(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		id               string
		memberID         string
	}{
		{
			name:             "ok_update_project_status",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/delete_member/200.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			memberID:         "cb889a9c-b20c-47ee-83b8-44b6d1721aca",
		},
		{
			name:             "failed_invalid_member_id",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/delete_member/404.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			memberID:         "cb889a9c-b20c-47ee-83b8-44b6d1721acb",
		},
		{
			name:             "empty_project_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_member/empty_project_id.json",
			id:               "",
			memberID:         "cb889a9c-b20c-47ee-83b8-44b6d1721acb",
		},
		{
			name:             "empty_member_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_member/empty_member_id.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			memberID:         "",
		},
		{
			name:             "project_not_found",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/delete_member/project_not_found.json",
			id:               "cb889a9c-b20c-47ee-83b8-44b6d1721acb",
			memberID:         "cb889a9c-b20c-47ee-83b8-44b6d1721acb",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/delete_member/delete_member.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}, gin.Param{Key: "memberID", Value: tt.memberID}}
				ctx.Request = httptest.NewRequest("DELETE", fmt.Sprintf("/api/v1/projects/%s/members/%s", tt.id, tt.memberID), nil)
				ctx.Request.Header.Set("Authorization", "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M")
				metadataHandler := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.DeleteMember(ctx)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.DeleteSlot] response mismatched")
			})
		})
	}
}

func TestHandler_DeleteSlot(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		id               string
		slotID           string
	}{
		{
			name:             "ok_update_project_status",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/delete_slot/200.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			slotID:           "f32d08ca-8863-4ab3-8c84-a11849451eb7",
		},
		{
			name:             "failed_invalid_member_id",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/delete_slot/404.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			slotID:           "cb889a9c-b20c-47ee-83b8-44b6d1721acb",
		},
		{
			name:             "empty_project_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_slot/empty_project_id.json",
			id:               "",
			slotID:           "f32d08ca-8863-4ab3-8c84-a11849451eb7",
		},
		{
			name:             "empty_member_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/delete_slot/empty_slot_id.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			slotID:           "",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/delete_slot/delete_slot.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}, gin.Param{Key: "slotID", Value: tt.slotID}}
				ctx.Request = httptest.NewRequest("DELETE", fmt.Sprintf("/api/v1/projects/%s/slots/%s", tt.id, tt.slotID), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				metadataHandler := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.DeleteSlot(ctx)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.DeleteSlot] response mismatched")
			})
		})
	}
}

func TestHandler_UpdateGeneralInfo(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		id               string
		input            request.UpdateProjectGeneralInfoRequest
	}{
		{
			name:             "ok_update_project_general_information",
			wantCode:         200,
			wantResponsePath: "testdata/update_general_info/200.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			input: request.UpdateProjectGeneralInfoRequest{
				Name:      "Fortress",
				StartDate: "1990-01-02",
				CountryID: view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				Stacks: []view.UUID{
					view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					view.MustGetUUIDFromString("b403ef95-4269-4830-bbb6-8e56e5ec0af4"),
				},
				Function:       model.ProjectFunctionManagement.String(),
				BankAccountID:  view.MustGetUUIDFromString("e79eb5b3-e2cb-4d7f-9273-46f4be88cb20"),
				ClientID:       view.MustGetUUIDFromString("afb9cf05-9517-4fb9-a4f2-66e6d90ad215"),
				OrganizationID: view.MustGetUUIDFromString("31fdf38f-77c0-4c06-b530-e2be8bc297e0"),
				AccountRating:  1,
				DeliveryRating: 1,
				LeadRating:     1,
				ImportantLevel: model.ProjectImportantLevelMedium.String(),
			},
		},
		{
			name:             "failed_invalid_project_id",
			wantCode:         404,
			wantResponsePath: "testdata/update_general_info/404.json",
			id:               "d100efd1-bfce-4cd6-885c-1e4ac3d30715",
			input: request.UpdateProjectGeneralInfoRequest{
				Name:      "Fortress",
				StartDate: "1990-01-02",
				CountryID: view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				Stacks: []view.UUID{
					view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					view.MustGetUUIDFromString("b403ef95-4269-4830-bbb6-8e56e5ec0af4"),
				},
				Function:       model.ProjectFunctionManagement.String(),
				AccountRating:  1,
				DeliveryRating: 1,
				LeadRating:     1,
				ImportantLevel: model.ProjectImportantLevelMedium.String(),
			},
		},
		{
			name:             "empty_project_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_general_info/invalid_project_id.json",
			id:               "",
			input: request.UpdateProjectGeneralInfoRequest{
				Name:      "Fortress",
				StartDate: "1990-01-02",
				CountryID: view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				Stacks: []view.UUID{
					view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					view.MustGetUUIDFromString("b403ef95-4269-4830-bbb6-8e56e5ec0af4"),
				},
				Function:       model.ProjectFunctionManagement.String(),
				AccountRating:  1,
				DeliveryRating: 1,
				LeadRating:     1,
				ImportantLevel: model.ProjectImportantLevelMedium.String(),
			},
		},
		{
			name:             "invalid_project_id_format",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_general_info/invalid_project_id.json",
			id:               "d100efd1-bfce-4cd6-885c-1e4ac3d307156",
			input: request.UpdateProjectGeneralInfoRequest{
				Name:      "Fortress",
				StartDate: "1990-01-02",
				CountryID: view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				Stacks: []view.UUID{
					view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					view.MustGetUUIDFromString("b403ef95-4269-4830-bbb6-8e56e5ec0af4"),
				},
				Function:       model.ProjectFunctionManagement.String(),
				AccountRating:  1,
				DeliveryRating: 1,
				LeadRating:     1,
				ImportantLevel: model.ProjectImportantLevelMedium.String(),
			},
		},
		{
			name:             "invalid_project_function",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_general_info/invalid_project_function.json",
			id:               "d100efd1-bfce-4cd6-885c-1e4ac3d30715",
			input: request.UpdateProjectGeneralInfoRequest{
				Name:      "Fortress",
				StartDate: "1990-01-02",
				CountryID: view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				Stacks: []view.UUID{
					view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					view.MustGetUUIDFromString("b403ef95-4269-4830-bbb6-8e56e5ec0af4"),
				},
				Function:       "a",
				AccountRating:  1,
				DeliveryRating: 1,
				LeadRating:     1,
				ImportantLevel: model.ProjectImportantLevelMedium.String(),
			},
		},
		{
			name:             "country_not_found",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_general_info/country_not_found.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			input: request.UpdateProjectGeneralInfoRequest{
				Name:      "Fortress",
				StartDate: "1990-01-02",
				CountryID: view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4d"),
				Stacks: []view.UUID{
					view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					view.MustGetUUIDFromString("b403ef95-4269-4830-bbb6-8e56e5ec0af4"),
				},
				Function:       model.ProjectFunctionDevelopment.String(),
				AccountRating:  1,
				DeliveryRating: 1,
				LeadRating:     1,
				ImportantLevel: model.ProjectImportantLevelMedium.String(),
			},
		},
		{
			name:             "stack_not_found",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_general_info/stack_not_found.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			input: request.UpdateProjectGeneralInfoRequest{
				Name:      "Fortress",
				StartDate: "1990-01-02",
				CountryID: view.MustGetUUIDFromString("4ef64490-c906-4192-a7f9-d2221dadfe4c"),
				Stacks: []view.UUID{
					view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2d"),
					view.MustGetUUIDFromString("b403ef95-4269-4830-bbb6-8e56e5ec0af4"),
				},
				Function:       model.ProjectFunctionDevelopment.String(),
				AccountRating:  1,
				DeliveryRating: 1,
				LeadRating:     1,
				ImportantLevel: model.ProjectImportantLevelMedium.String(),
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_general_info/update_general_info.sql")
				byteReq, err := json.Marshal(tt.input)
				require.Nil(t, err)

				bodyReader := strings.NewReader(string(byteReq))

				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}}
				ctx.Request = httptest.NewRequest("PUT", fmt.Sprintf("/api/v1/projects/%s/general-info", tt.id), bodyReader)
				ctx.Request.Header.Set("Authorization", "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M")
				metadataHandler := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.UpdateGeneralInfo(ctx)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.UpdateProjectGeneralInfo] response mismatched")
			})
		})
	}
}

func TestHandler_UpdateContactInfo(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		id               string
		input            request.UpdateContactInfoRequest
	}{
		{
			name:             "ok_update_project_contact_information",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/update_contact_info/200.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			input: request.UpdateContactInfoRequest{
				ClientEmail:  []string{"fortress@gmail.com"},
				ProjectEmail: "fortress@d.foundation",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				SalePersons: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
			},
		},
		{
			name:             "project_id_not_found",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_contact_info/404.json",
			id:               "d100efd1-bfce-4cd6-885c-1e4ac3d30714",
			input: request.UpdateContactInfoRequest{
				ClientEmail:  []string{"fortress@gmail.com"},
				ProjectEmail: "fortress@d.foundation",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				SalePersons: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
			},
		},
		{
			name:             "empty_project_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_contact_info/invalid_project_id.json",
			id:               "",
			input: request.UpdateContactInfoRequest{
				ClientEmail:  []string{"fortress@gmail.com"},
				ProjectEmail: "fortress@d.foundation",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				SalePersons: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
			},
		},
		{
			name:             "invalid_project_id_format",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_contact_info/invalid_project_id.json",
			id:               "d100efd1-bfce-4cd6-885c-1e4ac3d307149",
			input: request.UpdateContactInfoRequest{
				ClientEmail:  []string{"fortress@gmail.com"},
				ProjectEmail: "fortress@d.foundation",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				SalePersons: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
			},
		},
		{
			name:             "invalid_email_format",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_contact_info/invalid_email_format.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			input: request.UpdateContactInfoRequest{
				ClientEmail:  []string{"fortressgmail.com"},
				ProjectEmail: "fortress@d.foundation",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				SalePersons: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
			},
		},
		{
			name:             "account_manager_not_found",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_contact_info/account_manager_not_found.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			input: request.UpdateContactInfoRequest{
				ClientEmail:  []string{"fortress@gmail.com"},
				ProjectEmail: "fortress@d.foundation",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558d"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				SalePersons: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
			},
		},
		{
			name:             "delivery_manager_not_found",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_contact_info/delivery_manager_not_found.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			input: request.UpdateContactInfoRequest{
				ClientEmail:  []string{"fortress@gmail.com"},
				ProjectEmail: "fortress@d.foundation",
				AccountManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				DeliveryManagers: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98cd"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
				SalePersons: []request.ProjectHeadRequest{
					{
						EmployeeID:     view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
						CommissionRate: decimal.NewFromInt(100),
					},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_contact_info/update_contact_info.sql")
				byteReq, err := json.Marshal(tt.input)
				require.Nil(t, err)

				bodyReader := strings.NewReader(string(byteReq))

				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}}
				ctx.Request = httptest.NewRequest("PUT", fmt.Sprintf("/api/v1/projects/%s/contact-info", tt.id), bodyReader)
				ctx.Request.Header.Set("Authorization", "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M")
				metadataHandler := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.UpdateContactInfo(ctx)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.UpdateProjectContactInfo] response mismatched")
			})
		})
	}
}

func TestHandler_GetListWorkUnit(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		id               string
		query            string
	}{
		{
			name:             "ok_get_list_work_unit",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_list_work_unit/200.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			query:            "status=active",
		},
		{
			name:             "err_invalid_status",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_list_work_unit/400.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			query:            "status=activ",
		},
		{
			name:             "err_project_not_found",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/get_list_work_unit/404.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b14",
			query:            "status=active",
		},
		{
			name:             "empty_project_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_list_work_unit/invalid_project_id.json",
			id:               "",
			query:            "status=active",
		},
		{
			name:             "invalid_project_id_format",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/get_list_work_unit/invalid_project_id.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b156",
			query:            "status=active",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_list_work_unit/get_list_work_unit.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.AddParam("id", tt.id)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/projects/%s/work-units?%s", tt.id, tt.query), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.URL.RawQuery = tt.query

				h := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.GetWorkUnits(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Project.GetListWorkUnit] response mismatched")
			})
		})
	}
}

func TestHandler_UpdateWorkUnit(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		input            request.UpdateWorkUnitInput
		wantCode         int
		wantResponsePath string
	}{
		{
			name: "happy_case",
			input: request.UpdateWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				WorkUnitID: "69b32f7e-0433-4566-a801-72909172940e",
				Body: request.UpdateWorkUnitRequest{
					Name: "New Fortress Web",
					Type: view.WorkUnitTypeManagement,
					URL:  "https://github.com/dwarvesf/fortress-web",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
					},
				},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/update_work_unit/200.json",
		},
		{
			name: "not_found_project",
			input: request.UpdateWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b16",
				WorkUnitID: "69b32f7e-0433-4566-a801-72909172940e",
				Body: request.UpdateWorkUnitRequest{
					Name: "New Fortress Web",
					Type: view.WorkUnitTypeManagement,
					URL:  "https://github.com/dwarvesf/fortress-web",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
					},
				},
			},
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_work_unit/404.json",
		},
		{
			name: "invalid_type",
			input: request.UpdateWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				WorkUnitID: "69b32f7e-0433-4566-a801-72909172940e",
				Body: request.UpdateWorkUnitRequest{
					Name: "New Fortress Web",
					Type: "type",
					URL:  "https://github.com/dwarvesf/fortress-web",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_work_unit/400.json",
		},
		{
			name: "empty_project_id",
			input: request.UpdateWorkUnitInput{
				ProjectID:  "",
				WorkUnitID: "69b32f7e-0433-4566-a801-72909172940e",
				Body: request.UpdateWorkUnitRequest{
					Name: "New Fortress Web",
					Type: view.WorkUnitTypeManagement,
					URL:  "https://github.com/dwarvesf/fortress-web",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_work_unit/invalid_project_id.json",
		},
		{
			name: "invalid_format_project_id",
			input: request.UpdateWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b156",
				WorkUnitID: "69b32f7e-0433-4566-a801-72909172940e",
				Body: request.UpdateWorkUnitRequest{
					Name: "New Fortress Web",
					Type: view.WorkUnitTypeManagement,
					URL:  "https://github.com/dwarvesf/fortress-web",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_work_unit/invalid_project_id.json",
		},
		{
			name: "invalid_stack",
			input: request.UpdateWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				WorkUnitID: "69b32f7e-0433-4566-a801-72909172940e",
				Body: request.UpdateWorkUnitRequest{
					Name: "New Fortress Web",
					Type: view.WorkUnitTypeManagement,
					URL:  "https://github.com/dwarvesf/fortress-web",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2d"),
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
					}},
			},
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/update_work_unit/stack_not_found.json",
		},
		{
			name: "invalid_stack",
			input: request.UpdateWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				WorkUnitID: "69b32f7e-0433-4566-a801-72909172940e",
				Body: request.UpdateWorkUnitRequest{
					Name: "New Fortress Web",
					Type: view.WorkUnitTypeManagement,
					URL:  "https://github.com/dwarvesf/fortress-web",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("608ea227-45a5-4c8a-af43-6c7280d96340"),
					},
					Stacks: []view.UUID{},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/update_work_unit/invalid_stack.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_work_unit/update_work_unit.sql")
				body, err := json.Marshal(tt.input.Body)
				if err != nil {
					t.Error(err)
					return
				}

				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPost,
					fmt.Sprintf("/api/v1/projects/%s/work-units/%s", tt.input.ProjectID, tt.input.WorkUnitID),
					bytes.NewBuffer(body))
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.Header.Set("Content-Type", gin.MIMEJSON)
				ctx.AddParam("id", tt.input.ProjectID)
				ctx.AddParam("workUnitID", tt.input.WorkUnitID)

				h := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.UpdateWorkUnit(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Project.UpdateWorkUnit] response mismatched")
			})
		})
	}
}

func TestHandler_CreateWorkUnit(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		input            request.CreateWorkUnitInput
		wantCode         int
		wantResponsePath string
	}{
		{
			name: "happy_case",
			input: request.CreateWorkUnitInput{
				ProjectID: "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				Body: request.CreateWorkUnitRequest{
					Name:   "workunit1",
					Type:   model.WorkUnitTypeDevelopment.String(),
					Status: model.WorkUnitStatusArchived.String(),
					URL:    "https://github.com/dwarvesf/fortress-api",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					},
				},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/create_work_unit/200_success.json",
		},
		{
			name: "project_not_found",
			input: request.CreateWorkUnitInput{
				ProjectID: "8dc3be2e-19a4-4942-8a79-56db391a0b16",
				Body: request.CreateWorkUnitRequest{
					Name:   "workunit1",
					Type:   model.WorkUnitTypeDevelopment.String(),
					Status: model.WorkUnitStatusArchived.String(),
					URL:    "https://github.com/dwarvesf/fortress-api",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					},
				},
			},
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/create_work_unit/404_project_not_found.json",
		},
		{
			name: "empty_project_id",
			input: request.CreateWorkUnitInput{
				ProjectID: "",
				Body: request.CreateWorkUnitRequest{
					Name:   "workunit1",
					Type:   model.WorkUnitTypeDevelopment.String(),
					Status: model.WorkUnitStatusArchived.String(),
					URL:    "https://github.com/dwarvesf/fortress-api",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create_work_unit/invalid_project_id.json",
		},
		{
			name: "invalid_project_id_format",
			input: request.CreateWorkUnitInput{
				ProjectID: "8dc3be2e-19a4-4942-8a79-56db391a0b156",
				Body: request.CreateWorkUnitRequest{
					Name:   "workunit1",
					Type:   model.WorkUnitTypeDevelopment.String(),
					Status: model.WorkUnitStatusArchived.String(),
					URL:    "https://github.com/dwarvesf/fortress-api",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create_work_unit/invalid_project_id.json",
		},
		{
			name: "invalid_work_unit_type",
			input: request.CreateWorkUnitInput{
				ProjectID: "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				Body: request.CreateWorkUnitRequest{
					Name:   "workunit1",
					Type:   "a",
					Status: model.WorkUnitStatusArchived.String(),
					URL:    "https://github.com/dwarvesf/fortress-api",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create_work_unit/invalid_work_unit_type.json",
		},
		{
			name: "invalid_work_unit_status",
			input: request.CreateWorkUnitInput{
				ProjectID: "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				Body: request.CreateWorkUnitRequest{
					Name:   "workunit1",
					Type:   model.WorkUnitTypeDevelopment.String(),
					Status: "a",
					URL:    "https://github.com/dwarvesf/fortress-api",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
					},
					Stacks: []view.UUID{
						view.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
						view.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
					},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create_work_unit/invalid_work_unit_status.json",
		},
		{
			name: "invalid_work_unit_stack",
			input: request.CreateWorkUnitInput{
				ProjectID: "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				Body: request.CreateWorkUnitRequest{
					Name:   "workunit1",
					Type:   model.WorkUnitTypeDevelopment.String(),
					Status: model.WorkUnitStatusArchived.String(),
					URL:    "https://github.com/dwarvesf/fortress-api",
					Members: []view.UUID{
						view.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f"),
						view.MustGetUUIDFromString("ecea9d15-05ba-4a4e-9787-54210e3b98ce"),
					},
					Stacks: []view.UUID{},
				},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/create_work_unit/invalid_work_unit_stack.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/create_work_unit/create_work_unit.sql")
				body, err := json.Marshal(tt.input.Body)
				if err != nil {
					t.Error(err)
					return
				}

				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPost,
					fmt.Sprintf("/api/v1/projects/%s/work-units", tt.input.ProjectID),
					bytes.NewBuffer(body))
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.Header.Set("Content-Type", gin.MIMEJSON)
				ctx.AddParam("id", tt.input.ProjectID)

				h := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.CreateWorkUnit(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res := w.Body.Bytes()
				res, _ = utils.RemoveFieldInResponse(res, "id")

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Project.CreateWorkUnit] response mismatched")
			})
		})
	}
}

func TestHandler_ArchiveWorkUnit(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		input            request.ArchiveWorkUnitInput
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/archive_work_unit/200_ok.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				WorkUnitID: "4797347d-21e0-4dac-a6c7-c98bf2d6b27c",
			},
		},
		{
			name:             "invalid_project_id",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/archive_work_unit/404_project_not_found.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b16",
				WorkUnitID: "4797347d-21e0-4dac-a6c7-c98bf2d6b27c",
			},
		},
		{
			name:             "empty_project_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/archive_work_unit/invalid_project_id.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "",
				WorkUnitID: "4797347d-21e0-4dac-a6c7-c98bf2d6b27c",
			},
		},
		{
			name:             "invalid_project_id_format",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/archive_work_unit/invalid_project_id.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b156",
				WorkUnitID: "4797347d-21e0-4dac-a6c7-c98bf2d6b27c",
			},
		},
		{
			name:             "empty_work_unit_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/archive_work_unit/invalid_work_unit_id.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				WorkUnitID: "",
			},
		},
		{
			name:             "invalid_work_unit_id_format",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/archive_work_unit/invalid_work_unit_id.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				WorkUnitID: "4797347d-21e0-4dac-a6c7-c98bf2d6b27cd",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/archive_work_unit/archive_work_unit.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPut,
					fmt.Sprintf("/api/v1/projects/%s/work-units/%s/archive", tt.input.ProjectID, tt.input.WorkUnitID),
					nil)

				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.input.ProjectID)
				ctx.AddParam("workUnitID", tt.input.WorkUnitID)

				h := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.ArchiveWorkUnit(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.ArchiveWorkUnit] response mismatched")
			})
		})
	}
}

func TestHandler_UnarchiveWorkUnit(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		input            request.ArchiveWorkUnitInput
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/unarchive_work_unit/200_ok.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				WorkUnitID: "4797347d-21e0-4dac-a6c7-c98bf2d6b27c",
			},
		},
		{
			name:             "invalid_project_id",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/unarchive_work_unit/404_project_not_found.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b16",
				WorkUnitID: "4797347d-21e0-4dac-a6c7-c98bf2d6b27c",
			},
		},
		{
			name:             "empty_project_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/unarchive_work_unit/invalid_project_id.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "",
				WorkUnitID: "4797347d-21e0-4dac-a6c7-c98bf2d6b27c",
			},
		},
		{
			name:             "invalid_project_id_format",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/unarchive_work_unit/invalid_project_id.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b156",
				WorkUnitID: "4797347d-21e0-4dac-a6c7-c98bf2d6b27c",
			},
		},
		{
			name:             "empty_work_unit_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/unarchive_work_unit/invalid_work_unit_id.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				WorkUnitID: "",
			},
		},
		{
			name:             "invalid_work_unit_id_format",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/unarchive_work_unit/invalid_work_unit_id.json",
			input: request.ArchiveWorkUnitInput{
				ProjectID:  "8dc3be2e-19a4-4942-8a79-56db391a0b15",
				WorkUnitID: "4797347d-21e0-4dac-a6c7-c98bf2d6b27cd",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/unarchive_work_unit/unarchive_work_unit.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPut,
					fmt.Sprintf("/api/v1/projects/%s/work-units/%s/unarchive", tt.input.ProjectID, tt.input.WorkUnitID),
					nil)

				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.input.ProjectID)
				ctx.AddParam("workUnitID", tt.input.WorkUnitID)

				h := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.UnarchiveWorkUnit(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.UnarchiveWorkUnit] response mismatched")
			})
		})
	}
}

func TestHandler_UpdateSendingSurveyState(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          bool
		wantResponsePath string
		query            string
		id               string
	}{
		{
			name:             "ok_update_sending_survey",
			wantCode:         http.StatusOK,
			wantErr:          false,
			wantResponsePath: "testdata/update_sending_survey/200.json",
			query:            "allowsSendingSurvey=true",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
		},
		{
			name:             "failed_invalid_project_id",
			wantCode:         http.StatusNotFound,
			wantErr:          true,
			wantResponsePath: "testdata/update_sending_survey/404.json",
			query:            "allowsSendingSurvey=true",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b11",
		},
		{
			name:             "empty_project_id",
			wantCode:         http.StatusBadRequest,
			wantErr:          false,
			wantResponsePath: "testdata/update_sending_survey/invalid_project_id.json",
			query:            "allowsSendingSurvey=true",
			id:               "",
		},
		{
			name:             "invalid_project_id_format",
			wantCode:         http.StatusBadRequest,
			wantErr:          false,
			wantResponsePath: "testdata/update_sending_survey/invalid_project_id.json",
			query:            "allowsSendingSurvey=true",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b156",
		},
	}

	for _, tt := range tests {
		testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
			testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_sending_survey/update_sending_survey.sql")

			t.Run(tt.name, func(t *testing.T) {
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}}
				ctx.Request = httptest.NewRequest("PUT", fmt.Sprintf("/api/v1/projects/%s/sending-survey-state?%s", tt.id, tt.query), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.URL.RawQuery = tt.query
				metadataHandler := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.UpdateSendingSurveyState(ctx)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.Equal(t, tt.wantCode, w.Code)
				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.UpdateSendingSurveyState] response mismatched")
			})
		})
	}
}

func TestHandler_UnassignMember(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	controllerMock := controller.New(nil, nil, nil, nil, nil, nil)

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		id               string
		memberID         string
	}{
		{
			name:             "ok_update_project_status",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/unassign_member/200.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			memberID:         "2655832e-f009-4b73-a535-64c3a22e558f",
		},
		{
			name:             "failed_invalid_member_id",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/unassign_member/404.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			memberID:         "cb889a9c-b20c-47ee-83b8-44b6d1721acb",
		},
		{
			name:             "empty_project_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/unassign_member/empty_project_id.json",
			id:               "",
			memberID:         "cb889a9c-b20c-47ee-83b8-44b6d1721acb",
		},
		{
			name:             "empty_member_id",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/unassign_member/empty_member_id.json",
			id:               "8dc3be2e-19a4-4942-8a79-56db391a0b15",
			memberID:         "",
		},
		{
			name:             "project_not_found",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/unassign_member/project_not_found.json",
			id:               "cb889a9c-b20c-47ee-83b8-44b6d1721acb",
			memberID:         "cb889a9c-b20c-47ee-83b8-44b6d1721acb",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/unassign_member/unassign_member.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}, gin.Param{Key: "memberID", Value: tt.memberID}}
				ctx.Request = httptest.NewRequest("PUT", fmt.Sprintf("/api/v1/projects/%s/members/%s", tt.id, tt.memberID), nil)
				ctx.Request.Header.Set("Authorization", "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M")
				metadataHandler := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.UnassignMember(ctx)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.UnassignMember] response mismatched")
			})
		})
	}
}

```

# pkg/handler/project/project.go

```go
package project

import (
	"errors"
	"fmt"
	"net/http"
	"path/filepath"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/shopspring/decimal"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/handler/project/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/project/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/store/project"
	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store      *store.Store
	controller *controller.Controller
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
}

func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:      store,
		controller: controller,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
	}
}

func (h *handler) IcyWeeklyDistribution(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "IcyWeeklyDistribution",
	})

	weeklyIcyDistribution, err := h.store.IcyDistribution.GetWeekly(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to weekly icy distribution")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, "", "can't get weekly icy distribution"))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](weeklyIcyDistribution, nil, nil, "", ""))
}

// List godoc
// @Summary Get list of project
// @Description Get list of project
// @id getProjectList
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param status query  []string false  "Project status"
// @Param name   query  string false  "Project name"
// @Param type   query  string false  "Project type"
// @Param page   query  string false  "Page"
// @Param size   query  string false  "Size"
// @Success 200 {object} ProjectListDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects [get]
func (h *handler) List(c *gin.Context) {
	// 0. Get current logged in user data
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	query := request.GetListProjectInput{}
	if err := c.ShouldBindQuery(&query); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	query.StandardizeInput()
	pagination := model.Pagination{
		Page:         query.Page,
		Size:         query.Size,
		Sort:         query.Sort,
		Standardized: true,
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "List",
		"query":   query,
	})

	if err := query.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	projectTypes := make([]string, 0)
	for _, t := range query.Type {
		if strings.TrimSpace(t) != "" {
			projectTypes = append(projectTypes, t)
		}
	}

	projects, total, err := h.store.Project.All(h.repo.DB(), project.GetListProjectInput{
		Statuses: query.Status,
		Name:     query.Name,
		Types:    projectTypes,
	}, pagination)
	if err != nil {
		l.Error(err, "error query project from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToProjectsData(projects, userInfo),
		&view.PaginationResponse{Pagination: view.Pagination{Page: pagination.Page, Size: pagination.Size, Sort: pagination.Sort}, Total: total}, nil, nil, ""))
}

// UpdateProjectStatus godoc
// @Summary Update status for project by id
// @Description Update status for project by id
// @id updateProjectStatus
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param status body UpdateProjectStatusBody true "Project Status"
// @Success 200 {object} UpdateProjectStatusResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/status [put]
func (h *handler) UpdateProjectStatus(c *gin.Context) {
	projectID := c.Param("id")
	if projectID == "" || !model.IsUUIDFromString(projectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	var body request.UpdateProjectStatusBody
	if err := c.ShouldBindJSON(&body); err != nil {
		if err != nil {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "UpdateProjectStatus",
		"body":    body,
	})

	if !body.ProjectStatus.IsValid() {
		l.Error(errs.ErrInvalidProjectStatus, "invalid value for ProjectStatus")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectStatus, body, ""))
		return
	}

	p, err := h.store.Project.One(h.repo.DB(), projectID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, projectID, ""))
			return
		}

		l.Error(err, "failed to get project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, projectID, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	p.Status = model.ProjectStatus(body.ProjectStatus)
	p.EndDate = nil

	if p.Status == model.ProjectStatusClosed {
		p.EndDate = new(time.Time)
		*p.EndDate = time.Now()
	}

	_, err = h.store.Project.UpdateSelectedFieldsByID(tx.DB(), projectID, *p, "status", "end_date")
	if err != nil {
		l.Error(err, "failed to update project status")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}

	// TODO: we can open it when needing automation flow to inactivated project member
	//if body.ProjectStatus == model.ProjectStatusClosed {
	//	if err := h.closeProject(tx.DB(), projectID); err != nil {
	//		l.Error(err, "failed to close project")
	//		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
	//		return
	//	}
	//}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateProjectStatusResponse(p), nil, done(nil), nil, ""))
}

// func (h *handler) closeProject(db *gorm.DB, projectID string) error {
// 	err := h.store.ProjectMember.UpdateEndDateByProjectID(db, projectID)
// 	if err != nil {
// 		h.logger.Error(err, "failed to update end_date by project_id")
// 		return err
// 	}

// 	err = h.store.ProjectMember.UpdateSelectedFieldByProjectID(db, projectID,
// 		model.ProjectMember{Status: model.ProjectMemberStatusInactive},
// 		"status")
// 	if err != nil {
// 		h.logger.Error(err, "failed to update status of project_member by project_id")
// 		return err
// 	}

// 	err = h.store.ProjectSlot.UpdateSelectedFieldByProjectID(db, projectID,
// 		model.ProjectSlot{Status: model.ProjectMemberStatusInactive},
// 		"status",
// 	)
// 	if err != nil {
// 		h.logger.Error(err, "failed to update status of project_slot by project_id")
// 		return err
// 	}

// 	return nil
// }

// Create godoc
// @Summary	Create new project
// @Description	Create new project
// @id createProject
// @Tags Project
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param Body body CreateProjectRequest true "body"
// @Success 200 {object} CreateProjectRestponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects [post]
func (h *handler) Create(c *gin.Context) {
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	body := request.CreateProjectRequest{}
	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "Create",
		"body":    body,
	})

	if err := body.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	country, err := h.store.Country.One(h.repo.DB(), body.CountryID.String())
	if err != nil {
		l.Error(err, "failed to get country")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	var bankAccount *model.BankAccount
	if !body.BankAccountID.IsZero() {
		bankAccount, err = h.store.BankAccount.One(h.repo.DB(), body.BankAccountID.String())
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				l.Error(err, "bank account not found")
				c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrBankAccountNotFound, body, ""))
				return
			}

			l.Error(err, "failed to get bank account")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}
	}

	var organization *model.Organization
	if !body.OrganizationID.IsZero() {
		organization, err = h.store.Organization.One(h.repo.DB(), body.OrganizationID.String())
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				l.Error(err, "organization not found")
				c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrOrganizationNotFound, body, ""))
				return
			}

			l.Error(err, "failed to get organization")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}
	}

	if body.Code == "" {
		body.Code = utils.ProcessString(body.Name)
	}

	exists, err := h.store.Project.IsExistByCode(h.repo.DB(), body.Code)
	if err != nil {
		l.Error(err, "failed to check existence by code")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	if exists {
		l.Error(errs.ErrDuplicateProjectCode, "failed to create project")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrDuplicateProjectCode, body, ""))
		return
	}

	var client *model.Client
	if !body.ClientID.IsZero() {
		client, err = h.store.Client.One(h.repo.DB(), body.ClientID.String())
		if err != nil {
			l.Error(err, "client not found")
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrClientNotFound, body, ""))
			return
		}
	}

	// Create employee organization
	org, err := h.store.Organization.OneByCode(h.repo.DB(), model.OrganizationCodeDwarves)
	if err != nil {
		l.Error(err, "error invalid organization")
		if errors.Is(err, gorm.ErrRecordNotFound) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrOrganizationNotFound, body, ""))
			return
		}
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	p := &model.Project{
		Name:           body.Name,
		CountryID:      model.UUID(body.CountryID),
		Type:           model.ProjectType(body.Type),
		Status:         model.ProjectStatus(body.Status),
		StartDate:      body.GetStartDate(),
		ProjectEmail:   body.ProjectEmail,
		ClientEmail:    strings.Join(body.ClientEmail, ","),
		Country:        country,
		Code:           body.Code,
		Function:       model.ProjectFunction(body.Function),
		ClientID:       model.UUID(body.ClientID),
		ImportantLevel: model.ProjectImportantLevelMedium,
	}

	if body.OrganizationID.IsZero() {
		p.OrganizationID = org.ID
	} else {
		p.OrganizationID = model.UUID(body.OrganizationID)
	}

	if !body.BankAccountID.IsZero() {
		p.BankAccountID = model.UUID(body.BankAccountID)
		p.BankAccount = bankAccount
	}

	if !body.OrganizationID.IsZero() {
		p.OrganizationID = model.UUID(body.OrganizationID)
		p.Organization = organization
	}

	tx, done := h.repo.NewTransaction()

	if err := h.store.Project.Create(tx.DB(), p); err != nil {
		l.Error(err, "failed to create project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	p.Client = client

	// Create audit notion id
	if !body.AuditNotionID.IsZero() {
		if _, err := h.store.ProjectNotion.Create(tx.DB(), &model.ProjectNotion{ProjectID: p.ID, AuditNotionID: model.UUID(body.AuditNotionID)}); err != nil {
			l.Error(err, "failed to create project notion")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
			return
		}
	}

	// create project account manager
	ams, err := h.createProjectHeads(tx.DB(), p.ID, model.HeadPositionAccountManager, body.AccountManagers)
	if err != nil {
		l.Error(err, "failed to create account managers")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}
	p.Heads = append(p.Heads, ams...)

	// create project delivery manager
	dms, err := h.createProjectHeads(tx.DB(), p.ID, model.HeadPositionDeliveryManager, body.DeliveryManagers)
	if err != nil {
		l.Error(err, "failed to create delivery managers")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}
	p.Heads = append(p.Heads, dms...)

	// create project sale persons
	sps, err := h.createProjectHeads(tx.DB(), p.ID, model.HeadPositionSalePerson, body.DeliveryManagers)
	if err != nil {
		l.Error(err, "failed to create sale persons")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}
	p.Heads = append(p.Heads, sps...)

	// assign members to project
	for _, member := range body.Members {
		slot, code, err := h.createSlotsAndAssignMembers(tx.DB(), p, member, userInfo)
		if err != nil {
			l.Error(err, "failed to assign member to project")
			c.JSON(code, view.CreateResponse[any](nil, nil, done(err), member, ""))
			return
		}

		p.Slots = append(p.Slots, *slot)
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToCreateProjectDataResponse(userInfo, p), nil, done(nil), nil, ""))
}

func (h *handler) createProjectHeads(db *gorm.DB, projectID model.UUID, position model.HeadPosition, req []request.ProjectHeadRequest) ([]*model.ProjectHead, error) {
	var heads []*model.ProjectHead
	for _, head := range req {
		emp, err := h.store.Employee.One(db, head.EmployeeID.String(), false)
		if err != nil {
			h.logger.Error(err, "failed to get employee by id")
			return nil, err
		}

		head := &model.ProjectHead{
			ProjectID:      projectID,
			EmployeeID:     model.UUID(head.EmployeeID),
			CommissionRate: head.CommissionRate,
			Position:       position,
		}

		if err := h.store.ProjectHead.Create(db, head); err != nil {
			h.logger.Error(err, "failed to create project head")
			return nil, err
		}

		head.Employee = *emp
		heads = append(heads, head)
	}

	return heads, nil
}

// GetMembers godoc
// @Summary Get list members of project
// @Description Get list members of project
// @id getProjectMemberList
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string false "Project ID"
// @Param status query string false "Status"
// @Param preload query bool false "Preload data with default value is true"
// @Param page query string false "Page"
// @Param size query string false "Size"
// @Param sort query string false "Sort"
// @Param distinct query bool false "Distinct"
// @Success 200 {object} ProjectMemberListResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/members [get]
func (h *handler) GetMembers(c *gin.Context) {
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	query := request.GetListStaffInput{}
	if err := c.ShouldBindQuery(&query); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	pagination := model.Pagination{
		Page: query.Page,
		Size: query.Size,
		Sort: query.Sort,
	}
	pagination.Standardize()

	projectID := c.Param("id")
	if projectID == "" || !model.IsUUIDFromString(projectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler":   "project",
		"method":    "GetMembers",
		"projectID": projectID,
		"query":     query,
	})

	if err := query.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	project, err := h.store.Project.One(h.repo.DB(), projectID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, query, ""))
			return
		}
		l.Error(err, "cannot find project by id")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	var pendingSlots []*model.ProjectSlot
	var assignedMembers []*model.ProjectMember

	// Get pending slots
	if query.Status == "" || query.Status == model.ProjectMemberStatusPending.String() {
		pendingSlots, err = h.store.ProjectSlot.GetPendingSlots(h.repo.DB(), projectID, query.Preload)
		if err != nil {
			l.Error(err, "failed to get pending slots")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, ""))
			return
		}
	}

	// Get assigned members
	if query.Status != model.ProjectMemberStatusPending.String() {
		assignedMembers, err = h.store.ProjectMember.GetAssignedMembers(h.repo.DB(), projectID, query.Status, query.Preload)
		if err != nil {
			l.Error(err, "failed to get assigned members")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, ""))
			return
		}
	}

	// Merge pending slots and assigned members into a slice
	total, members := h.mergeSlotAndMembers(h.repo.DB(), pendingSlots, assignedMembers, pagination)

	heads, err := h.store.ProjectHead.GetActiveLeadsByProjectID(h.repo.DB(), projectID)
	if err != nil {
		l.Error(err, "failed to get project heads")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToProjectMemberListData(userInfo, members, heads, project, query.Distinct),
		&view.PaginationResponse{Pagination: view.Pagination{Page: pagination.Page, Size: pagination.Size, Sort: pagination.Sort}, Total: total}, nil, nil, ""))
}

func (h *handler) mergeSlotAndMembers(db *gorm.DB, slots []*model.ProjectSlot, members []*model.ProjectMember, pagination model.Pagination) (int64, []*model.ProjectMember) {
	results := make([]*model.ProjectMember, 0, len(slots)+len(members))

	for _, slot := range slots {
		member := &model.ProjectMember{
			ProjectID:      slot.ProjectID,
			ProjectSlotID:  slot.ID,
			SeniorityID:    slot.SeniorityID,
			DeploymentType: slot.DeploymentType,
			Status:         slot.Status,
			Rate:           slot.Rate,
			Discount:       slot.Discount,
			Seniority:      &slot.Seniority,
			Note:           slot.Note,
		}

		for _, psPosition := range slot.ProjectSlotPositions {
			member.Positions = append(member.Positions, psPosition.Position)
		}

		results = append(results, member)
	}

	results = append(results, members...)

	total := int64(len(results))

	// Get response by offset and limit
	limit, offset := pagination.ToLimitOffset()
	if offset > len(results) {
		results = []*model.ProjectMember{}
	} else if limit+offset > len(slots) {
		results = results[offset:]
	} else {
		results = results[offset : offset+limit]
	}

	return total, results
}

// DeleteMember godoc
// @Summary Delete member in a project
// @Description Delete member in a project
// @id deleteProjectMember
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param memberID path string true "Project Member ID"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /project/{id}/members/{memberID} [delete]
func (h *handler) DeleteMember(c *gin.Context) {
	input := request.DeleteMemberInput{
		ProjectID: c.Param("id"),
		MemberID:  c.Param("memberID"),
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "DeleteMember",
		"body":    input,
	})

	member, err := h.store.ProjectMember.OneByID(h.repo.DB(), input.MemberID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "project member not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectMemberNotFound, input, ""))
			return
		}
		l.Error(err, "failed to get project member")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	// if projectMember.Status == model.ProjectMemberStatusInactive {
	// 	l.Error(errs.ErrCouldNotDeleteInactiveMember, "can not change information of inactive member")
	// 	c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrCouldNotDeleteInactiveMember, input.MemberID, ""))
	// 	return
	// }

	tx, done := h.repo.NewTransaction()

	err = h.store.ProjectMemberPosition.DeleteByProjectMemberID(tx.DB(), member.ID.String())
	if err != nil {
		l.Error(err, "failed to delete project member position")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	err = h.store.ProjectMember.Delete(tx.DB(), member.ID.String())
	if err != nil {
		l.Error(err, "failed to delete project member")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	err = h.store.ProjectHead.DeleteByPositionInProject(tx.DB(),
		member.ProjectID.String(),
		member.EmployeeID.String(),
		model.HeadPositionTechnicalLead.String())
	if err != nil {
		l.Error(err, "failed to delete project head")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// Update project slot status to inactive
	_, err = h.store.ProjectSlot.UpdateSelectedFieldsByID(tx.DB(),
		member.ProjectSlotID.String(),
		model.ProjectSlot{
			Status: model.ProjectMemberStatusInactive,
		},
		"status")
	if err != nil {
		l.Error(err, "failed to update project slot")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

// DeleteSlot godoc
// @Summary Delete slot in a project
// @Description Delete slot in a project
// @id deleteProjectSlot
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param slotID path string true "Slot ID"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /project/{id}/slot/{slotID} [delete]
func (h *handler) DeleteSlot(c *gin.Context) {
	input := request.DeleteSlotInput{
		ProjectID: c.Param("id"),
		SlotID:    c.Param("slotID"),
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "DeleteSlot",
		"body":    input,
	})

	slot, err := h.store.ProjectSlot.One(h.repo.DB(), input.SlotID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "project slot not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectSlotNotFound, input, ""))
			return
		}
		l.Error(err, "failed to get project slot")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	slot.Status = model.ProjectMemberStatusInactive

	_, err = h.store.ProjectSlot.UpdateSelectedFieldsByID(h.repo.DB(), input.SlotID, *slot, "status")
	if err != nil {
		l.Error(err, "failed to update project slot")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// UnassignMember godoc
// @Summary Unassign member in a project
// @Description Unassign member in a project
// @id unassignProjectMember
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param memberID path string true "Employee ID"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /project/{id}/members/{memberID} [put]
func (h *handler) UnassignMember(c *gin.Context) {
	input := request.UnassignMemberInput{
		ProjectID: c.Param("id"),
		MemberID:  c.Param("memberID"),
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "UnassignMember",
		"body":    input,
	})

	// get member info
	projectMember, err := h.store.ProjectMember.GetActiveMemberInProject(h.repo.DB(), input.ProjectID, input.MemberID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "project member not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectMemberNotFound, input.MemberID, ""))
			return
		}
		l.Error(err, "failed to get project member")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input.MemberID, ""))
		return
	}

	// if projectMember.Status == model.ProjectMemberStatusInactive {
	// 	l.Error(errs.ErrCouldNotDeleteInactiveMember, "can not change information of inactive member")
	// 	c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrCouldNotDeleteInactiveMember, input.MemberID, ""))
	// 	return
	// }

	// Begin transaction
	tx, done := h.repo.NewTransaction()

	// remove member out of project
	timeNow := time.Now()
	if projectMember.EndDate == nil {
		projectMember.EndDate = &timeNow
	}

	projectMember.Status = model.ProjectMemberStatusInactive

	_, err = h.store.ProjectMember.UpdateSelectedFieldsByID(tx.DB(),
		projectMember.ID.String(),
		*projectMember,
		"end_date",
		"status")
	if err != nil {
		l.Error(err, "failed to update project member")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// update technical lead if employees is technical lead
	_, err = h.store.ProjectHead.UpdateDateOfEmployee(tx.DB(),
		input.MemberID,
		input.ProjectID,
		model.HeadPositionTechnicalLead.String(),
		projectMember.StartDate,
		projectMember.EndDate)
	if err != nil {
		l.Error(err, "failed to update endDate for technical lead")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// update slot status -> pending
	slot := model.ProjectSlot{
		Status: model.ProjectMemberStatusPending,
	}
	_, err = h.store.ProjectSlot.UpdateSelectedFieldsByID(tx.DB(), projectMember.ProjectSlotID.String(), slot, "status")
	if err != nil {
		l.Error(err, "failed to update project slot")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

// UpdateMember godoc
// @Summary Update member in an existing project
// @Description Update member in an existing project
// @id updateProjectMember
// @Tags Project
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param Body body UpdateMemberRequest true "Body"
// @Success 200 {object} CreateMemberDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/members [put]
func (h *handler) UpdateMember(c *gin.Context) {
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	var body request.UpdateMemberRequest
	if err := c.ShouldBindJSON(&body); err != nil {
		if err != nil {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}
	}

	projectID := c.Param("id")
	if projectID == "" || !model.IsUUIDFromString(projectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "UpdateMember",
		"body":    body,
	})

	if err := body.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	// check project existence
	p, err := h.store.Project.One(h.repo.DB(), projectID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, body, ""))
			return
		}

		l.Error(err, "failed to get project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	// check seniority existence
	exists, err := h.store.Seniority.IsExist(h.repo.DB(), body.SeniorityID.String())
	if err != nil {
		l.Error(err, "failed to check seniority existence")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	if !exists {
		l.Error(errs.ErrSeniorityNotFound, "cannot find seniority by id")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrSeniorityNotFound, body, ""))
		return
	}

	// check position existence
	positions, err := h.store.Position.All(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to get all positions")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	positionMap := model.ToPositionMap(positions)
	for _, pID := range body.Positions {
		if _, ok := positionMap[model.UUID(pID)]; !ok {
			l.Error(errs.ErrPositionNotFoundWithID(pID.String()), "position not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrPositionNotFoundWithID(pID.String()), body, ""))
			return
		}
	}

	// check project slot status
	slot, err := h.store.ProjectSlot.One(h.repo.DB(), body.ProjectSlotID.String())
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrProjectSlotNotFound, "cannot find project slot by id")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectSlotNotFound, body, ""))
			return
		}
		l.Error(err, "failed to get project slot by id")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	if !body.EmployeeID.IsZero() {
		member, err := h.updateProjectMember(tx.DB(), p, slot.ID.String(), projectID, body, userInfo)
		if err != nil {
			l.Error(err, "failed to update project member")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
			return
		}

		slot.ProjectMember = *member
	}

	// update project slot
	slot.SeniorityID = model.UUID(body.SeniorityID)
	slot.DeploymentType = model.DeploymentType(body.DeploymentType)
	slot.Status = model.ProjectMemberStatus(body.Status)
	slot.Note = body.Note

	if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) {
		slot.Rate = body.Rate
		slot.Discount = body.Discount
	}

	_, err = h.store.ProjectSlot.UpdateSelectedFieldsByID(tx.DB(), body.ProjectSlotID.String(), *slot,
		"seniority_id",
		"deployment_type",
		"status",
		"rate",
		"discount",
		"note",
	)
	if err != nil {
		l.Error(err, "failed to update project slot")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}

	// update project slot positions
	if err := h.store.ProjectSlotPosition.DeleteByProjectSlotID(tx.DB(), slot.ID.String()); err != nil {
		l.Error(err, "failed to delete project member positions")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	slotPos := make([]model.ProjectSlotPosition, 0, len(body.Positions))
	for _, v := range body.Positions {
		slotPos = append(slotPos, model.ProjectSlotPosition{
			ProjectSlotID: slot.ID,
			PositionID:    model.UUID(v),
		})
	}

	if err := h.store.ProjectSlotPosition.Create(tx.DB(), slotPos...); err != nil {
		l.Error(err, "failed to create project slot positions")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	slot.ProjectSlotPositions = slotPos

	for i, v := range slot.ProjectSlotPositions {
		slot.ProjectSlotPositions[i].Position = positionMap[v.PositionID]
	}

	for i, v := range slot.ProjectMember.ProjectMemberPositions {
		slot.ProjectMember.ProjectMemberPositions[i].Position = positionMap[v.PositionID]
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToCreateMemberData(userInfo, slot), nil, done(nil), nil, ""))
}

// updateProjectMember flow:
//
// --- start ---
//
//	if input.EmployeeID != nil {
//		if input.ProjectMemberID != nil {
//			update ProjectMember by ProjectMemberID
//		 } else {
//			update ProjectMember by ProjectID and EmployeeID
//		 }
//		 if !input.IsLead || input.EndDate != nil {
//			endDate := input.EndDate
//			if input.EndDate == nil {
//			   endDate = time.Now()
//				   update endDate of projectHead
//				}
//			 } else {
//				create new ProjectHead
//			 }
//		 }
//
// --- end ---
func (h *handler) updateProjectMember(db *gorm.DB, p *model.Project, slotID string, projectID string, input request.UpdateMemberRequest, userInfo *model.CurrentLoggedUserInfo) (*model.ProjectMember, error) {
	var member *model.ProjectMember
	var err error

	// check upsell person existence
	var upsellPerson *model.Employee
	if !input.UpsellPersonID.IsZero() {
		upsellPerson, err = h.store.Employee.One(h.repo.DB(), input.UpsellPersonID.String(), false)
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				h.logger.Error(errs.ErrEmployeeNotFound, "upsell person not found")
				return nil, err
			}

			h.logger.Error(err, "failed to get upsell person by id")
			return nil, err
		}
	}

	if !input.ProjectMemberID.IsZero() {
		// Update assigned slot
		member, err = h.store.ProjectMember.OneByID(db, input.ProjectMemberID.String())
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				h.logger.Error(errs.ErrProjectMemberNotFound, "project member not found")
				return nil, err
			}
			h.logger.Error(err, "failed to get project member by id")
			return nil, err
		}

		member.SeniorityID = model.UUID(input.SeniorityID)
		member.DeploymentType = model.DeploymentType(input.DeploymentType)
		member.StartDate = input.GetStartDate()
		member.Note = input.Note
		member.UpsellPersonID = model.UUID(input.UpsellPersonID)

		updateEndDate := false
		inputEndDate := input.GetEndDate()
		if member.EndDate != nil && inputEndDate == nil {
			member.EndDate = nil
			updateEndDate = true
		}

		if member.EndDate == nil && inputEndDate != nil {
			member.EndDate = inputEndDate
			updateEndDate = true
		}

		if member.EndDate != nil && inputEndDate != nil {
			if !member.EndDate.Equal(*inputEndDate) {
				member.EndDate = inputEndDate
				updateEndDate = true
			}
		}

		updateStatus := false
		if member.Status != model.ProjectMemberStatus(input.Status) {
			member.Status = model.ProjectMemberStatus(input.Status)
			updateStatus = true
		}

		if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) {
			member.UpsellCommissionRate = input.UpsellCommissionRate
		}

		updateRate := false
		if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) {
			if !member.Rate.Equal(input.Rate) {
				member.Rate = input.Rate
				updateRate = true
			}
			member.Discount = input.Discount
		}

		_, err = h.store.ProjectMember.UpdateSelectedFieldsByID(db, input.ProjectMemberID.String(), *member,
			"start_date",
			"end_date",
			"status",
			"rate",
			"discount",
			"deployment_type",
			"seniority_id",
			"note",
			"upsell_person_id",
			"upsell_commission_rate",
		)
		if err != nil {
			h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to update project member")
			return nil, err
		}

		if updateStatus {
			err = h.controller.Discord.Log(model.LogDiscordInput{
				Type: "project_member_update_status",
				Data: map[string]interface{}{
					"employee_id":         userInfo.UserID,
					"updated_employee_id": member.EmployeeID.String(),
					"project_name":        p.Name,
					"status":              member.Status.String(),
				},
			})
			if err != nil {
				h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to log project member status update")
			}
		}

		if updateRate {
			charRate, _ := member.Rate.Float64()
			rate := utils.FormatMoney(charRate, p.BankAccount.Currency.Name)
			err = h.controller.Discord.Log(model.LogDiscordInput{
				Type: "project_member_update_charge_rate",
				Data: map[string]interface{}{
					"employee_id":         userInfo.UserID,
					"updated_employee_id": member.EmployeeID.String(),
					"project_name":        p.Name,
					"rate":                fmt.Sprintf("%s %s", rate, p.BankAccount.Currency.Name),
				},
			})
			if err != nil {
				h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to log project member charge rate update")
			}
		}

		if updateEndDate {
			endDateLog := "N/A"
			if member.EndDate != nil {
				endDateLog = member.EndDate.Format("2006-01-02")
			}

			err = h.controller.Discord.Log(model.LogDiscordInput{
				Type: "project_member_update_end_date",
				Data: map[string]interface{}{
					"employee_id":         userInfo.UserID,
					"updated_employee_id": member.EmployeeID.String(),
					"project_name":        p.Name,
					"end_date":            endDateLog,
				},
			})
			if err != nil {
				h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to log project member end date update")
			}
		}
	} else {
		// Update pending slot

		// Is slot contains any member?
		member, err = h.store.ProjectMember.OneBySlotID(db, slotID)
		if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
			h.logger.Fields(logger.Fields{"slotID": slotID}).Error(err, "failed to get project member by slotID")
			return nil, err
		}

		if member != nil && !member.EmployeeID.IsZero() && member.EmployeeID != model.UUID(input.EmployeeID) {
			h.logger.
				Fields(logger.Fields{"member": member}).
				Error(errs.ErrSlotAlreadyContainsAnotherMember, "slot already contains another member")
			return nil, errs.ErrSlotAlreadyContainsAnotherMember
		}

		// Is member active in project?
		_, err = h.store.ProjectMember.GetActiveMemberInProject(db, projectID, input.EmployeeID.String())
		if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
			h.logger.Fields(logger.Fields{
				"projectID":  projectID,
				"employeeID": input.EmployeeID,
			}).Error(err, "failed to get active member in project")
			return nil, err
		}

		// If member is not active in project, create new project member
		if errors.Is(err, gorm.ErrRecordNotFound) {
			member = &model.ProjectMember{
				ProjectID:      model.MustGetUUIDFromString(projectID),
				EmployeeID:     model.UUID(input.EmployeeID),
				SeniorityID:    model.UUID(input.SeniorityID),
				ProjectSlotID:  model.MustGetUUIDFromString(slotID),
				DeploymentType: model.DeploymentType(input.DeploymentType),
				Status:         model.ProjectMemberStatus(input.Status),
				StartDate:      input.GetStartDate(),
				EndDate:        input.GetEndDate(),
				Note:           input.Note,
				UpsellPersonID: model.UUID(input.UpsellPersonID),
			}

			if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) {
				member.UpsellCommissionRate = input.UpsellCommissionRate
			}

			if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) {
				member.Rate = input.Rate
				member.Discount = input.Discount
			}

			if err := h.store.ProjectMember.Create(db, member); err != nil {
				h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to create project member")
				return nil, err
			}

			err = h.controller.Discord.Log(model.LogDiscordInput{
				Type: "project_member_add",
				Data: map[string]interface{}{
					"employee_id":         userInfo.UserID,
					"updated_employee_id": member.EmployeeID.String(),
					"project_name":        p.Name,
					"deployment_type":     member.DeploymentType.String(),
				},
			})
			if err != nil {
				h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to log project member add")
			}
		}
	}

	// update project member positions
	if err := h.store.ProjectMemberPosition.DeleteByProjectMemberID(db, member.ID.String()); err != nil {
		h.logger.Fields(logger.Fields{"memberID": member.ID}).Error(err, "failed to delete project member positions")
		return nil, err
	}

	memberPos := make([]model.ProjectMemberPosition, 0, len(input.Positions))
	for _, v := range input.Positions {
		memberPos = append(memberPos, model.ProjectMemberPosition{
			ProjectMemberID: member.ID,
			PositionID:      model.UUID(v),
		})
	}

	if err := h.store.ProjectMemberPosition.Create(db, memberPos...); err != nil {
		h.logger.Fields(logger.Fields{"positions": memberPos}).Error(err, "failed to create project member positions")
		return nil, err
	}

	member.UpsellPerson = upsellPerson
	member.ProjectMemberPositions = memberPos

	member.IsLead = input.IsLead
	endDate := input.GetEndDate()
	if !input.IsLead {
		// End of lead time
		if endDate == nil {
			endDate = new(time.Time)
			*endDate = time.Now()
		}

		_, err := h.store.ProjectHead.UpdateDateOfEmployee(db,
			input.EmployeeID.String(),
			projectID,
			model.HeadPositionTechnicalLead.String(),
			input.GetStartDate(),
			endDate)
		if err != nil {
			h.logger.Fields(logger.Fields{
				"projectID":  projectID,
				"employeeID": input.EmployeeID,
			}).Error(err, "failed to update end_date of project head")
			return nil, err
		}
	} else {
		// Start of lead time or update lead time
		_, err := h.updateProjectLead(db, projectID, model.UUID(input.EmployeeID), input.GetStartDate(), input.GetEndDate(), input.LeadCommissionRate, userInfo)
		if err != nil {
			h.logger.Fields(logger.Fields{
				"projectID":  projectID,
				"employeeID": input.EmployeeID,
			}).Error(err, "failed to update technicalLeads")
			return nil, err
		}
	}

	return member, nil
}

// AssignMember godoc
// @Summary Assign member into an existing project
// @Description Assign member in an existing project
// @id assignProjectMember
// @Tags Project
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param Body body AssignMemberRequest true "Body"
// @Success 200 {object} CreateMemberDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/members [post]
func (h *handler) AssignMember(c *gin.Context) {
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	var body request.AssignMemberRequest
	if err := c.ShouldBindJSON(&body); err != nil {
		if err != nil {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}
	}

	projectID := c.Param("id")
	if projectID == "" || !model.IsUUIDFromString(projectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "AssignMember",
		"body":    body,
		"id":      projectID,
	})

	if err := body.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	// TODO: uncomment
	// The code has been commented because inactive user can be assigned to project,
	// we do not need to check if member active in project or not

	// // get active project member info
	// if !body.EmployeeID.IsZero() {
	// 	_, err := h.store.ProjectMember.GetActiveMemberInProject(h.repo.DB(), projectID, body.EmployeeID.String())
	// 	if err != gorm.ErrRecordNotFound {
	// 		if err == nil {
	// 			l.Error(err, "project member exists")
	// 			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrProjectMemberExists, projectID, ""))
	// 			return
	// 		}
	// 		l.Error(err, "failed to query project member")
	// 		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, projectID, ""))
	// 		return
	// 	}
	// }

	// check project existence
	p, err := h.store.Project.One(h.repo.DB(), projectID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}
		l.Error(err, "error query project from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// remove commission rate if user does not have permission
	body.RestrictPermission(userInfo)

	tx, done := h.repo.NewTransaction()

	slot, code, err := h.createSlotsAndAssignMembers(tx.DB(), p, body, userInfo)
	if err != nil {
		l.Error(err, "failed to assign member to project")
		c.JSON(code, view.CreateResponse[any](nil, nil, done(err), body, ""))
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToCreateMemberData(userInfo, slot), nil, done(nil), nil, ""))
}

func (h *handler) createSlotsAndAssignMembers(db *gorm.DB, p *model.Project, req request.AssignMemberRequest, userInfo *model.CurrentLoggedUserInfo) (*model.ProjectSlot, int, error) {
	l := h.logger

	// check seniority existence
	seniority, err := h.store.Seniority.One(db, model.UUID(req.SeniorityID))
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrSeniorityNotFound, "cannot find seniority by id")
			return nil, http.StatusNotFound, errs.ErrSeniorityNotFound
		}
		l.Error(err, "failed to check seniority existence")
		return nil, http.StatusInternalServerError, err
	}

	// check position existence
	positions, err := h.store.Position.All(db)
	if err != nil {
		l.Error(err, "failed to get all position")
		return nil, http.StatusInternalServerError, err
	}

	positionMap := model.ToPositionMap(positions)
	for _, pID := range req.Positions {
		if _, ok := positionMap[model.UUID(pID)]; !ok {
			l.Error(errs.ErrPositionNotFoundWithID(pID.String()), "position not found")
			return nil, http.StatusNotFound, errs.ErrPositionNotFoundWithID(pID.String())
		}
	}

	// create project slot
	slot := &model.ProjectSlot{
		ProjectID:      p.ID,
		DeploymentType: model.DeploymentType(req.DeploymentType),
		Status:         req.GetStatus(),
		SeniorityID:    model.UUID(req.SeniorityID),
		Note:           req.Note,
	}

	if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) {
		slot.Rate = req.Rate
		slot.Discount = req.Discount
	}

	if err := h.store.ProjectSlot.Create(db, slot); err != nil {
		l.Error(err, "failed to create project slot")
		return nil, http.StatusInternalServerError, err
	}
	slot.Seniority = *seniority

	// create project slot position
	slotPos := make([]model.ProjectSlotPosition, 0, len(req.Positions))

	for _, v := range req.Positions {
		slotPos = append(slotPos, model.ProjectSlotPosition{
			ProjectSlotID: slot.ID,
			PositionID:    model.UUID(v),
		})
	}

	if err := h.store.ProjectSlotPosition.Create(db, slotPos...); err != nil {
		l.Error(err, "failed to create project member positions")
		return nil, http.StatusInternalServerError, err
	}

	for i := range slotPos {
		slotPos[i].Position = positionMap[slotPos[i].PositionID]
	}

	slot.ProjectSlotPositions = slotPos

	// assign member to slot
	if !req.EmployeeID.IsZero() {
		// check employee existence
		exists, err := h.store.Employee.IsExist(db, req.EmployeeID.String())
		if err != nil {
			l.Error(err, "failed to check employee existence")
			return nil, http.StatusInternalServerError, err
		}

		if !exists {
			l.Error(errs.ErrEmployeeNotFound, "cannot find employee by id")
			return nil, http.StatusNotFound, errs.ErrEmployeeNotFound
		}

		// check upsell person existence
		var upsellPerson *model.Employee
		if !req.UpsellPersonID.IsZero() {
			upsellPerson, err = h.store.Employee.One(db, req.UpsellPersonID.String(), false)
			if err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					l.Error(err, "failed to get upsell person")
					return nil, http.StatusInternalServerError, err
				}
				l.Error(errs.ErrEmployeeNotFound, "upsell person not found")
				return nil, http.StatusNotFound, errs.ErrEmployeeNotFound
			}
		}

		// create project member
		member := &model.ProjectMember{
			ProjectID:      p.ID,
			EmployeeID:     model.UUID(req.EmployeeID),
			SeniorityID:    model.UUID(req.SeniorityID),
			ProjectSlotID:  slot.ID,
			DeploymentType: model.DeploymentType(req.DeploymentType),
			Status:         req.GetStatus(),
			StartDate:      req.GetStartDate(),
			EndDate:        req.GetEndDate(),
			Note:           req.Note,
			UpsellPersonID: model.UUID(req.UpsellPersonID),
		}

		if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) {
			member.UpsellCommissionRate = req.UpsellCommissionRate
		}

		if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) {
			member.Rate = req.Rate
			member.Discount = req.Discount
		}

		if err = h.store.ProjectMember.Create(db, member); err != nil {
			l.Error(err, "failed to create project member")
			return nil, http.StatusInternalServerError, err
		}

		member.UpsellPerson = upsellPerson
		slot.ProjectMember = *member

		// create project member positions
		for _, v := range req.Positions {
			if err := h.store.ProjectMemberPosition.Create(db, model.ProjectMemberPosition{
				ProjectMemberID: member.ID,
				PositionID:      model.UUID(v),
			}); err != nil {
				l.Error(err, "failed to create project member positions")
				return nil, http.StatusInternalServerError, err
			}
		}

		// create project head
		slot.ProjectMember.IsLead = req.IsLead
		if req.IsLead {
			head := &model.ProjectHead{
				ProjectID:  p.ID,
				EmployeeID: model.UUID(req.EmployeeID),
				Position:   model.HeadPositionTechnicalLead,
				StartDate:  *req.GetStartDate(),
			}

			if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) {
				head.CommissionRate = req.LeadCommissionRate
			}

			if err := h.store.ProjectHead.Create(db, head); err != nil {
				l.Error(err, "failed to create project head")
				return nil, http.StatusInternalServerError, err
			}

			slot.ProjectMember.Head = head
		}

		err = h.controller.Discord.Log(model.LogDiscordInput{
			Type: "project_member_add",
			Data: map[string]interface{}{
				"employee_id":         userInfo.UserID,
				"updated_employee_id": member.EmployeeID.String(),
				"project_name":        p.Name,
				"deployment_type":     member.DeploymentType.String(),
			},
		})
		if err != nil {
			h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to log project member add")
		}
	}

	return slot, http.StatusOK, nil
}

// Details godoc
// @Summary Get details of a project
// @Description Get details of a project
// @id getProjectDetails
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Success 200 {object} ProjectDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id} [get]
func (h *handler) Details(c *gin.Context) {
	// 0. Get current logged in user data
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	projectID := c.Param("id")
	if projectID == "" {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "Details",
		"id":      projectID,
	})

	rs, err := h.store.Project.One(h.repo.DB(), projectID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}
		l.Error(err, "error query project from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadFullAccess) && !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadReadActive) {
		_, ok := userInfo.Projects[rs.ID]
		if !ok || !model.IsUserActiveInProject(userInfo.UserID, rs.ProjectMembers) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}
	}

	if rs.Status == model.ProjectStatusClosed && !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadFullAccess) {
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToProjectData(rs, userInfo), nil, nil, nil, ""))
}

// UpdateGeneralInfo godoc
// @Summary Update general info of the project by id
// @Description Update general info of the project by id
// @id updateProjectGeneralInfo
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param Body body UpdateProjectGeneralInfoRequest true "Body"
// @Success 200 {object} UpdateProjectGeneralInfoResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/general-info [put]
func (h *handler) UpdateGeneralInfo(c *gin.Context) {
	projectID := c.Param("id")
	if projectID == "" || !model.IsUUIDFromString(projectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	var body request.UpdateProjectGeneralInfoRequest
	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	if err := body.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "UpdateGeneralInfo",
		"id":      projectID,
		"request": body,
	})

	// Check project existence
	p, err := h.store.Project.One(h.repo.DB(), projectID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, projectID, ""))
			return
		}

		l.Error(err, "failed to get project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, projectID, ""))
		return
	}

	// Check country existence
	exist, err := h.store.Country.IsExist(h.repo.DB(), body.CountryID.String())
	if err != nil {
		l.Error(err, "error check existence of country")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	if !exist {
		l.Error(err, "country not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrCountryNotFound, body, ""))
		return
	}

	// Check bank account existence
	if !body.BankAccountID.IsZero() {
		exist, err := h.store.BankAccount.IsExist(h.repo.DB(), body.BankAccountID.String())
		if err != nil {
			l.Error(err, "error check existence of bank account")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}

		if !exist {
			l.Error(err, "bank account not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrBankAccountNotFound, body, ""))
			return
		}
	}

	// Check organization existence
	if !body.OrganizationID.IsZero() {
		exist, err := h.store.Organization.IsExist(h.repo.DB(), body.OrganizationID.String())
		if err != nil {
			l.Error(err, "error check existence of organization")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}

		if !exist {
			l.Error(err, "organization not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrOrganizationNotFound, body, ""))
			return
		}
	}

	if !body.CompanyInfoID.IsZero() {
		exist, err := h.store.CompanyInfo.IsExist(h.repo.DB(), body.CompanyInfoID.String())
		if err != nil {
			l.Error(err, "error check existence of company info")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}

		if !exist {
			l.Error(err, "company info not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrCompanyInfoNotFound, body, ""))
			return
		}
	}

	// Check valid stack id
	_, stacks, err := h.store.Stack.All(h.repo.DB(), "", nil)
	if err != nil {
		l.Error(err, "error when finding stacks")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	stackMap := model.ToStackMap(stacks)
	for _, sID := range body.Stacks {
		_, ok := stackMap[model.UUID(sID)]
		if !ok {
			l.Error(errs.ErrStackNotFoundWithID(sID.String()), "stack not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrStackNotFoundWithID(sID.String()), body, ""))
			return
		}
	}

	_, err = time.Parse("2006-01-02", body.StartDate)
	if body.StartDate != "" && err != nil {
		l.Error(errs.ErrInvalidStartDate, "invalid start date")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidStartDate, body, ""))
		return
	}

	if !body.ClientID.IsZero() {
		client, err := h.store.Client.One(h.repo.DB(), body.ClientID.String())
		if err != nil {
			l.Error(err, "client not found")
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrClientNotFound, body, ""))
			return
		}

		p.Client = client
		p.ClientID = client.ID
	}

	// Begin transaction
	tx, done := h.repo.NewTransaction()

	// Delete all exist employee stack
	if err := h.store.ProjectStack.DeleteByProjectID(tx.DB(), projectID); err != nil {
		l.Error(err, "failed to delete project stacks in database")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}

	// Create new employee stack
	for _, stackID := range body.Stacks {
		_, err := h.store.ProjectStack.Create(tx.DB(), &model.ProjectStack{
			ProjectID: model.MustGetUUIDFromString(projectID),
			StackID:   model.UUID(stackID),
		})
		if err != nil {
			l.Error(err, "failed to create project stack")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
			return
		}
	}

	p.Name = body.Name
	p.StartDate = body.GetStartDate()
	p.CountryID = model.UUID(body.CountryID)
	p.Function = model.ProjectFunction(body.Function)
	p.OrganizationID = model.UUID(body.OrganizationID)
	p.AccountRating = body.AccountRating
	p.DeliveryRating = body.DeliveryRating
	p.LeadRating = body.LeadRating
	p.ImportantLevel = model.ProjectImportantLevel(body.ImportantLevel)

	if !body.BankAccountID.IsZero() {
		p.BankAccountID = model.UUID(body.BankAccountID)
	}

	if !body.CompanyInfoID.IsZero() {
		p.CompanyInfoID = model.UUID(body.CompanyInfoID)
	}

	projectNotion, err := h.store.ProjectNotion.OneByProjectID(tx.DB(), p.ID.String())

	if err != nil {
		if !errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "failed to get project notion")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), projectID, ""))
			return
		} else if !body.AuditNotionID.IsZero() {
			// create new project notion
			_, err := h.store.ProjectNotion.Create(tx.DB(), &model.ProjectNotion{
				ProjectID:     p.ID,
				AuditNotionID: model.UUID(body.AuditNotionID),
			})
			if err != nil {
				l.Error(err, "failed to create project notion")
				c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
				return
			}
		}
	} else {
		projectNotion.AuditNotionID = model.UUID(body.AuditNotionID)
		// update audit notion id
		if _, err := h.store.ProjectNotion.UpdateSelectedFieldsByID(tx.DB(), projectNotion.ID.String(), *projectNotion); err != nil {
			l.Error(err, "failed to create project notion")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
			return
		}
	}

	// TODO: allow updating client_id
	_, err = h.store.Project.UpdateSelectedFieldsByID(tx.DB(), projectID, *p,
		"name",
		"start_date",
		"country_id",
		"function",
		"bank_account_id",
		"client_id",
		"organization_id",
		"account_rating",
		"delivery_rating",
		"lead_rating",
		"important_level",
		"company_info_id",
	)

	if err != nil {
		l.Error(err, "failed to update project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateProjectGeneralInfo(p), nil, done(nil), nil, ""))
}

// UpdateContactInfo godoc
// @Summary Update contact info of the project by id
// @Description Update contact info of the project by id
// @id updateProjectContactInfo
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param Body body UpdateContactInfoRequest true "Body"
// @Success 200 {object} UpdateProjectContactInfoResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/contact-info [put]
func (h *handler) UpdateContactInfo(c *gin.Context) {
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	projectID := c.Param("id")
	if projectID == "" || !model.IsUUIDFromString(projectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	var body request.UpdateContactInfoRequest
	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "UpdateContactInfo",
		"id":      projectID,
		"request": body,
	})

	// Validate client email address
	if err := body.Validate(); err != nil {
		l.Error(err, "invalid input request body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, projectID, ""))
		return
	}

	// Check project existence
	p, err := h.store.Project.One(h.repo.DB(), projectID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, projectID, ""))
			return
		}

		l.Error(err, "failed to get project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, projectID, ""))
		return
	}

	// Begin transaction
	tx, done := h.repo.NewTransaction()

	err = h.updateProjectHeads(tx.DB(), projectID, model.HeadPositionAccountManager, body.AccountManagers, userInfo)
	if err != nil {
		l.Error(err, "failed to update account managers")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}

	err = h.updateProjectHeads(tx.DB(), projectID, model.HeadPositionDeliveryManager, body.DeliveryManagers, userInfo)
	if err != nil {
		l.Error(err, "failed to update delivery managers")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}

	err = h.updateProjectHeads(tx.DB(), projectID, model.HeadPositionSalePerson, body.SalePersons, userInfo)
	if err != nil {
		l.Error(err, "failed to update sale persons")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}

	// Update email info
	p.ClientEmail = strings.Join(body.ClientEmail, ",")
	p.ProjectEmail = body.ProjectEmail

	_, err = h.store.Project.UpdateSelectedFieldsByID(tx.DB(), projectID, *p, "client_email", "project_email")
	if err != nil {
		l.Error(err, "failed to update project information to db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}

	heads, err := h.store.ProjectHead.GetActiveLeadsByProjectID(tx.DB(), projectID)
	if err != nil {
		l.Error(err, "failed to get project heads")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""))
		return
	}

	p.Heads = heads

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateProjectContactInfo(p, userInfo), nil, done(nil), nil, ""))
}

func (h *handler) updateProjectHeads(db *gorm.DB, projectID string, position model.HeadPosition, headsInput []request.ProjectHeadRequest, userInfo *model.CurrentLoggedUserInfo) error {
	// create input map
	headInputMap := map[model.UUID]decimal.Decimal{}
	for _, head := range headsInput {
		if head.EmployeeID.IsZero() {
			continue
		}
		exists, err := h.store.Employee.IsExist(db, head.EmployeeID.String())
		if err != nil {
			h.logger.Error(err, "failed to check employee existence")
			return err
		}

		if !exists {
			h.logger.Error(errs.ErrEmployeeNotFound, "employee not found")
			return errs.ErrEmployeeNotFound
		}

		headInputMap[model.UUID(head.EmployeeID)] = head.CommissionRate
	}

	heads, err := h.store.ProjectHead.GetByProjectIDAndPosition(db, projectID, position)
	if err != nil {
		h.logger.Fields(logger.Fields{
			"projectID": projectID,
			"position":  position,
		}).Error(err, "failed to get heads")
		return err
	}

	// update/delete exist heads
	for _, head := range heads {
		if _, ok := headInputMap[head.EmployeeID]; ok {
			if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) {
				head.CommissionRate = headInputMap[head.EmployeeID]

				_, err := h.store.ProjectHead.UpdateSelectedFieldsByID(db, head.ID.String(), *head, "commission_rate")
				if err != nil {
					h.logger.Fields(logger.Fields{
						"projectID": projectID,
						"headID":    head.ID.String(),
					}).Error(err, "failed to update head")
					return err
				}
			}

			delete(headInputMap, head.EmployeeID)
		} else {
			if err := h.store.ProjectHead.DeleteByID(db, head.ID.String()); err != nil {
				h.logger.Fields(logger.Fields{
					"projectID": projectID,
					"headID":    head.ID.String(),
				}).Error(err, "failed to delete head")
				return err
			}
		}
	}

	// create new head
	for employeeID, commissionRate := range headInputMap {
		if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) {
			commissionRate = decimal.Zero
		}

		head := &model.ProjectHead{
			BaseModel: model.BaseModel{
				ID: model.NewUUID(),
			},
			ProjectID:      model.MustGetUUIDFromString(projectID),
			EmployeeID:     employeeID,
			CommissionRate: commissionRate,
			Position:       position,
		}

		if err := h.store.ProjectHead.Create(db, head); err != nil {
			h.logger.AddField("head", head).Error(err, "failed to create head")
			return err
		}
	}

	return nil
}

func (h *handler) updateProjectLead(db *gorm.DB, projectID string, employeeID model.UUID, startDate *time.Time, endDate *time.Time, commissionRate decimal.Decimal, userInfo *model.CurrentLoggedUserInfo) (*model.ProjectHead, error) {
	head, err := h.store.ProjectHead.One(db, projectID, employeeID.String(), model.HeadPositionTechnicalLead)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		h.logger.Fields(logger.Fields{
			"projectID":  projectID,
			"employeeID": employeeID,
		}).Error(err, "failed to get technical lead")
		return nil, err
	}

	if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) {
		commissionRate = decimal.Zero
	} else if head != nil {
		head.CommissionRate = commissionRate
	}

	if err == nil {
		// Update old record
		head.StartDate = *startDate
		head.EndDate = endDate

		_, err := h.store.ProjectHead.UpdateSelectedFieldsByID(db, head.ID.String(), *head,
			"start_date",
			"end_date",
			"commission_rate",
		)
		if err != nil {
			h.logger.Fields(logger.Fields{"head": *head}).Error(err, "failed to update project head")
			return nil, err
		}
	} else {
		// Create new record
		head = &model.ProjectHead{
			ProjectID:      model.MustGetUUIDFromString(projectID),
			EmployeeID:     employeeID,
			CommissionRate: commissionRate,
			StartDate:      *startDate,
			EndDate:        endDate,
			Position:       model.HeadPositionTechnicalLead,
		}

		if err := h.store.ProjectHead.Create(db, head); err != nil {
			h.logger.Fields(logger.Fields{"head": head}).Error(err, "failed to create project head")
			return nil, err
		}
	}

	return head, nil
}

// GetWorkUnits godoc
// @Summary Get list work units of a project
// @Description Get list work units of a project
// @id getProjectWorkUnitList
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param status query  WorkUnitStatus false "status"
// @Success 200 {object} ListWorkUnitResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/work-units [get]
func (h *handler) GetWorkUnits(c *gin.Context) {
	// 0. Get current logged in user data
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	input := request.GetListWorkUnitInput{
		ProjectID: c.Param("id"),
	}

	if err := c.ShouldBindQuery(&input.Query); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input.Query, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler":   "project",
		"method":    "GetWorkUnits",
		"projectID": input.ProjectID,
		"query":     input.Query,
	})

	if err := input.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	p, err := h.store.Project.One(h.repo.DB(), input.ProjectID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, ""))
			return
		}

		l.Info("failed to check if project exists")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectWorkUnitsReadFullAccess) {
		_, ok := userInfo.Projects[p.ID]
		if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}
	}

	workUnits, err := h.store.WorkUnit.GetByProjectID(h.repo.DB(), input.ProjectID, model.WorkUnitStatus(input.Query.Status))
	if err != nil {
		l.Error(err, "failed to get work units")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input.ProjectID, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToWorkUnitList(workUnits, input.ProjectID, p.Code), nil, nil, nil, ""))
}

// CreateWorkUnit godoc
// @Summary Create work unit of a project
// @Description Get work unit of a project
// @id createProjectWorkUnit
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param body body CreateWorkUnitRequest true "Body"
// @Success 200 {object} WorkUnitResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/work-units [post]
func (h *handler) CreateWorkUnit(c *gin.Context) {
	// 0. Get current logged in user data
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	input := request.CreateWorkUnitInput{
		ProjectID: c.Param("id"),
	}
	if err := c.ShouldBindJSON(&input.Body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "CreateWorkUnit",
		"input":   input,
	})

	if err := input.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	p, err := h.store.Project.One(h.repo.DB(), input.ProjectID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrProjectNotFound, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}

		l.Error(err, "failed to get project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	// Has permission when have work unit create full-access and active in project
	if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectWorkUnitsCreateFullAccess) {
		_, ok := userInfo.Projects[p.ID]
		if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}

		leadMap := map[string]bool{}
		for _, v := range p.Heads {
			if v.IsLead() {
				leadMap[v.EmployeeID.String()] = true
			}
		}

		_, ok = leadMap[userInfo.UserID]
		if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrMemberIsNotProjectLead, nil, ""))
			return
		}
	}

	tx, done := h.repo.NewTransaction()

	workUnit := &model.WorkUnit{
		Name:      input.Body.Name,
		Type:      model.WorkUnitType(input.Body.Type),
		Status:    model.WorkUnitStatus(input.Body.Status),
		SourceURL: input.Body.URL,
		ProjectID: model.MustGetUUIDFromString(input.ProjectID),
	}

	if err := h.store.WorkUnit.Create(tx.DB(), workUnit); err != nil {
		l.Error(err, "failed to create new work unit")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	stacks, err := h.store.Stack.GetByIDs(tx.DB(), view.ToModelUUIDs(input.Body.Stacks))
	if err != nil {
		l.Error(err, "failed to get stacks")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// create work unit stack
	for _, stack := range stacks {
		wuStack := model.WorkUnitStack{
			StackID:    stack.ID,
			WorkUnitID: workUnit.ID,
		}
		if err := h.store.WorkUnitStack.Create(tx.DB(), &wuStack); err != nil {
			l.Error(err, "failed to create new work unit stack")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
			return
		}

		wuStack.Stack = *stack
		workUnit.WorkUnitStacks = append(workUnit.WorkUnitStacks, &wuStack)
	}

	employees, err := h.store.Employee.GetByIDs(tx.DB(), view.ToModelUUIDs(input.Body.Members))
	if err != nil {
		l.Error(err, "failed to get employees")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// create work unit member
	for _, employee := range employees {
		pMember, err := h.store.ProjectMember.GetActiveMemberInProject(tx.DB(), input.ProjectID, employee.ID.String())
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrMemberIsNotActiveInProject, "member is not active in project")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrMemberIsNotActiveInProject), input, ""))
			return
		}

		wuMember := model.WorkUnitMember{
			Status:     model.ProjectMemberStatusActive.String(),
			WorkUnitID: workUnit.ID,
			EmployeeID: employee.ID,
			ProjectID:  model.MustGetUUIDFromString(input.ProjectID),
			StartDate:  *pMember.StartDate,
		}
		if err := h.store.WorkUnitMember.Create(tx.DB(), &wuMember); err != nil {
			l.Error(err, "failed to create new work unit member")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
			return
		}

		wuMember.Employee = *employee
		workUnit.WorkUnitMembers = append(workUnit.WorkUnitMembers, &wuMember)
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToWorkUnit(workUnit, p.Code), nil, done(nil), nil, ""))
}

// UpdateWorkUnit godoc
// @Summary Update work unit info
// @Description Update work unit info
// @id updateProjectWorkUnit
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param workUnitID path string true "Work Unit ID"
// @Param Body body UpdateWorkUnitRequest true "Body"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/work-units/{workUnitID} [put]
func (h *handler) UpdateWorkUnit(c *gin.Context) {
	// 0. Get current logged in user data
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	input := request.UpdateWorkUnitInput{
		ProjectID:  c.Param("id"),
		WorkUnitID: c.Param("workUnitID"),
	}

	if err := c.ShouldBindJSON(&input.Body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input.Body, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "UpdateWorkUnit",
		"input":   input,
	})

	if err := input.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	p, err := h.store.Project.One(h.repo.DB(), input.ProjectID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrProjectNotFound, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}

		l.Error(err, "failed to get project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectWorkUnitsEditFullAccess) {
		_, ok := userInfo.Projects[p.ID]
		if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}

		leadMap := map[string]bool{}
		for _, v := range p.Heads {
			if v.IsLead() {
				leadMap[v.EmployeeID.String()] = true
			}
		}

		_, ok = leadMap[userInfo.UserID]
		if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrMemberIsNotProjectLead, nil, ""))
			return
		}
	}

	// Check Exitsences of elements in input
	status, err := h.checkExitsInUpdateWorkUnitInput(h.repo.DB(), input)

	if err != nil {
		l.Error(err, "err when checking the existence of elements in the input")
		c.JSON(status, view.CreateResponse[any](nil, nil, err, input.Body, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	workUnit := &model.WorkUnit{
		Name:      input.Body.Name,
		Type:      model.WorkUnitType(input.Body.Type),
		SourceURL: input.Body.URL,
		ProjectID: model.MustGetUUIDFromString(input.ProjectID),
	}

	_, err = h.store.WorkUnit.UpdateSelectedFieldsByID(tx.DB(), input.WorkUnitID, *workUnit, "name", "type", "source_url", "project_id")
	if err != nil {
		l.Error(err, "failed to update work unit")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// Update work unit stack
	if err := h.updateWorkUnitStack(tx.DB(), input.WorkUnitID, view.ToModelUUIDs(input.Body.Stacks)); err != nil {
		l.Error(err, "failed to update work unit stack")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// Get all active members of work unit
	members, err := h.store.WorkUnitMember.All(tx.DB(), input.WorkUnitID)
	if err != nil {
		l.Error(err, "failed to get all work unit members in database")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	var curMemberIDs []model.UUID

	for _, v := range members {
		curMemberIDs = append(curMemberIDs, v.EmployeeID)
	}

	// Get map for employee in work unit member
	inputMemberIDs := map[model.UUID]string{}
	for _, member := range input.Body.Members {
		inputMemberIDs[model.UUID(member)] = member.String()
	}

	// Get delete member id list
	var deleteMemberIDs []string

	for _, v := range curMemberIDs {
		_, ok := inputMemberIDs[v]
		if !ok {
			deleteMemberIDs = append(deleteMemberIDs, v.String())
		} else {
			delete(inputMemberIDs, v)
		}
	}

	// Get create member id list
	var createMemberIDs []model.UUID

	for id := range inputMemberIDs {
		createMemberIDs = append(createMemberIDs, id)
	}

	// Delete work unit members
	if status, err = h.deleteWorkUnit(tx.DB(), input.WorkUnitID, deleteMemberIDs); err != nil {
		l.Error(err, "failed to remove work unit member in database")
		c.JSON(status, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// Create new work unit member
	if status, err := h.createWorkUnit(tx.DB(), input.ProjectID, input.WorkUnitID, createMemberIDs); err != nil {
		l.Error(err, "failed to create new work unit member")
		c.JSON(status, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

func (h *handler) checkExitsInUpdateWorkUnitInput(db *gorm.DB, input request.UpdateWorkUnitInput) (int, error) {
	// Check project existence
	exists, err := h.store.Project.IsExist(db, input.ProjectID)
	if err != nil {
		return http.StatusInternalServerError, errs.ErrFailToCheckInputExistence
	}

	if !exists {
		return http.StatusNotFound, errs.ErrProjectNotFound
	}

	// Check work unit existence
	exists, err = h.store.WorkUnit.IsExists(h.repo.DB(), input.WorkUnitID)
	if err != nil {
		return http.StatusInternalServerError, errs.ErrFailToCheckInputExistence
	}

	if !exists {
		return http.StatusNotFound, errs.ErrProjectNotFound
	}

	// Check stack existence
	_, stacks, err := h.store.Stack.All(h.repo.DB(), "", nil)
	if err != nil {
		return http.StatusInternalServerError, errs.ErrFailToCheckInputExistence
	}

	stackMap := model.ToStackMap(stacks)
	for _, sID := range input.Body.Stacks {
		_, ok := stackMap[model.UUID(sID)]
		if !ok {
			return http.StatusNotFound, errs.ErrStackNotFoundWithID(sID.String())
		}
	}

	return 0, nil
}

func (h *handler) updateWorkUnitStack(db *gorm.DB, workUnitID string, stackIDs []model.UUID) error {
	// Delete all exist work unit stack
	if err := h.store.WorkUnitStack.DeleteByWorkUnitID(db, workUnitID); err != nil {
		return errs.ErrFailToDeleteWorkUnitStack
	}

	// Create new work unit stack
	for _, stackID := range stackIDs {
		err := h.store.WorkUnitStack.Create(db, &model.WorkUnitStack{
			WorkUnitID: model.MustGetUUIDFromString(workUnitID),
			StackID:    stackID,
		})
		if err != nil {
			return errs.ErrFailedToCreateWorkUnitStack
		}
	}

	return nil
}

func (h *handler) deleteWorkUnit(db *gorm.DB, workUnitID string, deleteMemberIDList []string) (int, error) {
	now := time.Now()
	for _, deleteMemberID := range deleteMemberIDList {
		workUnitMember, err := h.store.WorkUnitMember.One(db,
			workUnitID,
			deleteMemberID,
			model.WorkUnitMemberStatusActive.String())

		if errors.Is(err, gorm.ErrRecordNotFound) {
			return http.StatusNotFound, errs.ErrInvalidInActiveMember
		}
		if err != nil {
			return http.StatusInternalServerError, errs.ErrFailedToGetWorkUnitMember
		}

		deleteMember := &model.WorkUnitMember{
			Status:  model.WorkUnitMemberStatusInactive.String(),
			EndDate: &now,
		}

		if _, err = h.store.WorkUnitMember.UpdateSelectedFieldsByID(db, workUnitMember.ID.String(), *deleteMember, "status", "end_date"); err != nil {
			return http.StatusInternalServerError, errs.ErrFailedToUpdateWorkUnitMember
		}

		if err = h.store.WorkUnitMember.SoftDeleteByWorkUnitID(db, workUnitMember.ID.String(), deleteMemberID); err != nil {
			return http.StatusInternalServerError, errs.ErrFailedToSoftDeleteWorkUnitMember
		}
	}

	return 0, nil
}

func (h *handler) createWorkUnit(db *gorm.DB, projectID string, workUnitID string, createMemberIDList []model.UUID) (int, error) {
	for _, createMemberID := range createMemberIDList {
		_, err := h.store.ProjectMember.GetActiveMemberInProject(db, projectID, createMemberID.String())
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return http.StatusBadRequest, errs.ErrMemberIsInactive
		}

		if err != nil {
			return http.StatusInternalServerError, errs.ErrFailedToGetProjectMember
		}

		now := time.Now()
		wuMember := model.WorkUnitMember{
			Status:     model.ProjectMemberStatusActive.String(),
			WorkUnitID: model.MustGetUUIDFromString(workUnitID),
			EmployeeID: createMemberID,
			ProjectID:  model.MustGetUUIDFromString(projectID),
			StartDate:  now,
		}

		if err := h.store.WorkUnitMember.Create(db, &wuMember); err != nil {
			return http.StatusInternalServerError, errs.ErrFailedToCreateWorkUnitMember
		}
	}

	return 0, nil
}

// ArchiveWorkUnit godoc
// @Summary Archive an active work unit of a project
// @Description Archive an active work unit of a project
// @id archiveProjectWorkUnit
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param workUnitID path string true  "Work Unit ID"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/work-units/{workUnitID}/archive [put]
func (h *handler) ArchiveWorkUnit(c *gin.Context) {
	// 0. Get current logged in user data
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	input := request.ArchiveWorkUnitInput{
		ProjectID:  c.Param("id"),
		WorkUnitID: c.Param("workUnitID"),
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "ArchiveWorkUnit",
		"input":   input,
	})

	if err := input.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	p, err := h.store.Project.One(h.repo.DB(), input.ProjectID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrProjectNotFound, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}

		l.Error(err, "failed to get project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectWorkUnitsEditFullAccess) {
		_, ok := userInfo.Projects[p.ID]
		if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}

		leadMap := map[string]bool{}
		for _, v := range p.Heads {
			if v.IsLead() {
				leadMap[v.EmployeeID.String()] = true
			}
		}

		_, ok = leadMap[userInfo.UserID]
		if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrMemberIsNotProjectLead, nil, ""))
			return
		}
	}

	workUnit, err := h.store.WorkUnit.One(h.repo.DB(), input.WorkUnitID)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(err, "work unit not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrWorkUnitNotFound, nil, ""))
		return
	}
	if err != nil {
		l.Error(err, "failed to get one work unit")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	workUnit.Status = model.WorkUnitStatusArchived

	// update work unit status -> 'archived'
	_, err = h.store.WorkUnit.UpdateSelectedFieldsByID(tx.DB(), input.WorkUnitID, *workUnit, "status")
	if err != nil {
		l.Error(err, "failed to update work unit")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	wuMembers, err := h.store.WorkUnitMember.GetByWorkUnitID(tx.DB(), input.WorkUnitID)
	if err != nil {
		l.Error(err, "failed to get work unit members")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	// update work unit member: end_date = now() and status = 'inactive'
	timeNow := time.Now()
	for _, member := range wuMembers {
		member.EndDate = &timeNow
		member.Status = model.ProjectMemberStatusInactive.String()

		_, err := h.store.WorkUnitMember.UpdateSelectedFieldsByID(tx.DB(), member.ID.String(), *member, "end_date", "status")
		if err != nil {
			l.Error(err, "failed to get work unit members")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

// UnarchiveWorkUnit godoc
// @Summary Unarchive an archive work unit of a project
// @Description Unarchive an archive work unit of a project
// @id unarchiveProjectWorkUnit
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param workUnitID path string true "Work Unit ID"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/work-units/{workUnitID}/unarchive [put]
func (h *handler) UnarchiveWorkUnit(c *gin.Context) {
	// 0. Get current logged in user data
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	input := request.ArchiveWorkUnitInput{
		ProjectID:  c.Param("id"),
		WorkUnitID: c.Param("workUnitID"),
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "UnarchiveWorkUnit",
		"input":   input,
	})

	if err := input.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	p, err := h.store.Project.One(h.repo.DB(), input.ProjectID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrProjectNotFound, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}

		l.Error(err, "failed to get project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectWorkUnitsEditFullAccess) {
		_, ok := userInfo.Projects[p.ID]
		if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}

		leadMap := map[string]bool{}
		for _, v := range p.Heads {
			if v.IsLead() {
				leadMap[v.EmployeeID.String()] = true
			}
		}

		_, ok = leadMap[userInfo.UserID]
		if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrMemberIsNotProjectLead, nil, ""))
			return
		}
	}

	workUnit, err := h.store.WorkUnit.One(h.repo.DB(), input.WorkUnitID)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(err, "work unit not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrWorkUnitNotFound, nil, ""))
		return
	}
	if err != nil {
		l.Error(err, "failed to get one work unit")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	workUnit.Status = model.WorkUnitStatusActive

	// update work unit status -> 'active'
	_, err = h.store.WorkUnit.UpdateSelectedFieldsByID(tx.DB(), input.WorkUnitID, *workUnit, "status")
	if err != nil {
		l.Error(err, "failed to update work unit")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	wuMembers, err := h.store.WorkUnitMember.GetByWorkUnitID(tx.DB(), input.WorkUnitID)
	if err != nil {
		l.Error(err, "failed to get work unit members")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	// check member status in project and update work unit member
	for _, member := range wuMembers {
		// _, err := h.store.ProjectMember.GetActiveMemberInProject(tx.DB(), input.ProjectID, member.EmployeeID.String(), false)

		// if errors.Is(err, gorm.ErrRecordNotFound) {
		// 	l.Error(err, "member is not active in project")
		// 	c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrMemberIsInactive), nil, ""))
		// 	return
		// }
		// if err != nil {
		// 	l.Error(err, "failed to get one project member")
		// 	c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		// 	return
		// }

		member.EndDate = nil
		member.Status = model.ProjectMemberStatusActive.String()

		_, err = h.store.WorkUnitMember.UpdateSelectedFieldsByID(tx.DB(), member.ID.String(), *member, "end_date", "status")
		if err != nil {
			l.Error(err, "failed to get work unit members")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok"))
}

// UpdateSendingSurveyState godoc
// @Summary Update allows sending survey for project by id
// @Description Update allows sending survey for project by id
// @id updateProjectSendingSurveyState
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Project ID"
// @Param allowsSendingSurvey query bool false "Allows sending survey"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/sending-survey-state [put]
func (h *handler) UpdateSendingSurveyState(c *gin.Context) {
	projectID := c.Param("id")
	if projectID == "" || !model.IsUUIDFromString(projectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	query := request.UpdateSendingSurveyInput{}
	if err := c.ShouldBindQuery(&query); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "UpdateSendingSurveyState",
		"query":   query,
	})

	p, err := h.store.Project.One(h.repo.DB(), projectID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, projectID, ""))
			return
		}

		l.Error(err, "failed to get project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, projectID, ""))
		return
	}

	p.AllowsSendingSurvey = query.AllowsSendingSurvey
	_, err = h.store.Project.UpdateSelectedFieldsByID(h.repo.DB(), projectID, *p, "allows_sending_survey")
	if err != nil {
		l.Error(err, "failed to update project")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// UploadAvatar godoc
// @Summary Upload avatar of project by id
// @Description Upload avatar of project by id
// @id uploadProjectAvatar
// @Tags Project
// @Accept  json
// @Produce  json
// @Param id path string true "Project ID"
// @Security BearerAuth
// @Param file formData file true "avatar upload"
// @Success 200 {object} ProjectContentDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /projects/{id}/upload-avatar [post]
func (h *handler) UploadAvatar(c *gin.Context) {
	// 1.1 parse id from uri, validate id
	var params struct {
		ID string `uri:"id" binding:"required"`
	}

	if err := c.ShouldBindUri(&params); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, params, ""))
		return
	}

	// 1.2 get upload file
	file, err := c.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, file, ""))
		return
	}

	// 1.3 prepare the logger
	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "UploadAvatar",
		"params":  params,
		// "body":    body,
	})

	fileName := file.Filename
	fileExtension := model.ContentExtension(filepath.Ext(fileName))
	fileSize := file.Size
	filePath := fmt.Sprintf("https://storage.googleapis.com/%s/projects/%s/images/%s", h.config.Google.GCSBucketName, params.ID, fileName)
	gcsPath := fmt.Sprintf("projects/%s/images/%s", params.ID, fileName)
	// 2.1 validate
	if !fileExtension.ImageValid() {
		l.Info("invalid file extension")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, ""))
		return
	}
	if fileExtension == model.ContentExtensionJpg || fileExtension == model.ContentExtensionPng {
		if fileSize > model.MaxFileSizeImage {
			l.Info("invalid file size")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileSize, nil, ""))
			return
		}
	}

	tx, done := h.repo.NewTransaction()

	// 2.2 check project existed
	existed, err := h.store.Project.IsExist(tx.DB(), params.ID)
	if err != nil {
		l.Error(err, "error query project from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}
	if !existed {
		l.Info("project not existed")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrProjectNotExisted), nil, ""))
		return
	}

	// 2.3 upload to GCS
	multipart, err := file.Open()
	if err != nil {
		l.Error(err, "error in open file")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	err = h.service.GoogleStorage.UploadContentGCS(multipart, gcsPath)
	if err != nil {
		l.Error(err, "error in upload file")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	// 3. update avatar field
	_, err = h.store.Project.UpdateSelectedFieldsByID(tx.DB(), params.ID, model.Project{
		Avatar: filePath,
	}, "avatar")
	if err != nil {
		l.Error(err, "error in update avatar")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToProjectContentData(filePath), nil, done(nil), nil, ""))
}

// SyncProjectMemberStatus godoc
// @Summary Sync project member status
// @Description Sync project member status
// @id syncProjectMemberStatus
// @Tags Project
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /cron-jobs/sync-project-member-status [post]
func (h *handler) SyncProjectMemberStatus(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "project",
		"method":  "SyncProjectMemberStatus",
	})

	err := h.store.ProjectMember.UpdateEndDateOverdueMemberToInActive(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to update end date overdue member status to inactive")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	err = h.store.ProjectMember.UpdateMemberInClosedProjectToInActive(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to update member in closed/paused project status to inactive")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	err = h.store.ProjectMember.UpdateLeftMemberToInActive(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to update left member project status to inactive")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

```

# pkg/handler/project/interface.go

```go
package project

import "github.com/gin-gonic/gin"

type IHandler interface {
	ArchiveWorkUnit(c *gin.Context)
	AssignMember(c *gin.Context)
	Create(c *gin.Context)
	CreateWorkUnit(c *gin.Context)
	DeleteMember(c *gin.Context)
	DeleteSlot(c *gin.Context)
	Details(c *gin.Context)
	GetMembers(c *gin.Context)
	GetWorkUnits(c *gin.Context)
	List(c *gin.Context)
	SyncProjectMemberStatus(c *gin.Context)
	UnarchiveWorkUnit(c *gin.Context)
	UnassignMember(c *gin.Context)
	UpdateContactInfo(c *gin.Context)
	UpdateGeneralInfo(c *gin.Context)
	UpdateMember(c *gin.Context)
	UpdateProjectStatus(c *gin.Context)
	UpdateSendingSurveyState(c *gin.Context)
	UpdateWorkUnit(c *gin.Context)
	UploadAvatar(c *gin.Context)
	IcyWeeklyDistribution(c *gin.Context)
}

```

# pkg/handler/payroll/types.go

```go
package payroll

import "github.com/dwarvesf/fortress-api/pkg/model"

type payrollResponse struct {
	DisplayName          string            `json:"display_name"`
	BaseSalary           int64             `json:"base_salary"`
	SalaryAdvanceAmount  float64           `json:"salary_advance_amount"`
	Bonus                float64           `json:"bonus"`
	TotalWithoutContract float64           `json:"total_without_contract"`
	TotalWithContract    model.VietnamDong `json:"total_with_contract"`
	Notes                []string          `json:"notes"`
	Date                 int               `json:"date"`
	Month                int               `json:"month"`
	Year                 int               `json:"year"`
	BankAccountNumber    string            `json:"bank_account_number"`
	TWRecipientID        string            `json:"tw_recipient_id"` // will be removed
	TWRecipientName      string            `json:"tw_recipient_name"`
	TWAccountNumber      string            `json:"tw_account_number"`
	Bank                 string            `json:"bank"`
	HasContract          bool              `json:"has_contract"`
	PayrollID            string            `json:"payroll_id"`
	IsCommit             bool              `json:"is_commit"`
	IsPaid               bool              `json:"is_paid"`
	TWGBP                float64           `json:"tw_gbp"` // will be removed
	TWAmount             float64           `json:"tw_amount"`
	TWFee                float64           `json:"tw_fee"`
	TWEmail              string            `json:"tw_email"`
	TWCurrency           string            `json:"tw_currency"`
	Currency             string            `json:"currency"`
}

type payrollBHXHResponse struct {
	DisplayName   string `json:"display_name"`
	BHXH          int64  `json:"bhxh"`
	Batch         int    `json:"batch"`
	AccountNumber string `json:"account_number"`
	Bank          string `json:"bank"`
}

```

# pkg/handler/payroll/payroll_calculator.go

```go
package payroll

import (
	"encoding/json"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/service/currency"
	commissionStore "github.com/dwarvesf/fortress-api/pkg/store/employeecommission"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
)

// calculatePayrolls return list of payrolls for all given users in batchDate
func (h *handler) calculatePayrolls(users []*model.Employee, batchDate time.Time) (res []*model.Payroll, err error) {
	batch := batchDate.Day()
	// HACK: sneak quang into this
	if batch == 1 {
		quang, err := h.store.Employee.OneByEmail(h.repo.DB(), "quang@d.foundation")
		if err != nil {
			h.logger.Error(err, "Can't insert quang into 1st payroll batch")
			return nil, err
		}
		users = append(users, quang)
	}
	dueDate := batchDate.AddDate(0, 1, 0)
	var expenses []bcModel.Todo
	woodlandID := consts.PlaygroundID
	expenseID := consts.PlaygroundExpenseTodoID
	opsID := consts.PlaygroundID
	opsExpenseID := consts.PlaygroundExpenseTodoID
	approver := consts.NamNguyenBasecampID

	if h.config.Env == "prod" {
		woodlandID = consts.WoodlandID
		expenseID = consts.ExpenseTodoID
		opsID = consts.OperationID
		opsExpenseID = consts.OpsExpenseTodoID
		approver = consts.HanBasecampID
	}

	opsTodoLists, err := h.service.Basecamp.Todo.GetAllInList(opsExpenseID, opsID)
	if err != nil {
		h.logger.Error(err, "can't get ops expense todo")
		return nil, err
	}

	for _, exps := range opsTodoLists {
		isApproved := false
		cmts, err := h.service.Basecamp.Comment.Gets(opsID, exps.ID)
		if err != nil {
			h.logger.Error(err, "can't get basecamp approved message")
			return nil, err
		}

		for _, cmt := range cmts {
			if cmt.Creator.ID == approver && strings.Contains(strings.ToLower(cmt.Content), "approve") {
				isApproved = true
				break
			}
		}

		if isApproved {
			expenses = append(expenses, exps)
		}
	}

	// get team expenses
	todolists, err := h.service.Basecamp.Todo.GetGroups(expenseID, woodlandID)
	if err != nil {
		h.logger.Error(err, "can't get groups expense")
		return nil, err
	}

	for i := range todolists {
		e, err := h.service.Basecamp.Todo.GetAllInList(todolists[i].ID, woodlandID)
		if err != nil {
			h.logger.Error(err, "can't get expense todo")
			return nil, err
		}
		for j := range e {
			isApproved := false
			cmts, err := h.service.Basecamp.Comment.Gets(woodlandID, e[j].ID)
			if err != nil {
				h.logger.Error(err, "can't get basecamp approved message")
				return nil, err
			}
			for k := range cmts {
				if cmts[k].Creator.ID == approver && strings.Contains(strings.ToLower(cmts[k].Content), "approve") {
					isApproved = true
					break
				}
			}
			if isApproved {
				expenses = append(expenses, e[j])
			}
		}
	}

	accountingExpenses, err := h.getAccountingExpense(batch)
	if err != nil {
		h.logger.Error(err, "can't get accounting todo")
		return nil, err
	}

	expenses = append(expenses, accountingExpenses...)

	for i, u := range users {
		if users[i].BaseSalary.Currency == nil {
			continue
		}
		var total model.VietnamDong
		var baseSalary, contract int64
		if users[i].BaseSalary.Batch != batchDate.Day() {
			if users[i].TeamEmail != "quang@d.foundation" {
				continue
			} else {
				users[i].BaseSalary.PersonalAccountAmount = 0
				users[i].BaseSalary.CompanyAccountAmount = 0
				users[i].BaseSalary.ContractAmount = 0
			}
		}

		// TODO...
		// try to calculate if user start/end after/before the payroll
		// fallback to default
		baseSalary, contract, _ = tryPartialCalculation(batchDate, dueDate, *u.JoinedDate, u.LeftDate, users[i].BaseSalary.PersonalAccountAmount, users[i].BaseSalary.CompanyAccountAmount)

		var bonus, commission, reimbursementAmount model.VietnamDong
		var bonusExplains, commissionExplains []model.CommissionExplain

		bonus, commission, reimbursementAmount, bonusExplains, commissionExplains = h.getBonus(*users[i], batchDate, expenses)

		commBytes, err := json.Marshal(&commissionExplains)
		if err != nil {
			return nil, err
		}

		bonusBytes, err := json.Marshal(&bonusExplains)
		if err != nil {
			return nil, err
		}

		if users[i].BaseSalary.Currency.Name != currency.VNDCurrency {
			c, _, err := h.service.Wise.Convert(float64(commission), currency.VNDCurrency, users[i].BaseSalary.Currency.Name)
			if err != nil {
				return nil, err
			}
			b, _, err := h.service.Wise.Convert(float64(bonus), currency.VNDCurrency, users[i].BaseSalary.Currency.Name)
			if err != nil {
				return nil, err
			}
			temp, _, err := h.service.Wise.Convert(float64(baseSalary+contract)+b+c, users[i].BaseSalary.Currency.Name, currency.VNDCurrency)
			if err != nil {
				return nil, err
			}
			total = model.NewVietnamDong(int64(temp))
		} else {
			temp := model.NewVietnamDong(baseSalary)
			baseSalary = int64(temp.Format())
			total = model.NewVietnamDong(baseSalary+contract) + bonus + commission
		}
		if total == 0 {
			continue
		}

		// get advance salary
		advanceAmountUSD := 0.0
		advanceSalaries, err := h.store.SalaryAdvance.ListNotPayBackByEmployeeID(h.repo.DB(), u.ID.String())
		if err != nil {
			return nil, err
		}

		for _, as := range advanceSalaries {
			advanceAmountUSD += as.AmountUSD
		}
		advanceAmountVND, _, err := h.service.Wise.Convert(advanceAmountUSD, currency.USDCurrency, currency.VNDCurrency)
		if err != nil {
			return nil, err
		}
		// calculate total minus advance salary

		total = model.NewVietnamDong(int64(float64(total) - advanceAmountVND))

		p := model.Payroll{
			EmployeeID:          users[i].ID,
			Total:               total.Format(),
			BaseSalaryAmount:    baseSalary,
			ConversionAmount:    total.Format() - reimbursementAmount,
			SalaryAdvanceAmount: advanceAmountVND,
			DueDate:             &dueDate,
			Month:               int64(batchDate.Month()),
			Year:                int64(batchDate.Year()),
			CommissionExplain:   commBytes,
			CommissionAmount:    commission,
			ProjectBonusAmount:  bonus,
			ProjectBonusExplain: bonusBytes,
			Employee:            *users[i],
			ContractAmount:      contract,
		}

		res = append(res, &p)
	}

	return res, nil
}

func (h *handler) getBonus(u model.Employee, batchDate time.Time, expenses []bcModel.Todo) (bonus, commission, reimbursementAmount model.VietnamDong, bonusExplain, commissionExplain []model.CommissionExplain) {
	h.logger.Info("get bonus")
	var explanation string
	bonusRecords, err := h.store.Bonus.GetByUserID(h.repo.DB(), u.ID)
	if err != nil {
		return
	}

	if explanation != "" {
		bonusExplain = append(bonusExplain,
			model.CommissionExplain{
				Amount: 0,
				Month:  int(batchDate.Month()),
				Year:   batchDate.Year(),
				Name:   explanation,
			})
	}
	for i := range bonusRecords {
		bonus += bonusRecords[i].Amount
		bonusExplain = append(bonusExplain,
			model.CommissionExplain{
				Amount: bonusRecords[i].Amount,
				Month:  int(batchDate.Month()),
				Year:   batchDate.Year(),
				Name:   bonusRecords[i].Name,
			})
	}
	for i := range expenses {
		hasReimbursement := false
		for j := range expenses[i].Assignees {
			if expenses[i].Assignees[j].ID == u.BasecampID {
				hasReimbursement = true
				break
			}
		}
		if hasReimbursement {
			name, amount, err := h.getReimbursement(expenses[i].Title)
			if err != nil {
				return
			}
			if amount == 0 {
				continue
			}

			bonus += amount
			reimbursementAmount += amount
			bonusExplain = append(bonusExplain,
				model.CommissionExplain{
					Amount:           amount,
					Month:            int(batchDate.Month()),
					Year:             batchDate.Year(),
					Name:             name,
					BasecampTodoID:   expenses[i].ID,
					BasecampBucketID: expenses[i].Bucket.ID,
				})
		}
	}

	commissionQuery := commissionStore.Query{
		EmployeeID: u.ID.String(),
		IsPaid:     false,
	}
	userCommissions, err := h.store.EmployeeCommission.Get(h.repo.DB(), commissionQuery)
	if err != nil {
		return
	}

	for i := range userCommissions {
		commissionYear, commissionMonth, _ := userCommissions[i].CreatedAt.Date()
		commission += userCommissions[i].Amount
		if userCommissions[i].Invoice == nil {
			continue
		}
		name := userCommissions[i].Invoice.Number
		if userCommissions[i].Note != "" {
			name = fmt.Sprintf("%v - %v", name, userCommissions[i].Note)
		}
		commissionExplain = append(commissionExplain,
			model.CommissionExplain{
				ID:     userCommissions[i].ID,
				Amount: userCommissions[i].Amount,
				Month:  int(commissionMonth),
				Year:   commissionYear,
				Name:   name,
			})
	}
	return
}

func tryPartialCalculation(
	batchDate, dueDate, startDate time.Time,
	leftDate *time.Time,
	baseSalary, contract int64,
) (resBase, resContract int64, explanation string) {
	partialStart := batchDate
	partialEnd := dueDate
	isPartial := false
	if checkUserFirstBatch(startDate, batchDate) {
		partialStart = startDate
		isPartial = true
	}
	if leftDate != nil && leftDate.Before(dueDate) {
		partialEnd = *leftDate
		isPartial = true
	}
	if isPartial {
		var temp int64
		temp, explanation, _ = calculatePartialPayroll(partialStart, partialEnd, dueDate, batchDate, baseSalary+contract)
		baseSalary = temp - contract
		if baseSalary < 0 {
			contract += baseSalary
			baseSalary = 0
		}
	}

	return baseSalary, contract, explanation
}

func checkUserFirstBatch(startDate, batchDate time.Time) bool {
	if (startDate.Month() == batchDate.Month() && startDate.Year() == batchDate.Year()) ||
		(startDate.Month() == 12 && batchDate.Month() == 1 && startDate.Year() == batchDate.Year()-1) {
		return true
	}
	return false
}

func calculatePartialPayroll(startDate time.Time, endDate time.Time, dueDate time.Time, lastDueDate time.Time, totalSalary int64) (int64, string, error) {
	dayWorkOfMonth := int64(dueDate.Sub(lastDueDate).Hours() / 24)

	weekendsOfMonth := int64(timeutil.CountWeekendDays(lastDueDate, dueDate))

	// minus the weekends
	dayWorkOfMonth -= weekendsOfMonth

	// get day work in fist batch
	dayWorkOfFirstBatch := int64(endDate.Sub(startDate).Hours() / 24)

	// sum up with end date if left
	if !timeutil.IsSameDay(endDate, dueDate) {
		dayWorkOfFirstBatch++
	}

	// minus the weekends
	weekendsOfFirstBatch := int64(timeutil.CountWeekendDays(startDate, endDate))
	dayWorkOfFirstBatch -= weekendsOfFirstBatch

	if dayWorkOfFirstBatch == dayWorkOfMonth {
		return totalSalary, "", nil
	}

	// calculate salary per date
	// get the actual salary of first batch
	total := dayWorkOfFirstBatch * totalSalary / dayWorkOfMonth
	return total, fmt.Sprintf("Work from %s to %s", startDate.Format("2 Jan"), endDate.Format("2 Jan")), nil
}

func (h *handler) getReimbursement(expense string) (string, model.VietnamDong, error) {
	var amount model.VietnamDong
	splits := strings.Split(expense, "|")
	if len(splits) < 3 {
		return "", 0, nil
	}
	c := strings.TrimSpace(splits[2])
	bcAmount := h.service.Basecamp.ExtractBasecampExpenseAmount(strings.TrimSpace(splits[1]))
	if c != currency.VNDCurrency {
		tempAmount, _, err := h.service.Wise.Convert(float64(bcAmount), c, currency.VNDCurrency)
		if err != nil {
			return "", 0, err
		}
		amount = model.NewVietnamDong(int64(tempAmount))
	} else {
		amount = model.NewVietnamDong(int64(h.service.Basecamp.ExtractBasecampExpenseAmount(strings.TrimSpace(splits[1]))))
	}

	return strings.TrimSpace(splits[0]), amount.Format(), nil
}

func (h *handler) getAccountingExpense(batch int) (res []bcModel.Todo, err error) {
	accountingID := consts.AccountingID
	accountingTodoID := consts.AccountingTodoID

	if h.config.Env != "prod" {
		accountingID = consts.PlaygroundID
		accountingTodoID = consts.PlaygroundTodoID
	}

	// get accounting todo list
	lists, err := h.service.Basecamp.Todo.GetLists(accountingID, accountingTodoID)
	if err != nil {
		h.logger.Error(err, "can't get list of todo")
		return nil, err
	}

	var wg sync.WaitGroup
	var mu sync.Mutex
	// get all group in each list
	for i := range lists {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			groups, err := h.service.Basecamp.Todo.GetGroups(lists[i].ID, accountingID)
			if err != nil {
				h.logger.Error(err, "can't get groups in todo list")
				return
			}

			// filter out group only
			for j := range groups {
				if strings.ToLower(groups[j].Title) == "out" {
					// get all todo in out grou
					todos, err := h.service.Basecamp.Todo.GetAllInList(groups[j].ID, accountingID)
					if err != nil {
						h.logger.Error(err, "can't get todo in out group")
						return
					}

					// find expense in list of todos
					for k := range todos {
						if len(todos[k].Assignees) == 1 && todos[k].Assignees[0].ID != consts.HanBasecampID {
							mu.Lock()
							res = append(res, todos[k])
							mu.Unlock()
						}
					}
				}
			}
		}(i)
	}
	wg.Wait()

	return res, nil
}

```

# pkg/handler/payroll/new.go

```go
// Package payroll please edit this file only with approval from hnh
package payroll

import (
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/worker"
)

type IHandler interface {
	GetPayrollsByMonth(c *gin.Context)
	GetPayrollsBHXH(c *gin.Context)
	CommitPayroll(c *gin.Context)
	MarkPayrollAsPaid(c *gin.Context)
}

type handler struct {
	controller *controller.Controller
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	worker     *worker.Worker
	repo       store.DBRepo
	config     *config.Config
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, worker *worker.Worker, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		controller: controller,
		store:      store,
		repo:       repo,
		service:    service,
		worker:     worker,
		logger:     logger,
		config:     cfg,
	}
}

```

# pkg/handler/payroll/mark_paid.go

```go
package payroll

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/store/payroll"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

func (h *handler) MarkPayrollAsPaid(c *gin.Context) {
	var ids []string
	if err := c.Bind(&ids); err != nil {
		return
	}

	err := h.markPayrollAsPaid(ids)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
	}
	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "marking the payroll as paid was successful"))
}

// markPayrollAsPaid from selected payroll row in database
// update the is_paid and is_sent_mail in payroll table
// send email into the users that marked as paid
func (h *handler) markPayrollAsPaid(ids []string) error {
	for _, id := range ids {
		q := payroll.GetListPayrollInput{
			ID: id,
		}
		ps, err := h.store.Payroll.GetList(h.repo.DB(), q)
		if err != nil {
			return err
		}
		if len(ps) == 0 {
			continue
		}

		if err := h.service.GoogleMail.SendPayrollPaidMail(&ps[0]); err != nil {
			return err
		}

		fields := map[string]interface{}{
			"is_paid": true,
		}
		if err := h.store.Payroll.UpdateSpecificFields(h.repo.DB(), id, fields); err != nil {
			return err
		}
	}
	return nil
}

```

# pkg/handler/payroll/details.go

```go
package payroll

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/handler/payroll/errs"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/currency"
	"github.com/dwarvesf/fortress-api/pkg/store/employee"
	"github.com/dwarvesf/fortress-api/pkg/store/employeecommission"
	"github.com/dwarvesf/fortress-api/pkg/store/payroll"
	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

func (h *handler) GetPayrollsByMonth(c *gin.Context) {
	q := c.Request.URL.Query()

	email := q.Get("email")

	if q.Get("next") == "true" {
		res, err := h.getPayrollDetailHandler(0, 0, 0, email)
		if err != nil {
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		c.JSON(http.StatusOK, view.CreateResponse(res, nil, nil, nil, ""))
		return
	}

	batch, err := strconv.ParseInt(q.Get("date"), 0, 64)
	if err != nil {
		batch = 0
	}

	year, err := strconv.ParseInt(q.Get("year"), 0, 64)
	if err != nil || year <= 0 {
		year = int64(time.Now().Year())
	}

	if q.Get("month") == "" {
		if year != int64(time.Now().Year()) {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidYear, nil, ""))
			return
		}
		year = int64(time.Now().Year())
	}
	month, err := strconv.ParseInt(q.Get("month"), 0, 64)
	if err != nil {
		month = int64(time.Now().Month())
	}

	res, err := h.getPayrollDetailHandler(int(month), int(year), int(batch), email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(res, nil, nil, nil, ""))
}

func (h *handler) getPayrollDetailHandler(month, year, batch int, email string) (interface{}, error) {
	tx, done := h.repo.NewTransaction()
	if month == 0 && year == 0 && batch == 0 {
		date, err := h.store.Payroll.GetLatestCommitTime(tx.DB())
		if err != nil {
			h.logger.Error(err, "can't get payroll latest commit time")
			date = time.Now()
		}
		month = int(date.Month())
		year = date.Year()
		batch = int(model.FirstBatch)
		if date.Day() == int(model.FirstBatch) {
			batch = int(model.SecondBatch)
			month, year = timeutil.LastMonthYear(month, year)
		}
	} else {
		month, year = timeutil.LastMonthYear(month, year)
	}

	var res []payrollResponse
	var subTotal int64
	var bonusTotal model.VietnamDong

	isPaid := true

	for _, b := range []model.Batch{model.FirstBatch, model.SecondBatch} {
		if batch != 0 && batch != int(b) {
			continue
		}
		q := payroll.GetListPayrollInput{
			Month: month,
			Year:  year,
			Day:   int(b),
		}
		if email != "" {
			u, err := h.store.Employee.OneByEmail(tx.DB(), email)
			if err != nil {
				h.logger.Error(err, "can't get employee by email")
				return nil, err
			}
			q.UserID = u.ID.String()
		}

		batchDate := time.Date(year, time.Month(month), int(b), 0, 0, 0, 0, time.UTC)
		payrolls, err := h.store.Payroll.GetList(tx.DB(), q)
		if err != nil {
			h.logger.Error(err, "can't get payroll list")
			return nil, done(err)
		}

		if len(payrolls) == 0 {
			isPaid = false

			// TODO : get all user payroll
			isLeft := false
			us, _, err := h.store.Employee.All(tx.DB(), employee.EmployeeFilter{IsLeft: &isLeft, BatchDate: &batchDate, Preload: true}, model.Pagination{Page: 0, Size: 500})
			if err != nil {
				h.logger.Error(err, "can't get list active employee")
				return nil, err
			}

			var tempPayrolls []model.Payroll
			newPayrolls, err := h.calculatePayrolls(us, batchDate)
			if err != nil {
				h.logger.Error(err, "can't calculate payroll")
				return nil, err
			}

			for i := range newPayrolls {
				tempPayrolls = append(tempPayrolls, *newPayrolls[i])
			}
			payrolls = tempPayrolls
		}

		standardizedPayrolls := make([]model.Payroll, 0)
		for i := range payrolls {
			var notes []string

			// get tw quotes (default -> GBP)
			c := payrolls[i].Employee.WiseCurrency
			if c == "" {
				c = "GBP"
			}

			// !isForecast
			if batchDate.Month() <= time.Now().Month() || (batchDate.Month() == 12 && time.Now().Month() == 1) {
				toDate := batchDate.AddDate(0, 1, 0)
				commissionQuery := employeecommission.Query{
					EmployeeID: payrolls[i].Employee.ID.String(),
					IsPaid:     isPaid,
					FromDate:   &batchDate,
					ToDate:     &toDate,
				}
				userCommissions, err := h.store.EmployeeCommission.Get(h.repo.DB(), commissionQuery)
				if err != nil {
					return nil, err
				}
				duplicate := map[string]int{}
				for j := range userCommissions {
					if userCommissions[j].Amount != 0 {
						name := userCommissions[j].Invoice.Number
						if userCommissions[j].Note != "" {
							name = fmt.Sprintf("%v - %v", name, userCommissions[j].Note)
						}
						duplicate[name] += int(userCommissions[j].Amount)
					}
				}
				for j := range duplicate {
					notes = append(notes, fmt.Sprintf("%v (%v)", j, utils.FormatCurrencyAmount(duplicate[j])))
				}

				var bonusExplain []model.CommissionExplain
				if len(payrolls[i].ProjectBonusExplain) > 0 {
					if err := json.Unmarshal(payrolls[i].ProjectBonusExplain, &bonusExplain); err != nil {
						return nil, errs.ErrCannotReadProjectBonusExplain
					}
				}
				for j := range bonusExplain {
					notes = append(notes, fmt.Sprintf("%v (%v)", bonusExplain[j].Name, utils.FormatCurrencyAmount(int(bonusExplain[j].Amount))))
				}
			}

			standardizedPayroll, bonus, sub, err := h.preparePayroll(c, payrolls[i], false)
			if err != nil {
				return nil, err
			}
			subTotal += sub

			for j := range standardizedPayroll.CommissionExplains {
				isContained := false
				for n := range notes {
					if strings.Contains(notes[n], standardizedPayroll.CommissionExplains[j].Name) {
						isContained = true
					}
				}
				if isContained {
					continue
				}
				notes = append(notes, fmt.Sprintf("%v (%v)", standardizedPayroll.CommissionExplains[j].Name, utils.FormatCurrencyAmount(int(standardizedPayroll.CommissionExplains[j].Amount))))
			}
			for j := range standardizedPayroll.ProjectBonusExplains {
				isContained := false
				for n := range notes {
					if strings.Contains(notes[n], standardizedPayroll.ProjectBonusExplains[j].Name) {
						isContained = true
					}
				}
				if isContained {
					continue
				}
				notes = append(notes, fmt.Sprintf("%v (%v)", standardizedPayroll.ProjectBonusExplains[j].Name, utils.FormatCurrencyAmount(int(standardizedPayroll.ProjectBonusExplains[j].Amount))))
			}

			r := payrollResponse{
				DisplayName:          standardizedPayroll.Employee.FullName,
				BaseSalary:           standardizedPayroll.BaseSalaryAmount,
				SalaryAdvanceAmount:  standardizedPayroll.SalaryAdvanceAmount,
				Bonus:                bonus,
				TotalWithContract:    standardizedPayroll.Total,
				TotalWithoutContract: standardizedPayroll.TotalAllowance,
				Notes:                notes,
				Date:                 standardizedPayroll.Employee.BaseSalary.Batch,
				Month:                month,
				Year:                 year,
				BankAccountNumber:    standardizedPayroll.Employee.LocalBankNumber,
				Bank:                 standardizedPayroll.Employee.LocalBranchName,
				HasContract:          standardizedPayroll.ContractAmount != 0,
				PayrollID:            "",
				TWRecipientID:        standardizedPayroll.Employee.WiseRecipientID,
				TWRecipientName:      standardizedPayroll.Employee.WiseRecipientName,
				TWAccountNumber:      standardizedPayroll.Employee.WiseAccountNumber,
				TWEmail:              standardizedPayroll.Employee.WiseRecipientEmail,
				TWGBP:                standardizedPayroll.TWAmount,
				TWAmount:             standardizedPayroll.TWAmount,
				TWFee:                standardizedPayroll.TWFee,
				TWCurrency:           c,
				IsCommit:             !standardizedPayroll.ID.IsZero(),
				IsPaid:               standardizedPayroll.IsPaid,
				Currency:             standardizedPayroll.Employee.BaseSalary.Currency.Name,
			}
			if r.IsCommit {
				r.PayrollID = standardizedPayroll.ID.String()
			}
			res = append(res, r)
			standardizedPayrolls = append(standardizedPayrolls, *standardizedPayroll)
		}

		if email == "" {
			err = h.cachePayroll(month, year, batch, standardizedPayrolls)
			if err != nil {
				return nil, err
			}
		}
	}

	// return res, done(nil)
	sub := model.NewVietnamDong(subTotal)
	return map[string]interface{}{
		"sub_total":   sub.Format(),
		"bonus_total": bonusTotal,
		"payrolls":    res,
	}, nil
}

func (h *handler) preparePayroll(c string, p model.Payroll, markPaid bool) (*model.Payroll, float64, int64, error) {
	var bonus float64
	var subTotal int64

	if p.Employee.BaseSalary.Currency.Name != currency.VNDCurrency {
		c, _, err := h.service.Wise.Convert(float64(p.CommissionAmount), currency.VNDCurrency, p.Employee.BaseSalary.Currency.Name)
		if err != nil {
			return nil, 0, 0, err
		}

		b, _, err := h.service.Wise.Convert(float64(p.ProjectBonusAmount), currency.VNDCurrency, p.Employee.BaseSalary.Currency.Name)
		if err != nil {
			return nil, 0, 0, err
		}

		bonus = b + c

		p.TotalAllowance = float64(p.BaseSalaryAmount) + bonus - p.SalaryAdvanceAmount

		base, _, err := h.service.Wise.Convert(float64(p.BaseSalaryAmount), p.Employee.BaseSalary.Currency.Name, currency.VNDCurrency)
		if err != nil {
			return nil, 0, 0, err
		}
		subTotal += int64(base)
	} else {
		bonus = float64(p.CommissionAmount + p.ProjectBonusAmount)
		p.TotalAllowance = float64(p.BaseSalaryAmount) + bonus - p.SalaryAdvanceAmount
		subTotal += p.BaseSalaryAmount
	}

	projectBonusExplains, err := getProjectBonusExplains(&p)
	if err != nil {
		return nil, 0, 0, err
	}
	p.ProjectBonusExplains = projectBonusExplains

	commissionExplains, err := h.getCommissionExplains(&p, markPaid)
	if err != nil {
		return nil, 0, 0, err
	}
	p.CommissionExplains = commissionExplains

	for i, v := range p.ProjectBonusExplains {
		formattedAmount, err := h.getFormattedAmount(&p, v.Amount)
		if err != nil {
			return nil, 0, 0, err
		}
		p.ProjectBonusExplains[i].FormattedAmount = formattedAmount
	}
	for i, v := range p.CommissionExplains {
		formattedAmount, err := h.getFormattedAmount(&p, v.Amount)
		if err != nil {
			return nil, 0, 0, err
		}
		p.CommissionExplains[i].FormattedAmount = formattedAmount
	}

	quote, err := h.service.Wise.GetPayrollQuotes(c, p.Employee.BaseSalary.Currency.Name, p.TotalAllowance)
	if err != nil {
		h.logger.Error(err, "cannot use wise to get quote")
		return nil, 0, 0, err
	}
	p.TWAmount = quote.SourceAmount
	p.TWRate = quote.Rate
	p.TWFee = quote.Fee

	return &p, bonus, subTotal, nil
}

func (h *handler) getFormattedAmount(p *model.Payroll, amount model.VietnamDong) (string, error) {
	if p.Employee.BaseSalary.Currency.Name != currency.VNDCurrency {
		temp, _, err := h.service.Wise.Convert(float64(amount), currency.VNDCurrency, p.Employee.BaseSalary.Currency.Name)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("%.02f", temp), nil
	}
	return amount.String(), nil
}

func getProjectBonusExplains(p *model.Payroll) ([]model.ProjectBonusExplain, error) {
	projectBonusExplains := make([]model.ProjectBonusExplain, 0)
	err := json.Unmarshal(
		p.ProjectBonusExplain,
		&projectBonusExplains,
	)
	if err != nil {
		return nil, err
	}

	tempBonus := map[string]*model.ProjectBonusExplain{}
	for i := range projectBonusExplains {
		if tempBonus[projectBonusExplains[i].Name] == nil {
			tempBonus[projectBonusExplains[i].Name] = &projectBonusExplains[i]
		} else {
			tempBonus[projectBonusExplains[i].Name].Amount += projectBonusExplains[i].Amount
		}
	}
	var tempBonusExplains []model.ProjectBonusExplain
	for i := range tempBonus {
		tempBonusExplains = append(tempBonusExplains, *tempBonus[i])
	}

	return tempBonusExplains, nil
}

func (h *handler) getCommissionExplains(p *model.Payroll, markPaid bool) ([]model.CommissionExplain, error) {
	commissionExplains := make([]model.CommissionExplain, 0)
	err := json.Unmarshal(
		p.CommissionExplain,
		&commissionExplains,
	)
	if err != nil {
		return nil, err
	}
	if markPaid {
		for i := range commissionExplains {
			err := h.store.EmployeeCommission.MarkPaid(h.repo.DB(), commissionExplains[i].ID)
			if err != nil {
				return nil, err
			}
		}
	}

	tempCommission := map[string]*model.CommissionExplain{}
	for i := range commissionExplains {
		if commissionExplains[i].Amount == 0 {
			continue
		}
		if tempCommission[commissionExplains[i].Name] == nil {
			tempCommission[commissionExplains[i].Name] = &commissionExplains[i]
		} else {
			tempCommission[commissionExplains[i].Name].Amount += commissionExplains[i].Amount
		}
	}
	var tempCommissionExplains []model.CommissionExplain
	for i := range tempCommission {
		tempCommissionExplains = append(tempCommissionExplains, *tempCommission[i])
	}
	return tempCommissionExplains, nil
}

func (h *handler) cachePayroll(month, year, batch int, payrolls []model.Payroll) error {
	payrollsBytes, err := json.Marshal(&payrolls)
	if err != nil {
		return err
	}

	cPayroll, err := h.store.CachedPayroll.Get(h.repo.DB(), month, year, batch)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		return err
	}

	cPayroll.Month = month
	cPayroll.Year = year
	cPayroll.Batch = batch
	cPayroll.Payrolls = payrollsBytes

	return h.store.CachedPayroll.Set(h.repo.DB(), cPayroll)
}

```

# pkg/handler/payroll/commit.go

```go
package payroll

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/handler/payroll/errs"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/service/currency"
	"github.com/dwarvesf/fortress-api/pkg/store/payroll"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

func (h *handler) CommitPayroll(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "payroll",
		"method":  "CommitPayroll",
	})

	l.Info("Start commit payroll")

	year, err := strconv.ParseInt(c.Query("year"), 0, 64)
	if err != nil || year <= 0 {
		year = int64(time.Now().Year())
	}

	if c.Query("month") == "" {
		if year != int64(time.Now().Year()) {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrBadRequest, nil, ""))
			return
		}
		year = int64(time.Now().Year())
	}
	month, err := strconv.ParseInt(c.Query("month"), 0, 64)
	if err != nil {
		l.Errorf(err, "failed to parse month", "month", month)
		month = int64(time.Now().Month())
	}

	batch, err := strconv.ParseInt(c.Query("date"), 0, 64)
	if err != nil {
		l.Errorf(err, "failed to parse date", "date", batch)
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrBadRequest, nil, ""))
		return
	}

	email := c.Query("email")

	err = h.commitPayrollHandler(int(month), int(year), int(batch), email)
	if err != nil {
		l.Errorf(err, "failed to process commit payroll for batch date", "date", batch)
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	err = h.controller.Discord.Log(model.LogDiscordInput{
		Type: "payroll_commit",
		Data: map[string]interface{}{
			"batch_number": strconv.Itoa(int(batch)),
			"month":        time.Month(month).String(),
			"year":         year,
		},
	})
	if err != nil {
		l.Error(err, "failed to logs to discord")
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, ""))
}

func (h *handler) commitPayrollHandler(month, year, batch int, email string) error {
	month, year = timeutil.LastMonthYear(month, year)
	if month > int(time.Now().Month()) {
		if month != 12 && time.Now().Month() != 1 {
			return errors.New("cannot commit payroll too far away")
		}
	}
	for _, b := range []model.Batch{model.FirstBatch, model.SecondBatch} {
		if batch != int(b) {
			continue
		}
		q := payroll.GetListPayrollInput{
			Month: month,
			Year:  year,
			Day:   int(b),
		}
		if email != "" {
			u, err := h.store.Employee.OneByEmail(h.repo.DB(), email)
			if err != nil {
				return err
			}
			q.UserID = u.ID.String()
		}

		batchDate := time.Date(year, time.Month(month), int(b), 0, 0, 0, 0, time.UTC)
		var payrolls []model.Payroll
		cPayroll, err := h.store.CachedPayroll.Get(h.repo.DB(), month, year, batch)
		if err != nil {
			if !errors.Is(err, gorm.ErrRecordNotFound) {
				return errs.ErrPayrollNotSnapshotted
			}
			return err
		}
		err = json.Unmarshal(cPayroll.Payrolls, &payrolls)
		if err != nil {
			return err
		}

		// this is for testing
		// filteredPayrolls := []model.Payroll{}
		// for _, p := range payrolls {
		// 	if p.Employee.TeamEmail == "huy@d.foundation" {
		// 		filteredPayrolls = append(filteredPayrolls, p)
		// 	}
		// }
		// payrolls = filteredPayrolls

		for i := range payrolls {
			payrolls[i].IsPaid = true
			err = h.markBonusAsDone(&payrolls[i])
			if err != nil {
				return err
			}

			// hacky way to mark done commission
			if _, err := h.getCommissionExplains(&payrolls[i], true); err != nil {
				return err
			}

			// update is_pay_back to true if the employee has payback
			if payrolls[i].SalaryAdvanceAmount != 0 {
				salaryAdvances, err := h.store.SalaryAdvance.ListNotPayBackByEmployeeID(h.repo.DB(), payrolls[i].Employee.ID.String())
				if err != nil {
					return err
				}
				for _, salaryAdvance := range salaryAdvances {
					now := time.Now()
					salaryAdvance.IsPaidBack = true
					salaryAdvance.PaidAt = &now

					err = h.store.SalaryAdvance.Save(h.repo.DB(), &salaryAdvance)
					if err != nil {
						return err
					}
				}
			}
		}

		// Batch insert payrolls
		err = h.store.Payroll.InsertList(h.repo.DB(), payrolls)
		if err != nil {
			return err
		}

		// Using WaitGroup go routines to SendPayrollPaidEmail
		var wg sync.WaitGroup
		wg.Add(len(payrolls))
		c := make(chan *model.Payroll, len(payrolls)+1)
		for _, pr := range payrolls {
			go func(p model.Payroll) {
				defer wg.Done()
				if h.config.Env == "prod" || p.Employee.TeamEmail == "quang@d.foundation" || p.Employee.TeamEmail == "huy@d.foundation" {
					c <- &p
				}
			}(pr)
		}
		wg.Wait()

		c <- nil
		go h.activateGmailQueue(c)

		err = h.storePayrollTransaction(payrolls, batchDate)
		if err != nil {
			return err
		}
	}

	return nil
}

func (h *handler) storePayrollTransaction(p []model.Payroll, batchDate time.Time) error {
	var transactions []*model.AccountingTransaction
	for i := range p {
		m := model.AccountingMetadata{
			Source: "payroll",
			ID:     p[i].ID.String(),
		}
		bonusBytes, err := json.Marshal(&m)
		if err != nil {
			return err
		}
		var organization = "Dwarves Foundation"
		now := time.Now()

		// baseSalaryConversionAmount = total - bonus and reimbursement (commission + projectBonus) - contract, cannot use origin baseSalary becauuse it is not converted to VND
		baseSalaryConversionAmount := p[i].Total - model.NewVietnamDong(p[i].ContractAmount) - p[i].CommissionAmount - p[i].ProjectBonusAmount
		payrollTransaction := model.AccountingTransaction{
			Amount:           float64(p[i].BaseSalaryAmount),
			ConversionAmount: baseSalaryConversionAmount,
			Name:             fmt.Sprintf("Payroll TW - %v %v", p[i].Employee.FullName, batchDate.Format("02 January 2006")),
			Category:         p[i].Employee.BaseSalary.Category,
			Currency:         p[i].Employee.BaseSalary.Currency.Name,
			Date:             &now,
			CurrencyID:       &p[i].Employee.BaseSalary.Currency.ID,
			Organization:     organization,
			Metadata:         bonusBytes,
			ConversionRate:   float64(baseSalaryConversionAmount) / float64(p[i].BaseSalaryAmount),
			Type:             p[i].Employee.BaseSalary.Type,
		}
		transactions = append(transactions, &payrollTransaction)

		// separate BHXH and transferwise
		if p[i].ContractAmount != 0 {
			bhxhTransaction := model.AccountingTransaction{
				Amount:           float64(p[i].ContractAmount),
				ConversionAmount: model.NewVietnamDong(p[i].ContractAmount),
				Name:             fmt.Sprintf("Payroll BHXH - %v %v", p[i].Employee.FullName, batchDate.Format("02 January 2006")),
				Category:         p[i].Employee.BaseSalary.Category,
				Currency:         p[i].Employee.BaseSalary.Currency.Name,
				Date:             &now,
				CurrencyID:       &p[i].Employee.BaseSalary.Currency.ID,
				Organization:     organization,
				Metadata:         bonusBytes,
				ConversionRate:   1,
				Type:             p[i].Employee.BaseSalary.Type,
			}
			transactions = append(transactions, &bhxhTransaction)
		}

		// bonusConversionAmount = total bonus (commission + projectBonus) - reimbursement  (total - conversionAmount)
		bonusConversionAmount := p[i].CommissionAmount + p[i].ProjectBonusAmount - (p[i].Total - p[i].ConversionAmount)
		if bonusConversionAmount != 0 {
			cur, err := h.store.Currency.GetByName(h.repo.DB(), currency.VNDCurrency)
			if err != nil {
				return err
			}
			category := p[i].Employee.BaseSalary.Category
			t := model.AccountingSE
			if p[i].Employee.BaseSalary.Category == model.AccountingRec {
				category = model.AccountingCommHiring
				t = p[i].Employee.BaseSalary.Type
			}
			var commissionName string
			for j := range p[i].CommissionExplains {
				commissionName += p[i].CommissionExplains[j].Name + " "
			}
			if strings.Contains(commissionName, "Account") {
				category = model.AccountingCommAccount
			}
			if strings.Contains(commissionName, "Sales") {
				category = model.AccountingCommSales
			}
			if strings.Contains(commissionName, "Lead") {
				category = model.AccountingCommLead
			}
			bonusTransaction := model.AccountingTransaction{
				Amount:           float64(bonusConversionAmount),
				ConversionAmount: bonusConversionAmount,
				Name:             fmt.Sprintf("Bonus - %v %v", p[i].Employee.FullName, batchDate.Format("02 January 2006")),
				Category:         category,
				Currency:         cur.Name,
				Date:             &now,
				CurrencyID:       &cur.ID,
				Organization:     organization,
				Metadata:         bonusBytes,
				ConversionRate:   1,
				Type:             t,
			}
			transactions = append(transactions, &bonusTransaction)
		}
	}

	return h.storeMultipleTransaction(transactions)
}

func (h *handler) storeMultipleTransaction(transactions []*model.AccountingTransaction) error {
	if err := h.store.Accounting.CreateMultipleTransaction(h.repo.DB(), transactions); err != nil {
		return err
	}
	return nil
}

func (h *handler) markBonusAsDone(p *model.Payroll) error {
	var projectBonusExplains []model.ProjectBonusExplain
	err := json.Unmarshal(
		p.ProjectBonusExplain,
		&projectBonusExplains,
	)
	if err != nil {
		return err
	}

	for i := range projectBonusExplains {
		// handle the bonus from basecamp todo (expense reimbursement and accounting)
		if projectBonusExplains[i].BasecampBucketID != 0 && projectBonusExplains[i].BasecampTodoID != 0 {
			woodlandID := consts.PlaygroundID
			accountingID := consts.PlaygroundID
			if h.config.Env == "prod" {
				woodlandID = consts.WoodlandID
				accountingID = consts.AccountingID
			}

			// expense reimbursement -> from woodland -> mark done
			// accounting -> comment confirm message
			switch projectBonusExplains[i].BasecampBucketID {
			case woodlandID:
				err := h.service.Basecamp.Todo.Complete(projectBonusExplains[i].BasecampBucketID,
					projectBonusExplains[i].BasecampTodoID)
				if err != nil {
					return err
				}

			case accountingID:
				mention, err := h.service.Basecamp.BasecampMention(p.Employee.BasecampID)
				if err != nil {
					return err
				}
				msg := fmt.Sprintf("Amount has been deposited in your payroll %v", mention)
				cm := h.service.Basecamp.BuildCommentMessage(projectBonusExplains[i].BasecampBucketID, projectBonusExplains[i].BasecampTodoID, msg, "")
				h.worker.Enqueue(bcModel.BasecampCommentMsg, cm)
			}
		}
	}
	return nil
}

func (h *handler) activateGmailQueue(p chan *model.Payroll) {
	h.logger.Info("gmail queue activated")
	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()

	emailCh := make(chan *model.Payroll)

	go func() {
		for c := range emailCh {
			h.logger.Info(fmt.Sprintf("sending email %v", c.Employee.TeamEmail))
			err := h.service.GoogleMail.SendPayrollPaidMail(c)
			if err != nil {
				h.logger.Error(err, "error when sending email")
			}
		}
	}()

	for {
		select {
		case <-ticker.C:
			// Do something every second
		case c := <-p:
			if c == nil {
				return
			}
			emailCh <- c
		}
	}
}

```

# pkg/handler/payroll/bhxh.go

```go
package payroll

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/store/employee"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

func (h *handler) GetPayrollsBHXH(c *gin.Context) {
	res, err := h.getPayrollBHXHHandler()
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(res, nil, nil, nil, ""))
}

func (h *handler) getPayrollBHXHHandler() (interface{}, error) {
	var res []payrollBHXHResponse

	isLeft := false
	for _, b := range []model.Batch{model.FirstBatch, model.SecondBatch} {
		date := time.Date(time.Now().Year(), time.Now().Month(), int(b), 0, 0, 0, 0, time.Now().Location())
		us, _, err := h.store.Employee.All(h.repo.DB(), employee.EmployeeFilter{IsLeft: &isLeft, BatchDate: &date, Preload: true}, model.Pagination{Page: 0, Size: 500})
		if err != nil {
			return nil, err
		}
		for i := range us {
			if us[i].BaseSalary.CompanyAccountAmount == 0 || us[i].BaseSalary.Batch != int(b) {
				continue
			}
			res = append(res, payrollBHXHResponse{
				DisplayName:   us[i].FullName,
				BHXH:          us[i].BaseSalary.CompanyAccountAmount,
				Batch:         int(b),
				AccountNumber: us[i].LocalBankNumber,
				Bank:          us[i].LocalBranchName,
			})
		}
	}

	return res, nil
}

```

# pkg/handler/profile/profile_test.go

```go
package profile

import (
	"net/http/httptest"
	"os"
	"testing"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/require"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils/testhelper"
)

const testToken = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M"

func TestHandler_GetProfile(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "happy_case",
			wantCode:         200,
			wantErr:          nil,
			wantResponsePath: "testdata/get_profile/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_profile/get_profile.sql")
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest("GET", "/api/v1/profile", nil)
				ctx.Request.Header.Set("Authorization", testToken)

				controllerMock := controller.New(storeMock, txRepo, serviceMock, nil, loggerMock, &cfg)
				metadataHandler := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.GetProfile(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.GetProfile] response mismatched")
			})
		})
	}
}

//func TestHandler_UpdateProfileInfo(t *testing.T) {
//	// load env and test data
//	cfg := config.LoadTestConfig()
//	loggerMock := logger.NewLogrusLogger()
//	serviceMock := service.New(&cfg, nil, nil)
//	storeMock := store.New()
//
//	tests := []struct {
//		name             string
//		wantCode         int
//		wantErr          bool
//		wantResponsePath string
//		input            request.UpdateInfoInput
//	}{
//		{
//			name:             "ok_update_profile",
//			wantCode:         200,
//			wantErr:          false,
//			wantResponsePath: "testdata/update_info/200.json",
//			input: request.UpdateInfoInput{
//				PersonalEmail:      "thanhpham123@gmail.com",
//				PhoneNumber:        "0123456788",
//				PlaceOfResidence:   "200 Đường 3/2, Quận 10",
//				Address:            "201 Đường 3/2, Quận 10",
//				Country:            "Vietnam",
//				City:               "Hồ Chí Minh",
//				GithubID:           "githubid",
//				WiseRecipientID:    "012456",
//				WiseRecipientEmail: "thanhpd@gmail.com",
//				WiseRecipientName:  "Thanh Pham",
//				WiseAccountNumber:  "12531235",
//				WiseCurrency:       "VND",
//			},
//		},
//		{
//			name:             "invalid_phone_number",
//			wantCode:         400,
//			wantErr:          true,
//			wantResponsePath: "testdata/update_info/400.json",
//			input: request.UpdateInfoInput{
//				PersonalEmail:      "thanhpham123@gmail.com",
//				PhoneNumber:        "1234567",
//				PlaceOfResidence:   "200 Đường 3/2, Quận 10",
//				Address:            "201 Đường 3/2, Quận 10",
//				Country:            "Vietnam",
//				City:               "Hồ Chí Minh",
//				GithubID:           "githubid",
//				WiseRecipientID:    "012456",
//				WiseRecipientEmail: "thanhpd@gmail.com",
//				WiseRecipientName:  "Thanh Pham",
//				WiseAccountNumber:  "12531235",
//				WiseCurrency:       "VND",
//			},
//		},
//	}
//
//	for _, tt := range tests {
//		t.Run(tt.name, func(t *testing.T) {
//			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
//				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_info/update_info.sql")
//				byteReq, err := json.Marshal(tt.input)
//				require.Nil(t, err)
//				w := httptest.NewRecorder()
//
//				ctx, _ := gin.CreateTestContext(w)
//				bodyReader := strings.NewReader(string(byteReq))
//				ctx.Request = httptest.NewRequest("PUT", "/api/v1/profile", bodyReader)
//				ctx.Request.Header.Set("Authorization", testToken)
//
//				controllerMock := controller.New(storeMock, txRepo, serviceMock, nil, loggerMock, &cfg)
//				metadataHandler := New(controllerMock, storeMock, txRepo, serviceMock, loggerMock, &cfg)
//
//				metadataHandler.UpdateInfo(ctx)
//
//				require.Equal(t, tt.wantCode, w.Code)
//				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
//				require.NoError(t, err)
//
//				res, err := utils.RemoveFieldInResponse(w.Body.Bytes(), "updatedAt")
//				require.NoError(t, err)
//
//				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Profile.UpdateInfo] response mismatched")
//			})
//		})
//	}
//}

```

# pkg/handler/profile/profile.go

```go
package profile

import (
	"errors"
	"fmt"
	"net/http"
	"path/filepath"

	"github.com/bwmarrin/discordgo"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
	"gorm.io/gorm/utils"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/handler/profile/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/profile/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	controller *controller.Controller
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		controller: controller,
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
	}
}

// GetProfile godoc
// @Summary Get profile information of employee
// @Description Get profile information of employee
// @id getPofile
// @Tags Profile
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} ProfileDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /profile [get]
func (h *handler) GetProfile(c *gin.Context) {
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "profile",
		"method":  "GetProfile",
	})

	rs, err := h.store.Employee.One(h.repo.DB(), userID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("employee not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
		l.Error(err, "error query employee from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToProfileData(rs), nil, nil, nil, ""))
}

// UpdateInfo godoc
// @Summary Update profile info by id
// @Description Update profile info by id
// @id updateProfileInfo
// @Tags Profile
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Employee ID"
// @Param Body body UpdateInfoInput true "Body"
// @Success 200 {object} UpdateProfileInfoResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /profile [put]
func (h *handler) UpdateInfo(c *gin.Context) {
	employeeID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	input := request.UpdateInfoInput{}
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "profile",
		"method":  "UpdateInfo",
		"request": input,
	})

	emp, err := h.store.Employee.One(h.repo.DB(), employeeID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("emp not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
		l.Error(err, "failed to get emp")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// validate personal email
	_, err = h.store.Employee.OneByEmail(h.repo.DB(), input.PersonalEmail)
	if emp.PersonalEmail != input.PersonalEmail && input.PersonalEmail != "" && !errors.Is(err, gorm.ErrRecordNotFound) {
		if err == nil {
			l.Error(err, "personal email exists")
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrEmailExisted, input, ""))
			return
		}
		l.Error(err, "failed to get emp by email")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	city, err := h.validateAndMappingCity(h.repo.DB(), input.Country, input.City)
	if err != nil {
		l.Info("country or city is invalid")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidCountryOrCity, input, ""))
		return
	}

	input.Lat = city.Lat
	input.Long = city.Long

	input.ToEmployeeModel(emp)

	tx, done := h.repo.NewTransaction()
	// Update social accounts
	saInput := model.SocialAccountInput{
		GithubID:     input.GithubID,
		NotionID:     input.NotionID,
		NotionName:   input.NotionName,
		NotionEmail:  input.NotionEmail,
		LinkedInName: input.LinkedInName,
	}

	if err := h.updateSocialAccounts(tx.DB(), saInput, emp.ID); err != nil {
		l.Error(err, "failed to update emp")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// Get discord info
	discordID := ""
	discordMember, err := h.service.Discord.GetMemberByUsername(input.DiscordName)
	if err != nil {
		l.Error(err, "failed to get discord info")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}
	if discordMember == nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrCouldNotFoundDiscordMemberInGuild), input, ""))
		return
	}

	discordID = discordMember.User.ID

	tmpE, err := h.store.Employee.GetByDiscordID(tx.DB(), discordID, false)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		l.Errorf(err, "failed to get emp by discordID", "discordID", discordID)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	if !errors.Is(err, gorm.ErrRecordNotFound) {
		if tmpE.ID != emp.ID {
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrDiscordAccountAlreadyUsedByAnotherEmployee), input, ""))
			return
		}
	}

	discordAccountInput := &model.DiscordAccount{
		DiscordID:       discordID,
		DiscordUsername: input.DiscordName,
	}

	discordAccount, err := h.store.DiscordAccount.Upsert(tx.DB(), discordAccountInput)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	emp.DiscordAccountID = discordAccount.ID

	// Update emp
	_, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, *emp,
		"personal_email",
		"phone_number",
		"place_of_residence",
		"address",
		"country",
		"city",
		"lat",
		"long",
		"wise_recipient_id",
		"wise_account_number",
		"wise_recipient_email",
		"wise_recipient_name",
		"wise_currency",
		"discord_account_id",
	)
	if err != nil {
		l.Error(err, "failed to update emp")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateProfileInfoData(emp), nil, done(nil), nil, ""))
}

func (h *handler) updateSocialAccounts(db *gorm.DB, input model.SocialAccountInput, employeeID model.UUID) error {
	l := h.logger.Fields(logger.Fields{
		"handler": "profile",
		"method":  "updateSocialAccounts",
		"request": input,
	})

	accounts, err := h.store.SocialAccount.GetByEmployeeID(db, employeeID.String())
	if err != nil {
		l.Error(err, "failed to get social accounts by employeeID")
		return err
	}

	accountsInput := map[model.SocialAccountType]model.SocialAccount{
		model.SocialAccountTypeGitHub: {
			Type:       model.SocialAccountTypeGitHub,
			EmployeeID: employeeID,
			AccountID:  input.GithubID,
			Name:       input.GithubID,
		},
		model.SocialAccountTypeNotion: {
			Type:       model.SocialAccountTypeNotion,
			EmployeeID: employeeID,
			AccountID:  input.NotionID,
			Name:       input.NotionName,
			Email:      input.NotionEmail,
		},
		model.SocialAccountTypeLinkedIn: {
			EmployeeID: employeeID,
			Type:       model.SocialAccountTypeLinkedIn,
			AccountID:  input.LinkedInName,
			Name:       input.LinkedInName,
		},
	}

	for _, account := range accounts {
		delete(accountsInput, account.Type)

		switch account.Type {
		case model.SocialAccountTypeGitHub:
			account.AccountID = input.GithubID
			account.Name = input.GithubID
		case model.SocialAccountTypeNotion:
			account.Name = input.NotionName
			account.Email = input.NotionEmail
		case model.SocialAccountTypeLinkedIn:
			account.AccountID = input.LinkedInName
			account.Name = input.LinkedInName
		default:
			continue
		}

		if _, err := h.store.SocialAccount.UpdateSelectedFieldsByID(db, account.ID.String(), *account, "account_id", "name", "email"); err != nil {
			l.Errorf(err, "failed to update social account %s", account.ID)
			return err
		}
	}

	for _, account := range accountsInput {
		if _, err := h.store.SocialAccount.Create(db, &account); err != nil {
			l.AddField("account", account).Error(err, "failed to create social account")
			return err
		}
	}

	return nil
}

func (h *handler) validateAndMappingCity(db *gorm.DB, countryName string, cityName string) (*model.City, error) {
	country, err := h.store.Country.OneByName(db, countryName)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errs.ErrCountryNotFound
		}
		return nil, err
	}

	city := country.Cities.GetCity(cityName)
	if city == nil {
		return nil, errs.ErrCityDoesNotBelongToCountry
	}

	return city, nil
}

// UploadAvatar godoc
// @Summary Upload avatar  by id
// @Description Upload avatar  by id
// @id uploadProfileAvatar
// @Tags Profile
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param file formData file true "content upload"
// @Success 200 {object} EmployeeContentDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /profile/upload-avatar [post]
func (h *handler) UploadAvatar(c *gin.Context) {
	employeeID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	file, err := c.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, file, ""))
		return
	}

	// 1.3 prepare the logger
	l := h.logger.Fields(logger.Fields{
		"handler": "profile",
		"method":  "UploadAvatar",
		"id":      employeeID,
	})

	fileName := file.Filename
	fileExtension := model.ContentExtension(filepath.Ext(fileName))
	fileSize := file.Size
	filePath := fmt.Sprintf("https://storage.googleapis.com/%s/employees/%s/images/%s", h.config.Google.GCSBucketName, employeeID, fileName)
	gcsPath := fmt.Sprintf("employees/%s/images/%s", employeeID, fileName)
	fileType := "image"

	// 2.1 validate
	if !fileExtension.ImageValid() {
		l.Info("invalid file extension")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, ""))
		return
	}

	if fileSize > model.MaxFileSizeImage {
		l.Info("invalid file size")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileSize, nil, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	// 2.2 check file name exist
	_, err = h.store.Content.OneByPath(tx.DB(), filePath)
	if err != nil && err != gorm.ErrRecordNotFound {
		l.Error(err, "error query content from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}
	if err == nil {
		l.Info("file already existed")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrFileAlreadyExisted), nil, ""))
		return
	}

	// 2.3 check employee existed
	existedEmployee, err := h.store.Employee.One(tx.DB(), employeeID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("employee not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
		l.Error(err, "error query employee from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	_, err = h.store.Content.Create(tx.DB(), model.Content{
		Type:      fileType,
		Extension: fileExtension.String(),
		Path:      filePath,
		TargetID:  existedEmployee.ID,
		UploadBy:  existedEmployee.ID,
	})
	if err != nil {
		l.Error(err, "error query employee from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	// 3.1 update avatar link
	_, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, model.Employee{
		Avatar: filePath,
	}, "avatar")
	if err != nil {
		l.Error(err, "error update avatar from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	multipart, err := file.Open()
	if err != nil {
		l.Error(err, "error in open file")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	// 3.2 Upload to GCS
	err = h.service.GoogleStorage.UploadContentGCS(multipart, gcsPath)
	if err != nil {
		l.Error(err, "error in upload file")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToContentData(filePath), nil, done(nil), nil, ""))
}

// Upload godoc
// @Summary Upload image  by id
// @Description Upload image  by id
// @id uploadImage
// @Tags Profile
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param file formData file true "content upload"
// @Success 200 {object} EmployeeContentDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /profile/upload [post]
func (h *handler) Upload(c *gin.Context) {
	employeeID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	file, err := c.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, file, ""))
		return
	}

	fDoctype := c.PostForm("documentType")

	// 1.3 prepare the logger
	l := h.logger.Fields(logger.Fields{
		"handler": "profile",
		"method":  "UploadAvatar",
		"id":      employeeID,
	})

	docType := model.DocumentType(fDoctype)

	fileName := file.Filename
	fileExtension := model.ContentExtension(filepath.Ext(fileName))
	fileSize := file.Size
	filePath := fmt.Sprintf("https://storage.googleapis.com/%s/employees/%s/images/%s", h.config.Google.GCSBucketName, employeeID, fileName)
	gcsPath := fmt.Sprintf("employees/%s/images/%s", employeeID, fileName)
	fileType := "image"

	// 2.1 validate
	if !docType.Valid() {
		l.Info("invalid document type")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidDocumentType, nil, ""))
		return
	}
	if !fileExtension.ImageValid() {
		l.Info("invalid file extension")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, ""))
		return
	}

	if fileSize > model.MaxFileSizeImage {
		l.Info("invalid file size")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileSize, nil, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	// 2.2 check file name exist
	_, err = h.store.Content.OneByPath(tx.DB(), filePath)
	if err != nil && err != gorm.ErrRecordNotFound {
		l.Error(err, "error query content from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}
	if err == nil {
		l.Info("file already existed")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrFileAlreadyExisted), nil, ""))
		return
	}

	// 2.3 check employee existed
	existedEmployee, err := h.store.Employee.One(tx.DB(), employeeID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("employee not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
		l.Error(err, "error query employee from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	_, err = h.store.Content.Create(tx.DB(), model.Content{
		Type:      fileType,
		Extension: fileExtension.String(),
		Path:      filePath,
		TargetID:  existedEmployee.ID,
		UploadBy:  existedEmployee.ID,
	})
	if err != nil {
		l.Error(err, "error query employee from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	switch docType {
	case model.DocumentTypeAvatar:
		_, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, model.Employee{
			Avatar: filePath,
		}, "avatar")
		if err != nil {
			l.Error(err, "error update avatar from db")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
	case model.DocumentTypeIDPhotoFront:
		_, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, model.Employee{
			IdentityCardPhotoFront: filePath,
		}, "avatar")
		if err != nil {
			l.Error(err, "error update id card front from db")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
	case model.DocumentTypeIDPhotoBack:
		_, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, model.Employee{
			IdentityCardPhotoBack: filePath,
		}, "avatar")
		if err != nil {
			l.Error(err, "error update id card back from db")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
	}
	// 3.1 update avatar link

	multipart, err := file.Open()
	if err != nil {
		l.Error(err, "error in open file")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	// 3.2 Upload to GCS
	err = h.service.GoogleStorage.UploadContentGCS(multipart, gcsPath)
	if err != nil {
		l.Error(err, "error in upload file")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToContentData(filePath), nil, done(nil), nil, ""))
}

// GetInvitation godoc
// @Summary Get invitation state based on token
// @Description Submit Get invitation state based on token
// @id getInvitation
// @Tags Onboarding
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} EmployeeInvitationResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /invite [get]
func (h *handler) GetInvitation(c *gin.Context) {
	employeeID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "profile",
		"method":  "GetInvitation",
	})

	employeeInvitation, err := h.store.EmployeeInvitation.OneByEmployeeID(h.repo.DB(), employeeID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("employee invitation not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		l.Error(err, "failed to get employee invitation")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToBasicEmployeeInvitationData(employeeInvitation), nil, nil, nil, ""))
}

// SubmitOnboardingForm godoc
// @Summary Submit onboarding form
// @Description Submit Onboarding form
// @id submitOnboardingForm
// @Tags Onboarding
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param Body body SubmitOnboardingFormRequest true "Body"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /invite/submit [put]
func (h *handler) SubmitOnboardingForm(c *gin.Context) {
	employeeID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	input := request.SubmitOnboardingFormRequest{}
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "profile",
		"method":  "SubmitOnboardingForm",
		"request": input,
	})

	if err := input.Validate(); err != nil {
		l.Error(err, "failed to validate input")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	employeeInvitation, err := h.store.EmployeeInvitation.OneByEmployeeID(h.repo.DB(), employeeID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("employee invitation not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		l.Error(err, "failed to get employee invitation")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	if employeeInvitation.IsCompleted {
		l.Errorf(errs.ErrOnboardingFormAlreadyDone, "employee invitation is expired")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrOnboardingFormAlreadyDone, nil, ""))
		return
	}

	city, err := h.validateAndMappingCity(h.repo.DB(), input.Country, input.City)
	if err != nil {
		l.Info("country or city is invalid")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidCountryOrCity, input, ""))
		return
	}

	input.Lat = city.Lat
	input.Long = city.Long

	employee, err := h.store.Employee.One(h.repo.DB(), employeeID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Info("employee not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
		l.Error(err, "failed to get employee")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	updatedFields := []string{
		"address",
		"city",
		"lat",
		"long",
		"country",
		"gender",
		"horoscope",
		"date_of_birth",
		"local_bank_branch",
		"local_bank_currency",
		"local_bank_number",
		"local_bank_recipient_name",
		"local_branch_name",
		"mbti",
		"phone_number",
		"place_of_residence",
		"working_status",
		"discord_account_id",
	}

	if input.Avatar != "" {
		updatedFields = append(updatedFields, "avatar")
	}

	if input.IdentityCardPhotoFront != "" {
		updatedFields = append(updatedFields, "identity_card_photo_front")
	}

	if input.IdentityCardPhotoBack != "" {
		updatedFields = append(updatedFields, "identity_card_photo_back")
	}

	if input.PassportPhotoFront != "" {
		updatedFields = append(updatedFields, "passport_photo_front")
	}

	if input.PassportPhotoBack != "" {
		updatedFields = append(updatedFields, "passport_photo_back")
	}

	employeeData := input.ToEmployeeModel()

	tx, done := h.repo.NewTransaction()
	// Get discord info
	discordMember, err := h.service.Discord.GetMemberByUsername(input.DiscordName)
	if err != nil {
		l.Errorf(err, "failed to get discord info", "discordName", input.DiscordName)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	discordID := ""
	if discordMember == nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrCouldNotFoundDiscordMemberInGuild), input, ""))
		return
	}

	discordID = discordMember.User.ID

	tmpE, err := h.store.Employee.GetByDiscordID(tx.DB(), discordID, false)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	if !errors.Is(err, gorm.ErrRecordNotFound) {
		if tmpE.ID != employee.ID {
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrDiscordAccountAlreadyUsedByAnotherEmployee), input, ""))
			return
		}
	}

	discordAccountInput := &model.DiscordAccount{
		DiscordID:       discordID,
		DiscordUsername: input.DiscordName,
	}

	discordAccount, err := h.store.DiscordAccount.Upsert(tx.DB(), discordAccountInput)
	if err != nil {
		l.Error(err, "failed to get discord info")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
	}

	employeeData.DiscordAccountID = discordAccount.ID

	// Update employee
	_, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, *employeeData,
		updatedFields...,
	)
	if err != nil {
		l.Error(err, "failed to update employee")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// Update social accounts
	saInput := model.SocialAccountInput{
		GithubID:     input.GithubID,
		NotionName:   input.NotionName,
		LinkedInName: input.LinkedInName,
	}

	if err := h.updateSocialAccounts(tx.DB(), saInput, employee.ID); err != nil {
		l.Error(err, "failed to update employee")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	// Commit transaction update employee info
	_ = done(nil)
	employeeInvitation.IsInfoUpdated = true
	employeeInvitation.IsCompleted = true

	if !employeeInvitation.IsTeamEmailCreated {
		err = h.createTeamEmail(employee.TeamEmail, employee.PersonalEmail)
		if err != nil {
			l.Error(err, "failed to create create team email")
		} else {
			employeeInvitation.IsTeamEmailCreated = true
		}
	}

	if !employeeInvitation.IsBasecampAccountCreated {
		err = h.createBasecampAccount(employee)
		if err != nil {
			l.Error(err, "failed to create basecamp account")
		} else {
			employeeInvitation.IsBasecampAccountCreated = true
		}
	}

	if !employeeInvitation.IsDiscordRoleAssigned {
		err = h.assignDiscordRole(discordMember)
		if err != nil {
			l.Error(err, "failed to assign discord role")
		} else {
			employeeInvitation.IsDiscordRoleAssigned = true
		}
	}

	err = h.store.EmployeeInvitation.Save(h.repo.DB(), employeeInvitation)
	if err != nil {
		l.Error(err, "failed to update employee invitation")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	err = h.controller.Discord.Log(model.LogDiscordInput{
		Type: "employee_submit_onboarding_form",
		Data: map[string]interface{}{
			"employee_id": employee.ID.String(),
		},
	})
	if err != nil {
		l.Error(err, "failed to logs to discord")
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

func (h *handler) createTeamEmail(teamEmail string, personalEmail string) error {
	if h.config.Env != "prod" {
		return nil
	}

	return h.service.ImprovMX.CreateAccount(teamEmail, personalEmail)
}

func (h *handler) createBasecampAccount(employee *model.Employee) error {
	if h.config.Env != "prod" {
		employee.BasecampID = 123456
		employee.BasecampAttachableSGID = "sample_sg_id"
		_, err := h.store.Employee.UpdateSelectedFieldsByID(h.repo.DB(), employee.ID.String(), *employee,
			"basecamp_id",
			"basecamp_attachable_sgid",
		)
		if err != nil {
			return err
		}

		return nil
	}

	email := employee.PersonalEmail
	if employee.TeamEmail != "" {
		email = employee.TeamEmail
	}
	bcID, sgID, err := h.service.Basecamp.People.Create(employee.DisplayName, email, model.OrganizationNameDwarves)
	if err != nil {
		return err
	}

	employee.BasecampID = int(bcID)
	employee.BasecampAttachableSGID = sgID

	_, err = h.store.Employee.UpdateSelectedFieldsByID(h.repo.DB(), employee.ID.String(), *employee,
		"basecamp_id",
		"basecamp_attachable_sgid",
	)
	if err != nil {
		return err
	}

	return nil
}

func (h *handler) assignDiscordRole(discordMember *discordgo.Member) error {
	if discordMember == nil {
		return errs.ErrInvalidDiscordMemberInfo
	}
	// Get list discord role
	dRoles, err := h.service.Discord.GetRoles()
	if err != nil {
		return err
	}

	peepsRoleID := ""
	for _, r := range dRoles {
		if r.Name == model.DiscordRolePeeps.String() {
			peepsRoleID = r.ID
			break
		}
	}

	if peepsRoleID != "" {
		// Check if user already has peeps role
		if utils.Contains(discordMember.Roles, peepsRoleID) {
			return nil
		}

		err := h.service.Discord.AddRole(discordMember.User.ID, peepsRoleID)
		if err != nil {
			return err
		}
	}

	return nil
}

```

# pkg/handler/profile/interface.go

```go
package profile

import "github.com/gin-gonic/gin"

type IHandler interface {
	GetProfile(c *gin.Context)
	UpdateInfo(c *gin.Context)
	SubmitOnboardingForm(c *gin.Context)
	GetInvitation(c *gin.Context)
	Upload(c *gin.Context)
	UploadAvatar(c *gin.Context)
}

```

# pkg/handler/notion/update.go

```go
// Package notion please edit this file only with approval from hnh
package notion

import (
	"net/http"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

// ListUpdates godoc
// @Summary Get list updates from DF Updates
// @Description Get list updates from DF Updates
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/update [get]
func (h *handler) ListUpdates(c *gin.Context) {
	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Updates, nil, []notion.DatabaseQuerySort{
		{
			Property:  "Created at",
			Direction: notion.SortDirDesc,
		},
	}, 5)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get updates from notion"))
		return
	}

	var updates []model.NotionUpdate

	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)

		name := props["Name"].Title[0].Text.Content
		if r.Icon != nil && r.Icon.Emoji != nil {
			name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content
		}

		audience := ""
		if len(props["Audience"].MultiSelect) > 0 {
			audience = props["Audience"].MultiSelect[0].Name
		}

		updates = append(updates, model.NotionUpdate{
			ID:        r.ID,
			Name:      name,
			CreatedAt: props["Created at"].Date.Start.Time,
			Audience:  audience,
		})
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](updates, nil, nil, nil, "get list updates successfully"))
}

```

# pkg/handler/notion/tech_radar.go

```go
// Package notion please edit this file only with approval from hnh
package notion

import (
	"html"
	"net/http"
	"regexp"
	"strings"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"
	"github.com/thoas/go-funk"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

// ListTechRadars godoc
// @Summary Get list items from DF TechRadar
// @Description Get list items from DF TechRadar
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/tech-radars [get]
func (h *handler) ListTechRadars(c *gin.Context) {
	filter := &notion.DatabaseQueryFilter{}

	rings := []string{"Adopt", "Trial", "Assess", "Hold"}
	filterRings := rings

	if c.Query("name") != "" && len(c.Query("name")) < 2 {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "name must be at least 2 characters"))
		return
	}

	if len(c.Request.URL.Query()["ring"]) != 0 {
		filterRings = c.Request.URL.Query()["ring"]
	}

	for _, r := range filterRings {
		if !funk.Contains(rings, r) {
			continue
		}
		filter.Or = append(filter.Or, notion.DatabaseQueryFilter{
			Property: "Status",
			DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
				Select: &notion.SelectDatabaseQueryFilter{
					Equals: r,
				},
			},
		})
	}

	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.TechRadar, filter, nil, 0)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get items tech radar from notion"))
		return
	}

	var techs []model.NotionTechRadar
	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)

		if props["Name"].Title == nil || len(props["Name"].Title) == 0 {
			continue
		}

		name := props["Name"].Title[0].Text.Content
		if c.Query("name") != "" {
			input := c.Query("name")
			escaped := html.EscapeString(input)
			matched, err := regexp.MatchString(".*"+strings.ToLower(escaped)+".*", html.EscapeString(strings.ToLower(name)))
			if err != nil || !matched {
				continue
			}
		}

		if r.Icon != nil && r.Icon.Emoji != nil {
			name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content
		}

		assign := ""
		if len(props["Assign"].People) > 0 {
			assign = props["Assign"].People[0].Name
		}
		quadrant := ""
		if props["Quadrant"].Select != nil {
			quadrant = props["Quadrant"].Select.Name
		}
		ring := ""
		if props["Status"].Select != nil {
			ring = props["Status"].Select.Name
		}
		var categories []string
		for _, c := range props["Categories"].MultiSelect {
			categories = append(categories, c.Name)
		}
		var tags []string
		for _, t := range props["Tag"].MultiSelect {
			tags = append(tags, t.Name)
		}

		techs = append(techs, model.NotionTechRadar{
			ID:         r.ID,
			Name:       name,
			Assign:     assign,
			Quadrant:   quadrant,
			Categories: categories,
			Ring:       ring,
			Tags:       tags,
		})
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](techs, nil, nil, nil, "get list earn items successfully"))
}

// CreateTechRadar create a new tech radar item
// @Summary Create a new tech radar item
// @Description Create a new tech radar item
// @Tags TechRadar
// @Accept  json
// @Produce  json
// @Param body body model.NotionTechRadar true "body for create tech radar item"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
func (h *handler) CreateTechRadar(c *gin.Context) {
	var input model.NotionTechRadar
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "invalid input"))
		return
	}
	if input.Name == "" {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "name and ring are required"))
		return
	}

	// check item is existed
	var filter = &notion.DatabaseQueryFilter{}
	filter.And = append(filter.And, notion.DatabaseQueryFilter{
		Property: "Name",
		DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
			Title: &notion.TextPropertyFilter{
				Equals: input.Name,
			},
		},
	})

	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.TechRadar, filter, nil, 0)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get items tech radar from notion"))
		return
	}
	if len(resp.Results) > 0 {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "item is exist"))
		return
	}

	properties := map[string]interface{}{
		"Name":   input.Name,
		"Status": "Assess",
	}

	if input.Assign != "" {
		properties["Assign"] = input.Assign
	}

	// create tech radar item
	pageID, err := h.service.Notion.CreateDatabaseRecord(h.config.Notion.Databases.TechRadar, properties)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't create tech radar item"))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](pageID, nil, nil, nil, "create tech radar item successfully"))
}

```

# pkg/handler/notion/staffing_demand.go

```go
// Package notion please edit this file only with approval from hnh
package notion

import (
	"net/http"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

// ListStaffingDemands godoc
// @Summary Get list  staffing demands from DF Staffing Demand
// @Description Get list  staffing demands from DF Staffing Demand
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/staffing-demands [get]
func (h *handler) ListStaffingDemands(c *gin.Context) {
	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.StaffingDemand, nil, nil, 0)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "failed to get staffing demands from notion"))
		return
	}

	var staffingDemands []model.NotionStaffingDemand

	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)

		name := props["Project Name"].Title[0].Text.Content
		if r.Icon != nil && r.Icon.Emoji != nil {
			name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content
		}

		request := ""
		if len(props["Request"].RichText) > 0 {
			request = props["Request"].RichText[0].Text.Content
		}

		staffingDemands = append(staffingDemands, model.NotionStaffingDemand{
			ID:      r.ID,
			Name:    name,
			Request: request,
		})
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](staffingDemands, nil, nil, nil, "get list staffing demands successfully"))
}

```

# pkg/handler/notion/project_milestone.go

```go
package notion

import (
	"net/http"
	"regexp"
	"sort"
	"strings"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

// ListProjectMilestones godoc
// @Summary Get list  project milestones
// @Description Get list  project milestones
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/projects/milestones [get]
func (h *handler) ListProjectMilestones(c *gin.Context) {
	filter := &notion.DatabaseQueryFilter{}

	filter.And = append(filter.And, []notion.DatabaseQueryFilter{{
		Property: "Type",
		DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
			Select: &notion.SelectDatabaseQueryFilter{
				Equals: "Project",
			},
		},
	},
		{
			Property: "Status",
			DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
				Select: &notion.SelectDatabaseQueryFilter{
					DoesNotEqual: "Done",
				},
			},
		},
	}...)

	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Delivery, filter, nil, 0)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "failed to get milestones from notion"))
		return
	}

	var projects []struct {
		Name       string                         `json:"name"`
		Milestones []model.NotionProjectMilestone `json:"milestones"`
	}
	var milestones []model.NotionProjectMilestone

	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)

		if props["Project"].Select == nil || (props["Project"].Select != nil && props["Project"].Select.Name == "") {
			continue
		}

		if c.Query("project_name") != "" {
			matched, err := regexp.MatchString(".*"+strings.ToLower(c.Query("project_name"))+".*", strings.ToLower(props["Project"].Select.Name))
			if err != nil || !matched {
				continue
			}
		}

		m := model.NotionProjectMilestone{
			ID:      r.ID,
			Name:    props["Scope"].Title[0].PlainText,
			Project: props["Project"].Select.Name,
		}
		if props["Date"].Date != nil {
			m.StartDate = props["Date"].Date.Start.Time
			if props["Date"].Date.End != nil {
				m.EndDate = props["Date"].Date.End.Time
			}
		}
		milestones = append(milestones, m)
	}

	// group milestones by project name
	for _, m := range milestones {
		found := false
		for i := range projects {
			if projects[i].Name == m.Project {
				projects[i].Milestones = append(projects[i].Milestones, m)
				found = true
				break
			}
		}
		if !found {
			p := struct {
				Name       string                         `json:"name"`
				Milestones []model.NotionProjectMilestone `json:"milestones"`
			}{
				Name:       m.Project,
				Milestones: []model.NotionProjectMilestone{m},
			}
			projects = append(projects, p)
		}
	}

	for i := range projects {
		sort.Slice(projects[i].Milestones[:], func(j, k int) bool {
			return projects[i].Milestones[j].StartDate.Before(projects[i].Milestones[k].StartDate)
		})
	}

	sort.Slice(projects[:], func(i, j int) bool {
		return projects[i].Name < projects[j].Name
	})

	c.JSON(http.StatusOK, view.CreateResponse[any](projects, nil, nil, nil, "get list milestones successfully"))
}

```

# pkg/handler/notion/newsletter.go

```go
package notion

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"path/filepath"

	"github.com/Boostport/mjml-go"
	nt "github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/notion"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/sendgrid/sendgrid-go/helpers/mail"
)

type From struct {
	Email string `json:"email,omitempty"`
	Name  string `json:"name,omitempty"`
}

type ProjectChangelog struct {
	ProjectPageID string `json:"project_page_id,omitempty"`
	IsPreview     bool   `json:"is_preview"`
	From          From   `json:"from,omitempty"`
}

// SendNewsLetter godoc
// @Summary send project changelog
// @Description send project changelog
// @Tags Notion
// @Accept  json
// @Produce  json
// @Param id path string true "id"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/df-updates/{id}/send [post]
func (h *handler) SendNewsLetter(c *gin.Context) {
	contentID := c.Param("id")
	isPreview := false
	if c.Query("preview") == "true" {
		isPreview = true
	}
	categories := []string{"newsletter", contentID}
	var emails []*model.Email

	m, err := h.generateEmailNewsletter(
		contentID,
		&mail.Email{
			Name:    "Dwarves Team",
			Address: "team@d.foundation",
		},
		categories,
	)
	if err != nil {
		h.logger.Error(err, "generateEmailNewsletter() failed")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	if isPreview {
		emails = []*model.Email{
			{
				HTMLContent: m.HTMLContent,
				Subject:     m.Subject,
				From:        m.From,
				To: []*mail.Email{
					mail.NewEmail("Minh Luu", "leo@d.foundation"),
					mail.NewEmail("Huy Nguyen", "huy@d.foundation"),
					mail.NewEmail("Nikki", "nikki@d.foundation"),
					mail.NewEmail("Inno", "mytx@d.foundation"),
					mail.NewEmail("Vi", "tranthiaivi.cs@gmail.com"),
				},
				Categories: categories,
			},
		}
	} else {
		// get subscribers
		subscribers, _, err := h.getSubscribers(h.config.Notion.Databases.Audience, "Dwarves Updates")
		if err != nil {
			h.logger.Error(err, "getSubscribers() failed")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		// get audience list
		for _, s := range subscribers {
			if err != nil {
				h.logger.Error(err, "ToNewsletterHtml() failed with "+s.Address)
				c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
				return
			}
			emails = append(emails, &model.Email{
				HTMLContent: m.HTMLContent,
				Subject:     m.Subject,
				From:        m.From,
				To:          []*mail.Email{s},
				Categories:  categories,
			})
		}

		if h.config.Env != "prod" {
			if len(emails) > 1 {
				emails = emails[:1]
			}
		}
	}

	for _, email := range emails {
		err = h.service.Sendgrid.SendEmail(email)
		if err != nil {
			h.logger.Error(err, "send email failed: "+email.To[0].Address+" "+email.Subject)
			continue
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

func (h *handler) getSubscribers(pageID, audience string) ([]*mail.Email, []string, error) {
	records, err := h.service.Notion.QueryAudienceDatabase(pageID, audience)
	if err != nil {
		h.logger.Error(err, "query audience database")
		return nil, nil, err
	}

	var mails []*mail.Email
	var subs []string
	for i := range records {
		props := records[i].Properties.(nt.DatabasePageProperties)
		var name string
		if len(props["First Name"].RichText) > 0 {
			name = props["First Name"].RichText[0].PlainText
		}
		address := props["Email"].Email
		if address == nil {
			continue
		}
		if name == "" {
			continue
		}
		id := records[i].ID

		subs = append(subs, id)
		mails = append(mails, &mail.Email{
			Name:    name,
			Address: *address,
		})
	}
	return mails, subs, nil
}

func (h *handler) generateEmailNewsletter(id string, from *mail.Email, categories []string) (*model.Email, error) {
	m := model.Email{From: from, Categories: categories}
	var changelogBlocks []nt.Block
	title := "Dwarves Updates"

	page, err := h.service.Notion.GetBlock(id)
	if err != nil {
		h.logger.Error(err, "get block")
		return nil, err
	}
	switch v := page.(type) {
	case *nt.ChildPageBlock:
		title = v.Title
	}
	m.Subject = title

	pageContent, err := h.service.Notion.GetBlockChildren(id)
	if err != nil {
		h.logger.Errorf(err, "failed to download page", "pageID", id)
		return nil, err
	}
	changelogBlocks = pageContent.Results

	// Get children blocks of changelogBlocks
	for _, block := range changelogBlocks {
		if block.HasChildren() {
			children, err := h.service.Notion.GetBlockChildren(block.ID())
			if err != nil {
				h.logger.Errorf(err, "failed to get block children", "blockID", block.ID())
				return nil, err
			}

			switch v := block.(type) {
			case *nt.BulletedListItemBlock:
				v.Children = children.Results
			default:
				continue
			}
		}
	}

	// upload temp image from notion s3 to gcs
	for i, block := range changelogBlocks {
		switch v := block.(type) {
		case *nt.ImageBlock:
			// parse the url
			u, err := url.Parse(v.File.URL)
			if err != nil {
				return nil, err
			}

			// get the file extension
			extension := filepath.Ext(u.Path)

			fPath := fmt.Sprintf("https://storage.googleapis.com/%s/projects/newsletter-images/%s", h.config.Google.GCSBucketName, v.ID())
			gcsPath := fmt.Sprintf("projects/newsletter-images/%s", v.ID()+extension)

			response, err := http.Get(v.File.URL)
			if err != nil {
				return nil, err
			}

			defer response.Body.Close()

			if err := h.service.GoogleStorage.UploadContentGCS(response.Body, gcsPath); err != nil {
				return nil, err
			}
			changelogBlocks[i].(*nt.ImageBlock).File.URL = fPath + extension
		}
	}

	content, err := h.service.Notion.ToChangelogMJML(changelogBlocks, m)
	if err != nil {
		h.logger.Error(err, "To Changelog MJML")
		return nil, err
	}

	m.HTMLContent, err = mjml.ToHTML(context.Background(), fmt.Sprintf(notion.MJMLDFUpdateTemplate, content))
	if err != nil {
		h.logger.Error(err, "To HTML")
		return nil, err
	}

	return &m, nil
}

```

# pkg/handler/notion/memo.go

```go
// Package notion please edit this file only with approval from hnh
package notion

import (
	"net/http"

	"github.com/dstotijn/go-notion"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/gin-gonic/gin"
)

// ListMemos godoc
// @Summary Get list memos from DF Memos
// @Description Get list memos from DF Memos
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/memos [get]
func (h *handler) ListMemos(c *gin.Context) {
	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Memo, nil, []notion.DatabaseQuerySort{
		{
			Property:  "Created",
			Direction: notion.SortDirDesc,
		},
	}, 0)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get memos from notion"))
		return
	}

	var memos []model.NotionMemo

	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)

		name := props["Name"].Title[0].Text.Content
		if r.Icon != nil && r.Icon.Emoji != nil {
			name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content
		}

		author := ""
		if len(props["Author"].People) > 0 {
			author = props["Author"].People[0].Name
		}

		var tags []string
		if len(props["Tags"].MultiSelect) > 0 {
			for _, t := range props["Tags"].MultiSelect {
				tags = append(tags, t.Name)
			}
		}

		memos = append(memos, model.NotionMemo{
			ID:        r.ID,
			Name:      name,
			CreatedAt: props["Created"].Date.Start.Time,
			Tags:      tags,
			Author:    author,
		})
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](memos, nil, nil, nil, "get list memos successfully"))
}

```

# pkg/handler/notion/issue.go

```go
// Package notion please edit this file only with approval from hnh
package notion

import (
	"net/http"
	"time"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

// ListIssues godoc
// @Summary Get list issues from DF Issues & Resolution Log
// @Description Get list issues from DF Issues & Resolution Log
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/issues [get]
func (h *handler) ListIssues(c *gin.Context) {
	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Issue, nil, []notion.DatabaseQuerySort{
		{
			Property:  "Incident Date",
			Direction: notion.SortDirDesc,
		},
	}, 0)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get issues from notion"))
		return
	}

	var issues []model.NotionIssue
	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)
		if props["Status"].Status == nil || props["Status"].Status.Name == "Done" {
			continue
		}

		source := ""
		if len(props["Source"].MultiSelect) > 0 {
			source = props["Source"].MultiSelect[0].Name
		}
		serverity := ""
		if props["Severity"].Select != nil {
			serverity = props["Severity"].Select.Name
		}
		scope := ""
		if len(props["Scope"].MultiSelect) > 0 {
			scope = props["Scope"].MultiSelect[0].Name
		}
		var projects []string
		if len(props["Project"].Relation) > 0 {
			for _, p := range props["Project"].Relation {
				projects = append(projects, p.ID)
			}
		}
		pic := ""
		if len(props["PIC"].People) > 0 {
			pic = props["PIC"].People[0].Name
		}
		priority := ""
		if props["Priority"].Select != nil {
			priority = props["Priority"].Select.Name
		}
		profile := ""
		if len(props["Profile"].Relation) > 0 {
			profile = props["Profile"].Relation[0].ID
		}
		resolution := ""
		if len(props["Resolution"].RichText) > 0 {
			resolution = props["Resolution"].RichText[0].Text.Content
		}
		var incidentDate time.Time
		if props["Incident Date"].Date != nil {
			incidentDate = props["Incident Date"].Date.Start.Time
		}
		var solvedDate time.Time
		if props["Solved Date"].Date != nil {
			solvedDate = props["Solved Date"].Date.Start.Time
		}
		rootCause := ""
		if len(props["Rootcause"].RichText) > 0 {
			rootCause = props["Rootcause"].RichText[0].Text.Content
		}

		name := props["Name"].Title[0].Text.Content
		if r.Icon != nil && r.Icon.Emoji != nil {
			name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content
		}

		issues = append(issues, model.NotionIssue{
			ID:           r.ID,
			Name:         name,
			Status:       props["Status"].Status.Name,
			Source:       source,
			RootCause:    rootCause,
			IncidentDate: &incidentDate,
			SolvedDate:   &solvedDate,
			Severity:     serverity,
			Scope:        scope,
			Projects:     projects,
			PIC:          pic,
			Priority:     priority,
			Profile:      profile,
			Resolution:   resolution,
		})
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](issues, nil, nil, nil, "get list issues successfully"))
}

```

# pkg/handler/notion/interface.go

```go
package notion

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/gin-gonic/gin"
)

type IHandler interface {
	CreateTechRadar(c *gin.Context)
	GetAvailableProjectsChangelog(c *gin.Context)
	ListEarns(c *gin.Context)
	ListMemos(c *gin.Context)
	ListTechRadars(c *gin.Context)
	ListAudiences(c *gin.Context)
	ListEvents(c *gin.Context)
	ListDigests(c *gin.Context)
	ListUpdates(c *gin.Context)
	ListIssues(c *gin.Context)
	ListStaffingDemands(c *gin.Context)
	ListHiringPositions(c *gin.Context)
	ListProjectMilestones(c *gin.Context)
	SendNewsLetter(c *gin.Context)
	SendProjectChangelog(c *gin.Context)
}

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

// New returns a handler
func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

```

# pkg/handler/notion/hiring.go

```go
// Package notion Package hiring please edit this file only with approval from hnh
package notion

import (
	"net/http"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"
	"github.com/thoas/go-funk"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

// ListHiringPositions godoc
// @Summary Get list hiring from DF Dwarves Hiring
// @Description Get list hiring from DF Dwarves Hiring
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/hiring-positions [get]
func (h *handler) ListHiringPositions(c *gin.Context) {
	filter := &notion.DatabaseQueryFilter{}

	status := "Active"
	if c.Query("status") != "" {
		if !funk.Contains([]string{"Active", "Inactive"}, c.Query("status")) {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "status must be Active or Inactive"))
			return
		}
		status = c.Query("status")
	}
	filter.And = append(filter.And, notion.DatabaseQueryFilter{
		Property: "Status",
		DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
			Select: &notion.SelectDatabaseQueryFilter{
				Equals: status,
			},
		},
	})

	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Hiring, nil, []notion.DatabaseQuerySort{
		{
			Direction: notion.SortDirDesc,
			Timestamp: notion.SortTimeStampCreatedTime,
		},
	}, 0)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get hiring positions from notion"))
		return
	}

	var positions []model.NotionHiringPosition

	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)

		if props["Status"].Select == nil || props["Status"].Select.Name != status {
			continue
		}

		name := props["Name"].Title[0].Text.Content
		if r.Icon != nil && r.Icon.Emoji != nil {
			name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content
		}

		var projects []string
		if props["Project"].MultiSelect != nil {
			for _, p := range props["Project"].MultiSelect {
				projects = append(projects, p.Name)
			}
		}

		positions = append(positions, model.NotionHiringPosition{
			ID:        r.ID,
			Name:      name,
			Status:    props["Status"].Select.Name,
			Projects:  projects,
			CreatedAt: r.CreatedTime,
		})
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](positions, nil, nil, nil, "get list hiring positions successfully"))
}

```

# pkg/handler/notion/event.go

```go
// Package notion please edit this file only with approval from hnh
package notion

import (
	"net/http"
	"strconv"
	"time"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

// ListEvents godoc
// @Summary Get list events from DF Dwarves Community Events
// @Description Get list events from DF Dwarves Community Events
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/events [get]
func (h *handler) ListEvents(c *gin.Context) {
	filter := &notion.DatabaseQueryFilter{}

	nextDays := 7
	if c.Query("d") != "" {
		d, ok := c.GetQuery("d")
		if !ok {
			d = "7"
		}
		var err error
		nextDays, err = strconv.Atoi(d)
		if err != nil {
			nextDays = 7
		}
	}

	from := time.Now()
	to := from.Add(24 * time.Hour * time.Duration(nextDays))
	filter.And = append(filter.And, notion.DatabaseQueryFilter{
		Property: "Date",
		DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
			Date: &notion.DatePropertyFilter{
				OnOrAfter: &from,
			},
		},
	})
	filter.And = append(filter.And, notion.DatabaseQueryFilter{
		Property: "Date",
		DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
			Date: &notion.DatePropertyFilter{
				OnOrBefore: &to,
			},
		},
	})

	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Event, filter, []notion.DatabaseQuerySort{
		{
			Property:  "Date",
			Direction: notion.SortDirAsc,
		},
	}, 0)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get events from notion"))
		return
	}

	var events []model.NotionEvent

	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)

		name := props["Name"].Title[0].Text.Content
		if r.Icon != nil && r.Icon.Emoji != nil {
			name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content
		}

		activityType := ""
		if props["Activity Type"].Select != nil {
			activityType = props["Activity Type"].Select.Name
		}

		var date model.DateTime
		if props["Date"].Date != nil {
			date.Time = props["Date"].Date.Start.Time
			date.HasTime = props["Date"].Date.Start.HasTime()
		}

		events = append(events, model.NotionEvent{
			ID:           r.ID,
			Name:         name,
			ActivityType: activityType,
			Date:         date,
			CreatedAt:    r.CreatedTime,
		})
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](events, nil, nil, nil, "get list events successfully"))
}

```

# pkg/handler/notion/earn.go

```go
// Package notion please edit this file only with approval from hnh
package notion

import (
	"net/http"
	"time"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

// ListEarns godoc
// @Summary Get list items from DF earn
// @Description Get list items from DF earn
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/earns [get]
func (h *handler) ListEarns(c *gin.Context) {
	filter := &notion.DatabaseQueryFilter{}
	rewardFilter := 0

	filter.And = append(filter.And,
		notion.DatabaseQueryFilter{
			Property: "Reward 🧊",
			DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
				Number: &notion.NumberDatabaseQueryFilter{
					GreaterThan: &rewardFilter,
				},
			},
		},
		notion.DatabaseQueryFilter{
			Property: "Status",
			DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
				Status: &notion.StatusDatabaseQueryFilter{
					Equals: "Open",
				},
			},
		},
		notion.DatabaseQueryFilter{
			Property: "PICs",
			DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
				People: &notion.PeopleDatabaseQueryFilter{
					IsEmpty: true,
				},
			},
		},
	)

	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Earn, filter, []notion.DatabaseQuerySort{
		{
			Property:  "Reward 🧊",
			Direction: notion.SortDirAsc,
		},
	}, 0)

	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get items earn from notion"))
		return
	}

	var earns = make([]model.NotionEarn, 0, len(resp.Results))

	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)

		if props["Status"].Status == nil {
			continue
		}

		if props["Reward 🧊"].Number == nil || *props["Reward 🧊"].Number == 0 {
			continue
		}

		var tags []string
		for _, tag := range props["Tags"].MultiSelect {
			tags = append(tags, tag.Name)
		}

		var functions []string
		for _, f := range props["Function"].MultiSelect {
			functions = append(functions, f.Name)
		}

		var employees []model.Employee
		for _, e := range props["PICs"].People {
			if e.Person == nil {
				continue
			}

			employees = append(employees, model.Employee{
				FullName:      e.Name,
				PersonalEmail: e.Person.Email,
				Avatar:        e.AvatarURL,
			})
		}
		var dueData *time.Time
		if props["Due Date"].Date != nil {
			dueData = &props["Due Date"].Date.Start.Time
		}

		name := props["Name"].Title[0].Text.Content
		if r.Icon != nil && r.Icon.Emoji != nil {
			name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content
		}

		parentID := ""
		if len(props["Parent item"].Relation) > 0 {
			parentID = props["Parent item"].Relation[0].ID
		}

		earns = append(earns, model.NotionEarn{
			ID:       r.ID,
			Name:     name,
			Reward:   int(*props["Reward 🧊"].Number),
			Tags:     tags,
			PICs:     employees,
			Status:   props["Status"].Status.Name,
			Function: functions,
			DueDate:  dueData,
			ParentID: parentID,
		})
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](earns, nil, nil, nil, "get list earn items successfully"))
}

```

# pkg/handler/notion/digest.go

```go
// Package notion please edit this file only with approval from hnh
package notion

import (
	"net/http"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

// ListDigests godoc
// @Summary Get list digests from DF Internal Digest
// @Description Get list digests from DF Internal Digest
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/digests [get]
func (h *handler) ListDigests(c *gin.Context) {
	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Digest, nil, []notion.DatabaseQuerySort{
		{
			Property:  "Created at",
			Direction: notion.SortDirDesc,
		},
	}, 5)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get digests from notion"))
		return
	}

	var digests []model.NotionDigest

	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)

		name := props["Name"].Title[0].Text.Content
		if r.Icon != nil && r.Icon.Emoji != nil {
			name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content
		}

		digests = append(digests, model.NotionDigest{
			ID:        r.ID,
			Name:      name,
			CreatedAt: props["Created at"].Date.Start.Time,
		})
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](digests, nil, nil, nil, "get list digests successfully"))
}

```

# pkg/handler/notion/changelog.go

```go
package notion

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"path/filepath"
	"runtime/debug"
	"sort"
	"strings"
	"time"

	"github.com/Boostport/mjml-go"
	nt "github.com/dstotijn/go-notion"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/notion"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/gin-gonic/gin"
	"github.com/sendgrid/sendgrid-go/helpers/mail"
)

const (
	projectColumn             = "Project"
	clientsColumn             = "Client"
	groupEmailColumn          = "Group Email"
	changelogRecipientsColumn = "Changelog Recipients"
	leadColumn                = "Lead"
	changelogColumn           = "Changelog"
	portalColumn              = "Project Portal"
	emailSubject              = "EmailSubject"
)

type singleChangelogError struct {
	ProjectName string
	Err         error
}

func (e singleChangelogError) Error() string {
	return fmt.Sprintf("%s: %s", e.ProjectName, e.Err.Error())
}

func parseProjectChangelogNotionMessageFromCtx(c *gin.Context) (ProjectChangelog, error) {
	msg := ProjectChangelog{}
	err := c.ShouldBindJSON(&msg)
	if err != nil {
		return msg, err
	}
	return msg, nil
}

// GetAvailableProjectsChangelog godoc
// @Summary get available projects changelog
// @Description get available projects changelog
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/changelogs/projects/available [get]
func (h *handler) GetAvailableProjectsChangelog(c *gin.Context) {
	projects, err := h.service.Notion.ListProject()
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}
	c.JSON(http.StatusOK, view.CreateResponse[any](projects, nil, nil, nil, ""))
}

// SendProjectChangelog godoc
// @Summary send project changelog
// @Description send project changelog
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/changelogs/project [post]
func (h *handler) SendProjectChangelog(c *gin.Context) {
	msg, err := parseProjectChangelogNotionMessageFromCtx(c)
	if err != nil {
		h.logger.Error(err, "failed to parse project changelog message")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	if err = h.sendProjectChangelog(msg); err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

func (h *handler) sendProjectChangelog(changelog ProjectChangelog) error {
	key := "project changelog"
	if changelog.IsPreview {
		key = "project changelog preview"
	}
	categories := []string{key, changelog.ProjectPageID}
	values, err := h.service.Notion.GetProjectInDB(changelog.ProjectPageID)
	if err != nil {
		h.logger.Errorf(err, "failed to get project in db", "project", changelog.ProjectPageID)
		return err
	}
	return h.sendSingleProjectChangelog(changelog.ProjectPageID, *values, &mail.Email{
		Name:    changelog.From.Name,
		Address: changelog.From.Email},
		categories,
		changelog.IsPreview,
	)
}

func (h *handler) sendSingleProjectChangelog(
	id string,
	values nt.DatabasePageProperties,
	from *mail.Email,
	categories []string,
	isPreview bool,
) error {
	m, _, err := h.generateEmailChangelog(id, values, from, categories, isPreview)
	if err != nil {
		return err
	}

	if err := h.service.Sendgrid.SendEmail(m); err != nil {
		return err
	}

	h.logger.Info(fmt.Sprintf("Send %s successfully", m.Subject))
	return nil
}

func (h *handler) generateEmailChangelog(
	id string,
	values nt.DatabasePageProperties,
	from *mail.Email,
	categories []string,
	isPreview bool,
) (*model.Email, *model.ProjectChangelogPage, error) {
	m := model.Email{From: from, Categories: categories}
	var changelogBlocks []nt.Block
	projectName := ""
	archiveURL := ""
	p := model.ProjectChangelogPage{RowID: id}

	defer func() {
		if r := recover(); r != nil {
			fmt.Println("stacktrace from panic: \n" + string(debug.Stack()))
			h.logger.Error(fmt.Errorf("%v", r), "Recovered "+projectName)
		}
	}()

	// process
	for i, v := range values {
		switch i {
		case projectColumn:
			if len(v.Title) < 1 || v.Title[0].Text == nil {
				continue
			}
			projectName = v.Title[0].Text.Content
			p.Name = projectName
		case portalColumn:
			if v.URL == nil {
				continue
			}
			archiveURL = *v.URL
			if archiveURL != "" {
				if !strings.HasPrefix(archiveURL, "http") || !strings.HasPrefix(archiveURL, "https") {
					archiveURL = "https://" + archiveURL
				}
			}
		case changelogRecipientsColumn:
			if len(v.Relation) < 1 {
				continue
			}
			for _, c := range v.Relation {
				clientPage, err := h.service.Notion.FindClientPageForChangelog(c.ID)
				if err != nil {
					h.logger.Errorf(err, "failed to find client page for changelog", "clientPage", c.ID)
					return nil, nil, singleChangelogError{ProjectName: projectName, Err: err}
				}
				props := clientPage.Properties.(nt.DatabasePageProperties)
				var name string
				if len(props["First Name"].RichText) > 0 {
					name = props["First Name"].RichText[0].Text.Content
				}
				address := props["Email"].Email
				if name == "" || *address == "" {
					continue
				}
				m.To = append(m.To, &mail.Email{Name: name, Address: *address})
			}
		case groupEmailColumn:
			if len(v.RichText) < 1 || v.RichText[0].Text == nil {
				continue
			}
			groupEmails := v.RichText[0].Text.Content
			gms := strings.Split(groupEmails, ",")
			for _, groupEmail := range gms {
				bccMail := strings.TrimSpace(groupEmail)
				m.Bcc = append(m.Bcc, &mail.Email{Name: bccMail, Address: bccMail})
			}
		case leadColumn:
			if len(v.Relation) < 1 {
				continue
			}
			for _, c := range v.Relation {
				recipientsPage, err := h.service.Notion.FindClientPageForChangelog(c.ID)
				if err != nil {
					h.logger.Errorf(err, "failed to find page for changelogs", "clientPage", c.ID)
					return nil, nil, singleChangelogError{ProjectName: projectName, Err: err}
				}
				props := recipientsPage.Properties.(nt.DatabasePageProperties)
				var name string
				if len(props["Full Name"].Title) > 0 {
					name = props["Full Name"].Title[0].Text.Content
				}
				address := props["Team Email"].Email
				if name == "" || *address == "" {
					continue
				}
				m.Bcc = append(m.Bcc, &mail.Email{Name: name, Address: *address})
			}
		case changelogColumn:
			if v.URL == nil {
				continue
			}

			changelogsID := ""
			changelogsURL := *v.URL
			fields := strings.Split(changelogsURL, "/")
			changelogsID = strings.Split(fields[len(fields)-1], "?")[0]

			// timeFilter is one month ago from now
			timeFilter := time.Now().AddDate(0, -1, 0)

			resp, err := h.service.Notion.GetDatabase(changelogsID, &nt.DatabaseQueryFilter{
				And: []nt.DatabaseQueryFilter{
					{
						Property: "Created",
						DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{
							Date: &nt.DatePropertyFilter{
								OnOrAfter: &timeFilter,
							},
						},
					},
				},
			}, nil, 0)
			if err != nil {
				h.logger.Error(err, "download page")
				return nil, nil, singleChangelogError{ProjectName: projectName, Err: err}
			}
			var pages = resp.Results

			// get latest changelog
			sort.Slice(pages, func(i, j int) bool {
				propsI := pages[i].Properties.(nt.DatabasePageProperties)
				propsJ := pages[j].Properties.(nt.DatabasePageProperties)
				return propsI["Created"].Date.Start.After(propsJ["Created"].Date.Start.Time)
			})

			var latestChangelogPage = pages[0]

			pageContent, err := h.service.Notion.GetBlockChildren(latestChangelogPage.ID)
			if err != nil {
				h.logger.Errorf(err, "failed to download page", "pageID", latestChangelogPage.ID)
				return nil, nil, singleChangelogError{ProjectName: projectName, Err: err}
			}
			changelogBlocks = pageContent.Results
		}
	}

	// pageTitle := changelogPage.Root().Title
	if isPreview {
		// m.Bcc = []*mail.Email{mail.NewEmail("Minh Luu", "leo@dwarvesv.com")}
		m.Categories = []string{}
		m.To = []*mail.Email{mail.NewEmail("Minh Luu", "leo@d.foundation")}
	}
	m.Subject = values[emailSubject].Title[0].Text.Content

	// Get children blocks of changelogBlocks
	if err := h.getChildrenBlocks(changelogBlocks); err != nil {
		h.logger.Error(err, "failed to get block children")
		return nil, nil, singleChangelogError{ProjectName: projectName, Err: err}
	}

	// upload temp image from notion s3 to gcs
	for i, block := range changelogBlocks {
		switch v := block.(type) {
		case *nt.ImageBlock:
			var isExternalFile = v.External != nil
			var imgURL string

			if isExternalFile {
				imgURL = v.External.URL
			} else {
				imgURL = v.File.URL
			}

			// parse the url
			u, err := url.Parse(imgURL)
			if err != nil {
				return nil, nil, singleChangelogError{ProjectName: projectName, Err: err}
			}

			// get the file extension
			extension := filepath.Ext(u.Path)

			fPath := fmt.Sprintf("https://storage.googleapis.com/%s/projects/change-logs-images/%s", h.config.Google.GCSBucketName, v.ID())
			gcsPath := fmt.Sprintf("projects/change-logs-images/%s", v.ID()+extension)

			response, err := http.Get(imgURL)
			if err != nil {
				return nil, nil, singleChangelogError{ProjectName: projectName, Err: err}
			}

			defer response.Body.Close()

			if err := h.service.GoogleStorage.UploadContentGCS(response.Body, gcsPath); err != nil {
				return nil, nil, singleChangelogError{ProjectName: projectName, Err: err}
			}
			if isExternalFile {
				changelogBlocks[i].(*nt.ImageBlock).External.URL = fPath + extension
			} else {
				changelogBlocks[i].(*nt.ImageBlock).File.URL = fPath + extension
			}
		}
	}

	content, err := h.service.Notion.ToChangelogMJML(changelogBlocks, m)
	if err != nil {
		h.logger.Error(err, "To Changelog MJML")
		return nil, nil, singleChangelogError{ProjectName: projectName, Err: err}
	}

	mjmlContent := fmt.Sprintf(notion.MJMLChangelogTemplate, content, archiveURL, archiveURL)

	m.HTMLContent, err = mjml.ToHTML(context.Background(), mjmlContent)
	if err != nil {
		h.logger.Error(err, "To HTML")
		return nil, nil, singleChangelogError{ProjectName: projectName, Err: err}
	}

	return &m, &p, nil
}

func (h *handler) getChildrenBlocks(blocks []nt.Block) error {
	for _, block := range blocks {
		if block.HasChildren() {
			switch v := block.(type) {
			case *nt.BulletedListItemBlock:
				children, err := h.service.Notion.GetBlockChildren(block.ID())
				if err != nil {
					return err
				}

				v.Children = children.Results
				if err := h.getChildrenBlocks(v.Children); err != nil {
					return err
				}
			default:
				continue
			}
		}
	}

	return nil
}

```

# pkg/handler/notion/audience.go

```go
// Package notion please edit this file only with approval from hnh
package notion

import (
	"net/http"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

// ListAudiences godoc
// @Summary Get list audiences from DF Audience
// @Description Get list audiences from DF Audience
// @Tags Notion
// @Accept  json
// @Produce  json
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Router /notion/audiences [get]
func (h *handler) ListAudiences(c *gin.Context) {
	filter := &notion.DatabaseQueryFilter{}

	filterNewSubscriber := true
	if c.Query("new_subscriber") == "false" {
		filterNewSubscriber = false
	}

	filter.And = append(filter.And, notion.DatabaseQueryFilter{
		Property: "New Subscriber",
		DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{
			Checkbox: &notion.CheckboxDatabaseQueryFilter{
				Equals: &filterNewSubscriber,
			},
		},
	})

	resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Audience, filter, []notion.DatabaseQuerySort{
		{
			Direction: notion.SortDirDesc,
			Timestamp: notion.SortTimeStampCreatedTime,
		},
	}, 0)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get list audiences from notion"))
		return
	}

	var audiences []model.NotionAudience
	for _, r := range resp.Results {
		props := r.Properties.(notion.DatabasePageProperties)

		fullName := ""
		if len(props["Full Name"].Title) > 0 {
			fullName = props["Full Name"].Title[0].Text.Content
		}
		var sources []string
		for _, c := range props["Source"].MultiSelect {
			sources = append(sources, c.Name)
		}
		email := ""
		if props["Email"].Email != nil {
			email = *props["Email"].Email
		}

		audiences = append(audiences, model.NotionAudience{
			ID:        r.ID,
			FullName:  fullName,
			Email:     email,
			CreatedAt: r.CreatedTime,
			Sources:   sources,
		})
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](audiences, nil, nil, nil, "get list audiences successfully"))
}

```

# pkg/handler/news/news.go

```go
package news

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type handler struct {
	store      *store.Store
	controller *controller.Controller
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
}

// New returns a handler
func New(store *store.Store, repo store.DBRepo, controller *controller.Controller, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:      store,
		repo:       repo,
		controller: controller,
		logger:     logger,
		config:     cfg,
	}
}

```

# pkg/handler/news/interface.go

```go
package news

import (
	"github.com/gin-gonic/gin"
)

type IHandler interface {
	Fetch(c *gin.Context)
}

```

# pkg/handler/news/fetch.go

```go
package news

import (
	"net/http"
	"strings"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/gin-gonic/gin"
)

func (h *handler) Fetch(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "discord",
			"method":  "Fetch",
		},
	)

	platform := strings.TrimSpace(c.Query("platform"))
	if platform == "" {
		l.Info("platform is empty")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "platform is empty"))
		return
	}

	topic := strings.TrimSpace(c.Query("topic"))
	if topic == "" {
		l.Info("topic is empty")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "topic is empty"))
		return
	}

	var posts []model.News
	var err error
	switch platform {
	case model.LobstersPlatform:
		posts, err = h.controller.News.FetchLobstersNews(c.Request.Context(), topic)
		if err != nil {
			l.Error(err, "failed to fetch lobsters news")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	case model.RedditPlatform:
		posts, err = h.controller.News.FetchRedditNews(c.Request.Context(), topic)
		if err != nil {
			l.Error(err, "failed to fetch reddit news")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToFetchNewsResponse(posts), nil, nil, nil, ""))
}

```

# pkg/handler/metadata/request.go

```go
package metadata

// GetQuestionsInput input params for get questions api
type GetQuestionsInput struct {
	Category    EventType    `form:"category" json:"category" binding:"required"`
	Subcategory EventSubtype `form:"subcategory" json:"subcategory" binding:"required"`
}

type EventType string   // @name EventType
type EventStatus string // @name EventStatus

const (
	EventTypeFeedback EventType = "feedback"
	EventTypeSurvey   EventType = "survey"
)

// IsValid validation for EventType
func (e EventType) IsValid() bool {
	switch e {
	case
		EventTypeFeedback,
		EventTypeSurvey:
		return true
	}
	return false
}

func (e EventType) String() string {
	return string(e)
}

type EventSubtype string // @name EventSubtype

const (
	EventSubtypePeerReview   EventSubtype = "peer-review"
	EventSubtypeEngagement   EventSubtype = "engagement"
	EventSubtypeWork         EventSubtype = "work"
	EventSubtypeAppreciation EventSubtype = "appreciation"
	EventSubtypeComment      EventSubtype = "comment"
)

func (e EventSubtype) IsValid() bool {
	switch e {
	case
		EventSubtypePeerReview,
		EventSubtypeEngagement,
		EventSubtypeWork,
		EventSubtypeAppreciation,
		EventSubtypeComment:
		return true
	}
	return false
}

// Validate check valid for values in input params
func (i GetQuestionsInput) Validate() error {
	if i.Category == "" || !i.Category.IsValid() {
		return ErrInvalidCategory
	}

	if i.Subcategory == "" || !i.Subcategory.IsValid() {
		return ErrInvalidSubcategory
	}

	return nil
}

```

# pkg/handler/metadata/metadata_test.go

```go
package metadata

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/metadata/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils/testhelper"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/require"
)

const testToken = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M"

func TestHandler_GetWorkingStatus(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := &store.Store{}

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "ok_get_all",
			wantCode:         200,
			wantErr:          nil,
			wantResponsePath: "testdata/get_working_status/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest("GET", "/api/v1/metadata/working-status?%s", nil)
				metadataHandler := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.WorkingStatuses(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.GetWorkingStatus] response mismatched")
			})
		})
	}
}

func TestHandler_GetSeniority(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "ok_get_seniorities",
			wantCode:         200,
			wantErr:          nil,
			wantResponsePath: "testdata/get_seniorities/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest("GET", "/api/v1/metadata/seniorities", nil)
				metadataHandler := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.Seniorities(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.seniorities] response mismatched")
			})
		})
	}
}

func TestHandler_GetChapters(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "ok_get_chapters",
			wantCode:         200,
			wantErr:          nil,
			wantResponsePath: "testdata/get_chapters/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest("GET", "/api/v1/metadata/chapters", nil)
				metadataHandler := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.Chapters(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Chapters] response mismatched")
			})
		})
	}
}

func TestHandler_GetProjectStatuses(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "ok_get_project_statuses",
			wantCode:         200,
			wantErr:          nil,
			wantResponsePath: "testdata/get_project_statuses/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest("GET", "/api/v1/metadata/project-statuses", nil)
				metadataHandler := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.ProjectStatuses(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.ProjectStatuses] response mismatched")
			})
		})
	}
}

func TestHandler_GetPositions(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "ok_get_positions",
			wantCode:         200,
			wantErr:          nil,
			wantResponsePath: "testdata/get_positions/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest("GET", "/api/v1/metadata/positions", nil)
				metadataHandler := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.Positions(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Positions] response mismatched")
			})
		})
	}
}

func TestHandler_GetTechStacks(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "ok_get_stacks",
			wantCode:         200,
			wantErr:          nil,
			wantResponsePath: "testdata/get_stacks/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest("GET", "/api/v1/metadata/stacks", nil)
				metadataHandler := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)

				metadataHandler.Stacks(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Stacks] response mismatched")
			})
		})
	}
}

func TestHandler_GetQuestion(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		query            string
	}{
		{
			name:             "ok_get_questions",
			wantCode:         200,
			wantResponsePath: "testdata/get_questions/200.json",
			query:            "category=survey&subcategory=peer-review",
		},
		{
			name:             "invalid_subtype",
			wantCode:         400,
			wantResponsePath: "testdata/get_questions/400.json",
			query:            "category=feedback&subcategory=peer-revie",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest("GET", "/api/v1/metadata/questions", nil)
				ctx.Request.URL.RawQuery = tt.query
				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)

				h.GetQuestions(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.GetQuestions] response mismatched")
			})
		})
	}
}

func TestHandler_CreateStack(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		body             request.CreateStackInput
		wantResponsePath string
	}{
		{
			name:     "ok_create_stack",
			wantCode: http.StatusOK,
			body: request.CreateStackInput{
				Name:   "name",
				Code:   "code",
				Avatar: "avatar",
			},
			wantResponsePath: "testdata/create_stack/200.json",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				byteReq, err := json.Marshal(tt.body)
				require.Nil(t, err)
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Request = httptest.NewRequest(http.MethodPost, "/api/v1/metadata/stacks", bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.CreateStack(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.CreateStack] response mismatched")
			})
		})
	}
}

func TestHandler_UpdateStack(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		id               string
		body             request.UpdateStackBody
		wantResponsePath string
	}{
		{
			name:     "ok_update_stack",
			wantCode: http.StatusOK,
			id:       "0ecf47c8-cca4-4c30-94bb-054b1124c44f",
			body: request.UpdateStackBody{
				Name:   "Newname",
				Code:   "code",
				Avatar: "avatar",
			},
			wantResponsePath: "testdata/update_stack/200.json",
		},
		{
			name:     "not_found_stack",
			wantCode: http.StatusNotFound,
			id:       "0ecf47c8-cca4-4c30-94bb-054b1124c44e",
			body: request.UpdateStackBody{
				Name:   "Newname",
				Code:   "code",
				Avatar: "avatar",
			},
			wantResponsePath: "testdata/update_stack/404.json",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				byteReq, err := json.Marshal(tt.body)
				require.Nil(t, err)
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Request = httptest.NewRequest(http.MethodPut, fmt.Sprintf("/api/v1/metadata/stacks/%s", tt.id), bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.id)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.UpdateStack(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.UpdateStack] response mismatched")
			})
		})
	}
}

func TestHandler_DeleteStack(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		id               string
		wantResponsePath string
	}{
		{
			name:             "ok_delete_stack",
			wantCode:         http.StatusOK,
			id:               "0ecf47c8-cca4-4c30-94bb-054b1124c44f",
			wantResponsePath: "testdata/delete_stack/200.json",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPut, fmt.Sprintf("/api/v1/metadata/stacks/%s", tt.id), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.id)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.DeleteStack(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.DeleteStack] response mismatched")
			})
		})
	}
}

func TestHandler_CreatePosition(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		body             request.CreatePositionInput
		wantResponsePath string
	}{
		{
			name:     "ok_create_position",
			wantCode: http.StatusOK,
			body: request.CreatePositionInput{
				Name: "name",
				Code: "code",
			},
			wantResponsePath: "testdata/create_position/200.json",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				byteReq, err := json.Marshal(tt.body)
				require.Nil(t, err)
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Request = httptest.NewRequest(http.MethodPost, "/api/v1/metadata/positions", bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.CreatePosition(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.CreatePosition] response mismatched")
			})
		})
	}
}

func TestHandler_UpdatePosition(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		id               string
		body             request.UpdatePositionBody
		wantResponsePath string
	}{
		{
			name:     "ok_update_position",
			wantCode: http.StatusOK,
			id:       "11ccffea-2cc9-4e98-9bef-3464dfe4dec8",
			body: request.UpdatePositionBody{
				Name: "Newname",
				Code: "code",
			},
			wantResponsePath: "testdata/update_position/200.json",
		},
		{
			name:     "not_found_position",
			wantCode: http.StatusNotFound,
			id:       "0ecf47c8-cca4-4c30-94bb-054b1124c44e",
			body: request.UpdatePositionBody{
				Name: "Newname",
				Code: "code",
			},
			wantResponsePath: "testdata/update_position/404.json",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				byteReq, err := json.Marshal(tt.body)
				require.Nil(t, err)
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Request = httptest.NewRequest(http.MethodPut, fmt.Sprintf("/api/v1/metadata/positions/%s", tt.id), bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.id)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.UpdatePosition(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.UpdatePosition] response mismatched")
			})
		})
	}
}

func TestHandler_DeletePosition(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		id               string
		wantResponsePath string
	}{
		{
			name:             "ok_delete_stack",
			wantCode:         http.StatusOK,
			id:               "11ccffea-2cc9-4e98-9bef-3464dfe4dec8",
			wantResponsePath: "testdata/delete_stack/200.json",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPut, fmt.Sprintf("/api/v1/metadata/stacks/%s", tt.id), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.id)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.DeletePosition(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.DeletePosition] response mismatched")
			})
		})
	}
}

```

# pkg/handler/metadata/metadata.go

```go
package metadata

import (
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/metadata/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/metadata/request"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	bankRepo "github.com/dwarvesf/fortress-api/pkg/store/bank"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

// WorkingStatuses godoc
// @Summary Get list values for working status
// @Description Get list values for working status
// @id getWorkingStatusList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Success 200 {object} MetaDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/working-status [get]
func (h *handler) WorkingStatuses(c *gin.Context) {
	// return list values for working status
	// hardcode for now since we dont need db storage for this
	res := []view.MetaData{
		{
			Code: model.WorkingStatusLeft.String(),
			Name: "Left",
		},
		{
			Code: model.WorkingStatusOnBoarding.String(),
			Name: "On Boarding",
		},
		{
			Code: model.WorkingStatusProbation.String(),
			Name: "Probation",
		},
		{
			Code: model.WorkingStatusFullTime.String(),
			Name: "Full-time",
		},
		{
			Code: model.WorkingStatusContractor.String(),
			Name: "Contractor",
		},
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](res, nil, nil, nil, ""))
}

// Seniorities godoc
// @Summary Get list values for sentitorities
// @Description Get list values for sentitorities
// @id getSenioritiesList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Success 200 {object} SeniorityResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/seniorities [get]
func (h *handler) Seniorities(c *gin.Context) {
	// 1 prepare the logger
	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "Seniorities",
	})

	// 2 query seniorities from db
	seniorities, err := h.store.Seniority.All(h.repo.DB())
	if err != nil {
		l.Error(err, "error query seniorities from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 3 return array of seniorities
	c.JSON(http.StatusOK, view.CreateResponse[any](seniorities, nil, nil, nil, ""))
}

// Chapters godoc
// @Summary Get list values for chapters
// @Description Get list values for chapters
// @id getChaptersList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Success 200 {object} ChapterResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/chapters [get]
func (h *handler) Chapters(c *gin.Context) {
	// 1 prepare the logger

	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "Chapters",
	})

	// 2 query chapters from db
	chapters, err := h.store.Chapter.All(h.repo.DB())
	if err != nil {
		l.Error(err, "error query chapters from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 3 return array of chapters
	c.JSON(http.StatusOK, view.CreateResponse[any](chapters, nil, nil, nil, ""))
}

// Organizations godoc
// @Summary Get list values for organizations
// @Description Get list values for organizations
// @id getOrganizationsList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Success 200 {object} OrganizationsResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/organizations [get]
func (h *handler) Organizations(c *gin.Context) {
	// 1 prepare the logger
	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "Organizations",
	})

	// 2 query organizations from db
	organizations, err := h.store.Organization.All(h.repo.DB())
	if err != nil {
		l.Error(err, "error query organization from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 3 return array of organizations
	c.JSON(http.StatusOK, view.CreateResponse[any](organizations, nil, nil, nil, ""))
}

// GetRoles godoc
// @Summary Get list roles
// @Description Get list roles
// @id getRolesList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Success 200 {object} RolesResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/roles [get]
func (h *handler) GetRoles(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "GetRoles",
	})

	// 2 query roles from db
	roles, err := h.store.Role.All(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to get all roles")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 3 return array of roles
	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToRoles(roles), nil, nil, nil, ""))
}

// ProjectStatuses godoc
// @Summary Get list values for project statuses
// @Description Get list values for project statuses
// @id getProjectStatusesList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Success 200 {object} MetaDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/project-statuses [get]
func (h *handler) ProjectStatuses(c *gin.Context) {
	// return list values for project statuses
	// hardcode for now since we don't need db storage for this
	res := []view.MetaData{
		{
			Code: "on-boarding",
			Name: "On Boarding",
		},
		{
			Code: "paused",
			Name: "Paused",
		},
		{
			Code: "active",
			Name: "Active",
		},
		{
			Code: "closed",
			Name: "Closed",
		},
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](res, nil, nil, nil, ""))
}

// Positions godoc
// @Summary Get list values for positions
// @Description Get list values for positions
// @id getPositionsList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Success 200 {object} PositionResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/positions [get]
func (h *handler) Positions(c *gin.Context) {
	// 1 prepare the logger

	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "Positions",
	})

	// 2 query positions from db
	positions, err := h.store.Position.All(h.repo.DB())
	if err != nil {
		l.Error(err, "error query positions from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 3 return array of positions
	c.JSON(http.StatusOK, view.CreateResponse[any](positions, nil, nil, nil, ""))
}

// GetCountries godoc
// @Summary Get all countries
// @Description Get all countries
// @id getCountriesList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Success 200 {object} CountriesResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/countries [get]
func (h *handler) GetCountries(c *gin.Context) {
	countries, err := h.store.Country.All(h.repo.DB())
	if err != nil {
		h.logger.Fields(logger.Fields{
			"handler": "metadata",
			"method":  "GetCountries",
		}).Error(err, "failed to get all countries")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	rs, err := view.ToCountryView(countries)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(rs, nil, nil, nil, ""))
}

// GetCities godoc
// @Summary Get list cities by country
// @Description Get list cities by country
// @id getCitiesList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Success 200 {object} CitiesResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/countries/{country_id}/cities [get]
func (h *handler) GetCities(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "GetCities",
	})

	countryID := c.Param("country_id")
	if countryID == "" {
		l.Info("country_id is empty")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errors.New("country_id is empty"), nil, ""))
		return
	}

	country, err := h.store.Country.One(h.repo.DB(), countryID)
	if err != nil {
		l.AddField("countryID", countryID).Error(err, "failed to get cities")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(country.Cities, nil, nil, nil, ""))
}

// Stacks godoc
// @Summary Get list values for stacks
// @Description Get list values for stacks
// @id getStacksList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Param keyword query string false "Keyword"
// @Param page query string false "Page"
// @Param size query string false "Size"
// @Success 200 {object} StackResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/stacks [get]
func (h *handler) Stacks(c *gin.Context) {
	var input request.GetStacksInput
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "Stacks",
		"input":   input,
	})

	total, stacks, err := h.store.Stack.All(h.repo.DB(), input.Keyword, &input.Pagination)
	if err != nil {
		l.Error(err, "failed to get all stack")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](stacks,
		&view.PaginationResponse{Pagination: view.Pagination{Page: input.Pagination.Page, Size: input.Pagination.Size, Sort: input.Pagination.Sort}, Total: total}, nil, nil, ""))
}

// UpdateStack godoc
// @Summary Update stack information by ID
// @Description Update stack information by ID
// @id updateStack
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Stack ID"
// @Param Body body UpdateStackBody true "Body"
// @Success 200 {object} MessageResponse
// @Failure 404 {object} ErrorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/stacks/{id} [put]
func (h *handler) UpdateStack(c *gin.Context) {
	var input request.UpdateStackInput

	input.ID = c.Param("id")
	if err := c.ShouldBindJSON(&input.Body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "UpdateStack",
		"input":   input,
	})

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	stack, err := h.store.Stack.One(h.repo.DB(), input.ID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "Stack not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrStackNotFound, input, ""))
			return
		}

		l.Error(err, "failed to get stacks")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	stack.Name = input.Body.Name
	stack.Avatar = input.Body.Avatar
	stack.Code = input.Body.Code

	_, err = h.store.Stack.Update(h.repo.DB(), stack)
	if err != nil {
		l.Error(err, "error query Stacks from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 2 return array of account statuses
	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// CreateStack godoc
// @Summary Create new stack
// @Description Create new stack
// @id createStack
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param Body body CreateStackInput true "Body"
// @Success 200 {object} MessageResponse
// @Failure 404 {object} ErrorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/stacks [post]
func (h *handler) CreateStack(c *gin.Context) {
	var input request.CreateStackInput

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "CreateStack",
		"input":   input,
	})

	stack := &model.Stack{
		Name:   input.Name,
		Code:   input.Code,
		Avatar: input.Avatar,
	}

	_, err := h.store.Stack.Create(h.repo.DB(), stack)
	if err != nil {
		l.Error(err, "error query Stacks from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 2 return array of account statuses
	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// DeleteStack godoc
// @Summary Delete stack by ID
// @Description Delete stack by ID
// @id deleteStack
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Stack ID"
// @Success 200 {object} MessageResponse
// @Failure 404 {object} ErrorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/stacks/{id} [delete]
func (h *handler) DeleteStack(c *gin.Context) {
	stackID := c.Param("id")

	if stackID == "" || !model.IsUUIDFromString(stackID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidStackID, stackID, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "DeleteStack",
		"stackID": stackID,
	})

	if err := h.store.Stack.Delete(h.repo.DB(), stackID); err != nil {
		l.Error(err, "error query Stacks from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 2 return array of account statuses
	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// UpdatePosition godoc
// @Summary Update position information by ID
// @Description Update position information by ID
// @id updatePosition
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Position ID"
// @Param Body body UpdatePositionBody true "Body"
// @Success 200 {object} MessageResponse
// @Failure 404 {object} ErrorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/positions/{id} [put]
func (h *handler) UpdatePosition(c *gin.Context) {
	var input request.UpdatePositionInput

	input.ID = c.Param("id")
	if err := c.ShouldBindJSON(&input.Body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "UpdatePosition",
		"input":   input,
	})

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	position, err := h.store.Position.One(h.repo.DB(), model.MustGetUUIDFromString(input.ID))
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(err, "position not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrPositionNotFound, input, ""))
			return
		}

		l.Error(err, "failed to get position")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	position.Name = input.Body.Name
	position.Code = input.Body.Code

	_, err = h.store.Position.Update(h.repo.DB(), position)
	if err != nil {
		l.Error(err, "error query Positions from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// CreatePosition godoc
// @Summary Create new position
// @Description Create new position
// @id createPosition
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param Body body CreatePositionInput true "Body"
// @Success 200 {object} MessageResponse
// @Failure 404 {object} ErrorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/positions [post]
func (h *handler) CreatePosition(c *gin.Context) {
	var input request.CreatePositionInput

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "CreatePosition",
		"input":   input,
	})

	position := &model.Position{
		Name: input.Name,
		Code: input.Code,
	}

	_, err := h.store.Position.Create(h.repo.DB(), position)
	if err != nil {
		l.Error(err, "error query Positions from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// DeletePosition godoc
// @Summary Delete position by ID
// @Description Delete position by ID
// @id deletePosition
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Position ID"
// @Success 200 {object} MessageResponse
// @Failure 404 {object} ErrorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/positions/{id} [delete]
func (h *handler) DeletePosition(c *gin.Context) {
	positionID := c.Param("id")

	if positionID == "" || !model.IsUUIDFromString(positionID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidPositionID, positionID, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler":    "metadata",
		"method":     "DeletePosition",
		"positionID": positionID,
	})

	if err := h.store.Position.Delete(h.repo.DB(), positionID); err != nil {
		l.Error(err, "error query Position from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// GetQuestions godoc
// @Summary Get list question by category and subcategory
// @Description Get list question by category and subcategory
// @id getQuestionsList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Param category query EventType true "Category"
// @Param subcategory query EventSubtype true "Subcategory"
// @Success 200 {object} GetQuestionResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/questions [get]
func (h *handler) GetQuestions(c *gin.Context) {
	var input GetQuestionsInput

	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "GetQuestions",
		"input":   input,
	})

	rs, err := h.store.Question.AllByCategory(h.repo.DB(), model.EventType(input.Category), model.EventSubtype(input.Subcategory))
	if err != nil {
		l.Error(err, "failed to get question from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListQuestion(rs), nil, nil, nil, ""))
}

// GetCurrencies godoc
// @Summary Get list currencies
// @Description Get list currencies
// @id getCurrenciesList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Success 200 {object} GetCurrenciesResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /metadata/currencies [get]
func (h *handler) GetCurrencies(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "metadata",
		"method":  "GetCurrencies",
	})

	rs, err := h.store.Currency.GetList(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to get question from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToCurrencies(rs), nil, nil, nil, ""))
}

// Banks godoc
// @Summary Get all banks
// @Description Get all bank by given filter params
// @id getBanksList
// @Tags Metadata
// @Accept  json
// @Produce  json
// @Param id query string false "Bank ID"
// @Param bin query string false "Bin"
// @Param swiftCode query string false "Swift SwiftCode"
// @Success 200 {object} ListBankResponse
// @Failure 500 {object} ErrorResponse
// @Router /banks [get]
func (h *handler) Banks(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "bank",
		"method":  "List",
	})

	query := request.GetBankRequest{}
	if err := c.ShouldBindQuery(&query); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	res, err := h.store.Bank.All(h.repo.DB(), bankRepo.GetBanksInput{
		ID:        query.ID,
		Bin:       query.Bin,
		SwiftCode: query.SwiftCode,
	})
	if err != nil {
		l.Error(err, "failed to get all banks")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListBank(res), nil, nil, nil, ""))
}

```

# pkg/handler/metadata/interface.go

```go
package metadata

import "github.com/gin-gonic/gin"

type IHandler interface {
	Banks(c *gin.Context)
	Chapters(c *gin.Context)
	CreatePosition(c *gin.Context)
	CreateStack(c *gin.Context)
	DeletePosition(c *gin.Context)
	DeleteStack(c *gin.Context)
	GetCities(c *gin.Context)
	GetCountries(c *gin.Context)
	GetCurrencies(c *gin.Context)
	GetQuestions(c *gin.Context)
	GetRoles(c *gin.Context)
	Organizations(c *gin.Context)
	Positions(c *gin.Context)
	ProjectStatuses(c *gin.Context)
	Seniorities(c *gin.Context)
	Stacks(c *gin.Context)
	UpdatePosition(c *gin.Context)
	UpdateStack(c *gin.Context)
	WorkingStatuses(c *gin.Context)
}

```

# pkg/handler/metadata/errors.go

```go
package metadata

import "errors"

var (
	ErrInvalidCategory    = errors.New("invalid category")
	ErrInvalidSubcategory = errors.New("invalid subcategory")
)

```

# pkg/handler/memologs/memo_log.go

```go
package memologs

import (
	"context"
	"errors"
	"net/http"
	"strconv"
	"time"

	"github.com/bwmarrin/discordgo"
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/handler/memologs/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/service/mochiprofile"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/store/memolog"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/gin-gonic/gin"
)

type handler struct {
	controller *controller.Controller
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		controller: controller,
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
	}
}

// Create create memo logs
func (h *handler) Create(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "memologs",
			"method":  "Create",
		},
	)

	body := request.CreateMemoLogsRequest{}
	if err := c.ShouldBindJSON(&body); err != nil {
		l.Error(err, "[memologs.Create] failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	memologs := make([]model.MemoLog, 0)
	for _, b := range body {
		publishedAt, _ := time.Parse(time.RFC3339Nano, b.PublishedAt)

		existedAuthors, err := h.store.DiscordAccount.ListByMemoUsername(h.repo.DB(), b.Authors)
		if err != nil {
			l.Errorf(err, "[memologs.Create] failed to get authors", "authors", b.Authors)
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, b, ""))
			return
		}

		authors := make([]model.DiscordAccount, 0)

		// If author does not exist, we will create new author, use memo username as discord username to query discord member
		mapExistedAuthors := make(map[string]model.DiscordAccount)
		for _, author := range existedAuthors {
			mapExistedAuthors[author.MemoUsername] = author
		}

		for _, authorMemoUsername := range b.Authors {
			if a, ok := mapExistedAuthors[authorMemoUsername]; ok {
				authors = append(authors, a)
				continue
			}

			// Build new author aka new community member
			var newAuthor model.DiscordAccount

			// Search discord user by memo username
			discordMembers, err := h.service.Discord.SearchMember(authorMemoUsername)
			if err != nil {
				l.Errorf(err, "[memologs.Create] failed to get discord user", "discord username", authorMemoUsername)
			}

			var discordMember discordgo.Member
			if len(discordMembers) == 1 && discordMembers[0] != nil {
				discordMember = *discordMembers[0]
			}

			newAuthor.MemoUsername = authorMemoUsername
			newAuthor.DiscordUsername = discordMember.User.Username
			newAuthor.DiscordID = discordMember.User.ID
			newAuthor.PersonalEmail = discordMember.User.Email
			newAuthor.Roles = discordMember.Roles

			// Get profile by discord ID
			profile, err := h.service.MochiProfile.GetProfileByDiscordID(discordMember.User.ID)
			if err != nil {
				l.Errorf(err, "[memologs.Create] failed to get profile", "discord id", discordMember.User.ID)
			}

			if profile != nil {
				for _, assocAccount := range profile.AssociatedAccounts {
					if assocAccount.Platform == mochiprofile.ProfilePlatformGithub {
						githubIDInt, err := strconv.ParseInt(assocAccount.PlatformIdentifier, 10, 64)
						if err != nil {
							l.Errorf(err, "[memologs.Create] failed to parse github ID %d", assocAccount.PlatformIdentifier)
							continue
						}

						newAuthor.GithubUsername, err = h.service.Github.RetrieveUsernameByID(context.Background(), githubIDInt)
						if err != nil {
							l.Errorf(err, "[memologs.Create] failed to get github username with ID %d", githubIDInt)
							continue
						}

						break
					}
				}
			}

			authors = append(authors, newAuthor)
		}

		b := model.MemoLog{
			Title:       b.Title,
			URL:         b.URL,
			Authors:     authors,
			Tags:        b.Tags,
			PublishedAt: &publishedAt,
			Description: b.Description,
			Reward:      b.Reward,
		}
		memologs = append(memologs, b)
	}

	logs, err := h.store.MemoLog.Create(h.repo.DB(), memologs)
	if err != nil {
		l.Errorf(err, "[memologs.Create] failed to create new memo logs", "memologs", memologs)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, memologs, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToMemoLog(logs), nil, nil, body, ""))
}

// List list memo logs
func (h *handler) List(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "memologs",
			"method":  "List",
		},
	)

	var fromPtr, toPtr *time.Time

	fromStr := c.Query("from")
	if fromStr != "" {
		from, err := time.Parse(time.RFC3339, fromStr)
		if err != nil {
			l.Error(err, "failed to parse from time")
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		fromPtr = &from
	}

	toStr := c.Query("to")
	if toStr != "" {
		to, err := time.Parse(time.RFC3339, toStr)
		if err != nil {
			l.Error(err, "failed to parse to time")
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		toPtr = &to
	}

	memoLogs, err := h.store.MemoLog.List(h.repo.DB(), memolog.ListFilter{
		From: fromPtr,
		To:   toPtr,
	})
	if err != nil {
		l.Error(err, "failed to get memologs")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToMemoLog(memoLogs), nil, nil, nil, ""))
}

// Sync sync memo logs
func (h *handler) Sync(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "memologs",
			"method":  "Sync",
		},
	)

	results, err := h.controller.MemoLog.Sync()
	if err != nil {
		l.Error(err, "failed to sync memologs")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToMemoLog(results), nil, nil, nil, "ok"))
}

// ListOpenPullRequest list open pull request
func (h *handler) ListOpenPullRequest(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "memologs",
			"method":  "ListOpenPullRequest",
		},
	)

	memoprs, err := h.controller.MemoLog.ListOpenPullRequest()
	if err != nil {
		l.Error(err, "failed to list open pull request")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](memoprs, nil, nil, nil, "ok"))
}

// ListByDiscordID list memo logs by discord id
func (h *handler) ListByDiscordID(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "memologs",
			"method":  "ListByDiscordID",
		},
	)

	discordID := c.Query("discordID")
	if discordID == "" {
		l.Error(errors.New("discordID is required"), "discordID is required")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "discordID is required"))
		return
	}

	memoLogs, err := h.store.MemoLog.List(h.repo.DB(), memolog.ListFilter{
		DiscordID: discordID,
	})
	if err != nil {
		l.Error(err, "failed to get memologs")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	discordMemoRank, err := h.store.MemoLog.GetRankByDiscordID(h.repo.DB(), discordID)
	if err != nil {
		l.Error(err, "failed to get rank by discord id")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToMemoLogByDiscordID(memoLogs, discordMemoRank), nil, nil, nil, ""))
}

func (h *handler) GetTopAuthors(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "memologs",
			"method":  "GetTopAuthors",
		},
	)

	topAuthors, err := h.store.MemoLog.GetTopAuthors(h.repo.DB(), 10)
	if err != nil {
		l.Error(err, "failed to get top authors")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToMemoTopAuthors(topAuthors), nil, nil, nil, ""))
}

```

# pkg/handler/memologs/interface.go

```go
package memologs

import "github.com/gin-gonic/gin"

type IHandler interface {
	Create(c *gin.Context)
	List(c *gin.Context)
	Sync(c *gin.Context)
	ListOpenPullRequest(c *gin.Context)
	ListByDiscordID(c *gin.Context)
	GetTopAuthors(c *gin.Context)
}

```

# pkg/handler/invoice/invoice.go

```go
package invoice

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	invoiceCtrl "github.com/dwarvesf/fortress-api/pkg/controller/invoice"
	"github.com/dwarvesf/fortress-api/pkg/handler/invoice/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/invoice/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/dwarvesf/fortress-api/pkg/worker"
)

type handler struct {
	controller *controller.Controller
	store      *store.Store
	service    *service.Service
	worker     *worker.Worker
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
}

// New returns a handler
func New(ctrl *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, worker *worker.Worker, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		controller: ctrl,
		store:      store,
		repo:       repo,
		service:    service,
		worker:     worker,
		logger:     logger,
		config:     cfg,
	}
}

// List godoc
// @Summary Get latest invoice by project id
// @Description Get latest invoice by project id
// @id getInvoiceList
// @Tags Invoice
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param projectID query string false "projectID"
// @Param status query string false "status"
// @Param page query int false "page"
// @Param size query int false "size"
// @Param sort query string false "sort"
// @Success 200 {object} InvoiceListResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /invoices [get]
func (h *handler) List(c *gin.Context) {
	var query request.GetListInvoiceInput
	if err := c.ShouldBindQuery(&query); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "invoice",
		"method":  "GetLatestInvoice",
		"query":   query,
	})

	pagination := query.StandardizeInput()

	if err := query.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	invoices, total, err := h.controller.Invoice.List(invoiceCtrl.GetListInvoiceInput{
		Pagination: pagination,
		ProjectIDs: query.ProjectID,
		Statuses:   query.Status,
	})
	if err != nil {
		l.Error(err, "failed to get latest invoice")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	rs, err := view.ToInvoiceListResponse(invoices)
	if err != nil {
		l.Error(err, "failed to parse invoice list response")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](rs, &view.PaginationResponse{Total: total, Pagination: view.Pagination{Page: pagination.Page, Size: pagination.Size, Sort: pagination.Sort}}, nil, nil, ""))
}

// GetTemplate godoc
// @Summary Get the latest invoice by project id
// @Description Get the latest invoice by project id
// @id getInvoiceTemplate
// @Tags Invoice
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param projectID query string true "projectID"
// @Success 200 {object} InvoiceTemplateResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /invoices/template [get]
func (h *handler) GetTemplate(c *gin.Context) {
	now := time.Now()
	var input request.GetInvoiceInput
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if input.ProjectID == "" || !model.IsUUIDFromString(input.ProjectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "invoice",
		"method":  "GetTemplate",
		"input":   input,
	})

	nextInvoiceNumber, lastInvoice, p, err := h.controller.Invoice.GetTemplate(invoiceCtrl.GetInvoiceInput{
		Now:       &now,
		ProjectID: input.ProjectID,
	})
	if err != nil {
		l.Error(err, "failed to get invoice template")
		errs.ConvertControllerErr(c, err)
		return
	}

	rs, err := view.ToInvoiceTemplateResponse(p, lastInvoice, nextInvoiceNumber)
	if err != nil {
		l.Error(err, "failed to parse invoice template response")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](rs, nil, nil, nil, ""))
}

// Send godoc
// @Summary Create new invoice and send to client
// @Description Create new invoice and send to client
// @id sendInvoice
// @Tags Invoice
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param Body body SendInvoiceRequest true "body"
// @Success 200 {object} MessageResponse
// @Failure 404 {object} ErrorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /invoices/send [post]
func (h *handler) Send(c *gin.Context) {
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	var req request.SendInvoiceRequest

	l := h.logger.Fields(logger.Fields{
		"handler": "invoice",
		"method":  "Send",
	})

	if err := req.ValidateAndMappingRequest(c, h.config); err != nil {
		l.Errorf(err, "failed to validating and mapping the quest", "input", req)
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, ""))
		return
	}

	iv, err := req.ToInvoiceModel(userID)
	if err != nil {
		l.Error(err, "failed to parse request to invoice model")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, ""))
		return
	}

	_, err = h.controller.Invoice.Send(iv)
	if err != nil {
		l.Error(err, "failed to send invoice")
		errs.ConvertControllerErr(c, err)
		return
	}

	// send message to discord channel
	err = h.controller.Discord.Log(model.LogDiscordInput{
		Type: "invoice_send",
		Data: map[string]interface{}{
			"invoice_number": iv.Number,
			"employee_id":    userID,
		},
	})
	if err != nil {
		l.Error(err, "failed to log to discord")
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// UpdateStatus godoc
// @Summary Update status for invoice
// @Description Update status for invoice
// @Tags Invoice
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} MessageResponse
// @Failure 404 {object} ErrorResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /invoices/{id}/status [put]
func (h *handler) UpdateStatus(c *gin.Context) {
	invoiceID := c.Param("id")
	if invoiceID == "" || !model.IsUUIDFromString(invoiceID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidInvoiceID, nil, ""))
		return
	}

	var req request.UpdateStatusRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "invoice",
		"method":  "UpdateStatus",
		"req":     req,
	})

	if err := req.Validate(); err != nil {
		l.Error(err, "invalid request")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, ""))
		return
	}

	// check invoice existence
	_, err := h.controller.Invoice.UpdateStatus(invoiceCtrl.UpdateStatusInput{
		InvoiceID:         invoiceID,
		Status:            req.Status,
		SendThankYouEmail: req.SendThankYouEmail,
	})
	if err != nil {
		l.Error(err, "failed to update invoice status")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

```

# pkg/handler/invoice/interface.go

```go
package invoice

import "github.com/gin-gonic/gin"

type IHandler interface {
	GetTemplate(c *gin.Context)
	List(c *gin.Context)
	Send(c *gin.Context)
	UpdateStatus(c *gin.Context)
}

```

# pkg/handler/icy/interface.go

```go
package icy

import "github.com/gin-gonic/gin"

type IHandler interface {
	Accounting(c *gin.Context)
}

```

# pkg/handler/icy/icy.go

```go
package icy

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	controller *controller.Controller
	logger     logger.Logger
}

func New(
	controller *controller.Controller,
	logger logger.Logger,
) IHandler {
	return &handler{
		controller: controller,
		logger:     logger,
	}
}

func (h *handler) Accounting(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "icy",
		"method":  "Accounting",
	})

	accounting, err := h.controller.Icy.Accounting()
	if err != nil {
		l.Error(err, "failed to get icy accounting")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "failed to get icy accounting"))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToIcyAccounting(accounting), nil, nil, nil, ""))
}

```

# pkg/handler/healthz/interface.go

```go
package healthz

import "github.com/gin-gonic/gin"

type IHandler interface {
	Healthz(c *gin.Context)
}

```

# pkg/handler/healthz/healthz.go

```go
package healthz

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

type handler struct{}

func New() IHandler {
	return &handler{}
}

// Healthz handler
// Return "OK"
func (h *handler) Healthz(c *gin.Context) {
	c.Header("Content-Type", "text/plain")
	c.String(http.StatusOK, "OK")
}

```

# pkg/handler/feedback/interface.go

```go
package feedback

import "github.com/gin-gonic/gin"

type IHandler interface {
	List(c *gin.Context)
	Detail(c *gin.Context)
	Submit(c *gin.Context)
	CountUnreadFeedback(c *gin.Context)
}

```

# pkg/handler/feedback/feedback_test.go

```go
package feedback

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/require"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/feedback/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/utils/testhelper"
)

const testToken = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M"

func TestHandler_List(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		query            string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "empty_query",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/200_empty_query.json",
		},
		{
			name:             "get_draft_feedbacks",
			wantCode:         http.StatusOK,
			query:            "status=draft",
			wantResponsePath: "testdata/list/200_get_draft_feedbacks.json",
		},
		{
			name:             "get_draft_feedbacks",
			wantCode:         http.StatusBadRequest,
			query:            "status=draftf",
			wantResponsePath: "testdata/list/invalid_status.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/list/list.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/feedbacks?%s", tt.query), nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.URL.RawQuery = tt.query

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.List(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res, err := utils.RemoveFieldInSliceResponse(w.Body.Bytes(), "lastUpdated")
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Feedback.List] response mismatched")
			})
		})
	}
}

func TestHandler_Detail(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		feedbackID       string
		topicID          string
	}{
		{
			name:             "ok_detail",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/detail/200.json",
			feedbackID:       "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250d",
		},
		{
			name:             "ok_engagement",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/detail/200_engagement.json",
			feedbackID:       "53546ea4-1d9d-4216-96b2-75f84ec6d750",
			topicID:          "ebf376a6-3d11-4cea-b464-593103258838",
		},
		{
			name:             "ok_work",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/detail/200_work.json",
			feedbackID:       "d97ee823-f7d5-418b-b281-711cb1d8e947",
			topicID:          "9cf93fc1-5a38-4e2a-87de-41634b65fc87",
		},
		{
			name:             "failed_topic_not_found",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/detail/404.json",
			feedbackID:       "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
			topicID:          "e4a33adc-2495-43cf-b816-32feb8d5250e",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/detail/detail.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.feedbackID}, gin.Param{Key: "topicID", Value: tt.topicID}}
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/feedbacks/%s/topics/%s", tt.feedbackID, tt.topicID), nil)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.Detail(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Feedback.Detail] response mismatched")
			})
		})
	}
}

func TestHandler_Submit(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	tests := []struct {
		name             string
		body             request.SubmitFeedbackRequest
		wantCode         int
		wantResponsePath string
		topicID          string
		eventID          string
	}{
		{
			name:             "failed_unanswer_question",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/submit/400_unanswer_question.json",
			body: request.SubmitFeedbackRequest{
				Answers: []request.BasicEventQuestionRequest{
					{
						EventQuestionID: model.MustGetUUIDFromString("7a94c0f4-81cf-4736-8628-710e25cfc4e7"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("795219e6-67d8-4611-a5cb-38fb1057e4ee"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("40177889-8098-4cb7-931e-9cfe857e56f7"),
						Answer:          "",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("7886c936-fb48-4fc0-beb6-7a8c5d723b78"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("272a2524-efe3-4386-b463-a79143ef661e"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("86aac74b-4dc4-422b-ac70-735fe247eedf"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("faab80cf-9b4c-4deb-96b6-3d7a46cc5e7d"),
						Answer:          "ok",
					},
				},
				Status: model.EventReviewerStatusDone,
			},
			topicID: "e4a33adc-2495-43cf-b816-32feb8d5250d",
			eventID: "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
		},
		{
			name:             "ok_draft",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/submit/200.json",
			body: request.SubmitFeedbackRequest{
				Answers: []request.BasicEventQuestionRequest{
					{
						EventQuestionID: model.MustGetUUIDFromString("7a94c0f4-81cf-4736-8628-710e25cfc4e7"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("795219e6-67d8-4611-a5cb-38fb1057e4ee"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("40177889-8098-4cb7-931e-9cfe857e56f7"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("7886c936-fb48-4fc0-beb6-7a8c5d723b78"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("272a2524-efe3-4386-b463-a79143ef661e"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("86aac74b-4dc4-422b-ac70-735fe247eedf"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("faab80cf-9b4c-4deb-96b6-3d7a46cc5e7d"),
						Answer:          "ok",
					},
				},
				Status: model.EventReviewerStatusDraft,
			},
			topicID: "e4a33adc-2495-43cf-b816-32feb8d5250d",
			eventID: "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
		},
		{
			name:             "draft_not_found_topicID",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/submit/404.json",
			body: request.SubmitFeedbackRequest{
				Answers: []request.BasicEventQuestionRequest{
					{
						EventQuestionID: model.MustGetUUIDFromString("7a94c0f4-81cf-4736-8628-710e25cfc4e7"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("795219e6-67d8-4611-a5cb-38fb1057e4ee"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("40177889-8098-4cb7-931e-9cfe857e56f7"),
						Answer:          "",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("7886c936-fb48-4fc0-beb6-7a8c5d723b78"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("272a2524-efe3-4386-b463-a79143ef661e"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("86aac74b-4dc4-422b-ac70-735fe247eedf"),
						Answer:          "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("faab80cf-9b4c-4deb-96b6-3d7a46cc5e7d"),
						Answer:          "ok",
					},
				},
				Status: model.EventReviewerStatusDraft,
			},
			topicID: "e4a33adc-2495-43cf-b816-32feb8d5250e",
			eventID: "8a5bfedb-6e11-4f5c-82d9-2635cfcce3e2",
		},
		{
			name:             "ok_draft_engagement",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/submit/200_engagement.json",
			body: request.SubmitFeedbackRequest{
				Answers: []request.BasicEventQuestionRequest{
					{
						EventQuestionID: model.MustGetUUIDFromString("a9b63a36-0134-4aa3-9a9a-edb5a1d52645"),
						Answer:          "agree",
						Note:            "ok",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("ebf8ab8b-8827-49fe-a61a-40b140eba903"),
						Answer:          "agree",
						Note:            "ok",
					}, {
						EventQuestionID: model.MustGetUUIDFromString("fae6d117-38c9-4634-8e20-9c012fe0f222"),
						Answer:          "agree",
						Note:            "ok",
					}, {
						EventQuestionID: model.MustGetUUIDFromString("eb8e2a6a-0f86-40fb-b447-972bd8a53d15"),
						Answer:          "agree",
						Note:            "ok",
					}, {
						EventQuestionID: model.MustGetUUIDFromString("c2c3e368-27b0-4154-b2ff-10d1a9f29ba1"),
						Answer:          "agree",
						Note:            "ok",
					}, {
						EventQuestionID: model.MustGetUUIDFromString("ba0c090c-eefc-4e1a-b29d-a024e68c57fe"),
						Answer:          "agree",
						Note:            "ok",
					}, {
						EventQuestionID: model.MustGetUUIDFromString("f508b883-2294-4f50-84e7-f43a0be89bad"),
						Answer:          "agree",
						Note:            "ok",
					}, {
						EventQuestionID: model.MustGetUUIDFromString("57e4bb72-3c10-4652-b2b6-0f26be8ba936"),
						Answer:          "agree",
						Note:            "ok",
					}, {
						EventQuestionID: model.MustGetUUIDFromString("c6fde31e-59c3-4161-9180-490a4a591a17"),
						Answer:          "agree",
						Note:            "ok",
					}, {
						EventQuestionID: model.MustGetUUIDFromString("06c7451f-e155-409b-aebd-5082f897040a"),
						Answer:          "agree",
						Note:            "ok",
					}, {
						EventQuestionID: model.MustGetUUIDFromString("16c1285b-bb45-4093-bcec-5daa8e3eaac6"),
						Answer:          "agree",
						Note:            "ok",
					}, {
						EventQuestionID: model.MustGetUUIDFromString("c9722d74-1683-4c1f-8378-75584cd25753"),
						Answer:          "agree",
						Note:            "ok",
					},
				},
				Status: model.EventReviewerStatusDraft,
			},
			topicID: "ebf376a6-3d11-4cea-b464-593103258838",
			eventID: "53546ea4-1d9d-4216-96b2-75f84ec6d750",
		},
		{
			name:             "ok_work",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/submit/200_work.json",
			body: request.SubmitFeedbackRequest{
				Answers: []request.BasicEventQuestionRequest{
					{
						EventQuestionID: model.MustGetUUIDFromString("3784e437-c7d6-4142-9007-82a7f18f7d50"),
						Answer:          model.AgreementLevelMixed.String(),
						Note:            "nothing",
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("25ae4b9c-4d44-4946-8034-29ccec02a005"),
						Answer:          model.AgreementLevelMixed.String(),
					},
					{
						EventQuestionID: model.MustGetUUIDFromString("5c49dbcd-df16-4f04-bb98-a2dbb339e4d6"),
						Answer:          model.AgreementLevelMixed.String(),
						Note:            "ok",
					},
				},
				Status: model.EventReviewerStatusDraft,
			},
			topicID: "9cf93fc1-5a38-4e2a-87de-41634b65fc87",
			eventID: "d97ee823-f7d5-418b-b281-711cb1d8e947",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/submit/submit.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				byteReq, _ := json.Marshal(tt.body)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.eventID}, gin.Param{Key: "topicID", Value: tt.topicID}}

				ctx.Request = httptest.NewRequest(http.MethodPut, fmt.Sprintf("/api/v1/feedbacks/%s/topics/%s/submit", tt.eventID, tt.topicID), bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.Submit(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res, err := utils.RemoveFieldInSliceResponse(w.Body.Bytes(), "lastUpdated")
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Feedback.Draft] response mismatched")
			})
		})
	}
}

func TestHandler_UnreadInbox(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_unread_inbox/200_happy_case.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_unread_inbox/get_unread_inbox.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, "/api/v1/feedbacks/unreads", nil)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.CountUnreadFeedback(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Feedback.CountUnreadFeedback] response mismatched")
			})
		})
	}
}

```

# pkg/handler/feedback/feedback.go

```go
package feedback

import (
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/feedback/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/feedback/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/store/employeeeventquestion"
	"github.com/dwarvesf/fortress-api/pkg/store/employeeeventtopic"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

// New returns a handler
func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

// List godoc
// @Summary Get list feedbacks
// @Description Get list feedbacks
// @id getFeedbackList
// @Tags Feedback
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param status query string false "Status"
// @Param page query string false "Page"
// @Param size query string false "Size"
// @Param sort query string false "Sort"
// @Success 200 {object} ListFeedbackResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /feedbacks [get]
func (h *handler) List(c *gin.Context) {
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	input := request.GetListFeedbackInput{}
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	pagination := model.Pagination{
		Page: input.Page,
		Size: input.Size,
		Sort: input.Sort,
	}
	pagination.Standardize()

	l := h.logger.Fields(logger.Fields{
		"handler": "feedback",
		"method":  "List",
		"userID":  userID,
		"input":   input,
	})

	rs, total, err := h.store.EmployeeEventTopic.GetByEmployeeID(h.repo.DB(),
		userID,
		employeeeventtopic.GetByEmployeeIDInput{Status: input.Status},
		pagination)
	if err != nil {
		l.Error(err, "failed to get employee event topic by employeeID")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListFeedback(rs),
		&view.PaginationResponse{Pagination: view.Pagination{Page: pagination.Page, Size: pagination.Size, Sort: pagination.Sort}, Total: total}, nil, nil, ""))
}

// Detail godoc
// @Summary Get feedback detail for logged-in users
// @Description Get feedback detail for logged-in users
// @id getFeedbackDetail
// @Tags Feedback
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Feedback Event ID"
// @Param topicID path string true "Employee Event Topic ID"
// @Success 200 {object} FeedbackDetailResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /feedbacks/{id}/topics/{topicID} [get]
func (h *handler) Detail(c *gin.Context) {
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	input := request.DetailInput{
		EventID: c.Param("id"),
		TopicID: c.Param("topicID"),
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "feedback",
		"method":  "Detail",
		"input":   input,
	})

	// Check topic and feedback existence
	topic, err := h.store.EmployeeEventTopic.One(h.repo.DB(), input.TopicID, input.EventID, false)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(errs.ErrTopicNotFound, "topic not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrTopicNotFound, input, ""))
		return
	}

	if err != nil {
		l.Error(err, "failed when getting topic")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	eventReviewer, err := h.store.EmployeeEventReviewer.OneByReviewerID(h.repo.DB(), userID, input.TopicID)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(errs.ErrEmployeeEventReviewerNotFound, "employee event reviewer not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEmployeeEventReviewerNotFound, nil, ""))
		return
	}

	if err != nil {
		l.Error(err, "failed to get employee event reviewer")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	questions, err := h.store.EmployeeEventQuestion.GetByEventReviewerID(h.repo.DB(), eventReviewer.ID.String())
	if err != nil {
		l.Error(err, "failed to get employee event question by reviewer")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	reviewer, err := h.store.Employee.One(h.repo.DB(), userID, false)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(errs.ErrReviewerNotFound, "reviewer not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrReviewerNotFound, nil, ""))
		return
	}

	if err != nil {
		l.Error(err, "failed to get reviewer")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	if !eventReviewer.IsRead {
		eventReviewer.IsRead = true
		if _, err := h.store.EmployeeEventReviewer.UpdateSelectedFieldsByID(h.repo.DB(), eventReviewer.ID.String(), *eventReviewer, "is_read"); err != nil {
			l.Error(err, "failed to update employee event reviewer")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	}

	var project *model.Project
	if !topic.ProjectID.IsZero() {
		project, err = h.store.Project.One(h.repo.DB(), topic.ProjectID.String(), false)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(errs.ErrProjectNotFound, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, ""))
			return
		}

		if err != nil {
			l.Error(err, "failed to get project")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	}

	detailInfo := view.FeedbackDetailInfo{
		Status:       eventReviewer.ReviewerStatus,
		EmployeeID:   topic.EmployeeID.String(),
		Reviewer:     reviewer,
		TopicID:      input.TopicID,
		EventID:      input.EventID,
		Title:        topic.Title,
		Relationship: eventReviewer.Relationship,
		Project:      project,
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListFeedbackDetails(questions, detailInfo), nil, nil, nil, ""))
}

// Submit godoc
// @Summary Submit the draft or done answers
// @Description Submit the draft or done answers
// @id submitFeedback
// @Tags Feedback
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Feedback Event ID"
// @Param topicID path string true "Employee Event Topic ID"
// @Param Body body SubmitFeedbackRequest true "Body"
// @Success 200 {object} SubmitFeedbackResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /feedbacks/{id}/topics/{topicID}/submit [post]
func (h *handler) Submit(c *gin.Context) {
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	input := request.SubmitInput{
		EventID: c.Param("id"),
		TopicID: c.Param("topicID"),
	}

	if err := c.ShouldBindJSON(&input.Body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "feedback",
		"method":  "Submit",
		"userID":  userID,
		"input":   input,
	})

	// Begin transaction
	tx, done := h.repo.NewTransaction()

	// Check topic existence and validate eventID
	topic, err := h.store.EmployeeEventTopic.One(tx.DB(), input.TopicID, input.EventID, false)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(errs.ErrTopicNotFound, "topic not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrTopicNotFound), input, ""))
		return
	}

	if err != nil {
		l.Error(err, "failed when getting topic")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	eventReviewer, err := h.store.EmployeeEventReviewer.OneByReviewerID(tx.DB(), userID, input.TopicID)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(errs.ErrEventReviewerNotFound, "employee event reviewer not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrEventReviewerNotFound), input, ""))
		return
	}

	if err != nil {
		l.Error(err, "failed to get employee event reviewer record")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	if eventReviewer.ReviewerStatus == model.EventReviewerStatusDone {
		l.Error(errs.ErrCouldNotEditDoneFeedback, "could not edit the feedback marked as done")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrCouldNotEditDoneFeedback), nil, ""))
		return
	}

	// check questionID existence
	eventQuestions, err := h.store.EmployeeEventQuestion.GetByEventReviewerID(tx.DB(), eventReviewer.ID.String())
	if err != nil {
		l.Error(err, "failed to validate questionID")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	questionMap := model.ToQuestionMapType(eventQuestions)
	for i, e := range input.Body.Answers {
		_, ok := questionMap[e.EventQuestionID]
		if !ok {
			l.Error(errs.ErrEventQuestionNotFound(e.EventQuestionID.String()), "employee event question not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrEventQuestionNotFound(e.EventQuestionID.String())), input, ""))
			return
		}

		if questionMap[e.EventQuestionID] == model.QuestionTypeScale.String() {
			if (input.Body.Status == model.EventReviewerStatusDone && e.Answer == "" && !model.AgreementLevel(e.Answer).IsValid()) ||
				(input.Body.Status == model.EventReviewerStatusDraft && e.Answer != "" && !model.AgreementLevel(e.Answer).IsValid()) {
				l.Error(errs.ErrInvalidAnswerForLikertScale, "invalid answer for likert-scale question")
				c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, done(errs.ErrInvalidAnswerForLikertScale), input, ""))
				return
			}

			input.Body.Answers[i].Answer = model.AgreementLevelMap[model.AgreementLevel(e.Answer)]
		}
	}

	// Update answers in employee_event_questions table
	for _, e := range input.Body.Answers {
		data := employeeeventquestion.BasicEventQuestion{
			EventQuestionID: e.EventQuestionID.String(),
			Answer:          e.Answer,
			Note:            e.Note,
		}

		if err := h.store.EmployeeEventQuestion.UpdateAnswers(tx.DB(), data); err != nil {
			l.Error(err, "failed to update employee event question")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
	}

	// Update status in employee_event_reviewers table
	eventReviewer.ReviewerStatus = input.Body.Status
	if input.Body.Status == model.EventReviewerStatusDone {
		eventReviewer.AuthorStatus = model.EventAuthorStatusDone
	}
	_, err = h.store.EmployeeEventReviewer.UpdateSelectedFieldsByID(tx.DB(), eventReviewer.ID.String(), *eventReviewer, "reviewer_status", "author_status")
	if err != nil {
		l.Error(err, "failed to update employee event question")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	eventQuestions, err = h.store.EmployeeEventQuestion.GetByEventReviewerID(tx.DB(), eventReviewer.ID.String())
	if err != nil {
		l.Error(err, "failed to get all empoyee event questions by event reviewer")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, ""))
		return
	}

	if input.Body.Status == model.EventReviewerStatusDone {
		for _, e := range eventQuestions {
			if e.Answer == "" {
				l.Error(errs.ErrUnansweredquestions, "there are some unanswered questions")
				c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, done(errs.ErrUnansweredquestions), input, ""))
				return
			}
		}
	}

	reviewer, err := h.store.Employee.One(h.repo.DB(), userID, false)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(errs.ErrReviewerNotFound, "reviewer not found")
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrReviewerNotFound, nil, ""))
		return
	}

	if err != nil {
		l.Error(err, "failed to get reviewer")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	detailInfo := view.FeedbackDetailInfo{
		Status:     eventReviewer.ReviewerStatus,
		EmployeeID: topic.EmployeeID.String(),
		Reviewer:   reviewer,
		TopicID:    input.TopicID,
		EventID:    input.EventID,
		Title:      topic.Title,
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListSubmitFeedback(eventQuestions, detailInfo), nil, nil, done(nil), ""))
}

// CountUnreadFeedback godoc
// @Summary Get number of unread inbox for user
// @Description Get number of unread inbox for user
// @id countUnreadFeedback
// @Tags Feedback
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} UnreadFeedbackCountResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /feedbacks/unreads [get]
func (h *handler) CountUnreadFeedback(c *gin.Context) {
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "feedback",
		"method":  "CountUnreadFeedback",
		"userID":  userID,
	})

	// Get unread inbox
	count, err := h.store.EmployeeEventTopic.CountUnreadFeedbackByEmployeeID(h.repo.DB(), userID)
	if err != nil {
		l.Error(err, "failed to get unread inbox")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUnreadFeedbackCountData(userID, count), nil, nil, nil, ""))
}

```

# pkg/handler/engagement/interface.go

```go
package engagement

import "github.com/gin-gonic/gin"

type IHandler interface {
	UpsertRollup(c *gin.Context)
	GetLastMessageID(c *gin.Context)
	IndexMessages(c *gin.Context)
}

```

# pkg/handler/engagement/errors.go

```go
package engagement

```

# pkg/handler/engagement/engagement.go

```go
package engagement

import (
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/bwmarrin/discordgo"
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/handler/engagement/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/gin-gonic/gin"
)

type handler struct {
	controller *controller.Controller
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config

	// isIndexingMessages is used to make sure that there cannot be
	// a second IndexMessages invocation if the first one is not done
	isIndexingMessages bool
}

func New(
	controller *controller.Controller,
	store *store.Store,
	repo store.DBRepo,
	service *service.Service,
	logger logger.Logger,
	cfg *config.Config,
) IHandler {
	return &handler{
		controller: controller,
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
	}
}

// UpsertRollup godoc
// @Summary Upsert engagement rollup
// @Description Upsert engagement rollup
// @id upsertEngagementRollup
// @Tags Engagement
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param Body body UpsertRollupRequest true "Body"
// @Success 200 {object} MessageResponse
// @Success 400 {object} ErrorResponse
// @Success 500 {object} ErrorResponse
// @Router /engagements/rollup [post]
func (h *handler) UpsertRollup(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "engagement",
			"method":  "UpsertRollup",
		},
	)
	body := request.UpsertRollupRequest{}
	if err := c.ShouldBindJSON(&body); err != nil {
		l.Error(err, "error decoding body")
		c.JSON(
			http.StatusBadRequest,
			view.CreateResponse[any](nil, nil, err, body, ""),
		)
		return
	}
	l = l.AddField("body", body)
	if err := body.Validate(); err != nil {
		l.Error(err, "error validating data")
		c.JSON(
			http.StatusBadRequest,
			view.CreateResponse[any](nil, nil, err, body, ""),
		)
		return
	}

	discordUserID, err := strconv.ParseInt(body.DiscordUserID, 10, 64)
	if err != nil {
		l.Error(err, "unable to parse discordUserID to int64")
		c.JSON(
			http.StatusBadRequest,
			view.CreateResponse[any](nil, nil, err, body, ""),
		)
		return
	}
	lastMessageID, err := strconv.ParseInt(body.LastMessageID, 10, 64)
	if err != nil {
		l.Error(err, "unable to parse lastMessageID to int64")
		c.JSON(
			http.StatusBadRequest,
			view.CreateResponse[any](nil, nil, err, body, ""),
		)
		return
	}
	channelID, err := strconv.ParseInt(body.ChannelID, 10, 64)
	if err != nil {
		l.Error(err, "unable to parse channelID to int64")
		c.JSON(
			http.StatusBadRequest,
			view.CreateResponse[any](nil, nil, err, body, ""),
		)
		return
	}
	categoryID := int64(0)
	if body.CategoryID == "" {
		categoryID = -1
	} else {
		categoryID, err = strconv.ParseInt(body.CategoryID, 10, 64)
		if err != nil {
			l.Error(err, "unable to parse categoryID to int64")
			c.JSON(
				http.StatusBadRequest,
				view.CreateResponse[any](nil, nil, err, body, ""),
			)
			return
		}
	}

	tx, done := h.repo.NewTransaction()
	rollup := &model.EngagementsRollup{
		DiscordUserID: discordUserID,
		LastMessageID: lastMessageID,
		ChannelID:     channelID,
		CategoryID:    categoryID,
		MessageCount:  body.MessageCount,
		ReactionCount: body.ReactionCount,
	}
	_, err = h.store.EngagementsRollup.Upsert(tx.DB(), rollup)
	if err != nil {
		l.Error(err, "unable to upsert engagements rollup")
		c.JSON(
			http.StatusInternalServerError,
			view.CreateResponse[any](nil, nil, done(err), body, ""),
		)
		return
	}

	c.JSON(
		http.StatusOK,
		view.CreateResponse[any]("success", nil, done(nil), body, ""),
	)
}

// GetLastMessageID godoc
// @Summary Get local last message ID of a channel
// @Description Get local last message ID of a channel
// @id getLastMessageID
// @Tags Engagement
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param channel-id path string true "Discord Channel ID"
// @Success 200 {object} MessageResponse
// @Success 400 {object} ErrorResponse
// @Success 500 {object} ErrorResponse
// @Router /engagements/channel/:channel-id/last-message-id [get]
func (h *handler) GetLastMessageID(c *gin.Context) {
	channelID := c.Param("channel-id")
	l := h.logger.Fields(logger.Fields{
		"handler":   "engagement",
		"method":    "UpsertRollupRecord",
		"channelID": channelID,
	})

	tx, done := h.repo.NewTransaction()
	lastMessageID, err := h.store.EngagementsRollup.GetLastMessageID(tx.DB(), channelID)
	if err != nil {
		l.Error(err, "unable to get last message ID")
		c.JSON(
			http.StatusInternalServerError,
			view.CreateResponse[any](nil, nil, done(err), channelID, ""),
		)
		return
	}

	c.JSON(
		http.StatusOK,
		view.CreateResponse[any](lastMessageID, nil, done(nil), nil, "success"),
	)
}

func AggregateMessages(
	l logger.Logger,
	messages []*discordgo.Message,
	channelIDToCategoryID map[string]string,
) []*model.EngagementsRollup {
	userIDMessageIDToRecord := make(map[string]*model.EngagementsRollup)

	for _, message := range messages {
		l := l.AddField("messageID", message.ID)
		if message.Author == nil {
			l.Warn("missing author")
			continue
		}

		userID, err := strconv.ParseInt(message.Author.ID, 10, 64)
		if err != nil {
			l := l.AddField("userID", message.Author.ID)
			l.Error(err, "unable to parse user ID to int64")
			continue
		}
		messageID, err := strconv.ParseInt(message.ID, 10, 64)
		if err != nil {
			l := l.AddField("messageID", message.ID)
			l.Error(err, "unable to parse message ID to int64")
			continue
		}
		channelID, err := strconv.ParseInt(message.ChannelID, 10, 64)
		if err != nil {
			l := l.AddField("channelID", message.ChannelID)
			l.Error(err, "unable to parse channel ID to int64")
			continue
		}
		categoryID := int64(0)
		categoryIDStr := channelIDToCategoryID[message.ChannelID]
		if categoryIDStr == "" {
			categoryID = -1
		} else {
			categoryID, err = strconv.ParseInt(categoryIDStr, 10, 64)
			if err != nil {
				l := l.AddField("categoryIDStr", categoryIDStr)
				l.Error(err, "unable to parse category ID to int64")
				continue
			}
		}

		key := fmt.Sprintf("%d_%d", userID, channelID)
		record, ok := userIDMessageIDToRecord[key]
		if ok {
			record.MessageCount += 1
			record.LastMessageID = messageID
		} else {
			userIDMessageIDToRecord[key] = &model.EngagementsRollup{
				DiscordUserID:   userID,
				LastMessageID:   messageID,
				DiscordUsername: fmt.Sprintf("%s#%s", message.Author.Username, message.Author.Discriminator),
				ChannelID:       channelID,
				CategoryID:      categoryID,
				MessageCount:    1,
			}
		}
	}

	records := make([]*model.EngagementsRollup, 0, len(userIDMessageIDToRecord))
	for _, record := range userIDMessageIDToRecord {
		records = append(records, record)
	}

	return records
}

// IndexMessages godoc
// @Summary Index messages of provided Discord server
// @Description Index messages of provided Discord server
// @id indexEngagementMessages
// @Tags Engagement
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} MessageResponse
// @Success 400 {object} ErrorResponse
// @Success 500 {object} ErrorResponse
// @Router /cronjobs/index-engagement-messages [post]
func (h *handler) IndexMessages(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "engagement",
			"method":  "IndexMessages",
		},
	)

	if h.isIndexingMessages {
		l.Warn("handler is indexing messages")
		c.JSON(
			http.StatusAccepted,
			view.CreateResponse[any]("handler is indexing messages", nil, nil, nil, ""),
		)
		return
	}
	h.isIndexingMessages = true
	defer func() {
		h.isIndexingMessages = false
	}()

	l = h.logger.Fields(
		logger.Fields{
			"guildID": h.config.Discord.IDs.DwarvesGuild,
		},
	)
	channels, err := h.service.Discord.GetChannels()
	if err != nil {
		l.Error(err, "get channels error")
		c.JSON(
			http.StatusInternalServerError,
			view.CreateResponse[any](nil, nil, err, nil, ""),
		)
		return
	}
	l.Debugf("fetched channels: %v", channels)

	tx, done := h.repo.NewTransaction()
	allMessages := make([]*discordgo.Message, 0)
	// TODO: parallelize the code as each channel can be processed singly
	for _, channel := range channels {
		l := l.AddField("channelID", channel.ID)
		if channel.LastMessageID == "" {
			l.Debugf("channel has no message", channel.ID)
			continue
		}

		cursorMessageID, err := h.store.EngagementsRollup.GetLastMessageID(tx.DB(), channel.ID)
		if err != nil {
			l.Error(done(err), "get cursor message id error")
			c.JSON(
				http.StatusInternalServerError,
				view.CreateResponse[any](nil, nil, err, nil, ""),
			)
			return
		}
		messages, err := h.service.Discord.GetMessagesAfterCursor(
			channel.ID,
			cursorMessageID,
			channel.LastMessageID,
		)
		if err != nil {
			l := l.AddField("cursorMessageID", cursorMessageID)
			l.Warnf("get messages after cursor error: %s", err.Error())
			continue
		}
		l.Debugf("fetched %d message(s)", len(messages))
		allMessages = append(allMessages, messages...)
	}

	channelIDToCategoryID := make(map[string]string, len(channels))
	for _, channel := range channels {
		channelIDToCategoryID[channel.ID] = channel.ParentID
	}

	records := AggregateMessages(l, allMessages, channelIDToCategoryID)
	l.Debugf("aggregated %d message(s) to %d records", len(allMessages), len(records))
	for _, record := range records {
		_, err := h.store.EngagementsRollup.Upsert(tx.DB(), record)
		if err != nil {
			l.Error(done(err), "upsert record error")
			c.JSON(
				http.StatusInternalServerError,
				view.CreateResponse[any](nil, nil, err, nil, ""),
			)
			return
		}
		// wait 500ms after each insert to avoid overwhelming the database
		time.Sleep(500 * time.Millisecond)
	}

	c.JSON(
		http.StatusOK,
		view.CreateResponse[any]("success", nil, done(nil), nil, ""),
	)
}

```

# pkg/handler/earn/interface.go

```go
package earn

import "github.com/gin-gonic/gin"

type IHandler interface {
	ListEarn(c *gin.Context)
}

```

# pkg/handler/earn/earn.go

```go
package earn

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
	controller *controller.Controller
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
		controller: controller,
	}
}

// ListEarn godoc
// @Summary List of earns from memo
// @Description List of earns from memo
// @Tags Earn
// @Accept  json
// @Produce  json
// @Success 200 {object} ListEarnResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /earn [get]
func (h *handler) ListEarn(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "vault",
		"method":  "ListEarn",
	})

	earns, err := h.controller.Earn.ListEarn(c.Request.Context())
	if err != nil {
		l.Error(err, "get list earn failed")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToEarns(earns), nil, nil, nil, ""))
}

```

# pkg/handler/employee/interface.go

```go
package employee

import "github.com/gin-gonic/gin"

type IHandler interface {
	Create(c *gin.Context)
	Details(c *gin.Context)
	ListByDiscordRequest(c *gin.Context)
	GetLineManagers(c *gin.Context)
	List(c *gin.Context)
	ListWithMMAScore(c *gin.Context)
	UpdateEmployeeStatus(c *gin.Context)
	UpdateGeneralInfo(c *gin.Context)
	UpdateSkills(c *gin.Context)
	UpdatePersonalInfo(c *gin.Context)
	UploadAvatar(c *gin.Context)
	UpdateRole(c *gin.Context)
	UpdateBaseSalary(c *gin.Context)
	SalaryAdvance(c *gin.Context)
	CheckSalaryAdvance(c *gin.Context)
	SalaryAdvanceReport(c *gin.Context)
	GetEmployeeEarnTransactions(c *gin.Context)
	GetEmployeeTotalEarn(c *gin.Context)
	GetTotalEarn(c *gin.Context)
	OfficeCheckIn(c *gin.Context)

	PublicList(c *gin.Context)
}

```

# pkg/handler/employee/employee_test.go

```go
package employee

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/require"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/handler/employee/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/utils/testhelper"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/dwarvesf/fortress-api/pkg/worker"
)

const testToken = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M"

func TestHandler_List(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	queue := make(chan model.WorkerMessage, 1000)
	workerMock := worker.New(context.Background(), queue, serviceMock, loggerMock)

	tests := []struct {
		name             string
		body             request.GetListEmployeeQuery
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "without_working_status_and_pagination",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/without_working_status_and_pagination.json",
		},
		{
			name: "have_workingStatus_and_no_pagination",
			body: request.GetListEmployeeQuery{
				WorkingStatuses: []string{"contractor"},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/have_working_and_no_pagination.json",
		},
		{
			name: "have_workingStatuses_and_pagination",
			body: request.GetListEmployeeQuery{
				Pagination: view.Pagination{
					Page: 1,
					Size: 5,
				},
				WorkingStatuses: []string{"contractor"},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/have_working_and_pagination.json",
		},
		{
			name: "out_of_content",
			body: request.GetListEmployeeQuery{
				Pagination: view.Pagination{
					Page: 5,
					Size: 5,
				},
				WorkingStatuses: []string{"contractor"},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/out_of_content.json",
		},
		{
			name: "with_preload_false",
			body: request.GetListEmployeeQuery{
				Preload:         false,
				WorkingStatuses: []string{"probation"},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/with_preload_false.json",
		},
		{
			name: "without_preload",
			body: request.GetListEmployeeQuery{
				Preload:         false,
				WorkingStatuses: []string{"probation"},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/without_preload.json",
		},
		{
			name: "with_keyword",
			body: request.GetListEmployeeQuery{
				Preload: false,
				Keyword: "thanh",
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/with_keyword.json",
		},
		{
			name: "with_stack_code",
			body: request.GetListEmployeeQuery{
				Preload: false,
				Stacks:  []string{"golang"},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/with_stack_code.json",
		},
		{
			name: "with_project_code_and_position_code",
			body: request.GetListEmployeeQuery{
				Preload:   false,
				Projects:  []string{"fortress"},
				Positions: []string{"blockchain"},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/with_project_code_and_position_code.json",
		},
		{
			name: "with_list_working_status",
			body: request.GetListEmployeeQuery{
				Preload:         false,
				WorkingStatuses: []string{"contractor", "probation"},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/with_list_working_status.json",
		},
		{
			name: "invalid_position_code",
			body: request.GetListEmployeeQuery{
				Positions: []string{""},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/list/invalid_position_code.json",
		},
		{
			name: "invalid_chapter_code",
			body: request.GetListEmployeeQuery{
				Chapters: []string{""},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/list/invalid_chapter_code.json",
		},
		{
			name: "invalid_organization_code",
			body: request.GetListEmployeeQuery{
				Organizations: []string{""},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/list/invalid_organization_code.json",
		},
		{
			name: "invalid_project_code",
			body: request.GetListEmployeeQuery{
				Projects: []string{""},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/list/invalid_project_code.json",
		},
		{
			name: "invalid_seniority_code",
			body: request.GetListEmployeeQuery{
				Seniorities: []string{""},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/list/invalid_seniority_code.json",
		},
		{
			name: "invalid_stack_code",
			body: request.GetListEmployeeQuery{
				Stacks: []string{""},
			},
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/list/invalid_stack_code.json",
		},
		{
			name: "with_multiple_stacks",
			body: request.GetListEmployeeQuery{
				Stacks: []string{"golang", "react"},
			},
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/with_multiple_stack.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/list/list.sql")
				w := httptest.NewRecorder()
				byteReq, err := json.Marshal(tt.body)
				require.Nil(t, err)

				ctx, _ := gin.CreateTestContext(w)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Request = httptest.NewRequest(http.MethodPost, "/api/v1/employees/search", bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)

				ctrl := controller.New(storeMock, txRepo, serviceMock, workerMock, loggerMock, &cfg)
				h := New(ctrl, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.List(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res, err := utils.RemoveFieldInSliceResponse(w.Body.Bytes(), "updatedAt")
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.Employee.List] response mismatched")
			})
		})
	}
}

func TestHandler_One(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	queue := make(chan model.WorkerMessage, 1000)
	workerMock := worker.New(context.Background(), queue, serviceMock, loggerMock)

	tests := []struct {
		name             string
		id               string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "happy_case",
			id:               "2655832e-f009-4b73-a535-64c3a22e558f",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/one/200.json",
		},
		{
			name:             "not_found",
			id:               "2655832e-f009-4b73-a535-64c3a22e558e",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/one/404.json",
		},
		{
			name:             "happy_case_username",
			id:               "thanh",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/one/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/one/one.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.AddParam("id", tt.id)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/employees/%s", tt.id), nil)
				ctx.Request.Header.Set("Authorization", testToken)

				ctrl := controller.New(storeMock, txRepo, serviceMock, workerMock, loggerMock, &cfg)
				h := New(ctrl, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.Details(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Employee.Details] response mismatched")
			})
		})
	}
}

func TestHandler_UpdateEmployeeStatus(t *testing.T) {
	// load env and test data
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	queue := make(chan model.WorkerMessage, 1000)
	workerMock := worker.New(context.Background(), queue, serviceMock, loggerMock)

	tests := []struct {
		name             string
		wantCode         int
		id               string
		body             request.UpdateWorkingStatusRequest
		wantResponsePath string
	}{
		{
			name:     "ok_update_employee_status",
			wantCode: http.StatusOK,
			id:       "2655832e-f009-4b73-a535-64c3a22e558f",
			body: request.UpdateWorkingStatusRequest{
				EmployeeStatus: "contractor",
			},
			wantResponsePath: "testdata/update_employee_status/200.json",
		},
		{
			name:     "empty_employee_id",
			wantCode: http.StatusBadRequest,
			id:       "",
			body: request.UpdateWorkingStatusRequest{
				EmployeeStatus: "contractor",
			},
			wantResponsePath: "testdata/update_employee_status/400.json",
		},
		{
			name:     "wrong_format_employee_id",
			wantCode: http.StatusBadRequest,
			id:       "2655832e-f009-4b73-a535-64c3a22e558fa",
			body: request.UpdateWorkingStatusRequest{
				EmployeeStatus: "contractor",
			},
			wantResponsePath: "testdata/update_employee_status/400.json",
		},
		{
			name:     "invalid_employee_status",
			wantCode: http.StatusBadRequest,
			id:       "2655832e-f009-4b73-a535-64c3a22e558f",
			body: request.UpdateWorkingStatusRequest{
				EmployeeStatus: "contractorr",
			},
			wantResponsePath: "testdata/update_employee_status/invalid_employee_status.json",
		},
		{
			name:     "employee_not_found",
			wantCode: http.StatusNotFound,
			id:       "2655832e-f009-4b73-a535-64c3a22e558d",
			body: request.UpdateWorkingStatusRequest{
				EmployeeStatus: "contractor",
			},
			wantResponsePath: "testdata/update_employee_status/404.json",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_employee_status/update_employee_status.sql")
				byteReq, err := json.Marshal(tt.body)
				require.Nil(t, err)
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Request = httptest.NewRequest(http.MethodPut, fmt.Sprintf("/api/v1/employees/%s/employee-status", tt.id), bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.AddParam("id", tt.id)

				ctrl := controller.New(storeMock, txRepo, serviceMock, workerMock, loggerMock, &cfg)
				h := New(ctrl, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.UpdateEmployeeStatus(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res, err := utils.RemoveFieldInResponse(w.Body.Bytes(), "updatedAt")
				require.Nil(t, err)

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.UpdateEmployeeStatus] response mismatched")
			})
		})
	}
}

//func Test_UpdateGeneralInfo(t *testing.T) {
//	cfg := config.LoadTestConfig()
//	loggerMock := logger.NewLogrusLogger()
//	serviceMock := service.New(&cfg, nil, nil)
//	storeMock := store.New()
//	queue := make(chan model.WorkerMessage, 1000)
//	workerMock := worker.New(context.Background(), queue, serviceMock, loggerMock)
//
//	tests := []struct {
//		name             string
//		wantCode         int
//		wantErr          bool
//		wantResponsePath string
//		body             request.UpdateEmployeeGeneralInfoInput
//		id               string
//	}{
//		{
//			name:             "ok_update_general_info",
//			wantCode:         http.StatusOK,
//			wantErr:          false,
//			wantResponsePath: "testdata/update_general_info/200.json",
//			body: request.UpdateEmployeeGeneralInfoInput{
//				FullName:    "Phạm Đức Thành",
//				Email:       "thanh@d.foundation",
//				Phone:       "0123456788",
//				DisplayName: "new",
//			},
//			id: "2655832e-f009-4b73-a535-64c3a22e558f",
//		},
//		{
//			name:             "fail_wrong_employee_id",
//			wantCode:         http.StatusNotFound,
//			wantErr:          true,
//			wantResponsePath: "testdata/update_general_info/404.json",
//			body: request.UpdateEmployeeGeneralInfoInput{
//				FullName: "Phạm Đức Thành",
//				Email:    "thanh@d.foundation",
//				Phone:    "0123456788",
//			},
//			id: "2655832e-f009-4b73-a535-64c3a22e558a",
//		},
//		{
//			name:             "empty_employee_id",
//			wantCode:         http.StatusBadRequest,
//			wantErr:          true,
//			wantResponsePath: "testdata/update_general_info/400.json",
//			body: request.UpdateEmployeeGeneralInfoInput{
//				FullName: "Phạm Đức Thành",
//				Email:    "thanh@d.foundation",
//				Phone:    "0123456788",
//			},
//			id: "",
//		},
//		{
//			name:             "wrong_format_employee_id",
//			wantCode:         http.StatusBadRequest,
//			wantErr:          true,
//			wantResponsePath: "testdata/update_general_info/400.json",
//			body: request.UpdateEmployeeGeneralInfoInput{
//				FullName: "Phạm Đức Thành",
//				Email:    "thanh@d.foundation",
//				Phone:    "0123456788",
//			},
//			id: "2655832e-f009-4b73-a535-64c3a22e558aa",
//		},
//		{
//			name:             "not_found_line_manager",
//			wantCode:         http.StatusNotFound,
//			wantErr:          true,
//			wantResponsePath: "testdata/update_general_info/line_manager_not_found.json",
//			body: request.UpdateEmployeeGeneralInfoInput{
//				FullName:      "Phạm Đức Thành",
//				Email:         "thanh@d.foundation",
//				Phone:         "0123456788",
//				LineManagerID: model.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558b"),
//			},
//			id: "2655832e-f009-4b73-a535-64c3a22e558a",
//		},
//		{
//			name:             "invalid_join_date",
//			wantCode:         http.StatusBadRequest,
//			wantErr:          true,
//			wantResponsePath: "testdata/update_general_info/invalid_join_date.json",
//			body: request.UpdateEmployeeGeneralInfoInput{
//				FullName:   "Phạm Đức Thành",
//				Email:      "thanh@d.foundation",
//				Phone:      "0123456788",
//				JoinedDate: "2006-13-12",
//			},
//			id: "2655832e-f009-4b73-a535-64c3a22e558f",
//		},
//		{
//			name:             "organization_not_found",
//			wantCode:         http.StatusNotFound,
//			wantErr:          true,
//			wantResponsePath: "testdata/update_general_info/organization_not_found.json",
//			body: request.UpdateEmployeeGeneralInfoInput{
//				FullName:        "Phạm Đức Thành",
//				Email:           "thanh@d.foundation",
//				Phone:           "0123456788",
//				OrganizationIDs: []model.UUID{model.MustGetUUIDFromString("2655832e-f009-4b73-a535-64c3a22e558f")},
//			},
//			id: "2655832e-f009-4b73-a535-64c3a22e558f",
//		},
//	}
//
//	for _, tt := range tests {
//		t.Run(tt.name, func(t *testing.T) {
//			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
//				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_general_info/update_general_info.sql")
//				byteReq, err := json.Marshal(tt.body)
//				require.Nil(t, err)
//				w := httptest.NewRecorder()
//
//				ctx, _ := gin.CreateTestContext(w)
//				bodyReader := strings.NewReader(string(byteReq))
//				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}}
//				ctx.Request = httptest.NewRequest("PUT", "/api/v1/employees/"+tt.id+"/general-info", bodyReader)
//				ctx.Request.Header.Set("Authorization", testToken)
//				ctrl := controller.New(storeMock, txRepo, serviceMock, workerMock, loggerMock, &cfg)
//				h := New(ctrl, storeMock, txRepo, serviceMock, loggerMock, &cfg)
//
//				h.UpdateGeneralInfo(ctx)
//
//				require.Equal(t, tt.wantCode, w.Code)
//				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
//				require.NoError(t, err)
//
//				res, err := utils.RemoveFieldInResponse(w.Body.Bytes(), "updatedAt")
//				require.Nil(t, err)
//
//				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.UpdateGeneralInfo] response mismatched")
//			})
//		})
//	}
//}

func Test_UpdateSkill(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	queue := make(chan model.WorkerMessage, 1000)
	workerMock := worker.New(context.Background(), queue, serviceMock, loggerMock)
	// testRepoMock := store.NewPostgresStore(&cfg)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          bool
		wantResponsePath string
		body             request.UpdateSkillsRequest
		id               string
	}{
		{
			name:             "ok_update_skill",
			wantCode:         http.StatusOK,
			wantErr:          false,
			wantResponsePath: "testdata/update_skills/200.json",
			body: request.UpdateSkillsRequest{
				Positions: []model.UUID{
					model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					model.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				Chapters:  []model.UUID{model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8")},
				Seniority: model.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5"),
				Stacks: []model.UUID{
					model.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
					model.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
				},
				LeadingChapters: []model.UUID{
					model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
				},
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558f",
		},
		{
			name:             "not_found_employee",
			wantCode:         http.StatusNotFound,
			wantErr:          true,
			wantResponsePath: "testdata/update_skills/404.json",
			body: request.UpdateSkillsRequest{
				Positions: []model.UUID{
					model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					model.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				Chapters:  []model.UUID{model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8")},
				Seniority: model.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5"),
				Stacks: []model.UUID{
					model.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
					model.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
				},
				LeadingChapters: []model.UUID{
					model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
				},
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558a",
		},
		{
			name:             "empty_employee_id",
			wantCode:         http.StatusBadRequest,
			wantErr:          true,
			wantResponsePath: "testdata/update_skills/400.json",
			body: request.UpdateSkillsRequest{
				Positions: []model.UUID{
					model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					model.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				Chapters:  []model.UUID{model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8")},
				Seniority: model.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5"),
				Stacks: []model.UUID{
					model.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
					model.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
				},
				LeadingChapters: []model.UUID{
					model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
				},
			},
			id: "",
		},
		{
			name:             "wrong_format_employee_id",
			wantCode:         http.StatusBadRequest,
			wantErr:          true,
			wantResponsePath: "testdata/update_skills/400.json",
			body: request.UpdateSkillsRequest{
				Positions: []model.UUID{
					model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					model.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				Chapters:  []model.UUID{model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8")},
				Seniority: model.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5"),
				Stacks: []model.UUID{
					model.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44f"),
					model.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
				},
				LeadingChapters: []model.UUID{
					model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
				},
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558aa",
		},
		{
			name:             "invalid_stack",
			wantCode:         http.StatusNotFound,
			wantErr:          true,
			wantResponsePath: "testdata/update_skills/stack_not_found.json",
			body: request.UpdateSkillsRequest{
				Positions: []model.UUID{
					model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
					model.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				Chapters:  []model.UUID{model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8")},
				Seniority: model.MustGetUUIDFromString("39735742-829b-47f3-8f9d-daf0983914e5"),
				Stacks: []model.UUID{
					model.MustGetUUIDFromString("0ecf47c8-cca4-4c30-94bb-054b1124c44d"),
					model.MustGetUUIDFromString("fa0f4e46-7eab-4e5c-9d31-30489e69fe2e"),
				},
				LeadingChapters: []model.UUID{
					model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
				},
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558f",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_skills/update_skills.sql")
				byteReq, err := json.Marshal(tt.body)
				require.Nil(t, err)
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}}
				ctx.Request = httptest.NewRequest("PUT", fmt.Sprintf("/api/v1/employees/%s/skills", tt.id), bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)
				ctrl := controller.New(storeMock, txRepo, serviceMock, workerMock, loggerMock, &cfg)
				h := New(ctrl, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				h.UpdateSkills(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res, err := utils.RemoveFieldInResponse(w.Body.Bytes(), "updatedAt")
				require.Nil(t, err)

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.UpdateSkills] response mismatched")
			})
		})
	}
}

func Test_Create(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	queue := make(chan model.WorkerMessage, 1000)
	workerMock := worker.New(context.Background(), queue, serviceMock, loggerMock)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          bool
		wantResponsePath string
		body             request.CreateEmployeeRequest
		id               string
	}{
		{
			name:             "exists_user_create",
			wantCode:         400,
			wantErr:          true,
			wantResponsePath: "testdata/create/existed_user.json",
			body: request.CreateEmployeeRequest{
				FullName:      "Lê Nguyễn Minh Khôi",
				DisplayName:   "Khoi Le",
				TeamEmail:     "thanh@d.foundation",
				PersonalEmail: "khoi@gmail.com",
				Positions:     []model.UUID{model.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac")},
				Salary:        300,
				SeniorityID:   model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
				Roles: []model.UUID{
					model.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				Status:     model.WorkingStatusOnBoarding.String(),
				JoinedDate: time.Now().Format("2006-01-02"),
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558f",
		},
		{
			name:             "validation_err_create",
			wantCode:         400,
			wantErr:          true,
			wantResponsePath: "testdata/create/validation_err.json",
			body: request.CreateEmployeeRequest{
				FullName:      "Lê Nguyễn Minh Khôi",
				DisplayName:   "Khoi Le",
				TeamEmail:     "thanh@d.foundation",
				PersonalEmail: "khoigmail.com",
				Positions:     []model.UUID{model.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac")},
				Salary:        300,
				SeniorityID:   model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
				Roles: []model.UUID{
					model.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				Status:     model.WorkingStatusOnBoarding.String(),
				JoinedDate: time.Now().Format("2006-01-02"),
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558f",
		},
		{
			name:             "invalid_uuid_create",
			wantCode:         404,
			wantErr:          true,
			wantResponsePath: "testdata/create/invalid_uuid.json",
			body: request.CreateEmployeeRequest{
				FullName:      "Lê Nguyễn Minh Khôi",
				DisplayName:   "Khoi Le",
				TeamEmail:     "thanh@d.foundation",
				PersonalEmail: "khoi@gmail.com",
				Positions:     []model.UUID{model.MustGetUUIDFromString("c44c987c-ad34-4745-be2b-942e8670d32a")},
				Salary:        300,
				SeniorityID:   model.MustGetUUIDFromString("11ccffea-2cc9-4e98-9bef-3464dfe4dec8"),
				Roles: []model.UUID{
					model.MustGetUUIDFromString("d796884d-a8c4-4525-81e7-54a3b6099eac"),
				},
				Status:     model.WorkingStatusOnBoarding.String(),
				JoinedDate: time.Now().Format("2006-01-02"),
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558f",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/create/create.sql")
				byteReq, err := json.Marshal(tt.body)
				require.Nil(t, err)
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}}
				ctx.Request = httptest.NewRequest("POST", "/api/v1/employees/", bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)
				ctrl := controller.New(storeMock, txRepo, serviceMock, workerMock, loggerMock, &cfg)
				h := New(ctrl, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				h.Create(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res, err := utils.RemoveFieldInResponse(w.Body.Bytes(), "updatedAt")
				require.Nil(t, err)

				require.JSONEq(t, string(expRespRaw), string(res), "[employee.Handler.Create] response mismatched")
			})
		})
	}
}

func Test_UpdatePersonalInfo(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	queue := make(chan model.WorkerMessage, 1000)
	workerMock := worker.New(context.Background(), queue, serviceMock, loggerMock)

	dob, err := time.Parse("2006-01-02", "1990-01-02")
	require.Nil(t, err)
	tests := []struct {
		name             string
		wantCode         int
		wantErr          bool
		wantResponsePath string
		body             request.UpdatePersonalInfoRequest
		id               string
	}{
		{
			name:             "ok_update_personal_info",
			wantCode:         http.StatusOK,
			wantErr:          false,
			wantResponsePath: "testdata/update_personal_info/200.json",
			body: request.UpdatePersonalInfoRequest{
				DoB:           &dob,
				Gender:        "Male",
				Address:       "Phan Huy Ich, Tan Binh District, Ho Chi Minh, Vietnam",
				PersonalEmail: "thanhpham124@gmail.com",
				Country:       "Vietnam",
				City:          "Hồ Chí Minh",
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558f",
		},
		{
			name:             "employee_not_found",
			wantCode:         http.StatusNotFound,
			wantErr:          true,
			wantResponsePath: "testdata/update_personal_info/404.json",
			body: request.UpdatePersonalInfoRequest{
				DoB:           &dob,
				Gender:        "Male",
				Address:       "Phan Huy Ich, Tan Binh District, Ho Chi Minh, Vietnam",
				PersonalEmail: "thanhpham124@gmail.com",
				Country:       "Vietnam",
				City:          "Hồ Chí Minh",
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558a",
		},
		{
			name:             "empty_employee_id",
			wantCode:         http.StatusBadRequest,
			wantErr:          true,
			wantResponsePath: "testdata/update_personal_info/400.json",
			body: request.UpdatePersonalInfoRequest{
				DoB:           &dob,
				Gender:        "Male",
				Address:       "Phan Huy Ich, Tan Binh District, Ho Chi Minh, Vietnam",
				PersonalEmail: "thanhpham124@gmail.com",
				Country:       "Vietnam",
				City:          "Hồ Chí Minh",
			},
			id: "",
		},
		{
			name:             "wrong_employee_id_format",
			wantCode:         http.StatusBadRequest,
			wantErr:          true,
			wantResponsePath: "testdata/update_personal_info/400.json",
			body: request.UpdatePersonalInfoRequest{
				DoB:           &dob,
				Gender:        "Male",
				Address:       "Phan Huy Ich, Tan Binh District, Ho Chi Minh, Vietnam",
				PersonalEmail: "thanhpham124@gmail.com",
				Country:       "Vietnam",
				City:          "Hồ Chí Minh",
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558aa",
		},
		{
			name:             "invalid_country",
			wantCode:         http.StatusBadRequest,
			wantErr:          true,
			wantResponsePath: "testdata/update_personal_info/invalid_country.json",
			body: request.UpdatePersonalInfoRequest{
				DoB:           &dob,
				Gender:        "Male",
				Address:       "Phan Huy Ich, Tan Binh District, Ho Chi Minh, Vietnam",
				PersonalEmail: "thanhpham124@gmail.com",
				Country:       "Vietnam",
				City:          "Hồ Chí Minhh",
			},
			id: "2655832e-f009-4b73-a535-64c3a22e558f",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/update_personal_info/update_personal_info.sql")
				byteReq, err := json.Marshal(tt.body)
				require.Nil(t, err)
				w := httptest.NewRecorder()

				ctx, _ := gin.CreateTestContext(w)
				bodyReader := strings.NewReader(string(byteReq))
				ctx.Params = gin.Params{gin.Param{Key: "id", Value: tt.id}}
				ctx.Request = httptest.NewRequest("PUT", "/api/v1/employees/"+tt.id+"/personal-info", bodyReader)
				ctx.Request.Header.Set("Authorization", testToken)
				ctrl := controller.New(storeMock, txRepo, serviceMock, workerMock, loggerMock, &cfg)
				h := New(ctrl, storeMock, txRepo, serviceMock, loggerMock, &cfg)

				h.UpdatePersonalInfo(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				res, _ := utils.RemoveFieldInResponse(w.Body.Bytes(), "createdAt")
				res, _ = utils.RemoveFieldInResponse(res, "updatedAt")

				require.JSONEq(t, string(expRespRaw), string(res), "[Handler.UpdatePersonalInfo] response mismatched")
			})
		})
	}
}

func TestHandler_GetLineManagers(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()
	queue := make(chan model.WorkerMessage, 1000)
	workerMock := worker.New(context.Background(), queue, serviceMock, loggerMock)

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
		menteeID         string
		id               string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_line_managers/200_ok.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_line_managers/seed.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, "/api/v1/line-managers", nil)
				ctx.Request.Header.Set("Authorization", testToken)

				ctrl := controller.New(storeMock, txRepo, serviceMock, workerMock, loggerMock, &cfg)
				h := New(ctrl, storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.GetLineManagers(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Employee.GetLineManagers] response mismatched")
			})
		})
	}
}

```

# pkg/handler/employee/employee.go

```go
package employee

import (
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/controller/employee"
	"github.com/dwarvesf/fortress-api/pkg/handler/employee/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/employee/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	controller *controller.Controller
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		controller: controller,
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
	}
}

// List godoc
// @Summary Get the list of employees
// @Description Get the list of employees with pagination and workingStatus
// @id getEmployeeList
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param Body body GetListEmployeeQuery true "Body"
// @Success 200 {object} EmployeeListDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/search [post]
func (h *handler) List(c *gin.Context) {
	// 0. Get current logged in user data
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	var body request.GetListEmployeeQuery

	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	if err := body.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "List",
		"params":  body,
	})

	workingStatuses, err := h.getWorkingStatusInput(body.WorkingStatuses, userInfo)
	if err != nil {
		l.Error(err, "failed to get working status")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
	}

	pagination := model.Pagination{
		Page: body.Pagination.Page,
		Size: body.Pagination.Size,
	}
	pagination.Standardize()

	requestBody := employee.GetListEmployeeInput{
		Pagination: pagination,

		WorkingStatuses: body.WorkingStatuses,
		Preload:         body.Preload,
		Positions:       body.Positions,
		Stacks:          body.Stacks,
		Projects:        body.Projects,
		Chapters:        body.Chapters,
		Seniorities:     body.Seniorities,
		Organizations:   body.Organizations,
		LineManagers:    body.LineManagers,
		Keyword:         body.Keyword,
	}

	employees, total, err := h.controller.Employee.List(workingStatuses, requestBody, userInfo)
	if err != nil {
		l.Error(err, "failed to get list employees")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToEmployeeListData(employees, userInfo),
		&view.PaginationResponse{Pagination: view.Pagination{Page: pagination.Page, Size: pagination.Size, Sort: pagination.Sort}, Total: total}, nil, nil, ""))
}

func (h *handler) getWorkingStatusInput(input []string, userInfo *model.CurrentLoggedUserInfo) ([]string, error) {
	// user who do not have permission
	if !authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadFilterByAllStatuses) {
		if len(input) == 0 {
			return []string{
				model.WorkingStatusOnBoarding.String(),
				model.WorkingStatusProbation.String(),
				model.WorkingStatusFullTime.String(),
				model.WorkingStatusContractor.String(),
			}, nil
		}

		var result []string

		for _, v := range input {
			if v != model.WorkingStatusLeft.String() {
				result = append(result, v)
			}
		}

		return result, nil
	}

	// user who have permission
	if len(input) == 0 {
		return []string{
			model.WorkingStatusOnBoarding.String(),
			model.WorkingStatusProbation.String(),
			model.WorkingStatusFullTime.String(),
			model.WorkingStatusContractor.String(),
			model.WorkingStatusLeft.String(),
		}, nil
	}

	return input, nil
}

// Details godoc
// @Summary Get employee by id
// @Description Get employee by id
// @id getEmployeeDetails
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Employee ID"
// @Success 200 {object} EmployeeDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/{id} [get]
func (h *handler) Details(c *gin.Context) {
	// 0. Get current logged in user data
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	// 1. parse id from uri, validate id
	id := c.Param("id")

	// 1.1 prepare the logger
	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "Details",
		"id":      id,
	})

	rs, err := h.controller.Employee.Details(id, userInfo)
	if err != nil {
		l.Error(err, "failed to get detail employees")
		errs.ConvertControllerErr(c, err)
		return
	}

	// 3. return employee
	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToOneEmployeeData(rs, userInfo), nil, nil, nil, ""))
}

// UpdateEmployeeStatus godoc
// @Summary Update account status by employee id
// @Description Update account status by employee id
// @id updateEmployeeStatus
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Employee ID"
// @Param employeeStatus body UpdateWorkingStatusRequest true "Employee Status"
// @Success 200 {object} UpdateEmployeeStatusResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/{id}/employee-status [put]
func (h *handler) UpdateEmployeeStatus(c *gin.Context) {
	employeeID := c.Param("id")
	if employeeID == "" || !model.IsUUIDFromString(employeeID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEmployeeID, nil, ""))
		return
	}

	var body request.UpdateWorkingStatusRequest
	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "UpdateEmployeeStatus",
		"id":      employeeID,
	})

	if err := body.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	emp, err := h.controller.Employee.UpdateEmployeeStatus(employeeID, employee.UpdateWorkingStatusInput{
		EmployeeStatus: model.WorkingStatus(body.EmployeeStatus),
	})
	if err != nil {
		l.Error(err, "failed to update employee status")
		errs.ConvertControllerErr(c, err)
		return
	}

	userID, _ := authutils.GetUserIDFromContext(c, h.config)

	err = h.controller.Discord.Log(model.LogDiscordInput{
		Type: "employee_update_working_status",
		Data: map[string]interface{}{
			"working_status":      emp.WorkingStatus.String(),
			"employee_id":         userID,
			"updated_employee_id": emp.ID.String(),
		},
	})
	if err != nil {
		l.Error(err, "failed to logs to discord")
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEmployeeData(emp), nil, nil, nil, ""))
}

// UpdateGeneralInfo godoc
// @Summary Update general info of the employee by id
// @Description Update general info of the employee by id
// @id updateGeneralInfo
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Employee ID"
// @Param Body body UpdateEmployeeGeneralInfoRequest true "Body"
// @Success 200 {object} UpdateGeneralEmployeeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/{id}/general-info [put]
func (h *handler) UpdateGeneralInfo(c *gin.Context) {
	employeeID := c.Param("id")
	if employeeID == "" || !model.IsUUIDFromString(employeeID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEmployeeID, nil, ""))
		return
	}

	var body request.UpdateEmployeeGeneralInfoRequest
	if err := c.ShouldBindJSON(&body); err != nil {
		if err != nil {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "UpdateGeneralInfo",
		"request": body,
	})

	requestBody := employee.UpdateEmployeeGeneralInfoInput{
		FullName:           body.FullName,
		Email:              body.Email,
		Phone:              body.Phone,
		LineManagerID:      model.UUID(body.LineManagerID),
		DisplayName:        body.DisplayName,
		GithubID:           body.GithubID,
		NotionID:           body.NotionID,
		NotionName:         body.NotionName,
		NotionEmail:        body.NotionEmail,
		DiscordName:        body.DiscordName,
		LinkedInName:       body.LinkedInName,
		LeftDate:           body.LeftDate,
		JoinedDate:         body.JoinedDate,
		OrganizationIDs:    view.ToModelUUIDs(body.OrganizationIDs),
		ReferredBy:         model.UUID(body.ReferredBy),
		WiseRecipientID:    body.WiseRecipientID,
		WiseAccountNumber:  body.WiseAccountNumber,
		WiseRecipientEmail: body.WiseRecipientEmail,
		WiseRecipientName:  body.WiseRecipientName,
		WiseCurrency:       body.WiseCurrency,
	}

	emp, err := h.controller.Employee.UpdateGeneralInfo(employeeID, requestBody)
	if err != nil {
		l.Error(err, "failed to update general info for employee")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateGeneralInfoEmployeeData(emp), nil, nil, nil, ""))
}

// Create godoc
// @Summary Create new employee
// @Description Create new employee
// @id createEmployee
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param Body body CreateEmployeeRequest true "Body"
// @Success 200 {object} EmployeeDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees [post]
func (h *handler) Create(c *gin.Context) {
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 1. parse eml data from body
	var input request.CreateEmployeeRequest

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if err := input.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	// 1.1 prepare the logger
	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "Create",
		"input":   input,
	})

	requestBody := employee.CreateEmployeeInput{
		FullName:      input.FullName,
		DisplayName:   input.DisplayName,
		TeamEmail:     input.TeamEmail,
		PersonalEmail: input.PersonalEmail,
		Positions:     input.Positions,
		Salary:        input.Salary,
		SeniorityID:   input.SeniorityID,
		Roles:         input.Roles,
		Status:        input.Status,
		ReferredBy:    input.ReferredBy,
		JoinDate:      input.GetJoinedDate(),
	}

	eml, err := h.controller.Employee.Create(userID, requestBody)
	if err != nil {
		l.Error(err, "failed to create employee")
		errs.ConvertControllerErr(c, err)
		return
	}

	// 3. return employee
	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEmployeeData(eml), nil, nil, nil, ""))
}

// UpdateSkills godoc
// @Summary Update Skill for employee by id
// @Description Update Skill for employee by id
// @id updateSkill
// @Tags Employee
// @Accept  json
// @Produce  json
// @Param id path string true "Employee ID"
// @Security BearerAuth
// @Param Body body UpdateSkillsRequest true "Body"
// @Success 200 {object} UpdateSkillsEmployeeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/{id}/skills [put]
func (h *handler) UpdateSkills(c *gin.Context) {
	employeeID := c.Param("id")
	if employeeID == "" || !model.IsUUIDFromString(employeeID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEmployeeID, nil, ""))
		return
	}

	var body request.UpdateSkillsRequest
	if err := c.ShouldBindJSON(&body); err != nil {
		if err != nil {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "UpdateSkills",
		"request": body,
	})

	requestBody := employee.UpdateSkillsInput{
		Positions:       body.Positions,
		LeadingChapters: body.LeadingChapters,
		Chapters:        body.Chapters,
		Seniority:       body.Seniority,
		Stacks:          body.Stacks,
	}

	emp, err := h.controller.Employee.UpdateSkills(h.logger, employeeID, requestBody)
	if err != nil {
		l.Error(err, "failed to update skills")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateSkillEmployeeData(emp), nil, nil, nil, ""))
}

// UpdatePersonalInfo godoc
// @Summary Update personal info of the employee by id
// @Description Update personal info of the employee by id
// @id updatePersonalInfo
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Employee ID"
// @Param Body body UpdatePersonalInfoRequest true "Body"
// @Success 200 {object} UpdatePersonalEmployeeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/{id}/personal-info [put]
func (h *handler) UpdatePersonalInfo(c *gin.Context) {
	employeeID := c.Param("id")
	if employeeID == "" || !model.IsUUIDFromString(employeeID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEmployeeID, nil, ""))
		return
	}

	var body request.UpdatePersonalInfoRequest
	if err := c.ShouldBindJSON(&body); err != nil {
		if err != nil {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
			return
		}
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "UpdatePersonalInfo",
		"request": body,
	})

	city, err := h.validateAndMappingCity(h.repo.DB(), body.Country, body.City)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	requestBody := employee.UpdatePersonalInfoInput{
		DoB:              body.DoB,
		Gender:           body.Gender,
		PlaceOfResidence: body.PlaceOfResidence,
		Address:          body.Address,
		PersonalEmail:    body.PersonalEmail,
		Country:          body.Country,
		City:             body.City,
		Lat:              city.Lat,
		Long:             city.Long,
	}

	emp, err := h.controller.Employee.UpdatePersonalInfo(employeeID, requestBody)
	if err != nil {
		l.Error(err, "failed to update personal info")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdatePersonalEmployeeData(emp), nil, nil, nil, ""))
}

func (h *handler) validateAndMappingCity(db *gorm.DB, countryName string, cityName string) (*model.City, error) {
	country, err := h.store.Country.OneByName(db, countryName)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errs.ErrCountryNotFound
		}
		return nil, err
	}

	city := country.Cities.GetCity(cityName)
	if city == nil {
		return nil, errs.ErrCityDoesNotBelongToCountry
	}

	return city, nil
}

// UploadAvatar godoc
// @Summary Upload avatar of employee by id
// @Description Upload avatar of employee by id
// @id uploadAvatar
// @Tags Employee
// @Accept  json
// @Produce  json
// @Param id path string true "Employee ID"
// @Security BearerAuth
// @Param file formData file true "avatar upload"
// @Success 200 {object} EmployeeContentDataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/{id}/upload-avatar [post]
func (h *handler) UploadAvatar(c *gin.Context) {
	// 1.1 get userID
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	uuidUserID, err := model.UUIDFromString(userID)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 1.2 parse id from uri, validate id
	var params struct {
		ID string `uri:"id" binding:"required"`
	}

	if err := c.ShouldBindUri(&params); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, params, ""))
		return
	}

	// 1.3 get upload file
	file, err := c.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, file, ""))
		return
	}

	// 1.4 prepare the logger
	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "UploadAvatar",
		"params":  params,
		// "body":    body,
	})

	filePath, err := h.controller.Employee.UploadAvatar(uuidUserID, file, employee.UploadAvatarInput{
		ID: params.ID,
	})
	if err != nil {
		l.Error(err, "failed to update avatar")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToContentData(filePath), nil, nil, nil, ""))
}

// UpdateRole godoc
// @Summary Update role by employee id
// @Description Update role by employee id
// @id updateRole
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Employee ID"
// @Param Body body UpdateRoleRequest true "body"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/{id}/roles [put]
func (h *handler) UpdateRole(c *gin.Context) {
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	var input request.UpdateRoleInput

	input.EmployeeID = c.Param("id")
	if err := c.ShouldBindJSON(&input.Body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "UpdateRole",
		"input":   input,
	})

	if err := input.Validate(); err != nil {
		l.Error(err, "validate failed")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	inputRequest := employee.UpdateRoleInput{
		EmployeeID: input.EmployeeID,
		Body: employee.UpdateRoleBody{
			Roles: input.Body.Roles,
		},
	}

	err = h.controller.Employee.UpdateRole(userID, inputRequest)
	if err != nil {
		l.Error(err, "failed to update role")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// GetLineManagers godoc
// @Summary Get the list of line managers
// @Description Get the list of line managers
// @id getLineManagerList
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} LineManagersResponse
// @Failure 500 {object} ErrorResponse
// @Router /line-managers [get]
func (h *handler) GetLineManagers(c *gin.Context) {
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler":  "employee",
		"method":   "GetLineManagers",
		"userInfo": userInfo.UserID,
	})

	managers, err := h.controller.Employee.GetLineManagers(userInfo)
	if err != nil {
		l.Error(err, "failed to get line managers")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToBasicEmployees(managers), nil, nil, nil, ""))
}

// UpdateBaseSalary godoc
// @Summary Update employee's base salary by employee and base salary id
// @Description Update employee's base salary by employee and base salary id
// @id updateBaseSalary
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Employee ID"
// @Param Body body UpdateBaseSalaryRequest true "Body"
// @Success 200 {object} UpdateBaseSalaryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/{id}/base-salary [put]
func (h *handler) UpdateBaseSalary(c *gin.Context) {
	employeeID := c.Param("id")
	if employeeID == "" || !model.IsUUIDFromString(employeeID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEmployeeID, nil, ""))
		return
	}

	var req request.UpdateBaseSalaryRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		if err != nil {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, ""))
			return
		}
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "UpdateBaseSalary",
		"request": req,
	})

	requestBody := employee.UpdateBaseSalaryInput{
		ContractAmount:        req.ContractAmount,
		CompanyAccountAmount:  req.CompanyAccountAmount,
		PersonalAccountAmount: req.PersonalAccountAmount,
		CurrencyCode:          req.CurrencyCode,
		EffectiveDate:         req.EffectiveDate,
		Batch:                 req.Batch,
	}

	emp, err := h.controller.Employee.UpdateBaseSalary(h.logger, employeeID, requestBody)
	if err != nil {
		l.Error(err, "failed to update base salary")
		errs.ConvertControllerErr(c, err)
		return
	}

	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	totalBaseSalary := req.PersonalAccountAmount + req.CompanyAccountAmount
	formattedBaseSalary := utils.FormatMoney(float64(totalBaseSalary), "VND")
	// update discord as audit log
	err = h.controller.Discord.Log(model.LogDiscordInput{
		Type: "employee_update_base_salary",
		Data: map[string]interface{}{
			"employee_id":         userID,
			"updated_employee_id": employeeID,
			"new_salary":          formattedBaseSalary,
		},
	})
	if err != nil {
		l.Error(err, "failed to logs to discord")
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToBaseSalary(emp), nil, nil, nil, ""))
}

// PublicList godoc
// @Summary Get public employees list
// @Description Get public employees list
// @id getPublicEmployeeList
// @Tags Public
// @Accept  json
// @Produce  json
// @Success 200 {object} EmployeeLocationListResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /public/employees [get]
func (h *handler) PublicList(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "PublicList",
	})

	employees, err := h.controller.Employee.ListWithLocation()
	if err != nil {
		l.Error(err, "failed to list employees")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEmployeesWithLocation(employees), nil, nil, nil, ""))
}

func (h *handler) ListByDiscordRequest(c *gin.Context) {
	// 0. Get current logged in user data
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, ""))
		return
	}

	// 1. parse id from uri, validate id
	discordID := c.Query("discord_id")
	email := c.Query("email")
	key := c.Query("key")

	// 1.1 prepare the logger
	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "ListByDiscordRequest",
	})

	rs, err := h.controller.Employee.ListByDiscordRequest(discordID, email, key, userInfo)
	if err != nil {
		l.Error(err, "failed to get detail employees")
		errs.ConvertControllerErr(c, err)
		return
	}

	// 3. return employee
	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToDiscordEmployeeListData(rs, userInfo), nil, nil, nil, ""))
}

func (h *handler) ListWithMMAScore(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "DetailByDiscord",
	})

	rs, err := h.controller.Employee.ListWithMMAScore()
	if err != nil {
		l.Error(err, "failed to get employees with mma scores")
		errs.ConvertControllerErr(c, err)
		return
	}

	// 3. return employee
	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEmployeesWithMMAScore(rs), nil, nil, nil, ""))
}

// SalaryAdvance godoc
// @Summary Salary advance by discord id
// @Description Salary advance by discord id
// @id salaryAdvance
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param salaryAdvanceRequest body SalaryAdvanceRequest true "Salary Advance Request"
// @Success 200 {object} SalaryAdvanceResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/advance-salary [post]
func (h *handler) SalaryAdvance(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "employee",
		"method":  "SalaryAdvance",
	})

	body := request.SalaryAdvanceRequest{}
	if err := c.ShouldBindJSON(&body); err != nil {
		l.Error(err, "failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	amount, err := strconv.Atoi(body.Amount)
	if err != nil {
		l.Error(err, "failed to parse amount")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	response, err := h.controller.Employee.SalaryAdvance(body.DiscordID, int64(amount))
	if err != nil {
		l.Error(err, "failed to advance salary")
		errs.ConvertControllerErr(c, err)
		return
	}

	err = h.controller.Discord.Log(model.LogDiscordInput{
		Type: "employee_advance_salary",
		Data: map[string]interface{}{
			"employee_id": response.EmployeeID,
			"amount":      fmt.Sprintf("%v ICY($%v)", response.AmountICY, response.AmountUSD),
		},
	})
	if err != nil {
		l.Error(err, "failed to create discord log")
	}

	err = h.controller.Discord.PublicAdvanceSalaryLog(model.LogDiscordInput{
		Data: map[string]interface{}{
			"icy_amount": response.AmountICY,
			"usd_amount": response.AmountUSD,
		},
	})
	if err != nil {
		l.Error(err, "failed to create discord public log")
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToSalaryAdvance(response.AmountICY, response.AmountUSD, response.TransactionID, response.TransactionHash), nil, nil, nil, ""))
}

// CheckSalaryAdvance godoc
// @Summary Check salary advance by discord id
// @Description Check salary advance by discord id
// @id checkSalaryAdvance
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param checkSalaryAdvanceRequest body SalaryAdvanceRequest true "Check Salary Advance Request"
// @Success 200 {object} CheckSalaryAdvanceResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /employees/check-advance-salary [post]
func (h *handler) CheckSalaryAdvance(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "employee",
			"method":  "CheckSalaryAdvance",
		},
	)

	body := request.SalaryAdvanceRequest{}
	if err := c.ShouldBindJSON(&body); err != nil {
		l.Error(err, "failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	amountICY, amountUSD, err := h.controller.Employee.CheckSalaryAdvance(body.DiscordID)
	if err != nil {
		l.Error(err, "failed to check advance salary")
		errs.ConvertControllerErr(c, err)
		return
	}

	// 3. return employee
	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToCheckSalaryAdvance(amountICY, amountUSD), nil, nil, nil, "ok"))
}

// SalaryAdvanceReport godoc
// @Summary List salary advance aggregated by employee
// @Description List salary advance aggregated by employee
// @id SalaryAdvanceReport
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param SalaryAdvanceReportRequest body SalaryAdvanceReportRequest true "Get List Aggregated Salary Advance Request"
// @Success 200 {object} SalaryAdvanceReportResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /discords/salary-advance-report [get]
func (h *handler) SalaryAdvanceReport(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "employee",
			"method":  "ListSalaryAdvance",
		},
	)

	input := request.SalaryAdvanceReportRequest{}
	if err := c.ShouldBindQuery(&input); err != nil {
		l.Error(err, "failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	// default size is 10
	if input.Pagination.Size == 0 {
		input.Pagination.Size = 10
	}

	// default sort by amount_icy
	if input.Pagination.Sort == "" {
		input.Pagination.Sort = "amount_icy"
	}

	// default sort is DESC
	if input.SortOrder == "" {
		input.SortOrder = model.SortOrderDESC
	}

	if !input.SortOrder.IsValid() {
		l.Error(errs.ErrInvalidSortType, "invalid sort type")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidSortType, nil, ""))
		return
	}

	result, err := h.controller.Employee.ListAggregatedSalaryAdvance(employee.ListAggregatedSalaryAdvanceInput{
		Pagination: model.Pagination{
			Page: input.Pagination.Page,
			Size: input.Pagination.Size,
			Sort: input.Pagination.Sort,
		},
		SortOrder: input.SortOrder,
		IsPaid:    input.IsPaid,
	})
	if err != nil {
		l.Error(err, "failed to list advance salary")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToSalaryAdvanceReport(*result), &view.PaginationResponse{Pagination: input.Pagination, Total: result.Count}, nil, nil, ""))
}

// GetEmployeeEarnTransactions godoc
// @Summary List earn transactions of employee
// @Description List earn transactions of employee
// @id GetEmployeeEarnTransactions
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param discord_id path string true "Employee Discord ID"
// @Param page query int false "Page"
// @Param size query int false "Size"
// @Success 200 {object} GetEmployeeEarnTransactionsResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /discords/{discord_id}/earns/transactions [get]
func (h *handler) GetEmployeeEarnTransactions(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "employee",
			"method":  "GetEmployeeEarnTransactions",
		},
	)

	discordID := c.Param("discord_id")

	input := request.GetEmployeeEarnTransactionsRequest{}
	if err := c.ShouldBindQuery(&input); err != nil {
		l.Error(err, "failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	// default size is 10
	if input.Pagination.Size == 0 {
		input.Pagination.Size = 10
	}

	result, total, err := h.controller.Employee.GetEmployeeEarnTransactions(discordID, employee.GetEmployeeEarnTransactionsInput{
		Pagination: model.Pagination{
			Page: input.Pagination.Page,
			Size: input.Pagination.Size,
			Sort: input.Pagination.Sort,
		},
	})
	if err != nil {
		l.Error(err, "failed to get employee earn transactions")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(
		view.ToEmployeeEarnsTransactions(result),
		&view.PaginationResponse{
			Pagination: view.Pagination{
				Page: input.Pagination.Page,
				Size: input.Pagination.Size,
				Sort: input.Pagination.Sort,
			},
			Total: total,
		}, nil, nil, ""))
}

// GetEmployeeTotalEarn godoc
// @Summary Get total earn of employee
// @Description Get total earn of employee
// @id GetEmployeeTotalEarn
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param discord_id path string true "Employee Discord ID"
// @Success 200 {object} GetEmployeeTotalEarnResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /discords/{discord_id}/earns/total [get]
func (h *handler) GetEmployeeTotalEarn(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "employee",
			"method":  "GetEmployeeTotalEarn",
		},
	)

	discordID := c.Param("discord_id")

	earnsICY, earnsUSD, err := h.controller.Employee.GetEmployeeTotalEarn(discordID)
	if err != nil {
		l.Error(err, "failed to get employee total earn")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.EmployeeTotalEarn{
		TotalEarnsICY: earnsICY,
		TotalEarnsUSD: earnsUSD,
	}, nil, nil, nil, ""))
}

func (h *handler) GetTotalEarn(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "employee",
			"method":  "GetTotalEarn",
		},
	)

	var err error
	to := time.Now()
	from := to.AddDate(0, 0, -30)
	if c.Query("from") != "" {
		from, err = time.Parse("2006-01-02", c.Query("from"))
		if err != nil {
			l.Error(err, "failed to parse from date")
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "invalid from date"))
			return
		}
	}
	if c.Query("to") != "" {
		to, err = time.Parse("2006-01-02", c.Query("to"))
		if err != nil {
			l.Error(err, "failed to parse to date")
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "invalid to date"))
			return
		}
	}

	earnsICY, earnsUSD, err := h.controller.Employee.GetTotalEarn(from, to)
	if err != nil {
		l.Error(err, "failed to get total earn")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.EmployeeTotalEarn{
		TotalEarnsICY: earnsICY,
		TotalEarnsUSD: earnsUSD,
	}, nil, nil, nil, ""))
}

// OfficeCheckIn
// @Summary OfficeCheckIn for employee
// @Description OfficeCheckIn for employee
// @id OfficeCheckIn
// @Tags Employee
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param Body body CheckInRequest true "OfficeCheckIn Request"
// @Success 200 {object} CheckInResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /discords/office-checkin [post]
func (h *handler) OfficeCheckIn(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "employee",
			"method":  "OfficeCheckIn",
		},
	)

	var req request.CheckInRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		l.Error(err, "failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, ""))
		return
	}

	icyAmount := 5
	// Get the current date without time
	currentDate := time.Now().Truncate(24 * time.Hour)
	var resp []view.CheckInResponse
	for _, v := range req.CheckIns {
		// Truncate the givenTime to remove the time part
		givenDate := v.Time.Truncate(24 * time.Hour)
		// check givenDate does not equal currentDate
		if currentDate.After(givenDate) || currentDate.Before(givenDate) {
			resp = append(resp, view.CheckInResponse{
				DiscordID: v.DiscordID,
				Err:       "invalid time",
			})
			continue
		}

		data := view.CheckInResponse{
			DiscordID: v.DiscordID,
		}

		r, err := h.controller.Employee.CheckIn(v.DiscordID, v.Time, float64(icyAmount))
		if err != nil {
			l.Error(err, "failed to checkin")
			data.Err = err.Error()
			resp = append(resp, data)
			continue
		}

		data.IcyAmount = r.IcyAmount
		data.TransactionID = r.TransactionID
		data.TransactionHash = r.TransactionHash
		resp = append(resp, data)
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](resp, nil, nil, nil, ""))
}

```

# pkg/handler/discord/interface.go

```go
package discord

import "github.com/gin-gonic/gin"

type IHandler interface {
	SyncDiscordInfo(c *gin.Context)
	BirthdayDailyMessage(c *gin.Context)
	OnLeaveMessage(c *gin.Context)
	ReportBraineryMetrics(c *gin.Context)
	DeliveryMetricsReport(c *gin.Context)
	SyncMemo(c *gin.Context)
	SweepMemo(c *gin.Context)
	NotifyWeeklyMemos(c *gin.Context)
	CreateScheduledEvent(c *gin.Context)
	ListScheduledEvent(c *gin.Context)
	SetScheduledEventSpeakers(c *gin.Context)
	ListDiscordResearchTopics(c *gin.Context)
	UserOgifStats(c *gin.Context)
	OgifLeaderboard(c *gin.Context)
	SweepOgifEvent(c *gin.Context)
}

```

# pkg/handler/discord/discord.go

```go
package discord

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/bwmarrin/discordgo"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/handler/discord/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/service/mochiprofile"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/store/discordevent"
	"github.com/dwarvesf/fortress-api/pkg/store/employee"
	"github.com/dwarvesf/fortress-api/pkg/store/onleaverequest"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	controller *controller.Controller
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
}

func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		controller: controller,
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
	}
}

const (
	discordReadingChannel           = "1225085624260759622"
	discordRandomChannel            = "788084358991970337"
	discordPlayGroundReadingChannel = "1119171172198797393"
)

func (h *handler) SyncDiscordInfo(c *gin.Context) {
	guildMembers, err := h.service.Discord.GetMembers()
	if err != nil {
		h.logger.Error(err, "failed to get guild members")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	for _, member := range guildMembers {
		if member.User.Bot {
			continue
		}

		communityProfile := model.DiscordAccount{
			DiscordID:       member.User.ID,
			PersonalEmail:   member.User.Email,
			DiscordUsername: member.User.Username,
			Roles:           member.Roles,         // currently an array of Discord role_id(s)
			MemoUsername:    member.User.Username, // default memo username is discord username
		}

		mochiPrf, err := h.service.MochiProfile.GetProfileByDiscordID(member.User.ID)
		if err == nil {
			for _, account := range mochiPrf.AssociatedAccounts {
				if account.Platform == mochiprofile.ProfilePlatformGithub {
					communityProfile.GithubUsername = fmt.Sprintf("%v", account.PlatformMetadata["username"])
				}
			}
		}

		_, err = h.store.DiscordAccount.Upsert(h.repo.DB(), &communityProfile)
		if err != nil {
			h.logger.Error(err, "failed to upsert discord account")
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// BirthdayDailyMessage check if today is birthday of any employee in the system
// if yes, send birthday message to employee through discord
func (h *handler) BirthdayDailyMessage(c *gin.Context) {
	// check app run mode
	projectID := consts.OperationID
	todoListID := consts.BirthdayToDoListID

	if h.config.Env != "prod" {
		projectID = consts.PlaygroundID
		todoListID = consts.PlaygroundBirthdayTodoID
	}

	//random message pool
	pool := []string{
		`Dear %s, we wish you courage and persistence in reaching all your greatest goals. Have a great birthday!`,
		`Happy Birthday to %s. No one knows your real age, except God, Human Resources and you yourself. Enjoy the blast!`,
		`Happy Birthday, %s! Thank you for being such a great team player and for giving us a perfect excuse to party on a weekday! Let's go grab a drink!`,
		`Just so you know you'd look much younger if not for working in this field :) Happy Birthday, %s`,
		`Congratulation on a great day! Here's to another year closer of retiring! Happy Birthday, %s!`,
		`%s, thank you for being a part of making this company more lively and cheerful. Wish you all the best in this special day.`,
		`Dear %s, we wish you a great birthday and a memorable year. From all the Dwarves brothers.`,
		`I can’t believe you are still single – lol. I hope you have a super day and get everything you want like a companion to share it with. Happy birthday to %s!`,
		`Here’s to another year of version controlling, bug reports, and comments about the documentation looking like code. Happy birthday, mate %s!`,
		`Hope your birthday loops run smoothly and that you don’t break out of the for loop too soon. Cheers, %s!`,
		`Happy birthday, %s. May your code works perfectly the first time you ran it.`,
		`I wish you could have a programming language that does not need compiling, installing, or debugging to run perfectly on the first run. Have a happy birthday, %s`,
	}

	// query active user
	filter := employee.EmployeeFilter{
		WorkingStatuses: []string{"full-time"},
	}

	employees, _, err := h.store.Employee.All(h.repo.DB(), filter, model.Pagination{
		Page: 0,
		Size: 1000,
	})
	if err != nil {
		h.logger.Error(err, "failed to get employees")
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// format message if there is user's birthday
	var names string
	var birthDateNames []string
	todayDate := time.Now().Format("01/02")
	for _, e := range employees {
		now := time.Now()
		if now.Day() == e.DateOfBirth.Day() && now.Month() == e.DateOfBirth.Month() {
			if e.DiscordAccount != nil && e.DiscordAccount.DiscordID != "" {
				discordID := e.DiscordAccount.DiscordID
				names += fmt.Sprintf("<@%s>, ", discordID)
				birthDateNames = append(birthDateNames, e.FullName)
			}
		}
	}

	if len(birthDateNames) == 0 {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "no birthday today"))
		return
	}

	rand.New(rand.NewSource(time.Now().Unix()))
	msg := fmt.Sprintf(pool[rand.Intn(len(pool))], strings.TrimSuffix(names, ", "))

	//send message to Discord channel
	var discordMsg model.DiscordMessage
	discordMsg, err = h.service.Discord.PostBirthdayMsg(msg)
	if err != nil {
		h.logger.Error(err, "failed to post Discord message")
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, discordMsg, ""))
		return
	}

	//Make Basecamp todos
	for _, birthDateName := range birthDateNames {
		birthDayTodo := bcModel.Todo{
			Title:   fmt.Sprintf("Prepare gift for %s, %s", birthDateName, todayDate),
			Content: fmt.Sprintf("Prepare gift for %s, %s", birthDateName, todayDate),
		}
		_, err := h.service.Basecamp.Todo.Create(projectID, todoListID, birthDayTodo)
		if err != nil {
			h.logger.Error(err, "failed create Basecamp todo")
			c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, birthDateName, "k"))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// OnLeaveMessage check if today is birthday of any employee in the system
// if yes, send birthday message to employee thru discord
func (h *handler) OnLeaveMessage(c *gin.Context) {
	todayDate := time.Now().Format("2006-01-02")
	onLeaveData, err := h.store.OnLeaveRequest.All(h.repo.DB(), onleaverequest.GetOnLeaveInput{Date: todayDate})
	if err != nil {
		h.logger.Error(err, "failed to get employees")
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	if len(onLeaveData) == 0 {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "there is no one on leave today"))
		return
	}

	var names string
	for _, e := range onLeaveData {
		names += fmt.Sprintf("<@%s>, ", e.Creator.DiscordAccount.DiscordID)
	}

	msg := fmt.Sprintf("Please be notified that %s will be absent today", strings.TrimSuffix(names, ", "))

	discordMsg, err := h.service.Discord.SendMessage(model.DiscordMessage{
		Content: msg,
	}, h.config.Discord.Webhooks.AuditLog)
	if err != nil {
		h.logger.Error(err, "failed to post Discord message")
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, discordMsg, ""))
		return
	}

	h.logger.Infof("Discord message sent: %s", msg)
	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// ReportBraineryMetrics reports brainery metrics to a channel
func (h *handler) ReportBraineryMetrics(c *gin.Context) {
	body := request.BraineryReportInput{}
	if err := c.ShouldBindJSON(&body); err != nil {
		h.logger.Error(err, "failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}
	if err := body.Validate(); err != nil {
		h.logger.Errorf(err, "failed to validate data", "body", body)
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}
	now := time.Now()
	if body.View == "monthly" {
		now = now.Add(-24 * time.Hour)
	}

	latestPosts, logs, ncids, err := h.controller.BraineryLog.GetMetrics(now, body.View)
	if err != nil {
		h.logger.Error(err, "failed to get brainery metrics")
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	metrics := view.ToBraineryMetric(latestPosts, logs, ncids, body.View)

	//send message to Discord channel
	var discordMsg *discordgo.Message
	discordMsg, err = h.service.Discord.ReportBraineryMetrics(body.View, &metrics, body.ChannelID)
	if err != nil {
		h.logger.Error(err, "failed to report brainery metrics discord message")
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, discordMsg, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

func (h *handler) DeliveryMetricsReport(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "discord",
			"method":  "DeliveryMetricsReport",
		},
	)

	in := request.DeliveryMetricReportInput{}
	if err := c.ShouldBindJSON(&in); err != nil {
		l.Error(err, "failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, ""))
		return
	}

	if err := in.Validate(); err != nil {
		l.Errorf(err, "failed to validate data", "body", in)
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, ""))
		return
	}

	if in.Sync {
		err := h.controller.DeliveryMetric.Sync()
		if err != nil {
			l.Errorf(err, "failed sync latest data", "body", in)
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, ""))
			return
		}
	}

	if in.View == "weekly" {
		report, err := h.controller.DeliveryMetric.GetWeeklyReport()
		if err != nil {
			l.Errorf(err, "failed to get delivery metric weekly report", "body", in)
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, ""))
			return
		}

		leaderBoard, err := h.controller.DeliveryMetric.GetWeeklyLeaderBoard()
		if err != nil {
			l.Errorf(err, "failed to get delivery metric weekly report", "body", in)
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, ""))
			return
		}

		reportView := view.ToDeliveryMetricWeeklyReport(report)
		leaderBoardView := view.ToDeliveryMetricLeaderBoard(leaderBoard)

		discordMsg, err := h.service.Discord.DeliveryMetricWeeklyReport(reportView, leaderBoardView, in.ChannelID)
		if err != nil {
			h.logger.Error(err, "failed to post Discord message")
			c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, discordMsg, ""))
			return
		}
	}

	if in.View == "monthly" {
		report, err := h.controller.DeliveryMetric.GetMonthlyReport()
		if err != nil {
			l.Errorf(err, "failed to get delivery metric weekly report", "body", in)
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, ""))
			return
		}

		currentMonthReport := report.Reports[0]
		previousMonthReport := report.Reports[1]

		if in.OnlyCompletedMonth {
			currentMonthReport = report.Reports[1]
			previousMonthReport = report.Reports[2]
		}

		leaderBoard, err := h.controller.DeliveryMetric.GetMonthlyLeaderBoard(currentMonthReport.Month)
		if err != nil {
			l.Errorf(err, "failed to get delivery metric weekly report", "body", in)
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, ""))
			return
		}

		reportView := view.ToDeliveryMetricMonthlyReport(currentMonthReport, previousMonthReport)
		leaderBoardView := view.ToDeliveryMetricLeaderBoard(leaderBoard)

		discordMsg, err := h.service.Discord.DeliveryMetricMonthlyReport(reportView, leaderBoardView, in.ChannelID)
		if err != nil {
			h.logger.Error(err, "failed to post Discord message")
			c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, discordMsg, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// SyncMemo syncs memologs from the source memo.d.foundation
func (h *handler) SyncMemo(c *gin.Context) {
	targetChannelID := discordPlayGroundReadingChannel
	if h.config.Env == "prod" {
		targetChannelID = discordRandomChannel
	}

	memos, err := h.controller.MemoLog.Sync()
	if err != nil {
		h.logger.Error(err, "failed to sync memologs")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	if len(memos) == 0 {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "no new memo"))
		return
	}

	_, err = h.service.Discord.SendNewMemoMessage(h.config.Discord.IDs.DwarvesGuild, memos, targetChannelID)
	if err != nil {
		h.logger.Error(err, "failed to send new memo message")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// SweepMemo sweeps memologs
func (h *handler) SweepMemo(c *gin.Context) {
	err := h.controller.MemoLog.Sweep()
	if err != nil {
		h.logger.Error(err, "failed to sweep memologs")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

func (h *handler) NotifyWeeklyMemos(c *gin.Context) {
	// get last 7 days
	end := time.Now()
	start := end.AddDate(0, 0, -7)

	var weekRangeStr string
	startDay := start.Day()
	endDay := end.Day()
	startMonth := strings.ToUpper(start.Month().String())
	endMonth := strings.ToUpper(end.Month().String())
	if startMonth == endMonth {
		weekRangeStr = fmt.Sprintf("%v - %v %v", startDay, endDay, startMonth)
	} else {
		weekRangeStr = fmt.Sprintf("%v %v - %v %v", startDay, startMonth, endDay, endMonth)
	}

	memos, err := h.store.MemoLog.GetLimitByTimeRange(h.repo.DB(), &start, &end, 1000)
	if err != nil {
		h.logger.Error(err, "failed to retrieve weekly memos")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	if len(memos) == 0 {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "no new memos in this week"))
		return
	}

	targetChannelID := discordPlayGroundReadingChannel
	if h.config.Env == "prod" {
		targetChannelID = discordRandomChannel
	}

	_, err = h.service.Discord.SendWeeklyMemosMessage(h.config.Discord.IDs.DwarvesGuild, memos, weekRangeStr, targetChannelID)
	if err != nil {
		h.logger.Error(err, "failed to send weekly memos report")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// CreateScheduledEvent create new DF guild discord event
func (h *handler) CreateScheduledEvent(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "discord",
			"method":  "CreateScheduledEvent",
		},
	)

	in := request.DiscordEventInput{}
	if err := c.ShouldBindJSON(&in); err != nil {
		l.Error(err, "failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, ""))
		return
	}

	if err := in.Validate(); err != nil {
		l.Errorf(err, "failed to validate data", "body", in)
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, ""))
		return
	}

	// check if event already exists
	if _, err := h.store.DiscordEvent.
		One(h.repo.DB(),
			&discordevent.Query{DiscordEventID: in.ID}); !errors.Is(err, gorm.ErrRecordNotFound) {
		l.Errorf(err, "cannot find discord event", "body", in)
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, ""))
		return
	}

	evtType, err := in.EventType()
	if err != nil {
		l.Errorf(err, "failed to set event type", "body", in)
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, ""))
		return
	}

	// create event
	e := &model.Event{
		DiscordEventID:   in.ID,
		DiscordChannelID: in.DiscordChannelID,
		DiscordCreatorID: in.DiscordCreatorID,
		Name:             in.Name,
		Description:      in.Description,
		Date:             in.Date,
		EventType:        evtType,
		Image:            in.Image,
	}
	_, err = h.store.DiscordEvent.Create(h.repo.DB(), e)
	if err != nil {
		h.logger.Error(err, "failed to create event")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// create youtube broadcast
	if evtType == model.DiscordScheduledEventTypeOGIF {
		err = h.service.Youtube.CreateBroadcast(e)
		if err != nil {
			h.logger.Error(err, "failed to create youtube broadcast")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// ListScheduledEvent returns list of scheduled events
func (h *handler) ListScheduledEvent(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "discord",
			"method":  "ListScheduledEvent",
		},
	)

	var err error

	// get scheduled events from discord
	discordScheduledEvents, err := h.service.Discord.ListEvents()
	if err != nil {
		l.Error(err, "failed to get scheduled events")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	eventIDs := make([]string, 0)
	for _, e := range discordScheduledEvents {
		eventIDs = append(eventIDs, e.ID)
	}

	// Get future events
	now := time.Now()
	events, err := h.store.DiscordEvent.All(h.repo.DB(), &discordevent.Query{
		DiscordEventIDs: eventIDs,
	}, false)
	if err != nil {
		l.Error(err, "failed to get events")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	mapUpcomingEvents := make(map[string]bool)
	for _, e := range events {
		mapUpcomingEvents[e.DiscordEventID] = true
	}

	// Get completed events in the last 7 days, sometimes we need to update these events
	// If the event has date in the future, but cannot be found in discord, it means it has been done earlier
	after := now.AddDate(0, 0, -7)
	completedEvents, err := h.store.DiscordEvent.All(h.repo.DB(), &discordevent.Query{
		After: &after,
	}, false)
	if err != nil {
		l.Error(err, "failed to get completed events")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	for i := range completedEvents {
		event := completedEvents[i]
		if _, ok := mapUpcomingEvents[event.DiscordEventID]; ok {
			continue
		}

		event.IsOver = true
		events = append(events, event)
	}

	sort.Slice(events, func(i, j int) bool {
		return events[i].Date.After(events[j].Date)
	})

	c.JSON(http.StatusOK, view.CreateResponse[any](events, nil, nil, nil, "ok"))
}

// SetScheduledEventSpeakers sets speakers for a scheduled event
func (h *handler) SetScheduledEventSpeakers(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "discord",
			"method":  "SetScheduledEventSpeakers",
		},
	)

	in := []request.DiscordEventSpeakerInput{}
	if err := c.ShouldBindJSON(&in); err != nil {
		l.Error(err, "failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, ""))
		return
	}

	for _, i := range in {
		if err := i.Validate(); err != nil {
			l.Errorf(err, "failed to validate data", "body", in)
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, ""))
			return
		}
	}

	// get event
	discordEventID := c.Param("id")
	event, err := h.store.DiscordEvent.One(h.repo.DB(), &discordevent.Query{DiscordEventID: discordEventID})
	if err != nil {
		l.Errorf(err, "failed to get event", "body", in)
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, ""))
		return
	}

	// delete all speakers
	if err = h.store.EventSpeaker.DeleteAllByEventID(h.repo.DB(), event.ID.String()); err != nil {
		l.Errorf(err, "failed to delete all speakers", "body", in)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, ""))
		return
	}

	event.EventSpeakers = make([]model.EventSpeaker, 0)

	// get speakers
	for _, i := range in {
		speaker, err := h.store.DiscordAccount.OneByDiscordID(h.repo.DB(), i.ID)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			discordUser, err := h.service.Discord.GetMember(i.ID)
			if err != nil {
				l.Errorf(err, "failed to get discord user", "body", in)
				c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, ""))
				return
			}

			speaker = &model.DiscordAccount{
				DiscordID:       i.ID,
				DiscordUsername: discordUser.User.Username,
			}

			_, err = h.store.DiscordAccount.Upsert(h.repo.DB(), speaker)
			if err != nil {
				l.Errorf(err, "failed to upsert speaker", "body", in)
				c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, ""))
				return
			}
		} else if err != nil {
			l.Errorf(err, "failed to get speaker", "body", in)
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, ""))
			return
		}

		event.EventSpeakers = append(event.EventSpeakers, model.EventSpeaker{
			EventID:          event.ID,
			DiscordAccountID: speaker.ID,
			Topic:            i.Topic,
		})
	}

	// set speakers
	err = h.store.DiscordEvent.SetSpeakers(h.repo.DB(), event)
	if err != nil {
		l.Errorf(err, "failed to set speakers", "body", in)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToDiscordEvent(*event), nil, nil, nil, ""))
}

// ListDiscordResearchTopics godoc
// @Summary Get list of research topics on discord
// @Description Get list of research topics on discord
// @id ListDiscordResearchTopics
// @Tags Discord
// @Accept  json
// @Produce  json
// @Param page query string false "Page"
// @Param size query string false "Size"
// @Success 200 {object} ListResearchTopicResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /discords/research-topics [get]
func (h *handler) ListDiscordResearchTopics(c *gin.Context) {
	var query model.Pagination
	if err := c.ShouldBindQuery(&query); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "bind query failed"))
		return
	}
	query.Standardize()

	limit, offset := query.ToLimitOffset()

	// Default by last 7 days, 0 is get all
	inputDays := c.Query("days")
	if inputDays == "" {
		inputDays = "7"
	}
	days, err := strconv.Atoi(inputDays)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "invalid days query"))
	}

	topics, total, err := h.controller.Discord.ListDiscordResearchTopics(context.Background(), days, limit, offset)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(view.ToListResearchTopicResponse(topics),
		&view.PaginationResponse{
			Pagination: view.Pagination{
				Page: query.Page,
				Size: query.Size,
			},
			Total: total,
		}, nil, nil, ""))
}

func (h *handler) UserOgifStats(c *gin.Context) {
	discordID := c.Query("discordID")
	if discordID == "" {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errors.New("discord_id is required"), nil, ""))
		return
	}

	var afterTime time.Time
	after := c.Query("after")
	if after != "" {
		var err error
		afterTime, err = time.Parse(time.RFC3339, after)
		if err != nil {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errors.New("invalid after time format"), nil, ""))
			return
		}
	}

	stats, err := h.controller.Discord.UserOgifStats(c.Request.Context(), discordID, afterTime)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, errors.New("discord_id is required"), nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(stats, nil, nil, nil, ""))
}

func (h *handler) OgifLeaderboard(c *gin.Context) {
	var afterTime time.Time
	after := c.Query("after")
	if after != "" {
		var err error
		afterTime, err = time.Parse(time.RFC3339, after)
		if err != nil {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errors.New("invalid after time format"), nil, ""))
			return
		}
	}

	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

	leaderboard, err := h.controller.Discord.GetOgifLeaderboard(c.Request.Context(), afterTime, limit)
	if err != nil {
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse(leaderboard, nil, nil, nil, ""))
}

func (h *handler) SweepOgifEvent(c *gin.Context) {
	err := h.controller.Event.SweepOgifEvent(c.Request.Context())
	if err != nil {
		h.logger.Error(err, "failed to sweep events")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "events swept successfully"))
}

```

# pkg/handler/deliverymetric/sync.go

```go
package deliverymetric

import (
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/gin-gonic/gin"
	"net/http"
)

func (h *handler) Sync(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "deliverymetric",
			"method":  "Sync",
		},
	)

	err := h.controller.DeliveryMetric.Sync()
	if err != nil {
		l.Errorf(err, "failed to create delivery metric")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

```

# pkg/handler/deliverymetric/new.go

```go
package deliverymetric

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type handler struct {
	controller *controller.Controller
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		controller: controller,
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
	}
}

```

# pkg/handler/deliverymetric/interface.go

```go
package deliverymetric

import "github.com/gin-gonic/gin"

type IHandler interface {
	GetWeeklyReport(c *gin.Context)
	GetMonthlyReport(c *gin.Context)
	GetWeeklyLeaderBoard(c *gin.Context)
	GetMonthlyLeaderBoard(c *gin.Context)

	GetWeeklyReportDiscordMsg(c *gin.Context)
	GetMonthlyReportDiscordMsg(c *gin.Context)

	Sync(c *gin.Context)
}

```

# pkg/handler/deliverymetric/get.go

```go
package deliverymetric

import (
	"net/http"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/logger"
)

func (h *handler) GetWeeklyReport(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "delivery",
		"method":  "GetWeeklyReport",
	})

	// Get data of current week
	report, err := h.controller.DeliveryMetric.GetWeeklyReport()
	if err != nil {
		l.Error(err, "failed to get weekly report")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "failed to get weekly report"))
		return
	}

	// Return data
	c.JSON(http.StatusOK, view.CreateResponse[any](report, nil, nil, nil, ""))
}

func (h *handler) GetMonthlyReport(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "delivery",
		"method":  "GetMonthlyReport",
	})

	// Get data of current month
	report, err := h.controller.DeliveryMetric.GetMonthlyReport()
	if err != nil {
		l.Error(err, "failed to get monthly report")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "failed to get monthly report"))
		return
	}

	// Return data
	c.JSON(http.StatusOK, view.CreateResponse[any](report, nil, nil, nil, ""))
}

func (h *handler) GetWeeklyLeaderBoard(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "delivery",
		"method":  "GetWeeklyLeaderBoard",
	})

	// Get data of current week
	report, err := h.controller.DeliveryMetric.GetWeeklyLeaderBoard()
	if err != nil {
		l.Error(err, "failed to get weekly leaderboard")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "failed to get weekly leaderboard"))
		return
	}

	// Return data
	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToDeliveryMetricLeaderBoard(report), nil, nil, nil, ""))
}

func (h *handler) GetMonthlyLeaderBoard(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "delivery",
		"method":  "GetMonthlyLeaderBoard",
	})

	var month *time.Time
	if c.Query("month") != "" {
		m, err := time.Parse(time.RFC3339, c.Query("month"))
		if err != nil {
			l.Error(err, "failed to parse month")
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "failed to parse month"))
			return
		}
		month = &m
	}

	// Get data of current month
	report, err := h.controller.DeliveryMetric.GetMonthlyLeaderBoard(month)
	if err != nil {
		l.Error(err, "failed to get monthly leaderboard")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "failed to get monthly leaderboard"))
		return
	}

	// Return data
	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToDeliveryMetricLeaderBoard(report), nil, nil, nil, ""))
}

```

# pkg/handler/deliverymetric/discord_msg.go

```go
package deliverymetric

import (
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service/discord"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/gin-gonic/gin"
)

func (h *handler) GetWeeklyReportDiscordMsg(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "delivery",
		"method":  "GetWeeklyReportDiscordMsg",
	})

	report, err := h.controller.DeliveryMetric.GetWeeklyReport()
	if err != nil {
		l.Errorf(err, "failed to get delivery metric weekly report", "body")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	leaderBoard, err := h.controller.DeliveryMetric.GetWeeklyLeaderBoard()
	if err != nil {
		l.Errorf(err, "failed to get delivery metric weekly report")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	reportView := view.ToDeliveryMetricWeeklyReport(report)
	leaderBoardView := view.ToDeliveryMetricLeaderBoard(leaderBoard)

	msg := discord.CreateDeliveryMetricWeeklyReportMessage(reportView, leaderBoardView)
	c.JSON(http.StatusOK, view.CreateResponse[any](msg, nil, nil, nil, ""))
}

func (h *handler) GetMonthlyReportDiscordMsg(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "delivery",
		"method":  "GetMonthlyReportDiscordMsg",
	})

	report, err := h.controller.DeliveryMetric.GetMonthlyReport()
	if err != nil {
		l.Errorf(err, "failed to get delivery metric weekly report")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	currentMonthReport := report.Reports[1]
	previousMonthReport := report.Reports[2]

	if c.Query("to-now") == "true" {
		currentMonthReport = report.Reports[0]
		previousMonthReport = report.Reports[1]
	}

	leaderBoard, err := h.controller.DeliveryMetric.GetMonthlyLeaderBoard(currentMonthReport.Month)
	if err != nil {
		l.Errorf(err, "failed to get delivery metric weekly report")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	reportView := view.ToDeliveryMetricMonthlyReport(currentMonthReport, previousMonthReport)
	leaderBoardView := view.ToDeliveryMetricLeaderBoard(leaderBoard)

	msg := discord.CreateDeliveryMetricMonthlyReportMessage(reportView, leaderBoardView)
	c.JSON(http.StatusOK, view.CreateResponse[any](msg, nil, nil, nil, ""))
}

```

# pkg/handler/conversionrate/interface.go

```go
package conversionrate

import "github.com/gin-gonic/gin"

type IHandler interface {
	List(c *gin.Context)
	Sync(c *gin.Context)
}

```

# pkg/handler/conversionrate/conversion_rate.go

```go
package conversionrate

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
	controller *controller.Controller
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
		controller: controller,
	}
}

func (h *handler) List(c *gin.Context) {
	//l := h.logger.Fields(logger.Fields{
	//	"handler": "conversionRate",
	//	"method":  "List",
	//})

	//clients, err := h.controller.Client.List(c)
	//if err != nil {
	//	l.Error(err, "failed to get client list")
	//	c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
	//	return
	//}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

func (h *handler) Sync(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "conversionRate",
		"method":  "Sync",
	})

	err := h.controller.ConversionRate.Sync(c)
	if err != nil {
		l.Error(err, "failed to sync")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

```

# pkg/handler/companyinfo/interface.go

```go
package companyinfo

import "github.com/gin-gonic/gin"

type IHandler interface {
	List(c *gin.Context)
}

```

# pkg/handler/companyinfo/company_info.go

```go
package companyinfo

import (
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/view"
	"github.com/gin-gonic/gin"
)

type handler struct {
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
	controller *controller.Controller
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
		controller: controller,
	}
}

// List godoc
// @Summary Get all company info
// @Description Get all company info
// @id get list of company info
// @Tags Client
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} view.GetListCompanyInfoResponse
// @Failure 500 {object} ErrorResponse
// @Router /company-infos [get]
func (h *handler) List(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "companyInfo",
		"method":  "List",
	})

	companyInfos, err := h.controller.CompanyInfo.List(c)
	if err != nil {
		l.Error(err, "failed to get company info list")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToCompanyInfos(companyInfos), nil, nil, nil, ""))
}

```

# pkg/handler/dashboard/interface.go

```go
package dashboard

import "github.com/gin-gonic/gin"

type IHandler interface {
	GetProjectSizes(c *gin.Context)
	GetWorkSurveys(c *gin.Context)
	GetActionItemReports(c *gin.Context)
	GetEngineeringHealth(c *gin.Context)
	GetAudits(c *gin.Context)
	GetActionItemSquashReports(c *gin.Context)
	GetSummary(c *gin.Context)
	GetResourcesAvailability(c *gin.Context)
	GetEngagementInfo(c *gin.Context)
	GetEngagementInfoDetail(c *gin.Context)
	GetResourceUtilization(c *gin.Context)
	GetWorkUnitDistribution(c *gin.Context)
	GetWorkUnitDistributionSummary(c *gin.Context)
	GetResourceWorkSurveySummaries(c *gin.Context)
}

```

# pkg/handler/dashboard/dashboard_test.go

```go
package dashboard

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/golang/mock/gomock"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/require"

	"github.com/dwarvesf/fortress-api/pkg/config"
	utilMock "github.com/dwarvesf/fortress-api/pkg/handler/dashboard/util/mocks"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils/testhelper"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
)

const testToken = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjk1ODMzMzA5NDUsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIn0.oIdlwWGBy4E1CbSoEX6r2B6NQLbew_J-RttpAcg6w8M"

func TestHandler_GetProjectSizes(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		query            string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "ok",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/project_sizes/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/project_sizes/project_sizes.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, "/api/v1/dashboards/projects/sizes", nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.URL.RawQuery = tt.query

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetProjectSizes(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetProjectSizes] response mismatched")
			})
		})
	}
}

//func TestHandler_GetResourceWorkSurveySummaries(t *testing.T) {
//	cfg := config.LoadTestConfig()
//	loggerMock := logger.NewLogrusLogger()
//	serviceMock := service.New(&cfg, nil, nil)
//	storeMock := store.New()
//
//	tests := []struct {
//		name             string
//		wantCode         int
//		wantResponsePath string
//		query            string
//	}{
//		{
//			name:             "happy_case",
//			wantCode:         http.StatusOK,
//			wantResponsePath: "testdata/get_resource_work_survey_summaries/200.json",
//		},
//		{
//			name:             "query_by_keyword",
//			wantCode:         http.StatusOK,
//			wantResponsePath: "testdata/get_resource_work_survey_summaries/200_with_keyword.json",
//			query:            "keyword=nam",
//		},
//	}
//	for _, tt := range tests {
//		t.Run(tt.name, func(t *testing.T) {
//			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
//				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_resource_work_survey_summaries/seed.sql")
//				w := httptest.NewRecorder()
//				ctx, _ := gin.CreateTestContext(w)
//				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/dashboards/resources/work-survey-summaries?%s", tt.query), nil)
//				ctx.Request.URL.RawQuery = tt.query
//				ctx.Request.Header.Set("Authorization", testToken)
//
//				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
//				h.GetResourceWorkSurveySummaries(ctx)
//				require.Equal(t, tt.wantCode, w.Code)
//				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
//				require.NoError(t, err)
//
//				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetResourceWorkSurveySummaries] response mismatched")
//			})
//		})
//	}
//}

func TestHandler_GetWorkSurveys(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
		query            string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/work_surveys/200.json",
		},
		{
			name:             "happy_case_with_project_id",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/work_surveys/200_with_project_id.json",
			query:            "projectID=8dc3be2e-19a4-4942-8a79-56db391a0b15",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/work_surveys/work_surveys.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/dashboards/projects/work-surveys?%s", tt.query), nil)
				ctx.Request.URL.RawQuery = tt.query
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetWorkSurveys(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetWorkSurveys] response mismatched")
			})
		})
	}
}

func TestHandler_GetActionItemReports(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
		query            string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/action_items/200.json",
		},
		{
			name:             "happy_case_with_project_id",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/action_items/200_with_project_id.json",
			query:            "projectID=8dc3be2e-19a4-4942-8a79-56db391a0b15",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/action_items/action_items.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/dashboards/projects/action-items?%s", tt.query), nil)
				ctx.Request.URL.RawQuery = tt.query
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetActionItemReports(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetActionItemReports] response mismatched")
			})
		})
	}
}

func TestHandler_GetEngineeringHealth(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
		query            string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/engineering_healths/200_without_project_id.json",
		},
		{
			name:             "happy_case_with_project_id",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/engineering_healths/200_with_project_id.json",
			query:            "projectID=8dc3be2e-19a4-4942-8a79-56db391a0b15",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/engineering_healths/engineering_healths.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/dashboards/projects/engineering-healths?%s", tt.query), nil)
				ctx.Request.URL.RawQuery = tt.query
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetEngineeringHealth(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetEngineeringHealth] response mismatched")
			})
		})
	}
}

func TestHandler_GetAudits(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
		query            string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/audits/200_without_project_id.json",
		},
		{
			name:             "happy_case_with_project_id",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/audits/200_with_project_id.json",
			query:            "projectID=8dc3be2e-19a4-4942-8a79-56db391a0b15",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/audits/audits.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/dashboards/projects/audits?%s", tt.query), nil)
				ctx.Request.URL.RawQuery = tt.query
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetAudits(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetAudits] response mismatched")
			})
		})
	}
}

func TestHandler_GetActionItemSquashReports(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
		query            string
	}{
		{
			name:             "worse_case_with_project_id",
			wantCode:         http.StatusNotFound,
			wantResponsePath: "testdata/action_item_squash/project_not_found.json",
			query:            "projectID=8dc3be2e-19a4-4942-8a79-56db391a0b13",
		},
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/action_item_squash/200.json",
		},
		{
			name:             "happy_case_with_project_id",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/action_item_squash/200_with_project_id.json",
			query:            "projectID=8dc3be2e-19a4-4942-8a79-56db391a0b15",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/action_item_squash/action_items.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/dashboards/projects/action-item-squash?%s", tt.query), nil)
				ctx.Request.URL.RawQuery = tt.query
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetActionItemSquashReports(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetActionItemReports] response mismatched")
			})
		})
	}
}

func TestHandler_GetSummary(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		query            string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "ok",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/summary/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/summary/summary.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, "/api/v1/dashboards/projects/summary", nil)
				ctx.Request.Header.Set("Authorization", testToken)
				ctx.Request.URL.RawQuery = tt.query

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetSummary(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetSummary] response mismatched")
			})
		})
	}
}

func TestHandler_GetResourcesAvailability(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_resources_availability/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_resources_availability/seed.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, "/api/v1/dashboards/resources/availabilities", nil)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetResourcesAvailability(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetResourcesAvailability] response mismatched")
			})
		})
	}
}

func TestHandler_GetEngagementInfo(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
		query            string
		dataSeeding      bool
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/engagement_info/200.json",
			dataSeeding:      true,
		},
		{
			name:             "no_record",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/engagement_info/no_record.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				if tt.dataSeeding {
					testhelper.LoadTestSQLFile(t, txRepo, fmt.Sprintf("./testdata/engagement_info/%s.sql", tt.name))
				}
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, "/api/v1/dashboards/enagagement/info", nil)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetEngagementInfo(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetEngagementInfo] response mismatched")
			})
		})
	}
}

func TestHandler_GetEngagementInfoDetail(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
		query            string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/engagement_info_detail/200.json",
			query:            "filter=seniority&startDate=2022-10-01",
		},
		{
			name:             "invalid_filter",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/engagement_info_detail/invalid_filter.json",
			query:            "filter=unknown&startDate=2022-10-01",
		},
		{
			name:             "invalid_start_date",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/engagement_info_detail/invalid_start_date.json",
			query:            "filter=chapter&startDate=unknown",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				if tt.wantCode == http.StatusOK {
					testhelper.LoadTestSQLFile(t, txRepo, fmt.Sprintf("./testdata/engagement_info_detail/%s.sql", tt.name))
				}
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/dashboards/enagagement/detail?%s", tt.query), nil)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetEngagementInfoDetail(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetEngagementInfoDetail] response mismatched")
			})
		})
	}
}

func TestHandler_GetResourceUtilization(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	timeNow, err := timeutil.ParseStringToDate("2023-03-03")
	require.NoError(t, err)

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "happy_case",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/get_resource_utilization/200_ok.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/get_resource_utilization/seed.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodPost, "/api/v1/dashboards/resources/utilization", nil)
				ctx.Request.Header.Set("Authorization", testToken)

				uMock.EXPECT().TimeNow().Return(*timeNow).AnyTimes()

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetResourceUtilization(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetResourceUtilization] response mismatched")
			})
		})
	}
}

func TestHandler_GetWorkUnitDistribution(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
		query            string
	}{
		{
			name:             "happy_case_with_name",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/work_unit_distribution/200_with_name.json",
			query:            "name=hai",
		},
		{
			name:             "happy_case_with_name_and_sort",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/work_unit_distribution/200_with_name_and_sort.json",
			query:            "name=hai&sort=asc",
		},
		{
			name:             "happy_case_with_name_sort_and_type",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/work_unit_distribution/200_with_name_sort_and_type.json",
			query:            "name=hai&sort=asc&type=training",
		},
		{
			name:             "invalid_sort",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/work_unit_distribution/400_invalid_sort.json",
			query:            "name=th&sort=ascd&type=training",
		},
		{
			name:             "invalid_type",
			wantCode:         http.StatusBadRequest,
			wantResponsePath: "testdata/work_unit_distribution/400_invalid_type.json",
			query:            "name=th&sort=asc&type=trainding",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/work_unit_distribution/work_unit_distribution.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/dashboards/resources/work-unit-distribution?%s", tt.query), nil)
				ctx.Request.URL.RawQuery = tt.query
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetWorkUnitDistribution(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetWorkUnitDistribution] response mismatched")
			})
		})
	}
}

func TestHandler_GetWorkUnitDistributionSummary(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	uMock := utilMock.NewMockIUtil(ctrl)

	tests := []struct {
		name             string
		wantCode         int
		wantErr          error
		wantResponsePath string
	}{
		{
			name:             "happy_case_with_name",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/work_unit_distribution_summary/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/work_unit_distribution_summary/work_unit_distribution_summary.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, "/api/v1/dashboards/resources/work-unit-distribution-summary", nil)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg, uMock)
				h.GetWorkUnitDistributionSummary(ctx)
				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.Dashboard.GetWorkUnitDistributionSummary] response mismatched")
			})
		})
	}
}

```

# pkg/handler/dashboard/dashboard.go

```go
package dashboard

import (
	"errors"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/dashboard/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/dashboard/request"
	"github.com/dwarvesf/fortress-api/pkg/handler/dashboard/util"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
	util    util.IUtil
}

// New returns a handler
func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config, u util.IUtil) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
		util:    u,
	}
}

// GetProjectSizes godoc
// @Summary Get the total number of active member in each project
// @Description Get the total number of active member in each project
// @id getProjectSizeList
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} ProjectSizeResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/projects/sizes [get]
func (h *handler) GetProjectSizes(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetProjectSizes",
	})

	res, err := h.store.Dashboard.GetProjectSizes(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to get project sizes")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToProjectSizes(res), nil, nil, nil, ""))
}

// GetWorkSurveys godoc
// @Summary Get Work Surveys data for dashboard
// @Description Get Work Surveys data for dashboard
// @id getWorkSurveyList
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param projectID   query  string false  "Project ID"
// @Success 200 {object} WorkSurveyResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/projects/work-surveys [get]
func (h *handler) GetWorkSurveys(c *gin.Context) {
	input := request.WorkSurveysInput{}
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if input.ProjectID != "" && !model.IsUUIDFromString(input.ProjectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetWorkSurveys",
		"input":   input,
	})

	var project *model.Project
	var workSurveys []*model.WorkSurvey
	var err error

	if input.ProjectID != "" {
		// Check project existence
		project, err = h.store.Project.One(h.repo.DB(), input.ProjectID, false)
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				l.Error(err, "project not found")
				c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, ""))
				return
			}

			l.Error(err, "failed to get project")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
			return
		}

		// Get work survey by project ID
		workSurveys, err = h.store.Dashboard.GetWorkSurveysByProjectID(h.repo.DB(), input.ProjectID)
		if err != nil {
			l.Error(err, "failed to get work survey by project ID")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	} else {
		workSurveys, err = h.store.Dashboard.GetAllWorkSurveys(h.repo.DB())
		if err != nil {
			l.Error(err, "failed to get work survey")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToWorkSurveyData(project, workSurveys), nil, nil, nil, ""))
}

// GetActionItemReports godoc
// @Summary Get Action items report for dashboard
// @Description Get Action items report for dashboard
// @id getActionItemReportList
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param projectID   query  string false  "Project ID"
// @Success 200 {object} ActionItemReportResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/projects/action-items [get]
func (h *handler) GetActionItemReports(c *gin.Context) {
	input := request.ActionItemInput{}
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if input.ProjectID != "" && !model.IsUUIDFromString(input.ProjectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetActionItemReports",
		"input":   input,
	})

	var actionItemReports []*model.ActionItemReport
	var err error

	if input.ProjectID != "" {
		// Check project existence
		isExist, err := h.store.Project.IsExist(h.repo.DB(), input.ProjectID)
		if err != nil {
			l.Error(err, "failed to get project by project ID")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
		if !isExist {
			l.Error(err, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, ""))
			return
		}

		// Get audit notion id by project ID
		projectNotion, err := h.store.ProjectNotion.OneByProjectID(h.repo.DB(), input.ProjectID)
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				l.Error(err, "project notion not found")
				c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotionNotFound, input, ""))
				return
			}

			l.Error(err, "failed to get project notion by project ID")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		// Get action item report by project ID
		actionItemReports, err = h.store.Dashboard.GetActionItemReportsByProjectNotionID(h.repo.DB(), projectNotion.AuditNotionID.String())
		if err != nil {
			l.Error(err, "failed to get action item report by project ID")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	} else {
		actionItemReports, err = h.store.Dashboard.GetAllActionItemReports(h.repo.DB())
		if err != nil {
			l.Error(err, "failed to get action item report")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToActionItemReportData(actionItemReports), nil, nil, nil, ""))
}

// GetEngineeringHealth godoc
// @Summary Get Engineering health information for dashboard
// @Description Get Engineering health information for dashboard
// @id getEngineeringHealth
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param projectID   query  string false  "Project ID"
// @Success 200 {object} EngineeringHealthResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/projects/engineering-healths [get]
func (h *handler) GetEngineeringHealth(c *gin.Context) {
	input := request.WorkSurveysInput{}
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if input.ProjectID != "" && !model.IsUUIDFromString(input.ProjectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetEngineeringHealth",
		"input":   input,
	})

	var average []*model.AverageEngineeringHealth
	var groups []*model.GroupEngineeringHealth
	var err error

	if input.ProjectID != "" {
		// Check project existence
		isExist, err := h.store.Project.IsExist(h.repo.DB(), input.ProjectID)
		if err != nil {
			l.Error(err, "failed to get project by project ID")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
		if !isExist {
			l.Error(err, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, ""))
			return
		}

		// Get audit notion id by project ID
		projectNotion, err := h.store.ProjectNotion.OneByProjectID(h.repo.DB(), input.ProjectID)
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				l.Error(err, "project notion not found")
				c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotionNotFound, input, ""))
				return
			}

			l.Error(err, "failed to get project notion by project ID")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		average, err = h.store.Dashboard.AverageEngineeringHealthByProjectNotionID(h.repo.DB(), projectNotion.AuditNotionID.String())
		if err != nil {
			l.Error(err, "failed to get average engineering health")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		groups, err = h.store.Dashboard.GroupEngineeringHealthByProjectNotionID(h.repo.DB(), projectNotion.AuditNotionID.String())
		if err != nil {
			l.Error(err, "failed to get group engineering health")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	} else {
		average, err = h.store.Dashboard.AverageEngineeringHealth(h.repo.DB())
		if err != nil {
			l.Error(err, "failed to get average engineering health")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		groups, err = h.store.Dashboard.GroupEngineeringHealth(h.repo.DB())
		if err != nil {
			l.Error(err, "failed to get group engineering health")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEngineeringHealthData(average, groups), nil, nil, nil, ""))
}

// GetAudits godoc
// @Summary Get Audit information for dashboard
// @Description Get Audit information for dashboard
// @id getAuditList
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param projectID   query  string false  "Project ID"
// @Success 200 {object} AuditResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/projects/audits [get]
func (h *handler) GetAudits(c *gin.Context) {
	input := request.WorkSurveysInput{}
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if input.ProjectID != "" && !model.IsUUIDFromString(input.ProjectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetAudits",
		"input":   input,
	})

	var average []*model.AverageAudit
	var groups []*model.GroupAudit
	var err error

	if input.ProjectID != "" {
		// Check project existence
		isExist, err := h.store.Project.IsExist(h.repo.DB(), input.ProjectID)
		if err != nil {
			l.Error(err, "failed to get project by project ID")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
		if !isExist {
			l.Error(err, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, ""))
			return
		}

		// Get audit notion id by project ID
		projectNotion, err := h.store.ProjectNotion.OneByProjectID(h.repo.DB(), input.ProjectID)
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				l.Error(err, "project notion not found")
				c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotionNotFound, input, ""))
				return
			}

			l.Error(err, "failed to get project notion by project ID")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		average, err = h.store.Dashboard.GetAverageAuditByProjectNotionID(h.repo.DB(), projectNotion.AuditNotionID.String())
		if err != nil {
			l.Error(err, "failed to get average audits")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		groups, err = h.store.Dashboard.GetGroupAuditByProjectNotionID(h.repo.DB(), projectNotion.AuditNotionID.String())
		if err != nil {
			l.Error(err, "failed to get group audits")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	} else {
		average, err = h.store.Dashboard.GetAverageAudit(h.repo.DB())
		if err != nil {
			l.Error(err, "failed to get average audits")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}

		groups, err = h.store.Dashboard.GetGroupAudit(h.repo.DB())
		if err != nil {
			l.Error(err, "failed to get group audits")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToAuditData(average, groups), nil, nil, nil, ""))
}

// GetActionItemSquashReports godoc
// @Summary Get Action items squash report for dashboard
// @Description Get Action items squash report for dashboard
// @id getActionItemSquashReportList
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param projectID   query  string false  "Project ID"
// @Success 200 {object} ActionItemSquashReportResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/projects/action-item-squash [get]
func (h *handler) GetActionItemSquashReports(c *gin.Context) {
	input := request.ActionItemInput{}
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	if input.ProjectID != "" && !model.IsUUIDFromString(input.ProjectID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetActionItemSquashReports",
		"input":   input,
	})

	var actionItemSquashReports []*model.ActionItemSquashReport
	var err error

	if input.ProjectID != "" {
		// Check project existence
		isExist, err := h.store.Project.IsExist(h.repo.DB(), input.ProjectID)
		if err != nil {
			l.Error(err, "failed to get project by project ID")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
		if !isExist {
			l.Error(err, "project not found")
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, ""))
			return
		}

		// Get action item report by project ID
		actionItemSquashReports, err = h.store.Dashboard.GetActionItemSquashReportsByProjectID(h.repo.DB(), input.ProjectID)
		if err != nil {
			l.Error(err, "failed to get action item squash report by project ID")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	} else {
		actionItemSquashReports, err = h.store.Dashboard.GetAllActionItemSquashReports(h.repo.DB())
		if err != nil {
			l.Error(err, "failed to get action item squash report")
			c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
			return
		}
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToActionItemSquashReportData(actionItemSquashReports), nil, nil, nil, ""))
}

// GetSummary godoc
// @Summary Get the summary audit info for projects
// @Description Get the summary audit info for projects
// @id getProjectSummary
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} AuditSummariesResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/projects/summary [get]
func (h *handler) GetSummary(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetSummary",
	})

	summaries, err := h.store.Dashboard.GetAuditSummaries(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to get audit summaries")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	summaryMap := make(map[model.UUID][]*model.AuditSummary)

	for _, summary := range summaries {
		summaryMap[summary.ID] = append(summaryMap[summary.ID], summary)
	}

	now := time.Now()
	currentMonth := now.Month()
	currentYear := now.Year()
	firstDayOfLastQuarter := time.Date(currentYear, (currentMonth-1)/3*3+1, 1, 0, 0, 0, 0, time.UTC)
	previousQuarterSizes, err := h.store.Dashboard.GetProjectSizesByStartTime(h.repo.DB(), firstDayOfLastQuarter)
	if err != nil {
		l.Error(err, "failed to get project sizes")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	previousQuarterMap := make(map[model.UUID]int64)
	for _, projectSize := range previousQuarterSizes {
		previousQuarterMap[projectSize.ID] = projectSize.Size
	}

	allProjects, err := h.store.Dashboard.GetProjectSizes(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to get project sizes")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// Create map for all projects
	allProjectsMap := make(map[model.UUID]*model.ProjectSize)
	for _, project := range allProjects {
		allProjectsMap[project.ID] = project
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToAuditSummaries(summaryMap, previousQuarterMap, allProjectsMap), nil, nil, nil, ""))
}

// GetResourcesAvailability godoc
// @Summary Get resources availability
// @Description Get resources availability
// @id getResourcesAvailability
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} ResourceAvailabilityResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/resources/availabilities [get]
func (h *handler) GetResourcesAvailability(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetResourcesAvailability",
	})

	slots, err := h.store.Dashboard.GetPendingSlots(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to get pending slots")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	employees, err := h.store.Dashboard.GetAvailableEmployees(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to get available employees")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToResourceAvailability(slots, employees), nil, nil, nil, ""))
}

// GetEngagementInfo godoc
// @Summary Get engagement dashboard
// @Description Get engagement dashboard
// @id getEngagementInfo
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} GetEngagementDashboardResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/engagement/info [get]
func (h *handler) GetEngagementInfo(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetEngagementInfo",
	})

	events, err := h.store.FeedbackEvent.GetLatestEventByType(h.repo.DB(), model.EventTypeSurvey, model.EventSubtypeEngagement, 4)
	if err != nil {
		l.Error(err, "failed to get engagement events")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, errs.ErrEventNotFound, nil, ""))
		return
	}

	timeList := make([]time.Time, 0)
	for _, t := range events {
		timeList = append(timeList, *t.StartDate)
	}

	statistic, err := h.store.EmployeeEventQuestion.GetAverageAnswerEngagementByTime(h.repo.DB(), timeList)
	if err != nil {
		l.Error(err, "failed to get engagement statistic")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEngagementDashboard(statistic), nil, nil, nil, ""))
}

// GetEngagementInfoDetail godoc
// @Summary Get engagement dashboard
// @Description Get engagement dashboard
// @id getEngagementInfoDetailList
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param filter  query  string true  "chapter/seniority/project"
// @Param startDate  query  string true  "startDate"
// @Success 200 {object} GetEngagementDashboardDetailResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/engagement/detail [get]
func (h *handler) GetEngagementInfoDetail(c *gin.Context) {
	query := request.GetEngagementDashboardDetailRequest{}
	if err := c.ShouldBindQuery(&query); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, ""))
		return
	}

	filter := model.EngagementDashboardFilter(query.Filter)
	if !filter.IsValid() {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEngagementDashboardFilter, query, ""))
		return
	}

	startDate, err := time.Parse("2006-01-02", query.StartDate)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidStartDate, query, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetEngagementInfoDetail",
	})

	statistic, err := h.store.EmployeeEventQuestion.GetAverageAnswerEngagementByFilter(h.repo.DB(), filter, &startDate)
	if err != nil {
		l.Error(err, "failed to get engagement statistic")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEngagementDashboardDetails(statistic), nil, nil, nil, ""))
}

// GetResourceUtilization godoc
// @Summary Get dashboard resource utilization
// @Description Get dashboard resource utilization
// @id getResourceUtilizationList
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} GetDashboardResourceUtilizationResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/resources/utilization [get]
func (h *handler) GetResourceUtilization(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetResourceUtilization",
	})

	res, err := h.store.Dashboard.GetResourceUtilization(h.repo.DB(), h.util.TimeNow())
	if err != nil {
		l.Error(err, "failed to get resource utilization by year")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToReSourceUtilizations(res), nil, nil, nil, ""))
}

// GetWorkUnitDistributionSummary godoc
// @Summary Get summary for workunit distribution dashboard
// @Description Get summary for workunit distribution dashboard
// @id getWorkUnitDistributionSummary
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} SummaryWorkUnitDistributionResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/resources/work-unit-distribution-summary [get]
func (h *handler) GetWorkUnitDistributionSummary(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetWorkUnitDistributionSummary",
	})

	// Get total work unit distribution
	totalWorkUnitDistribution, err := h.store.Dashboard.TotalWorkUnitDistribution(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to get total work unit distribution")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToSummaryWorkUnitDistributionData(totalWorkUnitDistribution), nil, nil, nil, ""))
}

// GetWorkUnitDistribution godoc
// @Summary Get work unit distribution data for dashboard
// @Description Get work unit distribution data for dashboard
// @id getWorkUnitDistributionList
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param name   query  string false  "employee name for filter"
// @Param sort   query  string false  "sort required"
// @Param type   query  string false  "work unit type for filter"
// @Success 200 {object} WorkUnitDistributionsResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/resources/work-unit-distribution [get]
func (h *handler) GetWorkUnitDistribution(c *gin.Context) {
	input := request.WorkUnitDistributionInput{}
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetWorkUnitDistribution",
		"input":   input,
	})

	// Check and validate input
	if input.Type != "" && !input.Type.IsValid() {
		l.Error(errs.ErrInvalidWorkUnitDistributionType, "invalid work unit distribution type")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidWorkUnitDistributionType, nil, ""))
		return
	}

	if input.Sort != "" && !input.Sort.IsValid() {
		l.Error(errs.ErrInvalidWorkUnitDistributionSort, "invalid work unit distribution sort")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidWorkUnitDistributionSort, nil, ""))
		return
	}

	employees, err := h.store.Dashboard.GetWorkUnitDistributionEmployees(h.repo.DB(), input.Name, input.Type.String())
	if err != nil {
		l.Error(err, "failed to get work unit distribution employees")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToWorkUnitDistributionData(employees, input.Sort.String()), nil, nil, nil, ""))
}

// GetResourceWorkSurveySummaries godoc
// @Summary Get resource work summaries for dashboard
// @Description Get resource work summaries for dashboard
// @id getResourceWorkSurveySummaryList
// @Tags Dashboard
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param keyword query string false "Keyword"
// @Param page query string false "Page"
// @Param size query string false "Size"
// @Success 200 {object} WorkSurveySummaryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /dashboards/resources/work-survey-summaries [get]
func (h *handler) GetResourceWorkSurveySummaries(c *gin.Context) {
	input := request.GetResourceWorkSurveySummariesInput{}
	if err := c.ShouldBindQuery(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	input.Standardize()

	l := h.logger.Fields(logger.Fields{
		"handler": "dashboard",
		"method":  "GetResourceWorkSurveySummaries",
		"input":   input,
	})

	reviews, err := h.store.Dashboard.GetAllWorkReviews(h.repo.DB(), input.Keyword, input.Pagination)
	if err != nil {
		l.Error(err, "failed to get all work reviews")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToWorkSummaries(reviews),
		&view.PaginationResponse{Pagination: view.Pagination{Page: input.Pagination.Page, Size: input.Pagination.Size, Sort: input.Pagination.Sort}}, nil, nil, ""))
}

```

# pkg/handler/communitynft/interface.go

```go
package communitynft

import "github.com/gin-gonic/gin"

type IHandler interface {
	GetNftMetadata(c *gin.Context)
}

```

# pkg/handler/communitynft/communitynft.go

```go
package communitynft

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	ctrl "github.com/dwarvesf/fortress-api/pkg/controller/communitynft"
	"github.com/dwarvesf/fortress-api/pkg/handler/communitynft/errs"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
	controller *controller.Controller
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
		controller: controller,
	}
}

// GetNftMetadata godoc
// @Summary Get metadata of a nft
// @Description Get metadata of a nft
// @id getNftMetadata
// @Tags CommunityNft
// @Accept  json
// @Produce  json
// @Param id path string true "NFT ID"
// @Success 200 {object} GetNftMetadataResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /community-nfts/{id} [get]
func (h *handler) GetNftMetadata(c *gin.Context) {
	tokenIdStr := c.Param("id")
	if tokenIdStr == "" {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidTokenID, nil, ""))
		return
	}
	tid, err := strconv.Atoi(tokenIdStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidTokenID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "client",
		"method":  "Detail",
	})

	nftMetadata, err := h.controller.CommunityNft.GetNftMetadata(tid)
	if err == ctrl.ErrTokenNotFound {
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrTokenNotFound, nil, ""))
		return
	}
	if err != nil {
		l.Error(err, "failed to get nft metadata")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.ToNftMetadata(nftMetadata))
}

```

# pkg/handler/client/interface.go

```go
package client

import "github.com/gin-gonic/gin"

type IHandler interface {
	Create(c *gin.Context)
	List(c *gin.Context)
	Detail(c *gin.Context)
	Update(c *gin.Context)
	Delete(c *gin.Context)

	PublicList(c *gin.Context)
}

```

# pkg/handler/client/client.go

```go
package client

import (
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/handler/client/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/client/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
	controller *controller.Controller
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
		controller: controller,
	}
}

// Create godoc
// @Summary Create new client
// @Description Create new client
// @id createClient
// @Tags Client
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param Body body CreateClientRequest true "Body"
// @Success 200 {object} CreateClientResponse
// @Failure 500 {object} ErrorResponse
// @Router /clients [post]
func (h *handler) Create(c *gin.Context) {
	input := request.CreateClientRequest{}
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "client",
		"method":  "Create",
		"request": input,
	})

	client, err := h.controller.Client.Create(c, input)
	if err != nil {
		l.Error(err, "failed to create client")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToClient(client), nil, nil, nil, ""))
}

// List godoc
// @Summary Get all clients
// @Description Get all clients
// @id getListClients
// @Tags Client
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} GetListClientResponse
// @Failure 500 {object} ErrorResponse
// @Router /clients [get]
func (h *handler) List(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "client",
		"method":  "List",
	})

	clients, err := h.controller.Client.List(c)
	if err != nil {
		l.Error(err, "failed to get client list")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToClients(clients), nil, nil, nil, ""))
}

// Detail godoc
// @Summary Get client detail by id
// @Description Get client detail by id
// @id getClientDetail
// @Tags Client
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Client ID"
// @Success 200 {object} GetDetailClientResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /clients/{id} [get]
func (h *handler) Detail(c *gin.Context) {
	clientID := c.Param("id")
	if clientID == "" || !model.IsUUIDFromString(clientID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidClientID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "client",
		"method":  "Detail",
	})

	client, err := h.controller.Client.Detail(c, clientID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrClientNotFound, nil, ""))
			return
		}

		l.Error(err, "failed to get client detail")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToClient(client), nil, nil, nil, ""))
}

// Update godoc
// @Summary Update client by id
// @Description Update client by id
// @id updateClient
// @Tags Client
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param id path string true "Client ID"
// @Param Body body UpdateClientInput true "Body"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /clients/{id} [put]
func (h *handler) Update(c *gin.Context) {
	clientID := c.Param("id")
	if clientID == "" || !model.IsUUIDFromString(clientID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidClientID, nil, ""))
		return
	}

	input := request.UpdateClientInput{}
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "client",
		"method":  "Update",
		"request": input,
	})

	errCode, err := h.controller.Client.Update(c, clientID, input)
	if err != nil {
		l.Error(err, "failed to update client")
		c.JSON(errCode, view.CreateResponse[any](nil, nil, err, input, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// Delete godoc
// @Summary Delete client by id
// @Description Delete client by id
// @id deleteClient
// @Tags Client
// @Accept  json
// @Produce  json
// @Param id path string true "Client ID"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /clients/{id} [delete]
func (h *handler) Delete(c *gin.Context) {
	clientID := c.Param("id")
	if clientID == "" || !model.IsUUIDFromString(clientID) {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidClientID, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler":  "client",
		"method":   "UpdateInfo",
		"clientID": clientID,
	})

	errCode, err := h.controller.Client.Delete(c, clientID)
	if err != nil {
		l.Error(err, "failed to delete client")
		c.JSON(errCode, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

// PublicList godoc
// @Summary Get all clients
// @Description Get all clients
// @id getAllPublicClients
// @Tags Public
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} PublicClientListResponse
// @Failure 500 {object} ErrorResponse
// @Router /public/clients [get]
func (h *handler) PublicList(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "client",
		"method":  "PublicList",
	})

	clients, err := h.controller.Client.PublicList(c)
	if err != nil {
		l.Error(err, "failed to get client list")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToPublicClientListResponse(clients), nil, nil, nil, ""))
}

```

# pkg/handler/brainerylogs/interface.go

```go
package brainerylogs

import "github.com/gin-gonic/gin"

type IHandler interface {
	Create(c *gin.Context)
	GetMetrics(c *gin.Context)
	Sync(c *gin.Context)
}

```

# pkg/handler/brainerylogs/brainery_log.go

```go
package brainerylogs

import (
	"net/http"
	"regexp"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/shopspring/decimal"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/store/employee"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	controller *controller.Controller
	store      *store.Store
	service    *service.Service
	logger     logger.Logger
	repo       store.DBRepo
	config     *config.Config
}

// New returns a handler
func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		controller: controller,
		store:      store,
		repo:       repo,
		service:    service,
		logger:     logger,
		config:     cfg,
	}
}

const (
	braineryLogsChannelID           = "955015316293972048"
	braineryLogsPlaygroundChannelID = "1119171172198797393"
)

// Create godoc
// @Summary Create brainery logs
// @Description Create brainery logs
// @id createBraineryLog
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param body body CreateBraineryLogRequest true "Body"
// @Success 200 {object} MessageResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /brainery-logs [post]
func (h *handler) Create(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "brainerylogs",
			"method":  "Create",
		},
	)

	body := request.CreateBraineryLogRequest{}
	if err := c.ShouldBindJSON(&body); err != nil {
		l.Error(err, "failed to decode body")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}
	if err := body.Validate(); err != nil {
		l.Errorf(err, "failed to validate data", "body", body)
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	publishedAt, _ := time.Parse(time.RFC3339Nano, body.PublishedAt)

	b := model.BraineryLog{
		Title:       body.Title,
		URL:         body.URL,
		GithubID:    body.GithubID,
		DiscordID:   body.DiscordID,
		Tags:        body.Tags,
		PublishedAt: &publishedAt,
		Reward:      body.Reward,
	}

	log, err := h.controller.BraineryLog.Create(b)
	if err != nil {
		l.Errorf(err, "failed to create brainery logs", "braineryLog", b)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, log, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any]("success", nil, nil, body, ""))
}

// GetMetrics godoc
// @Summary Get brainery metric
// @Description Get brainery metric
// @id getBraineryMetric
// @Tags Project
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Param view query string false "Time view"
// @Param date query string false "Date" Format(date)
// @Success 200 {object} BraineryMetricResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /brainery-logs/metrics [get]
func (h *handler) GetMetrics(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "brainerylogs",
			"method":  "GetMetrics",
		},
	)

	queryView := c.DefaultQuery("view", "weekly")
	date := c.Query("date")
	selectedDate := time.Now()

	if date != "" {
		t, err := time.Parse("2006-01-02", date)
		if err != nil {
			l.Error(err, "failed to parse date")
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidDateFormat, nil, ""))
			return
		}

		selectedDate = t
	}

	latestPosts, logs, ncids, err := h.controller.BraineryLog.GetMetrics(selectedDate, queryView)
	if err != nil {
		l.Error(err, "failed to get brainery metrics")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToBraineryMetric(latestPosts, logs, ncids, queryView), nil, nil, nil, ""))
}

func (h *handler) Sync(c *gin.Context) {
	l := h.logger.Fields(
		logger.Fields{
			"handler": "brainerylogs",
			"method":  "Sync",
		},
	)

	githubPattern := `github\.com/([\w-]+)`
	githubRe := regexp.MustCompile(githubPattern)

	displayNameIDMap := map[string]string{
		"An Tran":           "656dd867-39c1-4ed8-b72e-63d0e89c3679",
		"Bach Phuong":       "1782aaea-733c-4ced-8d30-a921abede14e",
		"Bien Vo":           "5a8f3d89-04a0-4a0e-bdc8-73045ced6a08",
		"Binh Le":           "06126b41-b20f-4ca2-933a-06fdb01fe362",
		"Dung Ho":           "bf1d3fcc-6a59-413e-a692-113989849556",
		"Hieu Phan":         "e0d8c920-f4f1-4309-aabf-1d83f792f45b",
		"Huy Tieu":          "3c420751-bb9a-4878-896e-2f10f3a633d6",
		"Khanh Truong":      "63d163a7-e9f5-4210-a685-151061fe9c29",
		"Khoi Nguyen":       "224b9b85-7206-46bd-803a-5308fd4e81e1",
		"Lap Nguyen":        "e84c1860-6991-44a1-b687-fec078b842eb",
		"Le Duc Chinh":      "40f33d74-91ae-4eec-ba35-8d330376d6e1",
		"M.Vu Cuong(Jim)":   "07a5a7b2-6e5f-4165-bbdf-40d06f3e7837",
		"Ngo Lap Nguyen":    "e84c1860-6991-44a1-b687-fec078b842eb",
		"Ngo Trong Khoi":    "8281ade3-214a-4348-a171-42b0fe304032",
		"Nguyen Dinh Nam":   "a5ddbb54-3faa-4f92-964a-3754928d3f21",
		"Nguyen Huu Nguyen": "9a91ff6b-7367-403f-b23d-4c16dabd6857",
		"Nguyen Tran Khanh": "14bdccb9-3460-40f6-ba87-6ad1a7884670",
		"Nguyen Xuan Anh":   "69bf5adf-7ba2-4abc-b87e-9a68668a267e",
		"Nhut Huynh":        "a8f34385-61f8-46f0-9403-4b05e37cd8e3",
		"Pham Duc Thanh":    "3e858c81-d661-4d4f-b913-e02dd6f4007e",
		"Pham Ngoc Thanh":   "ec086e4a-2167-4924-adfd-84be02edebe9",
		"Pham The Hung":     "133483cd-7a76-4a6d-9c63-964900284a44",
		"Phan Viet Trung":   "ee219b4e-e4dc-4782-b590-03f799cd41ab",
		"Phat Ha":           "1b63c305-b04b-47ab-ab1b-e6810d8a17cc",
		"Phuc Le":           "d8a6af04-9e0a-4724-97c4-a78ecd5e9bc4",
		"Thanh Pham":        "3e858c81-d661-4d4f-b913-e02dd6f4007e",
		"Tom Nguyen":        "69bf5adf-7ba2-4abc-b87e-9a68668a267e",
		"Tran Hoang Nam":    "d8b2785c-31f1-451b-8bb5-385cbc873402",
		"Tran Khac Vy":      "2641297b-c632-4c22-9a42-61291d621552",
		"Trung Phan":        "ee219b4e-e4dc-4782-b590-03f799cd41ab",
		"Truong Hung Khanh": "63d163a7-e9f5-4210-a685-151061fe9c29",
		"Vy Tran":           "2641297b-c632-4c22-9a42-61291d621552",
	}

	body := request.SyncBraineryLogs{}
	if err := c.ShouldBindJSON(&body); err != nil {
		l.Errorf(err, "failed to parse request")
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	if body.StartMessageID == "" {
		body.StartMessageID = "960194750806364171"
	}

	if body.EndMessageID == "" {
		body.EndMessageID = "1120663834261205052"
	}

	channelID := braineryLogsChannelID
	if h.config.Env != "prod" {
		channelID = braineryLogsChannelID
	}

	messages, err := h.service.Discord.GetMessagesAfterCursor(channelID, body.StartMessageID, body.EndMessageID)
	if err != nil {
		l.Errorf(err, "failed to get messages from discord", "startMessageID", body.StartMessageID, "endMessageID", body.EndMessageID)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	socialAccounts, err := h.store.SocialAccount.GetByType(h.repo.DB(), model.SocialAccountTypeGitHub.String())
	if err != nil {
		l.Errorf(err, "failed to get social accounts")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	githubEmployeeIDMap, empIDGithubMap := model.SocialAccounts(socialAccounts).ToMap()

	employees, _, err := h.store.Employee.All(h.repo.DB(), employee.EmployeeFilter{}, model.Pagination{
		Page: 0,
		Size: 1000,
	})
	if err != nil {
		l.Errorf(err, "failed to get employees")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	employeeDiscordMap := make(map[string]string)
	for _, e := range employees {
		if e.DiscordAccount != nil && e.DiscordAccount.DiscordID != "" {
			employeeDiscordMap[e.ID.String()] = e.DiscordAccount.DiscordID
		}
	}

	var braineryLogs []model.BraineryLog
	for _, m := range messages {
		if !m.Author.Bot {
			continue
		}

		if len(m.Embeds) == 0 {
			continue
		}

		githubID := ""
		discordID := ""
		employeeID := ""
		var tags []string
		for _, f := range m.Embeds[0].Fields {
			if f.Name == "Topic" {
				if f.Value != "" {
					tmp := strings.ReplaceAll(f.Value, "#", "")
					tmp = strings.ReplaceAll(tmp, "\n", "/")
					tmp = strings.ReplaceAll(tmp, " ", "")
					tmp = strings.ReplaceAll(tmp, "...", "")
					tmp = strings.ToLower(tmp)
					tmpTags := strings.Split(tmp, "/")
					tags = append(tags, tmpTags...)
				}
			}

			if f.Name == "Tags" {
				if f.Value != "" {
					tmp := strings.ReplaceAll(f.Value, "#", "")
					tmp = strings.ReplaceAll(tmp, "\n", "/")
					tmp = strings.ReplaceAll(tmp, " ", "")
					tmp = strings.ReplaceAll(tmp, "...", "")
					tmp = strings.ToLower(tmp)
					tmpTags := strings.Split(tmp, "/")
					tags = append(tags, tmpTags...)
				}
			}

			if f.Name == "Author" && strings.Contains(m.Embeds[0].URL, "https://github.com/dwarvesf") {
				githubID = f.Value
				v, ok := githubEmployeeIDMap[f.Value]
				if ok {
					employeeID = v
					d, ok := employeeDiscordMap[v]
					if ok {
						discordID = d
					}
				}
			}

			if f.Name == "Author" && strings.Contains(m.Embeds[0].URL, "https://brain.d.foundation") {
				github := githubRe.FindStringSubmatch(f.Value)
				if len(github) > 1 {
					githubID = github[1]
					v, ok := githubEmployeeIDMap[github[1]]
					if ok {
						employeeID = v
						d, ok := employeeDiscordMap[v]
						if ok {
							discordID = d
						}
					}
				} else {
					v, ok := displayNameIDMap[f.Value]
					if ok {
						employeeID = v
						d, ok := employeeDiscordMap[v]
						if ok {
							discordID = d
						}

						gh, ok := empIDGithubMap[v]
						if ok {
							githubID = gh
						}
					} else {
						githubID = f.Value
					}
				}
			}
		}

		eid := model.UUID{}
		euuid, err := model.UUIDFromString(employeeID)
		if err == nil {
			eid = euuid
		}

		loc, _ := time.LoadLocation("Asia/Ho_Chi_Minh")
		t := m.Timestamp.In(loc)
		l := model.BraineryLog{
			Title:       m.Embeds[0].Title,
			URL:         m.Embeds[0].URL,
			GithubID:    githubID,
			DiscordID:   discordID,
			EmployeeID:  eid,
			Tags:        tags,
			PublishedAt: &t,
			Reward:      decimal.NewFromInt(10),
		}

		braineryLogs = append(braineryLogs, l)
	}

	if len(braineryLogs) == 0 {
		c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
		return
	}

	_, err = h.store.BraineryLog.Create(h.repo.DB(), braineryLogs)
	if err != nil {
		l.Errorf(err, "failed to create brainery logs")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

```

# pkg/handler/bankaccount/interface.go

```go
package bankaccount

import "github.com/gin-gonic/gin"

type IHandler interface {
	List(c *gin.Context)
}

```

# pkg/handler/bankaccount/bank_account_test.go

```go
package bankaccount

import (
	"net/http"
	"net/http/httptest"
	"os"
	"testing"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/require"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils/testhelper"
)

const testToken = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTkzMjExNDIsImlkIjoiMjY1NTgzMmUtZjAwOS00YjczLWE1MzUtNjRjM2EyMmU1NThmIiwiYXZhdGFyIjoiaHR0cHM6Ly9zMy1hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tL2ZvcnRyZXNzLWltYWdlcy81MTUzNTc0Njk1NjYzOTU1OTQ0LnBuZyIsImVtYWlsIjoidGhhbmhAZC5mb3VuZGF0aW9uIiwicGVybWlzc2lvbnMiOlsiZW1wbG95ZWVzLnJlYWQiXSwidXNlcl9pbmZvIjpudWxsfQ.GENGPEucSUrILN6tHDKxLMtj0M0REVMUPC7-XhDMpGM"

func TestHandler_List(t *testing.T) {
	cfg := config.LoadTestConfig()
	loggerMock := logger.NewLogrusLogger()
	serviceMock := service.New(&cfg, nil, nil)
	storeMock := store.New()

	tests := []struct {
		name             string
		wantCode         int
		wantResponsePath string
	}{
		{
			name:             "ok",
			wantCode:         http.StatusOK,
			wantResponsePath: "testdata/list/200.json",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testhelper.TestWithTxDB(t, func(txRepo store.DBRepo) {
				testhelper.LoadTestSQLFile(t, txRepo, "./testdata/list/list.sql")
				w := httptest.NewRecorder()
				ctx, _ := gin.CreateTestContext(w)
				ctx.Request = httptest.NewRequest(http.MethodGet, "/api/v1/bank-accounts", nil)
				ctx.Request.Header.Set("Authorization", testToken)

				h := New(storeMock, txRepo, serviceMock, loggerMock, &cfg)
				h.List(ctx)

				require.Equal(t, tt.wantCode, w.Code)
				expRespRaw, err := os.ReadFile(tt.wantResponsePath)
				require.NoError(t, err)

				require.JSONEq(t, string(expRespRaw), w.Body.String(), "[Handler.BankAccount.List] response mismatched")
			})
		})
	}
}

```

# pkg/handler/bankaccount/bank_account.go

```go
package bankaccount

import (
	"net/http"

	"github.com/gin-gonic/gin"
	_ "github.com/lib/pq"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

// List godoc
// @Summary Get all bank accounts
// @Description Get all bank accounts
// @id listBankAccounts
// @Tags Bank
// @Accept  json
// @Produce  json
// @Success 200 {object} ListBankAccountResponse
// @Failure 500 {object} ErrorResponse
// @Router /bank-accounts [get]
func (h *handler) List(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "bankaccount",
		"method":  "List",
	})

	res, err := h.store.BankAccount.All(h.repo.DB())
	if err != nil {
		l.Error(err, "failed to get all bank accounts")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListBankAccount(res), nil, nil, nil, ""))
}

```

# pkg/handler/auth/interface.go

```go
package auth

import "github.com/gin-gonic/gin"

type IHandler interface {
	Auth(c *gin.Context)
	Me(c *gin.Context)
	CreateAPIKey(c *gin.Context)
}

```

# pkg/handler/auth/auth.png

This is a binary file of the type: Image

# pkg/handler/auth/auth.go

```go
package auth

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/controller"
	"github.com/dwarvesf/fortress-api/pkg/controller/auth"
	"github.com/dwarvesf/fortress-api/pkg/handler/auth/errs"
	"github.com/dwarvesf/fortress-api/pkg/handler/auth/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	controller *controller.Controller
	logger     logger.Logger
	config     *config.Config
}

func New(controller *controller.Controller, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		controller: controller,
		logger:     logger,
		config:     cfg,
	}
}

// Auth godoc
// @Summary Authorize user when login
// @Description Authorize user when login
// @id auth
// @Tags Auth
// @Accept  json
// @Produce  json
// @Param code body string true "Google login code"
// @Param redirectUrl body string true "Google redirect url"
// @Success 200 {object} AuthData
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth [post]
func (h *handler) Auth(c *gin.Context) {
	// 1. parse code, redirectUrl from body
	var req struct {
		Code        string `json:"code" binding:"required"`
		RedirectURL string `json:"redirectUrl" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, ""))
		return
	}

	// 1.1 prepare the logger
	l := h.logger.Fields(logger.Fields{
		"handler": "auth",
		"method":  "Auth",
		"body":    req,
	})

	e, jwt, err := h.controller.Auth.Auth(auth.AuthenticationInput{
		Code:        req.Code,
		RedirectURL: req.RedirectURL,
	})
	if err != nil {
		l.Info("failed to called controller")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, req, ""))
		return
	}

	// 3. return auth data
	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToAuthData(jwt, e), nil, nil, nil, ""))
}

// Me godoc
// @Summary Get logged-in user data
// @Description Get logged-in user data
// @id me
// @Tags Auth
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} AuthUserResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/me [get]
func (h *handler) Me(c *gin.Context) {
	userID, err := authutils.GetUserIDFromContext(c, h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "auth",
		"method":  "Me",
	})

	rs, perms, err := h.controller.Auth.Me(userID)
	if err != nil {
		l.Error(err, "error query employee from db")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToAuthorizedUserData(rs, perms), nil, nil, nil, ""))
}

// CreateAPIKey godoc
// @Summary Create API key
// @Description Create API key
// @id createApiKey
// @Tags Auth
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} APIKeyResponse
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/api-key [post]
func (h *handler) CreateAPIKey(c *gin.Context) {
	var body request.CreateAPIKeyInput

	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""))
		return
	}

	l := h.logger.Fields(logger.Fields{
		"handler": "auth",
		"method":  "CreateAPIKey",
	})

	key, err := h.controller.Auth.CreateAPIKey(body.RoleID)
	if err != nil {
		l.Error(err, "error create api key")
		errs.ConvertControllerErr(c, err)
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](&view.APIKeyData{
		Key: key,
	}, nil, nil, nil, ""))
}

```

# pkg/handler/asset/interface.go

```go
package asset

import "github.com/gin-gonic/gin"

type IHandler interface {
	Upload(c *gin.Context)
}

```

# pkg/handler/asset/asset.go

```go
package asset

import (
	"fmt"
	"net/http"
	"path/filepath"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/asset/errs"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

// New returns a handler
func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

// Upload godoc
// @Summary Upload the content
// @Description Upload the content
// @id upload
// @Tags Asset
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param file formData file true "content upload"
// @Param type formData string true "image/doc"
// @Param targetType formData string true "employees/projects/change-logs/invoices"
// @Param targetID formData string false "employeeID/projectID"
// @Success 200 {object} ContentDataResponse
// @Failure 500 {object} ErrorResponse
// @Router /assets/upload [post]
func (h *handler) Upload(c *gin.Context) {
	// 1.1 get userID
	userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	uuidUserID, err := model.UUIDFromString(userInfo.UserID)
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, ""))
		return
	}

	// 1.2 get upload file
	file, err := c.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, file, ""))
		return
	}

	fType := c.PostForm("type")
	tType := c.PostForm("targetType")
	tID := c.PostForm("targetID")

	l := h.logger.Fields(logger.Fields{
		"handler": "asset",
		"method":  "Upload",
	})

	fileName := file.Filename
	fileExtension := model.ContentExtension(filepath.Ext(fileName))
	fileType := model.ContentType(fType)
	targetType := model.ContentTargetType(tType)
	fileSize := file.Size

	if !fileType.Valid() {
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, ""))
		return
	}
	if !targetType.Valid() {
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, ""))
		return
	}

	if fileType == model.ContentTypeImage && !fileExtension.ImageValid() {
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, ""))
		return
	}

	if (fileType == model.ContentTypeImage && fileSize > model.MaxFileSizeImage) || (fileType == model.ContentTypeDoc && fileSize > model.MaxFileSizePdf) {
		c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileSize, nil, ""))
		return
	}

	tx, done := h.repo.NewTransaction()

	if targetType == model.ContentTargetTypeEmployee {
		if tID == "" {
			tID = uuidUserID.String()
		}
		isExisted, err := h.store.Employee.IsExist(tx.DB(), tID)
		if err != nil {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
		if !isExisted {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrEmployeeNotFound), nil, ""))
			return
		}
	}

	if targetType == model.ContentTargetTypeProject {
		isExisted, err := h.store.Project.IsExist(tx.DB(), tID)
		if err != nil {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
		if !isExisted {
			c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrProjectNotFound), nil, ""))
			return
		}
	}
	gcsPath := ""
	if targetType == model.ContentTargetTypeEmployee || targetType == model.ContentTargetTypeProject {
		gcsPath = fmt.Sprintf("%s/%s/%s/%s", targetType, tID, fileType, fileName)
	} else {
		gcsPath = fmt.Sprintf("%s/%s", targetType, fileName)
	}
	filePath := fmt.Sprintf("https://storage.googleapis.com/%s/%s", h.config.Google.GCSBucketName, gcsPath)

	var targetID model.UUID
	if targetType == model.ContentTargetTypeEmployee || targetType == model.ContentTargetTypeProject {
		targetID, err = model.UUIDFromString(tID)
		if err != nil {
			c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, done(err), nil, ""))
			return
		}
	}
	authType := "Authorization"
	if authutils.IsAPIKey(c) {
		authType = "ApiKey"
	}
	content, err := h.store.Content.Create(tx.DB(), model.Content{
		Type:       fileType.String(),
		Extension:  fileExtension.String(),
		Path:       filePath,
		TargetID:   targetID,
		UploadBy:   uuidUserID,
		TargetType: targetType.String(),
		AuthType:   authType,
	})
	if err != nil {
		l.Error(err, "error create content")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	multipart, err := file.Open()
	if err != nil {
		l.Error(err, "error in open file")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	// 3. Upload to GCS
	err = h.service.GoogleStorage.UploadContentGCS(multipart, gcsPath)
	if err != nil {
		l.Error(err, "error in upload file")
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](view.ToContentData(content.Path), nil, done(nil), nil, ""))
}

```

# pkg/handler/audit/interface.go

```go
package audit

import "github.com/gin-gonic/gin"

type IHandler interface {
	Sync(c *gin.Context)
}

```

# pkg/handler/audit/audit.go

```go
package audit

import (
	"errors"
	"net/http"
	"reflect"
	"time"

	"github.com/dstotijn/go-notion"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/audit/errs"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

const (
	VoconicAudit1  = "0fde875d-67b1-4c23-b524-4b541b301c62"
	NghenhanAudit1 = "23d6b63b-3a2b-49fc-8af7-5ffca1379a29"
)

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

// New returns a handler
func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

// Sync godoc
// @Summary Sync audit info from Notion to database
// @Description Sync audit info from Notion to database
// @id syncAudit
// @Tags Audit
// @Accept  json
// @Produce  json
// @Security BearerAuth
// @Success 200 {object} MessageResponse
// @Router /cronjobs/audits [post]
func (h *handler) Sync(c *gin.Context) {
	h.SyncAuditCycle()

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "sync audit from notion successfully"))
}

// SyncAuditCycle sync audit cycle from notion to database
func (h *handler) SyncAuditCycle() {
	l := h.logger.Fields(logger.Fields{
		"method": "SyncAuditCycle",
	})

	l.Infof("Sync audit cycle started")

	// Start Transaction
	tx, done := h.repo.NewTransaction()

	// Get all audit cycle from notion
	database, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.AuditCycle, nil, nil, 0)
	if err != nil {
		l.Error(done(err), "failed to get database from notion")
		return
	}

	// Map notion page
	mapPage := NotionDatabaseToMap(tx.DB(), database)

	// Get all audit cycle from database
	auditCycles, err := h.store.AuditCycle.All(tx.DB())
	if err != nil {
		l.Error(done(err), "failed to get audit cycle from database")
		return
	}

	auditCycleMap := model.AuditCycleToMap(auditCycles)

	// Compare and update
	// Create audit cycle if not exist in auditCycleMap
	for _, page := range mapPage {
		// If auditCycle not exist in mapPage
		if ac, ok := auditCycleMap[model.MustGetUUIDFromString(page.ID)]; !ok {
			l.Infof("Create audit cycle ID: %s", page.ID)
			auditCycle := model.NewAuditCycleFromNotionPage(&page, h.config.Notion.Databases.AuditCycle)

			// Check project_is map with audit_notion_id in db or not
			exists, err := h.store.ProjectNotion.IsExistByAuditNotionID(tx.DB(), auditCycle.ProjectID.String())
			if err != nil {
				l.Error(done(err), "failed to check project_notion")
				return
			}

			if !exists {
				l.Infof("Project %s not exist in project_notion", auditCycle.ProjectID.String())
				continue
			}

			// Create audits
			if err := h.createAudits(tx.DB(), &page, auditCycle); err != nil {
				l.Error(done(err), "failed to create audit")
				return
			}

			// Create audit cycle
			_, err = h.store.AuditCycle.Create(tx.DB(), auditCycle)
			if err != nil {
				l.Error(done(err), "failed to create audit cycle")
				return
			}
		} else {
			l.Infof("Sync audit cycle ID: %s", page.ID)
			delete(auditCycleMap, model.MustGetUUIDFromString(page.ID))
			if err := h.syncAuditCycle(tx.DB(), &page, ac); err != nil {
				l.Error(done(err), "failed to sync audit cycle")
				return
			}
		}
	}

	// Delete audit cycle if not exist in mapPage
	for _, auditCycle := range auditCycleMap {
		l.Infof("Delete audit cycle ID: %s", auditCycle.ID.String())
		if err := h.deleteAuditCycle(tx.DB(), auditCycle); err != nil {
			l.Error(done(err), "failed to delete audit cycle")
			return
		}
	}

	// Set value action item high, action item to 0
	if err := h.store.AuditCycle.ResetActionItem(tx.DB()); err != nil {
		l.Error(done(err), "failed to reset action item")
		return
	}

	if err := h.store.Audit.ResetActionItem(tx.DB()); err != nil {
		l.Error(done(err), "failed to reset action item")
		return
	}

	// Sync Action Item
	if err := h.SyncActionItem(tx.DB()); err != nil {
		l.Error(done(err), "failed to sync action item")
		return
	}

	if err := done(nil); err != nil {
		l.Error(err, "failed to commit txn")
	}

	l.Infof("Sync audit cycle finished")
}

// SyncActionItem sync action item from notion to database
func (h *handler) SyncActionItem(db *gorm.DB) error {
	l := h.logger.Fields(logger.Fields{
		"method": "SyncActionItem",
	})

	l.Infof("Syncing action item started")
	// Get all audit cycle from database
	actionItems, err := h.store.ActionItem.All(db)
	if err != nil {
		l.Error(err, "failed to get audit cycle from database")
		return err
	}

	actionItemMap := model.ActionItemToMap(actionItems)

	// Sync action item
	if err := h.syncActionItemPage(db, h.config.Notion.Databases.AuditActionItem, false, actionItemMap); err != nil {
		l.Error(err, "failed to run function syncActionItemPage")
		return err
	}

	// Delete non-exist action item
	for _, actionItem := range actionItemMap {
		if err := h.store.ActionItem.Delete(db, actionItem.ID.String()); err != nil {
			l.Error(err, "failed to delete action item")
			return err
		}
	}

	// Sync audit action item
	if err := h.syncAuditActionItem(db); err != nil {
		l.Error(err, "failed to run function syncAuditActionItem")
		return err
	}

	if err := h.snapShot(db); err != nil {
		l.Error(err, "failed to run function snapShot")
		return err
	}

	l.Infof("Syncing action item finished")

	return nil
}

// createAudits create audit record for each audit cycle
func (h *handler) createAudits(db *gorm.DB, page *notion.Page, auditCycle *model.AuditCycle) error {
	l := h.logger.Fields(logger.Fields{
		"method":       "createAudits",
		"pageID":       page.ID,
		"auditCycleID": auditCycle.ID.String(),
	})

	audit, err := h.service.Notion.GetBlockChildren(page.ID)
	if err != nil {
		l.Error(err, "failed to get audit from notion")
		return err
	}

	// Find the audit checklist block index
	auditChecklistIndex := -1
	for index, block := range audit.Results {
		if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) {
			auditChecklistIndex = index
		}
	}

	if page.ID == NghenhanAudit1 || page.ID == VoconicAudit1 || auditChecklistIndex == -1 {
		return nil
	}

	properties := page.Properties.(notion.DatabasePageProperties)
	auditChecklist, err := h.service.Notion.GetDatabase(audit.Results[auditChecklistIndex].ID(), nil, nil, 0)
	if err != nil {
		l.Error(err, "failed to get database from notion")
		return err
	}

	// Create audit record for each row
	for _, row := range auditChecklist.Results {
		if err := h.createAudit(db, page, row, properties, auditChecklistIndex, audit, auditCycle); err != nil {
			l.Error(err, "failed to create audit")
			return err
		}
	}

	return nil
}

// syncActionItemPage sync a action item include create action item if not exist, dekete, udpate exist item and update action item high in audit cycle
func (h *handler) syncActionItemPage(db *gorm.DB, databaseID string, withStartCursor bool, actionItemMap map[model.UUID]*model.ActionItem) error {
	l := h.logger.Fields(logger.Fields{
		"method":          "syncActionItemPage",
		"databaseID":      databaseID,
		"withStartCursor": withStartCursor,
	})

	// Get audit action database
	var database *notion.DatabaseQueryResponse
	var err error

	if withStartCursor {
		database, err = h.service.Notion.GetDatabaseWithStartCursor(h.config.Notion.Databases.AuditActionItem, databaseID)
		if err != nil {
			l.Error(err, "failed to get database from notion")
			return err
		}
	} else {
		database, err = h.service.Notion.GetDatabase(databaseID, nil, nil, 0)
		if err != nil {
			l.Error(err, "failed to get database from notion")
			return err
		}
	}

	if database.HasMore {
		err = h.syncActionItemPage(db, *database.NextCursor, true, actionItemMap)
		if err != nil {
			l.Error(err, "failed to run function syncActionItemPage")
			return err
		}
	}

	// Map notion page
	mapPage := NotionDatabaseToMap(db, database)

	// Compare and update
	// Create action item if not exist in actionItemMap
	for _, page := range mapPage {
		l.Infof("Create action item ID: %s", page.ID)
		// If actionItem not exist in mapPage
		actionItempProperties := page.Properties.(notion.DatabasePageProperties)

		pic := &model.Employee{}
		picID := model.UUID{}

		if actionItempProperties["PIC"].People != nil && len(actionItempProperties["PIC"].People) > 0 {
			pic, err = h.store.Employee.OneByNotionID(db, actionItempProperties["PIC"].People[0].ID)
			if err != nil {
				l.Error(err, "failed to get pic from notion id")
			}
		}

		if pic != nil {
			picID = pic.ID
		}

		newActionItem := model.NewActionItemFromNotionPage(page, picID, h.config.Notion.Databases.AuditActionItem)

		// Check whether project_id map with audit_notion_id in db or not
		if !newActionItem.ProjectID.IsZero() {
			exits, err := h.store.ProjectNotion.IsExistByAuditNotionID(db, newActionItem.ProjectID.String())
			if err != nil {
				l.Error(err, "failed to check project_notion_id exits in db")
				return err
			}

			if !exits {
				l.Infof("Project ID: %s not exits in project_notion_id table", newActionItem.ProjectID.String())
				continue
			}
		}

		if !newActionItem.AuditCycleID.IsZero() {
			auditCycle, err := h.store.AuditCycle.One(db, newActionItem.AuditCycleID.String())
			if err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					l.Infof("Audit cycle ID: %s not exits in db", newActionItem.AuditCycleID.String())
					continue
				}

				l.Error(err, "failed to get audit cycle from database")
				return err
			}

			newActionItem.ProjectID = auditCycle.ProjectID
		}

		if ai, ok := actionItemMap[model.MustGetUUIDFromString(page.ID)]; !ok {
			// Create action item
			newActionItem, err = h.store.ActionItem.Create(db, newActionItem)
			if err != nil {
				l.Error(err, "failed to create action item")
				return err
			}
		} else {
			// Update action item
			if !model.CompareActionItem(ai, newActionItem) {
				// Update action item
				newActionItem.ID = ai.ID
				newActionItem, err = h.store.ActionItem.UpdateSelectedFieldsByID(db, newActionItem.ID.String(), *newActionItem,
					"project_id",
					"notion_db_id",
					"pic_id",
					"audit_cycle_id",
					"name",
					"description",
					"need_help",
					"priority",
					"status")
				if err != nil {
					l.Error(err, "failed to update action item")
					return err
				}
			}

			delete(actionItemMap, model.MustGetUUIDFromString(page.ID))
		}

		// Update audit cycle
		if !newActionItem.AuditCycleID.IsZero() {
			auditCycle, err := h.store.AuditCycle.One(db, newActionItem.AuditCycleID.String())
			if err != nil {
				l.Error(err, "failed to get audit cycle from database")
				return err
			}

			if newActionItem.Priority != nil && newActionItem.Status != model.ActionItemStatusDone {
				// Update audit cycle
				switch *newActionItem.Priority {
				case model.ActionItemPriorityLow:
					auditCycle.ActionItemLow++
				case model.ActionItemPriorityMedium:
					auditCycle.ActionItemMedium++
				case model.ActionItemPriorityHigh:
					auditCycle.ActionItemHigh++
				}

				if _, err = h.store.AuditCycle.Update(db, auditCycle); err != nil {
					l.Error(err, "failed to update audit cycle")
					return err
				}
			}
		}
	}

	return nil
}

// syncAuditCycle sync audit cycle if it already exists
func (h *handler) syncAuditCycle(db *gorm.DB, page *notion.Page, auditCycle *model.AuditCycle) error {
	l := h.logger.Fields(logger.Fields{
		"method": "syncAuditCycle",
		"pageID": page.ID,
	})

	newAuditCycle := model.NewAuditCycleFromNotionPage(page, h.config.Notion.Databases.AuditCycle)

	cloneAuditCycle, err := h.store.AuditCycle.One(db, newAuditCycle.ID.String())
	if err != nil {
		l.Error(err, "failed to get audit cycle from database")
		return err
	}

	if err := h.syncAudit(db, page, cloneAuditCycle); err != nil {
		l.Error(err, "failed to sync audit")
		return err
	}

	if !model.CompareAuditCycle(auditCycle, newAuditCycle) || !compareAuditID(auditCycle.HealthAuditID, cloneAuditCycle.HealthAuditID) || !compareAuditID(auditCycle.ProcessAuditID, cloneAuditCycle.ProcessAuditID) ||
		!compareAuditID(auditCycle.BackendAuditID, cloneAuditCycle.BackendAuditID) || !compareAuditID(auditCycle.FrontendAuditID, cloneAuditCycle.FrontendAuditID) || !compareAuditID(auditCycle.BlockchainAuditID, cloneAuditCycle.BlockchainAuditID) ||
		!compareAuditID(auditCycle.SystemAuditID, cloneAuditCycle.SystemAuditID) || !compareAuditID(auditCycle.MobileAuditID, cloneAuditCycle.MobileAuditID) {
		// Update audit cycle
		newAuditCycle.HealthAuditID = cloneAuditCycle.HealthAuditID
		newAuditCycle.ProcessAuditID = cloneAuditCycle.ProcessAuditID
		newAuditCycle.BackendAuditID = cloneAuditCycle.BackendAuditID
		newAuditCycle.FrontendAuditID = cloneAuditCycle.FrontendAuditID
		newAuditCycle.BlockchainAuditID = cloneAuditCycle.BlockchainAuditID
		newAuditCycle.SystemAuditID = cloneAuditCycle.SystemAuditID
		newAuditCycle.MobileAuditID = cloneAuditCycle.MobileAuditID

		_, err := h.store.AuditCycle.UpdateSelectedFieldsByID(db, newAuditCycle.ID.String(), *newAuditCycle,
			"project_id",
			"notion_db_id",
			"health_audit_id",
			"process_audit_id",
			"backend_audit_id",
			"frontend_audit_id",
			"blockchain_audit_id",
			"system_audit_id",
			"mobile_audit_id",
			"cycle",
			"average_score",
			"flag",
			"quarter")

		if err != nil {
			l.Error(err, "failed to update audit cycle")
			return err
		}
	}

	return nil
}

func compareAuditID(oldID, newID *model.UUID) bool {
	if oldID == nil && newID == nil {
		return true
	}

	if oldID == nil || newID == nil {
		return false
	}

	return oldID.String() == newID.String()
}

// deleteAuditCycle delete audit cycle if it not exists in notion
func (h *handler) deleteAuditCycle(db *gorm.DB, auditCycle *model.AuditCycle) error {
	l := h.logger.Fields(logger.Fields{
		"method":       "deleteAuditCycle",
		"auditCycleID": auditCycle.ID.String(),
	})

	auditMap := model.AuditMap(*auditCycle)

	for auditID := range auditMap {
		if err := h.deleteAudit(db, auditID); err != nil {
			l.Error(err, "failed to delete audit")
			return err
		}
	}

	if err := h.store.AuditCycle.Delete(db, auditCycle.ID.String()); err != nil {
		l.Error(err, "failed to delete audit cycle")
		return err
	}

	return nil
}

// syncAudit sync audit if it already exists
func (h *handler) syncAudit(db *gorm.DB, page *notion.Page, auditCycle *model.AuditCycle) error {
	l := h.logger.Fields(logger.Fields{
		"method":       "syncAudit",
		"pageID":       page.ID,
		"auditCycleID": auditCycle.ID.String(),
	})

	audit, err := h.service.Notion.GetBlockChildren(page.ID)
	if err != nil {
		l.Error(err, "failed to get audit from notion")
		return err
	}

	// Find the audit checklist block index
	auditChecklistIndex := -1
	for index, block := range audit.Results {
		if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) {
			auditChecklistIndex = index
		}
	}

	if page.ID == NghenhanAudit1 || page.ID == VoconicAudit1 || auditChecklistIndex == -1 {
		return nil
	}

	properties := page.Properties.(notion.DatabasePageProperties)
	auditChecklist, err := h.service.Notion.GetDatabase(audit.Results[auditChecklistIndex].ID(), nil, nil, 0)
	if err != nil {
		l.Error(err, "failed to get database from notion")
		return err
	}

	auditMap := model.AuditMap(*auditCycle)

	// Sync audit record for each row
	for _, row := range auditChecklist.Results {
		// Check audit existence in database
		if _, ok := auditMap[model.MustGetUUIDFromString(row.ID)]; !ok {
			// if audit is not exist create audit
			if err := h.createAudit(db, page, row, properties, auditChecklistIndex, audit, auditCycle); err != nil {
				l.Error(err, "failed to create audit")
				return err
			}
		} else {
			// Delete audit from audit map
			delete(auditMap, model.MustGetUUIDFromString(row.ID))

			// Check audit info with info in the database
			// Get audit in database
			auditDB, err := h.store.Audit.One(db, row.ID)
			if err != nil {
				l.Error(err, "failed to get audit from database")
				return err
			}

			// Get auditor from notion id
			checklistProperties := row.Properties.(notion.DatabasePageProperties)
			if len(checklistProperties["Auditor"].People) == 0 {
				l.Error(errs.ErrMissingAuditorInAudit, "missing auditor in audit")
				return errs.ErrMissingAuditorInAudit
			}

			auditor, err := h.store.Employee.OneByNotionID(db, checklistProperties["Auditor"].People[0].ID)
			if err != nil {
				l.Error(err, "failed to get auditor from notion id")
			}

			auditorID := model.UUID{}
			if auditor != nil {
				auditorID = auditor.ID
			}

			flag, err := h.getFlag(db, page, &row)
			if err != nil {
				l.Error(err, "failed to get flag")
				return errs.ErrFailedToGetFlag
			}

			if len(properties["Project"].Relation) == 0 {
				l.Error(errs.ErrMissingProjectInAudit, "missing project in audit")
				return errs.ErrMissingProjectInAudit
			}

			newAudit := model.NewAuditFromNotionPage(row, properties["Project"].Relation[0].ID, auditorID, flag, audit.Results[auditChecklistIndex].ID())

			// compare new audit object
			if !model.CompareAudit(*auditDB, *newAudit) {
				// Update audit
				newAudit.ID = auditDB.ID
				if _, err := h.store.Audit.UpdateSelectedFieldsByID(db, newAudit.ID.String(), *newAudit,
					"project_id",
					"notion_db_id",
					"auditor_id",
					"name",
					"type",
					"score",
					"status",
					"flag",
					"action_item",
					"duration",
					"audited_at"); err != nil {
					l.Error(err, "failed to update audit")
					return err
				}
			}

			// Sync audit participant - DONE
			if err := h.syncParticipant(db, checklistProperties, newAudit.ID); err != nil {
				l.Error(err, "failed to sync audit participant")
				return err
			}

			// Sync Audit Items - DONE
			if err := h.syncAuditItem(db, page, &row); err != nil {
				l.Error(err, "failed to sync audit item")
				return err
			}
		}
	}

	// Delete non-existent audits
	for key := range auditMap {
		deletedAudit, err := h.store.Audit.One(db, key.String())
		if err != nil {
			l.Error(err, "failed to get audit from database")
			return err
		}

		h.deleteAuditIDForAuditCycle(db, deletedAudit, auditCycle)
		if err := h.deleteAudit(db, key); err != nil {
			l.Error(err, "failed to delete audit")
			return err
		}
	}

	return nil
}

func (h *handler) deleteAudit(db *gorm.DB, auditID model.UUID) error {
	l := h.logger.Fields(logger.Fields{
		"method":  "deleteAudit",
		"auditID": auditID.String(),
	})

	// Delete audit item
	if err := h.store.AuditItem.DeleteByAuditID(db, auditID.String()); err != nil {
		l.Error(err, "failed to delete audit item")
		return err
	}

	// Delete audit participant
	if err := h.store.AuditParticipant.DeleteByAuditID(db, auditID.String()); err != nil {
		l.Error(err, "failed to delete audit participant")
		return err
	}

	// Delete audit action item by audit id
	if err := h.store.AuditActionItem.DeleteByAuditID(db, auditID.String()); err != nil {
		l.Error(err, "failed to delete audit action item")
		return err
	}

	// Delete audit
	if err := h.store.Audit.Delete(db, auditID.String()); err != nil {
		l.Error(err, "failed to delete audit")
		return err
	}

	return nil
}

func (h *handler) createAudit(db *gorm.DB, page *notion.Page, row notion.Page, properties notion.DatabasePageProperties, auditChecklistIndex int, audit *notion.BlockChildrenResponse, auditCycle *model.AuditCycle) error {
	l := h.logger.Fields(logger.Fields{
		"method": "createAudit",
	})
	// get auditor from notion id
	checklistProperties := row.Properties.(notion.DatabasePageProperties)
	if len(checklistProperties["Auditor"].People) == 0 {
		l.Error(errs.ErrMissingAuditorInAudit, "auditor is missing in audit")
		return errs.ErrMissingAuditorInAudit
	}

	auditor, err := h.store.Employee.OneByNotionID(db, checklistProperties["Auditor"].People[0].ID)
	if err != nil {
		l.Error(err, "failed to get auditor from notion id")
		return err
	}

	// Create new audit object
	flag, err := h.getFlag(db, page, &row)
	if err != nil {
		l.Error(err, "failed to get flag")
		return errs.ErrFailedToGetFlag
	}

	projectID := ""
	if properties["Project"].Relation != nil && len(properties["Project"].Relation) > 0 {
		projectID = properties["Project"].Relation[0].ID
	}

	newAudit := model.NewAuditFromNotionPage(row, projectID, auditor.ID, flag, audit.Results[auditChecklistIndex].ID())
	// if something wrong with the audit object, return nil
	if newAudit == nil {
		return nil
	}

	newAudit, _ = h.store.Audit.Create(db, newAudit)

	// Create new audit participant
	if len(checklistProperties["Participants"].People) > 0 {
		for _, p := range checklistProperties["Participants"].People {
			participant, err := h.store.Employee.OneByNotionID(db, p.ID)
			if err != nil {
				l.Error(err, "failed to get participant by notion id")
				continue
			}

			_, err = h.store.AuditParticipant.Create(db, &model.AuditParticipant{
				AuditID:    newAudit.ID,
				EmployeeID: participant.ID,
			})

			if err != nil {
				l.Error(err, "failed to create audit participant")
				return err
			}
		}
	}

	// Update audit cycle
	h.updateAuditIDForAuditCycle(db, newAudit, auditCycle)

	// Create Audit Items
	if err := h.createAuditItem(db, page, &row); err != nil {
		l.Error(err, "failed to create audit item")
		return err
	}

	return nil
}

func (h *handler) syncParticipant(db *gorm.DB, checklistProperties notion.DatabasePageProperties, auditID model.UUID) error {
	l := h.logger.Fields(logger.Fields{
		"method":  "syncParticipant",
		"auditID": auditID.String(),
	})

	// Get all audit participant
	auditParticipants, err := h.store.AuditParticipant.AllByAuditID(db, auditID.String())
	if err != nil {
		l.Error(err, "failed to get all audit participant")
		return err
	}

	apMap := model.AuditParticipantToMap(auditParticipants)

	if len(checklistProperties["Participants"].People) > 0 {
		for _, p := range checklistProperties["Participants"].People {
			participant, err := h.store.Employee.OneByNotionID(db, p.ID)
			if err != nil {
				l.Error(err, "failed to get participant by notion id")
				continue
			}

			if _, ok := apMap[participant.ID]; !ok {
				_, err = h.store.AuditParticipant.Create(db, &model.AuditParticipant{
					AuditID:    auditID,
					EmployeeID: participant.ID,
				})

				if err != nil {
					l.Error(err, "failed to create audit participant")
					return err
				}
			} else {
				delete(apMap, participant.ID)
			}
		}

		for _, p := range apMap {
			if err := h.store.AuditParticipant.Delete(db, p.ID.String()); err != nil {
				l.Error(err, "failed to delete audit participant")
				return err
			}
		}
	}

	return nil
}

func (h *handler) deleteAuditIDForAuditCycle(db *gorm.DB, audit *model.Audit, auditCycle *model.AuditCycle) {
	switch audit.Type {
	case model.AuditTypeHealth:
		if *auditCycle.HealthAuditID == audit.ID {
			auditCycle.HealthAuditID = nil
		}
	case model.AuditTypeProcess:
		if *auditCycle.ProcessAuditID == audit.ID {
			auditCycle.ProcessAuditID = nil
		}
	case model.AuditTypeBackend:
		if *auditCycle.BackendAuditID == audit.ID {
			auditCycle.BackendAuditID = nil
		}
	case model.AuditTypeFrontend:
		if *auditCycle.FrontendAuditID == audit.ID {
			auditCycle.FrontendAuditID = nil
		}
	case model.AuditTypeSystem:
		if *auditCycle.SystemAuditID == audit.ID {
			auditCycle.SystemAuditID = nil
		}
	case model.AuditTypeMobile:
		if *auditCycle.MobileAuditID == audit.ID {
			auditCycle.MobileAuditID = nil
		}
	case model.AuditTypeBlockchain:
		if *auditCycle.BlockchainAuditID == audit.ID {
			auditCycle.BlockchainAuditID = nil
		}
	}
}

func (h *handler) updateAuditIDForAuditCycle(db *gorm.DB, audit *model.Audit, auditCycle *model.AuditCycle) {
	switch audit.Type {
	case model.AuditTypeHealth:
		auditCycle.HealthAuditID = &audit.ID
	case model.AuditTypeProcess:
		auditCycle.ProcessAuditID = &audit.ID
	case model.AuditTypeBackend:
		auditCycle.BackendAuditID = &audit.ID
	case model.AuditTypeFrontend:
		auditCycle.FrontendAuditID = &audit.ID
	case model.AuditTypeSystem:
		auditCycle.SystemAuditID = &audit.ID
	case model.AuditTypeMobile:
		auditCycle.MobileAuditID = &audit.ID
	case model.AuditTypeBlockchain:
		auditCycle.BlockchainAuditID = &audit.ID
	}

	if audit.Score != 0 {
		auditCycle.Status = model.AuditStatusAudited
	}
}

func (h *handler) getFlag(db *gorm.DB, page *notion.Page, row *notion.Page) (model.AuditFlag, error) {
	l := h.logger.Fields(logger.Fields{
		"method": "getFlag",
		"pageID": page.ID,
		"rowID":  row.ID,
	})

	countPoor, countAcceptable := 0, 0
	checklistPage, err := h.service.Notion.GetBlockChildren(row.ID)
	if err != nil {
		l.Error(err, "failed to get audit from notion")
		return "", err
	}

	// Find the audit checklist block index
	checklistDatabaseIndex := -1
	for index, block := range checklistPage.Results {
		if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) {
			checklistDatabaseIndex = index
		}
	}

	if checklistDatabaseIndex == -1 {
		return model.AuditFlagGreen, nil
	}
	checklistDatabase, err := h.service.Notion.GetDatabase(checklistPage.Results[checklistDatabaseIndex].ID(), nil, nil, 0)
	if err != nil {
		l.Error(err, "failed to get database from notion")
		return "", err
	}

	// Create audit item record for each row
	for _, checklist := range checklistDatabase.Results {
		// Create new audit object
		properties := checklist.Properties.(notion.DatabasePageProperties)
		if properties["Grade"].Select != nil {
			switch properties["Grade"].Select.Name {
			case "Poor":
				countPoor++
			case "Acceptable":
				countAcceptable++
			}
		}
	}

	if countPoor >= 3 {
		return model.AuditFlagRed, nil
	} else if countAcceptable >= 3 {
		return model.AuditFlagYellow, nil
	}

	return model.AuditFlagGreen, nil
}

func (h *handler) createAuditItem(db *gorm.DB, page *notion.Page, row *notion.Page) error {
	l := h.logger.Fields(logger.Fields{
		"method": "createAuditItem",
		"pageID": page.ID,
		"rowID":  row.ID,
	})

	l.Infof("Create audit item %s", row.ID)
	checklistPage, err := h.service.Notion.GetBlockChildren(row.ID)
	if err != nil {
		l.Error(err, "failed to get audit from notion")
		return err
	}

	// Find the audit checklist block index
	checklistDatabaseIndex := -1
	for index, block := range checklistPage.Results {
		if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) {
			checklistDatabaseIndex = index
		}
	}

	checklistDatabase, err := h.service.Notion.GetDatabase(checklistPage.Results[checklistDatabaseIndex].ID(), nil, nil, 0)
	if err != nil {
		l.Error(err, "failed to get database from notion")
		return err
	}

	// Create audit item record for each row
	for _, checklist := range checklistDatabase.Results {
		// Create new audit object
		newAuditItem := model.NewAuditItemFromNotionPage(checklist, row.ID, checklistPage.Results[checklistDatabaseIndex].ID())
		_, err := h.store.AuditItem.Create(db, newAuditItem)
		if err != nil {
			l.Error(err, "failed to create audit item")
		}
	}

	return nil
}

func (h *handler) syncAuditItem(db *gorm.DB, page *notion.Page, row *notion.Page) error {
	l := h.logger.Fields(logger.Fields{
		"method": "syncAuditItem",
		"pageID": page.ID,
		"rowID":  row.ID,
	})

	// Get all audit items
	auditItems, err := h.store.AuditItem.AllByAuditID(db, row.ID)
	if err != nil {
		l.Error(err, "failed to get audit items from database")
		return err
	}

	aiMap := model.AuditItemToMap(auditItems)

	l.Infof("Sync audit item %s", row.ID)
	checklistPage, err := h.service.Notion.GetBlockChildren(row.ID)
	if err != nil {
		l.Error(err, "failed to get audit from notion")
		return err
	}

	// Find the audit checklist block index
	checklistDatabaseIndex := -1
	for index, block := range checklistPage.Results {
		if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) {
			checklistDatabaseIndex = index
		}
	}

	checklistDatabase, err := h.service.Notion.GetDatabase(checklistPage.Results[checklistDatabaseIndex].ID(), nil, nil, 0)
	if err != nil {
		l.Error(err, "failed to get database from notion")
		return err
	}

	// Sync audit item record for each row
	for _, checklist := range checklistDatabase.Results {
		if _, ok := aiMap[model.MustGetUUIDFromString(checklist.ID)]; !ok {
			// Create new audit object
			newAuditItem := model.NewAuditItemFromNotionPage(checklist, row.ID, checklistPage.Results[checklistDatabaseIndex].ID())
			_, err = h.store.AuditItem.Create(db, newAuditItem)
			if err != nil {
				l.Error(err, "failed to create audit item")
				return err
			}
		} else {
			// Update audit object
			auditItem := aiMap[model.MustGetUUIDFromString(checklist.ID)]
			newAuditItem := model.NewAuditItemFromNotionPage(checklist, row.ID, checklistPage.Results[checklistDatabaseIndex].ID())
			if !model.CompareAuditItem(&auditItem, newAuditItem) {
				newAuditItem.ID = auditItem.ID
				if _, err := h.store.AuditItem.UpdateSelectedFieldsByID(db, newAuditItem.ID.String(), *newAuditItem,
					"audit_id",
					"notion_db_id",
					"name",
					"area",
					"requirements",
					"grade",
					"severity",
					"notes",
					"action_item_id"); err != nil {
					l.Error(err, "failed to update audit item")
					return err
				}
			}
			delete(aiMap, model.MustGetUUIDFromString(checklist.ID))
		}
	}

	// Delete audit items not exist
	for _, auditItem := range aiMap {
		if err := h.store.AuditItem.Delete(db, auditItem.ID.String()); err != nil {
			l.Error(err, "failed to delete audit item")
			return err
		}
	}

	return nil
}

func NotionDatabaseToMap(db *gorm.DB, database *notion.DatabaseQueryResponse) map[string]notion.Page {
	result := make(map[string]notion.Page)
	for _, r := range database.Results {
		result[r.ID] = r
	}

	return result
}

// syncAuditActionItem sync audit action item for all audit cycle, audit, audit item, audit action item
func (h *handler) syncAuditActionItem(db *gorm.DB) error {
	l := h.logger.Fields(logger.Fields{
		"method": "syncAuditActionItem",
	})

	l.Infof("Syncing audit action item started")

	// Get all audit cycle from database
	auditCycles, err := h.store.AuditCycle.All(db)
	if err != nil {
		l.Error(err, "failed to get audit cycle from database")
		return err
	}

	// Sync audit action item for all audit cycles
	for _, auditCycle := range auditCycles {
		if err := h.syncAuditActionItemInAuditCycle(db, auditCycle); err != nil {
			l.Error(err, "failed to run syncAuditActionItemInAuditCycle function")
			return err
		}
	}

	l.Infof("Syncing audit action item finished")
	return err
}

func (h *handler) syncAuditActionItemInAuditCycle(db *gorm.DB, auditCycle *model.AuditCycle) error {
	l := h.logger.Fields(logger.Fields{
		"method":       "syncAuditActionItemInAuditCycle",
		"auditCycleID": auditCycle.ID.String(),
	})

	l.Infof("Sync Audit Action Item for audit cycle: %s", auditCycle.ID.String())
	// check if audit cycle has audit
	if auditCycle.HealthAuditID != nil {
		if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.HealthAuditID); err != nil {
			l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.HealthAuditID.String())
			return err
		}
	}

	if auditCycle.ProcessAuditID != nil {
		if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.ProcessAuditID); err != nil {
			l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.ProcessAuditID.String())
			return err
		}
	}

	if auditCycle.FrontendAuditID != nil {
		if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.FrontendAuditID); err != nil {
			l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.FrontendAuditID.String())
			return err
		}
	}

	if auditCycle.BackendAuditID != nil {
		if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.BackendAuditID); err != nil {
			l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.BackendAuditID.String())
			return err
		}
	}

	if auditCycle.MobileAuditID != nil {
		if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.MobileAuditID); err != nil {
			l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.MobileAuditID.String())
			return err
		}
	}

	if auditCycle.BlockchainAuditID != nil {
		if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.BlockchainAuditID); err != nil {
			l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.BlockchainAuditID.String())
			return err
		}
	}

	if auditCycle.SystemAuditID != nil {
		if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.SystemAuditID); err != nil {
			l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.SystemAuditID.String())
			return err
		}
	}

	return nil
}

func (h *handler) syncAuditActionItemInAudit(db *gorm.DB, auditCycle *model.AuditCycle, auditID model.UUID) error {
	l := h.logger.Fields(logger.Fields{
		"method":       "syncAuditActionItemInAudit",
		"auditID":      auditID.String(),
		"auditCycleID": auditCycle.ID.String(),
	})

	l.Infof("Sync Audit Action Item for audit: %s", auditID.String())
	audit, err := h.store.Audit.One(db, auditID.String())
	if err != nil {
		l.Error(err, "failed to get audit from database")
		return err
	}

	// call api to get data of the audit from notion
	checklistPage, err := h.service.Notion.GetBlockChildren(audit.ID.String())
	if err != nil {
		l.Error(err, "failed to get audit from notion")
		return err
	}

	// Find the audit checklist block index
	checklistDatabaseIndex := -1
	for index, block := range checklistPage.Results {
		if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) {
			checklistDatabaseIndex = index
		}
	}

	checklistDatabase, err := h.service.Notion.GetDatabase(checklistPage.Results[checklistDatabaseIndex].ID(), nil, nil, 0)
	if err != nil {
		l.Error(err, "failed to get database from notion")
		return err
	}

	// Get all audit action item in the database
	auditActionItem, err := h.store.AuditActionItem.AllByAuditID(db, auditID.String())
	if err != nil {
		l.Error(err, "failed to get audit action item from database")
		return err
	}

	aaiMap := model.AuditActionItemToMap(auditActionItem)

	// Loop through all audit items and update to database if it have value in Audit action items field
	for _, checklist := range checklistDatabase.Results {
		checklistProperties := checklist.Properties.(notion.DatabasePageProperties)
		// Get audit item
		auditItem, err := h.store.AuditItem.One(db, checklist.ID)
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				l.Errorf(err, "audit item with id: %s not found", checklist.ID)
				continue
			}

			l.Error(err, "failed to get audit item from database")
			return err
		}

		if checklistProperties["☎️ Audit Action Items"].Relation == nil && auditItem.ActionItemID != nil {
			// Update audit item if action item to nil
			auditItem.ActionItemID = nil
			if _, err = h.store.AuditItem.UpdateSelectedFieldsByID(db, auditItem.ID.String(), *auditItem, "action_item_id"); err != nil {
				l.Error(err, "failed to update audit item")
				return err
			}
		} else if len(checklistProperties["☎️ Audit Action Items"].Relation) > 0 {
			// update audit_items(action_item_id)->audit(action_item)-> create record trong audit_action_items
			// Get action item
			actionItem, err := h.store.ActionItem.One(db, checklistProperties["☎️ Audit Action Items"].Relation[0].ID)
			if err != nil {
				// if err is not found skip update
				if errors.Is(err, gorm.ErrRecordNotFound) {
					continue
				}

				l.Error(err, "failed to get action item from database")
				return err
			}

			// Update audit item if action item change
			if auditItem.ActionItemID == nil || (auditItem.ActionItemID != nil && *auditItem.ActionItemID != actionItem.ID) {
				auditItem.ActionItemID = &actionItem.ID
				if _, err = h.store.AuditItem.UpdateSelectedFieldsByID(db, auditItem.ID.String(), *auditItem, "action_item_id"); err != nil {
					l.Error(err, "failed to update audit item")
					return err
				}
			}

			// Update audit
			audit.ActionItem++
			if audit, err = h.store.Audit.Update(db, audit); err != nil {
				l.Error(err, "failed to update audit")
				return err
			}

			// Update audit action item table
			if _, ok := aaiMap[model.AuditAction{AuditID: audit.ID, ActionItemID: actionItem.ID}]; ok {
				delete(aaiMap, model.AuditAction{AuditID: audit.ID, ActionItemID: actionItem.ID})
			} else {
				// Create audit action item
				auditActionItem := &model.AuditActionItem{
					AuditID:      audit.ID,
					ActionItemID: actionItem.ID,
				}
				if _, err = h.store.AuditActionItem.Create(db, auditActionItem); err != nil {
					l.Error(err, "failed to create audit action item")
					return err
				}
			}
		}
	}

	// Delete audit action item
	for _, aai := range aaiMap {
		if err := h.store.AuditActionItem.Delete(db, aai.ID.String()); err != nil {
			l.Error(err, "failed to delete audit action item")
			return err
		}
	}

	return nil
}

func (h *handler) snapShot(db *gorm.DB) error {
	l := h.logger.Fields(logger.Fields{
		"method": "snapShot",
	})

	// Get all audit cycle from database
	auditCycles, err := h.store.AuditCycle.All(db)
	if err != nil {
		l.Error(err, "failed to get audit cycle from database")
		return err
	}

	// Create action item snapshot record for each audit cycle
	for _, auditCycle := range auditCycles {
		projectNotion, err := h.store.ProjectNotion.OneByAuditNotionID(db, auditCycle.ProjectID.String())
		if err != nil {
			l.Error(err, "failed to get project notion from database")
			return err
		}

		if projectNotion.Project.Status != model.ProjectStatusClosed && projectNotion.Project.Status != model.ProjectStatusPaused {
			actionItemSnapshot := &model.ActionItemSnapshot{
				ProjectID:    auditCycle.ProjectID,
				AuditCycleID: auditCycle.ID,
				High:         auditCycle.ActionItemHigh,
				Medium:       auditCycle.ActionItemMedium,
				Low:          auditCycle.ActionItemLow,
			}

			// Check record exists in database
			today := time.Now().Format("2006-01-02")

			if snapShot, err := h.store.ActionItemSnapshot.OneByAuditCycleIDAndTime(db, auditCycle.ID.String(), today); err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					if _, err := h.store.ActionItemSnapshot.Create(db, actionItemSnapshot); err != nil {
						l.Error(err, "failed to create action item snapshot")
						return err
					}
				} else {
					l.Error(err, "failed to get action item snapshot from database")
					return err
				}
			} else {
				// Update if record exists
				if !model.CompareActionItemSnapshot(snapShot, actionItemSnapshot) {
					if _, err := h.store.ActionItemSnapshot.UpdateSelectedFieldsByID(db, snapShot.ID.String(), *actionItemSnapshot, "high", "medium", "low"); err != nil {
						l.Error(err, "failed to update action item snapshot")
						return err
					}
				}
			}
		}
	}

	return nil
}

```

# pkg/handler/accounting/service.go

```go
package accounting

import "github.com/gin-gonic/gin"

type IHandler interface {
	CreateAccountingTodo(c *gin.Context)
}

```

# pkg/handler/accounting/accounting.go

```go
package accounting

import (
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/jackc/numfmt"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/store/project"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type handler struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler {
	return &handler{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

func (h handler) CreateAccountingTodo(c *gin.Context) {
	l := h.logger.Fields(logger.Fields{
		"handler": "Accounting",
		"method":  "CreateAccountingTodo",
	})

	month, year := timeutil.GetMonthAndYearOfNextMonth()

	l.Info(fmt.Sprintf("Creating accounting todo for %s-%v", time.Month(month), year))
	accountingTodo := consts.PlaygroundID
	todoSetID := consts.PlaygroundTodoID
	if h.config.Env == "prod" {
		accountingTodo = consts.AccountingID
		todoSetID = consts.AccountingTodoID
	}

	todoList := bcModel.TodoList{Name: fmt.Sprintf("Accounting | %s %v", time.Month(month).String(), year)}
	todoGroupInFoundation := bcModel.TodoGroup{Name: "In"}
	todoGroupOut := bcModel.TodoGroup{Name: "Out"}

	// Get list accounting(Service table in db) template

	outTodoTemplates, err := h.store.OperationalService.FindOperationByMonth(h.repo.DB(), time.Month(month))
	if err != nil {
		l.Errorf(err, "failed to find operation by month", "month", time.Month(month))
		c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, time.Month(month), ""))
		return
	}

	createTodo, err := h.service.Basecamp.Todo.CreateList(accountingTodo, todoSetID, todoList)
	if err != nil {
		l.Errorf(err, "failed to create todo list", "accountingTodo", accountingTodo, "todoSetID", todoSetID, "todoList", todoList)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, ""))
		return
	}

	//Create In group
	inGroup, err := h.service.Basecamp.Todo.CreateGroup(accountingTodo, createTodo.ID, todoGroupInFoundation)
	if err != nil {
		l.Errorf(err, "failed to create todo list", "accountingTodo", accountingTodo, "createTodo.ID", createTodo.ID, "todoGroupInFoundation", todoGroupInFoundation)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, ""))
		return
	}

	// Create Out group
	outGroup, err := h.service.Basecamp.Todo.CreateGroup(accountingTodo, createTodo.ID, todoGroupOut)
	if err != nil {
		l.Errorf(err, "failed to create group", "accountingTodo", accountingTodo, "createTodo.ID", createTodo.ID, "todoGroupOut", todoGroupOut)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, ""))
		return
	}

	// Create todoList for each accounting template into out Group
	err = h.createTodoInOutGroup(outGroup.ID, accountingTodo, outTodoTemplates, month, year)
	if err != nil {
		l.Errorf(err, "failed to create In Out todo group", "accountingTodo", accountingTodo, "outTodoTemplates", outTodoTemplates, "month", month, "year", year)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, ""))
		return
	}

	// Create Salary to do and add into out group
	err = h.createSalaryTodo(outGroup.ID, accountingTodo, month, year)
	if err != nil {
		l.Errorf(err, "failed to create salary todo", "accountingTodo", accountingTodo, "month", month, "year", year)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, ""))
		return
	}
	// create to do IN group
	err = h.createTodoInInGroup(inGroup.ID, accountingTodo)
	if err != nil {
		l.Errorf(err, "failed to create salary todo", "accountingTodo", accountingTodo, "inGroup.ID", inGroup.ID)
		c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, ""))
		return
	}

	c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok"))
}

func (h handler) createTodoInOutGroup(outGroupID int, projectID int, outTodoTemplates []*model.OperationalService, month int, year int) error {
	l := h.logger.Fields(logger.Fields{
		"handler": "Accounting",
		"method":  "createTodoInOutGroup",
	})
	for _, v := range outTodoTemplates {
		extraMsg := ""

		// Create CBRE management fee from `Office Rental` template
		if strings.Contains(v.Name, "Office Rental") {
			extraMsg = fmt.Sprintf("Hado Office Rental %v/%v", month, year)

			s := v.Name
			for _, v := range []string{"Tiền điện", "CBRE"} {
				content := strings.Replace(s, "Office Rental", v, 1)
				todo := bcModel.Todo{
					Content:     fmt.Sprintf("%s %v/%v", content, month, year),
					Description: fmt.Sprintf("I3.18.08 thanh toan %s %v/%v", v, month, year),
					DueOn:       fmt.Sprintf("%v-%v-%v", timeutil.LastDayOfMonth(month, year).Day(), month, year),
					AssigneeIDs: []int{consts.QuangBasecampID},
				}
				_, err := h.service.Basecamp.Todo.Create(projectID, outGroupID, todo)
				if err != nil {
					l.Error(err, "Fail when try to create CBRE management fee")
					return err
				}
			}
		}

		f := &numfmt.Formatter{
			NegativeTemplate: "(n)",
			MinDecimalPlaces: 0,
		}

		todo := bcModel.Todo{
			Content:     fmt.Sprintf("%s | %s | %s", v.Name, strings.Replace(f.Format(v.Amount), ",", ".", -1), v.Currency.Name), //nolint:govet
			DueOn:       fmt.Sprintf("%v-%v-%v", timeutil.LastDayOfMonth(month, year).Day(), month, year),
			AssigneeIDs: []int{consts.QuangBasecampID},
			Description: extraMsg,
		}
		_, err := h.service.Basecamp.Todo.Create(projectID, outGroupID, todo)
		if err != nil {
			l.Error(err, "Fail when try to create out todos")
			return err
		}
	}
	return nil
}

func (h handler) createSalaryTodo(outGroupID int, projectID int, month int, year int) error {
	//created TO DO salary 15th
	salary15 := bcModel.Todo{
		Content:     "salary 15th",
		DueOn:       fmt.Sprintf("%v-%v-%v", 12, year, month),
		AssigneeIDs: []int{consts.QuangBasecampID, consts.HanBasecampID},
	}
	_, err := h.service.Basecamp.Todo.Create(projectID, outGroupID, salary15)
	if err != nil {
		return err
	}

	// Create To do Salary 1st
	salary1 := bcModel.Todo{
		Content:     "salary 1st",
		DueOn:       fmt.Sprintf("%v-%v-%v", 27, year, month),
		AssigneeIDs: []int{consts.QuangBasecampID, consts.HanBasecampID},
	}

	_, err = h.service.Basecamp.Todo.Create(projectID, outGroupID, salary1)
	if err != nil {
		return err
	}
	return nil
}

func (h handler) createTodoInInGroup(inGroupID int, projectID int) error {
	l := h.logger.Fields(logger.Fields{
		"handler": "Accounting",
		"method":  "createSalaryTodo",
	})
	activeProjects, _, err := h.store.Project.All(h.repo.DB(), project.GetListProjectInput{Statuses: []string{model.ProjectStatusActive.String()}}, model.Pagination{})
	if err != nil {
		return err
	}
	now := time.Now()
	month := int(now.Month())
	year := now.Year()

	for _, p := range activeProjects {
		// Default will assign to Giang Than
		assigneeIDs := []int{consts.GiangThanBasecampID}

		_, err := h.service.Basecamp.Todo.Create(projectID, inGroupID, buildInvoiceTodo(p.Name, month, year, assigneeIDs))
		if err != nil {
			l.Error(err, fmt.Sprint("Failed to create invoice todo on project", p.Name))
		}
	}
	return nil
}

func buildInvoiceTodo(name string, month, year int, assigneeIDs []int) bcModel.Todo {
	dueOn := getProjectInvoiceDueOn(name, month, year)
	content := getProjectInvoiceContent(name, month, year)
	return bcModel.Todo{
		Content:     content,
		AssigneeIDs: assigneeIDs,
		DueOn:       dueOn,
	}
}
func getProjectInvoiceDueOn(name string, month, year int) string {
	var day int
	if strings.ToLower(name) == "voconic" {
		day = 23
	} else {
		a := timeutil.LastDayOfMonth(month, year)
		day = a.Day()
	}
	return fmt.Sprintf("%v-%v-%v", day, month, year)
}
func getProjectInvoiceContent(name string, month, year int) string {
	return fmt.Sprintf("%s %v/%v", name, month, year)
}

```

# pkg/controller/news/reddit.go

```go
package news

import (
	"context"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

func (c *controller) FetchRedditNews(ctx context.Context, tag string) ([]model.News, error) {
	// Fetch Golang news from Reddit
	redditPosts, err := c.service.Reddit.FetchGolangNews(ctx)
	if err != nil {
		return nil, err
	}

	// Truncate to last 10 posts if more than 10
	if len(redditPosts) > 10 {
		redditPosts = redditPosts[len(redditPosts)-10:]
	}

	// Convert to model.News
	news := make([]model.News, len(redditPosts))
	for i, post := range redditPosts {
		news[i] = model.News{
			Title:        post.Title,
			URL:          post.URL,
			Popularity:   int64(post.Score),
			CommentCount: int64(post.NumberOfComments),
			Description:  post.Body,
			Tags:         []string{tag}, // Using the input tag
			CreatedAt:    post.Created.Time,
		}
	}

	return news, nil
}

```

# pkg/controller/news/new.go

```go
package news

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	config  *config.Config
}

func New(store *store.Store, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

```

# pkg/controller/news/lobsters.go

```go
package news

import (
	"context"
	"sort"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

func (c *controller) FetchLobstersNews(ctx context.Context, tag string) ([]model.News, error) {
	logger := c.logger.Fields(logger.Fields{
		"controller": "news",
		"method":     "FetchLobstersNews",
		"tag":        tag,
	})

	news, err := c.service.Lobsters.FetchNews(tag)
	if err != nil {
		logger.Error(err, "failed to fetch news from lobsters")
		return nil, err
	}

	normalized := make([]model.News, 0, len(news))
	for _, n := range news {
		url := n.URL
		if url == "" {
			url = n.ShortIDURL
		}
		if url == "" {
			continue
		}

		normalized = append(normalized, model.News{
			Title:        n.Title,
			URL:          url,
			Popularity:   int64(n.Score),
			CommentCount: int64(n.CommentCount),
			Description:  n.Description,
			Tags:         n.Tags,
			CreatedAt:    n.CreatedAt,
		})
	}

	// Sort by creation time (descending) and then by popularity (descending)
	sort.Slice(normalized, func(i, j int) bool {
		if normalized[i].CreatedAt.Equal(normalized[j].CreatedAt) {
			return normalized[i].Popularity > normalized[j].Popularity
		}
		return normalized[i].CreatedAt.After(normalized[j].CreatedAt)
	})

	// Filter for posts within the last 24 hours
	emerging := make([]model.News, 0)
	for _, n := range normalized {
		if time.Since(n.CreatedAt) <= 24*time.Hour {
			emerging = append(emerging, n)
		}
	}

	// If more than 10 posts in 24 hours, truncate to 10
	if len(emerging) > 10 {
		emerging = emerging[:10]
	} else if len(emerging) < 10 {
		// If less than 10 posts in 24 hours, add more posts without time check
		for _, n := range normalized {
			if len(emerging) == 10 {
				break
			}
			if time.Since(n.CreatedAt) > 24*time.Hour {
				emerging = append(emerging, n)
			}
		}
	}

	return emerging, nil
}

```

# pkg/controller/news/interface.go

```go
package news

import (
	"context"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IController interface {
	FetchLobstersNews(ctx context.Context, tag string) ([]model.News, error)
	FetchRedditNews(ctx context.Context, tag string) ([]model.News, error)
}

```

# pkg/controller/memologs/sync.go

```go
package memologs

import (
	"encoding/xml"
	"errors"
	"net/http"
	"strings"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/store/memolog"
)

const (
	dfMemoRssURL = "https://memo.d.foundation/index.xml"
)

func (c *controller) Sync() ([]model.MemoLog, error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "memologs",
		"method":     "Sync",
	})

	last7days := time.Now().AddDate(0, 0, -7)
	latestMemos, err := c.store.MemoLog.List(c.repo.DB(), memolog.ListFilter{
		From: &last7days,
	})
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		l.Errorf(err, "failed to get latest memo")
		return nil, err
	}

	latestMemosMap := make(map[string]model.MemoLog)
	for _, memo := range latestMemos {
		latestMemosMap[memo.URL] = memo
	}

	resp, err := http.Get(dfMemoRssURL)
	if err != nil {
		l.Errorf(err, "failed to get rss feed from %s, status code: %d", dfMemoRssURL, resp.StatusCode)
		return nil, err
	}
	defer resp.Body.Close()

	decoder := xml.NewDecoder(resp.Body)

	inItem := false
	currentElem := ""
	item := Item{}
	newMemos := make([]model.MemoLog, 0)
	stop := false
	for !stop {
		token, err := decoder.Token()
		if err != nil {
			break
		}

		switch se := token.(type) {
		case xml.StartElement:
			currentElem = se.Name.Local
			if se.Name.Local == "item" {
				inItem = true
				item = Item{}
			}
		case xml.EndElement:
			if se.Name.Local == "item" {
				inItem = false

				if _, ok := latestMemosMap[item.Link]; ok {
					continue
				}

				// Ignore folder is built as an item
				if item.Description == "" && item.Author == "" {
					continue
				}

				pubDate, _ := time.Parse(time.RFC1123Z, item.PubDate)
				if pubDate.Before(last7days) {
					stop = true
					break
				}

				authorUsernames := make([]string, 0)
				for _, s := range strings.Split(strings.TrimSpace(item.Author), ",") {
					if s != "" {
						authorUsernames = append(authorUsernames, strings.TrimSpace(s))
					}
				}

				authors, err := c.store.DiscordAccount.ListByMemoUsername(c.repo.DB(), authorUsernames)
				if err != nil {
					l.Errorf(err, "failed to get authors by discord usernames: %v", authorUsernames)
					continue
				}

				newMemos = append(newMemos, model.MemoLog{
					Title:               item.Title,
					URL:                 item.Link,
					Description:         item.Description,
					PublishedAt:         &pubDate,
					Authors:             authors,
					AuthorMemoUsernames: authorUsernames,
					Category:            extractMemoCategory(item.Link),
				})
			}
		case xml.CharData:
			if inItem {
				data := string(se)
				switch currentElem {
				case "title":
					item.Title = data
				case "link":
					item.Link = data
				case "pubDate":
					item.PubDate = data
				case "author":
					item.Author = data
				case "guid":
					item.Guid = data
				case "description":
					item.Description = data
				case "draft":
					item.Draft = data
				}
			}
		}
	}

	if len(newMemos) == 0 {
		return nil, nil
	}

	// Create new memos
	results, err := c.store.MemoLog.Create(c.repo.DB(), newMemos)
	if err != nil {
		l.Errorf(err, "failed to create new memos")
		return nil, err
	}

	return results, nil
}

type Item struct {
	Title       string `xml:"title"`
	Link        string `xml:"link"`
	PubDate     string `xml:"pubDate"`
	Author      string `xml:"author"`
	Guid        string `xml:"guid"`
	Description string `xml:"description"`
	Draft       string `xml:"draft"`
}

// extractMemoCategory extracts memo category from link
func extractMemoCategory(url string) []string {
	routes := strings.Split(url, "memo.d.foundation")
	if len(routes) < 2 {
		return nil
	}

	splitPath := strings.Split(strings.TrimSpace(routes[1]), "/")

	// Filter out empty string
	category := make([]string, 0)
	for _, s := range splitPath {
		if s != "" {
			category = append(category, s)
		}
	}

	// final thing is the name of memo, ignore it
	if len(category) > 0 {
		category = category[:len(category)-1]
	}

	return category
}

```

# pkg/controller/memologs/sweep.go

```go
package memologs

import (
	"encoding/xml"
	"net/http"
	"strings"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

func (c *controller) Sweep() error {
	// List memo logs without authors
	memoLogs, err := c.store.MemoLog.ListNonAuthor(c.repo.DB())
	if err != nil {
		return err
	}

	// Fetch memo data from the RSS feed
	resp, err := http.Get(dfMemoRssURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	var feed struct {
		Items []struct {
			Link   string `xml:"link"`
			Author string `xml:"author"`
		} `xml:"channel>item"`
	}

	if err := xml.NewDecoder(resp.Body).Decode(&feed); err != nil {
		return err
	}

	memoData := make(map[string][]string)
	for _, item := range feed.Items {
		authors := strings.Split(item.Author, ",")
		for i := 0; i < len(authors); i++ {
			authors[i] = strings.TrimSpace(authors[i])
			if authors[i] == "" {
				authors = append(authors[:i], authors[i+1:]...)
				i--
			}
		}

		if len(authors) == 0 {
			continue
		}
		memoData[item.Link] = authors
	}

	// Process each memo log
	for _, memoLog := range memoLogs {
		usernames := memoData[memoLog.URL]
		if len(usernames) == 0 {
			continue
		}

		// Fetch Discord accounts for the usernames
		discordAccounts, err := c.store.DiscordAccount.ListByMemoUsername(c.repo.DB(), usernames)
		if err != nil {
			return err
		}

		// Create memo authors
		for _, discordAccount := range discordAccounts {
			memoAuthor := &model.MemoAuthor{
				MemoLogID:        memoLog.ID,
				DiscordAccountID: discordAccount.ID,
			}
			if err := c.store.MemoLog.CreateMemoAuthor(c.repo.DB(), memoAuthor); err != nil {
				return err
			}
		}
	}
	return nil
}

```

# pkg/controller/memologs/pr.go

```go
package memologs

import (
	"context"
	"fmt"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

var (
	repoMemos            = []string{"brainery", "playground", "playbook"}
	dwarvesFoundationOrg = "dwarvesf"
)

func (c controller) ListOpenPullRequest() (map[string][]model.MemoPullRequest, error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "memologs",
		"method":     "ListOpenPullRequest",
	})

	memoPrs := make(map[string][]model.MemoPullRequest, len(repoMemos))

	// Get discord accounts
	discordAccounts, err := c.store.DiscordAccount.All(c.repo.DB())
	if err != nil {
		l.Error(err, "failed to get discord accounts")
		return nil, fmt.Errorf("failed to get discord accounts: %w", err)
	}

	mapGithubWithDiscord := make(map[string]string, len(discordAccounts))
	for _, dc := range discordAccounts {
		if dc != nil && dc.GithubUsername != "" {
			mapGithubWithDiscord[dc.GithubUsername] = dc.DiscordID
		}
	}

	for _, repo := range repoMemos {
		memoRepoName := fmt.Sprintf("%s/%s", dwarvesFoundationOrg, repo)

		prs, err := c.service.Github.FetchOpenPullRequest(context.Background(), repo)
		if err != nil {
			l.Errorf(err, "failed to fetch open pull requests for %s", repo)
			return memoPrs, err
		}

		memoPullRequest := make([]model.MemoPullRequest, 0, len(prs))
		for _, pr := range prs {
			user := pr.GetUser()
			githubUserName := ""

			if user != nil {
				githubUserName = user.GetLogin()
			}

			discordID := mapGithubWithDiscord[githubUserName]

			prMap := model.MemoPullRequest{
				Number:         pr.GetNumber(),
				Title:          pr.GetTitle(),
				Url:            pr.GetHTMLURL(),
				DiscordId:      discordID,
				GithubUserName: githubUserName,
				Timestamp:      pr.GetCreatedAt().Time,
			}
			memoPullRequest = append(memoPullRequest, prMap)
		}

		memoPrs[memoRepoName] = memoPullRequest
	}

	return memoPrs, nil
}

```

# pkg/controller/memologs/new.go

```go
package memologs

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

type IController interface {
	Sync() ([]model.MemoLog, error)
	Sweep() error
	ListOpenPullRequest() (map[string][]model.MemoPullRequest, error)
}

```

# pkg/controller/icy/icy.go

```go
package icy

import (
	"math/big"
	"strings"
	"sync"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/math"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/service/icyswap"
	"github.com/dwarvesf/fortress-api/pkg/service/mochipay"
	"github.com/dwarvesf/fortress-api/pkg/service/mochiprofile"
)

type IController interface {
	Accounting() (*model.IcyAccounting, error)
}

type controller struct {
	service *service.Service
	logger  logger.Logger
	config  *config.Config
}

func New(service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

func (c *controller) Accounting() (*model.IcyAccounting, error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "icy",
		"method":     "Accounting",
	})

	// 0.Prepare token and swap contract data
	icy := c.icy()
	usdt := c.usdc()
	icySwap := c.icySwap()

	// 1.Get current conversion rate from icyswap contract
	conversionRate, err := c.service.IcySwap.ConversionRate()
	if err != nil {
		l.Error(err, "failed to get icy conversion rate")
		return nil, err
	}
	usdtDecimals := new(big.Float).SetInt(math.BigPow(10, int64(usdt.Decimals)))
	conversionRateFloat, _ := new(big.Float).Quo(new(big.Float).SetInt(conversionRate), usdtDecimals).Float32()

	// 2. Get current usdt fund in icyswap contract
	icyswapUsdtBal, err := c.service.IcySwap.UsdcFund()
	if err != nil {
		l.Error(err, "failed to get usdt fund in icyswap contract")
		return nil, err
	}

	// 3. Get Circulating Icy
	// circulating icy = total supply - icy in contract - icy of team - icy in mochi app - icy in vault

	// 3.1 Get total icy supply
	icyTotalSupply, _ := new(big.Int).SetString(icy.TotalSupply, 10)

	// 3.2 Get total locked icy amount
	lockedIcyAmount, err := c.lockedIcyAmount()
	if err != nil {
		c.logger.Error(err, "failed to get locked icy amount")
		return nil, err
	}

	// 3.3 Calculate circulating icy amount
	circulatingIcy := new(big.Int).Sub(icyTotalSupply, lockedIcyAmount)

	// 4.Get offset usdt
	// offset usd: circulating icy in usdt - usd fund in contract -> get how many usd left to redeem

	circulatingIcyInUsdt := new(big.Int).Mul(circulatingIcy, conversionRate)
	// continue to divide to 10^18 for get the amount in usdt decimals
	circulatingIcyInUsdt = new(big.Int).Div(circulatingIcyInUsdt, math.BigPow(10, 18))

	offsetUsdt := new(big.Int).Sub(circulatingIcyInUsdt, icyswapUsdtBal)

	// 5. Return accounting result
	return &model.IcyAccounting{
		ICY:                &icy,
		USDT:               &usdt,
		IcySwap:            &icySwap,
		ConversionRate:     conversionRateFloat,
		ContractFundInUSDT: icyswapUsdtBal.String(),
		CirculatingICY:     circulatingIcy.String(),
		OffsetUSDT:         offsetUsdt.String(),
	}, nil
}

func (c *controller) lockedIcyAmount() (*big.Int, error) {
	lockedIcyAmount := big.NewInt(0)

	// 0. fetch onchain locked icy amount
	onchainLockedAmount, err := c.onchainLockedIcyAmount()
	if err != nil {
		c.logger.Error(err, "failed to get onchain locked icy amount")
		return nil, err
	}
	lockedIcyAmount = new(big.Int).Add(lockedIcyAmount, onchainLockedAmount)

	// 1. fetch offchain locked icy amount
	offchainLockedAmount, err := c.offchainLockedIcyAmount()
	if err != nil {
		c.logger.Error(err, "failed to get offchain locked icy amount")
		return nil, err
	}
	lockedIcyAmount = new(big.Int).Add(lockedIcyAmount, offchainLockedAmount)

	// 2. return result
	return lockedIcyAmount, nil
}

func (c *controller) onchainLockedIcyAmount() (*big.Int, error) {
	icyAddress := common.HexToAddress(c.icy().Address)
	oldIcySwapContractAddr := common.HexToAddress("0xd327b6d878bcd9d5ec6a5bc99445985d75f0d6e5")
	icyswapAddr := common.HexToAddress(icyswap.ICYSwapAddress)
	teamAddr := common.HexToAddress("0x0762c4b40c9cb21Af95192a3Dc3EDd3043CF3d41")
	icyLockedAddrs := []common.Address{oldIcySwapContractAddr, icyswapAddr, teamAddr}

	type FetchResult struct {
		amount *big.Int
		err    error
	}
	fetchIcyResults := make(chan FetchResult)

	wg := sync.WaitGroup{}
	wg.Add(len(icyLockedAddrs))
	go func() {
		wg.Wait()
		close(fetchIcyResults)
	}()

	for _, lockedAddr := range icyLockedAddrs {
		go func(ownerAddr common.Address) {
			amount, err := c.service.BaseClient.ERC20Balance(icyAddress, ownerAddr)
			fetchIcyResults <- FetchResult{
				amount: amount,
				err:    err,
			}
			wg.Done()
		}(lockedAddr)
	}

	lockedIcyAmount := big.NewInt(0)
	for res := range fetchIcyResults {
		if res.err != nil {
			return nil, res.err
		}
		lockedIcyAmount = new(big.Int).Add(lockedIcyAmount, res.amount)
	}

	return lockedIcyAmount, nil
}

func (c *controller) offchainLockedIcyAmount() (*big.Int, error) {
	// 0. get all profile, which type is vault or app
	profileIds := make([]string, 0)
	const pageSize int64 = 50
	var page int64 = 0
	for {
		res, err := c.service.MochiProfile.GetListProfiles(mochiprofile.ListProfilesRequest{
			Types: []mochiprofile.ProfileType{
				mochiprofile.ProfileTypeApplication,
				mochiprofile.ProfileTypeVault,
			},
			Page: page,
			Size: pageSize,
		})
		if err != nil {
			return nil, err
		}
		for _, p := range res.Data {
			profileIds = append(profileIds, p.ID)
		}

		hasNext := res.Pagination.Total/pageSize-page > 0
		if !hasNext {
			break
		}
		page += 1
	}

	// 1. get balance of all profiles
	balRes, err := c.service.MochiPay.GetBatchBalances(profileIds)
	if err != nil {
		return nil, err
	}

	total := big.NewInt(0)
	icy := c.icy()
	for _, b := range balRes.Data {
		// filter token icy
		if strings.EqualFold(b.Token.Address, icy.Address) && strings.EqualFold(b.Token.ChainId, icy.ChainID) {
			amount, _ := new(big.Int).SetString(b.Amount, 10)
			total = new(big.Int).Add(total, amount)
		}
	}

	return total, nil
}

func (c *controller) icy() model.TokenInfo {
	return model.TokenInfo{
		Name:        "Icy",
		Symbol:      "ICY",
		Address:     mochipay.ICYAddress,
		Decimals:    18,
		Chain:       mochipay.BASEChainID,
		ChainID:     mochipay.BASEChainID,
		TotalSupply: "100000000000000000000000",
	}
}

func (c *controller) usdc() model.TokenInfo {
	return model.TokenInfo{
		Name:     "USD Base Coin",
		Symbol:   "USDbC",
		Address:  icyswap.USDCAddress,
		Decimals: 6,
		Chain:    mochipay.BaseChainName,
		ChainID:  mochipay.BASEChainID,
	}
}

func (c *controller) icySwap() model.ContractInfo {
	return model.ContractInfo{
		Name:    "IcySwap",
		Address: icyswap.ICYSwapAddress,
		Chain:   mochipay.BaseChainName,
	}
}

```

# pkg/controller/event/event.go

```go
package event

import (
	"context"
	"strings"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/service/mochipay"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/store/discordevent"
	"github.com/ethereum/go-ethereum/log"
)

type IController interface {
	SweepOgifEvent(c context.Context) error
}

type controller struct {
	service *service.Service
	logger  logger.Logger
	config  *config.Config
	store   *store.Store
	repo    store.DBRepo
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		service: service,
		logger:  logger,
		config:  cfg,
		repo:    repo,
	}
}
func (c *controller) SweepOgifEvent(ctx context.Context) error {
	isSender := true
	// Fetch latest 50 transactions
	txReq := mochipay.ListTransactionsRequest{
		ActionList:   []mochipay.TransactionAction{mochipay.TransactionActionVaultTransfer},
		IsSender:     &isSender,
		ProfileID:    "1707664412564787200",
		Size:         100,
		SortBy:       "created_at-",
		Status:       mochipay.TransactionStatusSuccess,
		TokenAddress: mochipay.ICYAddress,
	}
	txResp, err := c.service.MochiPay.GetListTransactions(txReq)
	if err != nil {
		return err
	}

	if len(txResp.Data) == 0 {
		return nil // No transactions to process
	}

	// Get the time of the last transaction
	lastTxTime := txResp.Data[len(txResp.Data)-1].CreatedAt

	// Fetch all events after the last transaction time
	events, err := c.store.DiscordEvent.All(c.repo.DB(), &discordevent.Query{
		After: &lastTxTime,
		Limit: 100,
	}, true)
	if err != nil {
		return err
	}

	txMap := make(map[string]bool)
	for _, tx := range txResp.Data {
		txMap[tx.Id] = false
	}

	for _, event := range events {
		if len(event.EventSpeakers) != 0 {
			continue
		}
		// Find transactions for this event
		for _, tx := range txResp.Data {
			if !strings.HasPrefix(strings.ToLower(tx.Metadata["message"].(string)), "ogif") {
				log.Debug("tx is not ogif")
				continue
			}

			txCreatedDate := time.Date(tx.CreatedAt.Year(), tx.CreatedAt.Month(), tx.CreatedAt.Day(), 0, 0, 0, 0, tx.CreatedAt.Location())
			eventDate := time.Date(event.Date.Year(), event.Date.Month(), event.Date.Day(), 0, 0, 0, 0, event.Date.Location())
			if txCreatedDate.Before(eventDate) {
				log.Debug("tx created before event date")
				continue
			}

			if txMap[tx.Id] {
				log.Debug("tx already processed")
				continue
			}

			profile, err := c.service.MochiProfile.GetProfile(tx.FromProfileId)
			if err != nil {
				txMap[tx.Id] = true
				c.logger.Error(err, "failed to get MochiProfile")
				continue
			}

			var discordID string
			for _, account := range profile.AssociatedAccounts {
				if account.Platform == "discord" {
					discordID = account.PlatformIdentifier
					break
				}
			}

			if discordID == "" {
				log.Debug("tx is not from discord")
				continue
			}

			discordAccount, err := c.store.DiscordAccount.OneByDiscordID(c.repo.DB(), discordID)
			if err != nil {
				c.logger.Error(err, "failed to get discordAccount")
				continue
			}

			speaker := &model.EventSpeaker{
				EventID:          event.ID,
				DiscordAccountID: discordAccount.ID,
				Topic:            tx.Metadata["message"].(string),
			}

			_, err = c.store.EventSpeaker.Create(c.repo.DB(), speaker)
			if err != nil {
				c.logger.Error(err, "failed to create event speaker")
				continue
			}

			txMap[tx.Id] = true
		}
	}

	return nil
}

```

# pkg/controller/invoice/update_status.go

```go
package invoice

import (
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
	"strconv"
	"sync"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	sInvoice "github.com/dwarvesf/fortress-api/pkg/store/invoice"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
)

type UpdateStatusInput struct {
	InvoiceID         string              `json:"invoiceID"`
	Status            model.InvoiceStatus `json:"status"`
	SendThankYouEmail bool                `json:"sendThankYouEmail"`
}

func (c *controller) UpdateStatus(in UpdateStatusInput) (*model.Invoice, error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "invoice",
		"method":     "UpdateStatus",
		"req":        in,
	})

	// check invoice existence
	invoice, err := c.store.Invoice.One(c.repo.DB(), &sInvoice.Query{ID: in.InvoiceID})
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(ErrInvoiceNotFound, "invoice not found")
			return nil, ErrInvoiceNotFound
		}

		l.Error(err, "failed to get invoice")
		return nil, err
	}

	if invoice.Status == in.Status {
		l.Error(ErrInvoiceStatusAlready, "invoice status already")
		return nil, ErrInvoiceStatusAlready
	}

	switch in.Status {
	case model.InvoiceStatusError:
		_, err = c.MarkInvoiceAsError(invoice)
	case model.InvoiceStatusPaid:
		_, err = c.MarkInvoiceAsPaid(invoice, in.SendThankYouEmail)
	default:
		_, err = c.store.Invoice.UpdateSelectedFieldsByID(c.repo.DB(), invoice.ID.String(), *invoice, "status")
	}
	if err != nil {
		l.Error(err, "failed to update invoice")
		return nil, err
	}

	return invoice, nil
}

func (c *controller) MarkInvoiceAsError(invoice *model.Invoice) (*model.Invoice, error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "invoice",
		"method":     "MarkInvoiceAsError",
		"req":        invoice,
	})

	tx, done := c.repo.NewTransaction()
	invoice.Status = model.InvoiceStatusError
	iv, err := c.store.Invoice.UpdateSelectedFieldsByID(tx.DB(), invoice.ID.String(), *invoice, "status")
	if err != nil {
		l.Errorf(err, "failed to update invoice status to error")
		return nil, done(err)
	}

	err = c.store.InvoiceNumberCaching.UnCountErrorInvoice(tx.DB(), *invoice.InvoicedAt)
	if err != nil {
		l.Errorf(err, "failed to un-count error invoice")
		return nil, done(err)
	}

	if err := c.markInvoiceTodoAsError(invoice); err != nil {
		return nil, done(err)
	}

	if err := c.service.GoogleDrive.MoveInvoicePDF(invoice, "Sent", "Error"); err != nil {
		l.Errorf(err, "failed to upload invoice pdf to google drive")
		return nil, done(err)
	}

	return iv, done(nil)
}

func (c *controller) markInvoiceTodoAsError(invoice *model.Invoice) error {
	if invoice.Project == nil {
		return fmt.Errorf(`missing project info`)
	}

	bucketID, todoID, err := c.getInvoiceTodo(invoice)
	if err != nil {
		return err
	}

	c.worker.Enqueue(bcModel.BasecampCommentMsg, c.service.Basecamp.BuildCommentMessage(bucketID, todoID, "Invoice has been mark as error", "failed"))

	return c.service.Basecamp.Recording.Archive(bucketID, todoID)
}

type processPaidInvoiceRequest struct {
	Invoice          *model.Invoice
	InvoiceTodoID    int
	InvoiceBucketID  int
	SentThankYouMail bool
}

func (c *controller) MarkInvoiceAsPaid(invoice *model.Invoice, sendThankYouEmail bool) (*model.Invoice, error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "invoice",
		"method":     "MarkInvoiceAsPaid",
		"req":        invoice,
	})

	if invoice.Status != model.InvoiceStatusSent && invoice.Status != model.InvoiceStatusOverdue {
		err := fmt.Errorf(`unable to update invoice status, invoice have status %v`, invoice.Status)
		l.Errorf(err, "failed to update invoice", "invoiceID", invoice.ID.String())
		return nil, err
	}
	invoice.Status = model.InvoiceStatusPaid

	bucketID, todoID, err := c.getInvoiceTodo(invoice)
	if err != nil {
		l.Errorf(err, "failed to get invoice todo", "invoiceID", invoice.ID.String())
		return nil, err
	}

	err = c.service.Basecamp.Todo.Complete(bucketID, todoID)
	if err != nil {
		l.Errorf(err, "failed to complete invoice todo", "invoiceID", invoice.ID.String())
	}

	c.processPaidInvoice(l, &processPaidInvoiceRequest{
		Invoice:          invoice,
		InvoiceTodoID:    todoID,
		InvoiceBucketID:  bucketID,
		SentThankYouMail: sendThankYouEmail,
	})

	return invoice, nil
}

func (c *controller) MarkInvoiceAsPaidByBasecampWebhookMessage(invoice *model.Invoice, msg *model.BasecampWebhookMessage) (*model.Invoice, error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "invoice",
		"method":     "MarkInvoiceAsPaidByBasecampWebhookMessage",
		"req":        invoice,
	})
	invoice.Status = model.InvoiceStatusPaid

	c.processPaidInvoice(l, &processPaidInvoiceRequest{
		Invoice:          invoice,
		InvoiceTodoID:    msg.Recording.ID,
		InvoiceBucketID:  msg.Recording.Bucket.ID,
		SentThankYouMail: true,
	})

	return invoice, nil
}

func (c *controller) processPaidInvoice(l logger.Logger, req *processPaidInvoiceRequest) {
	wg := &sync.WaitGroup{}
	wg.Add(3)

	go func() {
		_ = c.processPaidInvoiceData(l, wg, req)
	}()

	go c.sendThankYouEmail(l, wg, req)
	go c.movePaidInvoiceGDrive(l, wg, req)

	wg.Wait()
}

func (c *controller) processPaidInvoiceData(l logger.Logger, wg *sync.WaitGroup, req *processPaidInvoiceRequest) error {
	// Start Transaction
	tx, done := c.repo.NewTransaction()

	msg := consts.CommentUpdateInvoiceFailed
	msgType := bcModel.CommentMsgTypeFailed
	defer func() {
		wg.Done()
		c.worker.Enqueue(bcModel.BasecampCommentMsg, c.service.Basecamp.BuildCommentMessage(req.InvoiceBucketID, req.InvoiceTodoID, msg, msgType))
	}()

	now := time.Now()
	req.Invoice.PaidAt = &now
	_, err := c.store.Invoice.UpdateSelectedFieldsByID(tx.DB(), req.Invoice.ID.String(), *req.Invoice, "status", "paid_at")
	if err != nil {
		l.Errorf(err, "failed to update invoice status to paid", "invoice", req.Invoice)
		return done(err)
	}

	_, err = c.storeCommission(tx.DB(), l, req.Invoice)
	if err != nil {
		l.Errorf(err, "failed to store invoice commission", "invoice", req.Invoice)
		return done(err)
	}

	m := model.AccountingMetadata{
		Source: "invoice",
		ID:     req.Invoice.ID.String(),
	}

	bonusBytes, err := json.Marshal(&m)
	if err != nil {
		l.Errorf(err, "failed to process invoice accounting metadata", "invoiceNumber", req.Invoice.Number)
		return done(err)
	}

	projectOrg := ""
	if req.Invoice.Project.Organization != nil {
		projectOrg = req.Invoice.Project.Organization.Name
	}

	currencyName := "VND"
	currencyID := model.UUID{}
	if req.Invoice.Project.BankAccount.Currency != nil {
		currencyName = req.Invoice.Project.BankAccount.Currency.Name
		currencyID = req.Invoice.Project.BankAccount.Currency.ID
	}

	accountingTxn := &model.AccountingTransaction{
		Name:             req.Invoice.Number,
		Amount:           req.Invoice.Total,
		Date:             &now,
		ConversionAmount: model.VietnamDong(req.Invoice.ConversionAmount),
		Organization:     projectOrg,
		Category:         model.AccountingIn,
		Type:             model.AccountingIncome,
		Currency:         currencyName,
		CurrencyID:       &currencyID,
		ConversionRate:   req.Invoice.ConversionRate,
		Metadata:         bonusBytes,
	}

	err = c.store.Accounting.CreateTransaction(tx.DB(), accountingTxn)
	if err != nil {
		l.Errorf(err, "failed to create accounting transaction", "Accounting Transaction", accountingTxn)
		return done(err)
	}

	msg = consts.CommentUpdateInvoiceSuccessfully
	msgType = bcModel.CommentMsgTypeCompleted

	return done(nil)
}

func (c *controller) sendThankYouEmail(l logger.Logger, wg *sync.WaitGroup, req *processPaidInvoiceRequest) {
	msg := c.service.Basecamp.BuildCommentMessage(req.InvoiceBucketID, req.InvoiceTodoID, consts.CommentThankYouEmailSent, bcModel.CommentMsgTypeCompleted)

	defer func() {
		c.worker.Enqueue(bcModel.BasecampCommentMsg, msg)
		wg.Done()
	}()

	err := c.service.GoogleMail.SendInvoiceThankYouMail(req.Invoice)
	if err != nil {
		l.Errorf(err, "failed to send invoice thank you mail", "invoice", req.Invoice)
		msg = c.service.Basecamp.BuildCommentMessage(req.InvoiceBucketID, req.InvoiceTodoID, consts.CommentThankYouEmailFailed, bcModel.CommentMsgTypeFailed)
		return
	}
}

func (c *controller) getInvoiceTodo(iv *model.Invoice) (bucketID, todoID int, err error) {
	if iv.Project == nil {
		return 0, 0, fmt.Errorf(`missing project info`)
	}

	accountingID := consts.AccountingID
	accountingTodoID := consts.AccountingTodoID

	if c.config.Env != "prod" {
		accountingID = consts.PlaygroundID
		accountingTodoID = consts.PlaygroundTodoID
	}

	re := regexp.MustCompile(`Accounting \| ([A-Za-z]+) ([0-9]{4})`)

	todoLists, err := c.service.Basecamp.Todo.GetLists(accountingID, accountingTodoID)
	if err != nil {
		return 0, 0, err
	}

	var todoList *bcModel.TodoList
	var latestListDate time.Time

	for i := range todoLists {
		info := re.FindStringSubmatch(todoLists[i].Title)
		if len(info) == 3 {
			month, err := timeutil.GetMonthFromString(info[1])
			if err != nil {
				continue
			}
			year, _ := strconv.Atoi(info[2])
			listDate := time.Date(year, time.Month(month), 1, 0, 0, 0, 0, time.UTC)
			if listDate.After(latestListDate) {
				todoList = &todoLists[i]
				latestListDate = listDate
			}
		}
	}

	if todoList == nil {
		month := iv.Month + 1
		if month > 12 {
			month = 1
		}
		todoList, err = c.service.Basecamp.Todo.CreateList(
			accountingID,
			accountingTodoID,
			bcModel.TodoList{Name: fmt.Sprintf(
				`Accounting | %v %v`, time.Month(month).String(),
				iv.Year)},
		)
		if err != nil {
			return 0, 0, err
		}
	}

	todoGroup, err := c.service.Basecamp.Todo.FirstOrCreateGroup(
		accountingID,
		todoList.ID,
		`In`)
	if err != nil {
		return 0, 0, err
	}

	todo, err := c.service.Basecamp.Todo.FirstOrCreateInvoiceTodo(
		accountingID,
		todoGroup.ID,
		iv)
	if err != nil {
		return 0, 0, err
	}

	return accountingID, todo.ID, nil
}

```

# pkg/controller/invoice/send.go

```go
package invoice

import (
	"bytes"
	"errors"
	"fmt"
	"math"
	"math/rand"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
	"time"

	"github.com/Rhymond/go-money"
	toPdf "github.com/SebastiaanKlippert/go-wkhtmltopdf"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
)

func (c *controller) Send(iv *model.Invoice) (*model.Invoice, error) {
	now := time.Now()

	l := c.logger.Fields(logger.Fields{
		"controller": "invoice",
		"method":     "Send",
	})

	// check sender existence
	exists, err := c.store.Employee.IsExist(c.repo.DB(), iv.SentBy.String())
	if err != nil {
		l.Error(err, "failed to check sender existence")
		return nil, err
	}

	if !exists {
		l.Error(ErrSenderNotFound, "sender not exist")
		return nil, err
	}

	// check bank account existence
	b, err := c.store.BankAccount.One(c.repo.DB(), iv.BankID.String())
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(ErrBankAccountNotFound, "project not found")
			return nil, err
		}

		l.Error(err, "failed to check bank account existence")
		return nil, err
	}

	iv.Bank = b

	// check project existence
	p, err := c.store.Project.One(c.repo.DB(), iv.ProjectID.String(), true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			l.Error(ErrProjectNotFound, "project not found")
			return nil, err
		}

		l.Error(err, "failed to check project existence")
		return nil, err
	}
	iv.Project = p

	nextInvoiceNumber, err := c.store.Invoice.GetNextInvoiceNumber(c.repo.DB(), now.Year(), p.Code)
	if err != nil {
		l.Error(err, "failed to get next invoice Number")
		return nil, err
	}
	iv.Number = *nextInvoiceNumber

	invoiceItems, err := model.GetInfoItems(iv.LineItems)
	if err != nil {
		l.Errorf(err, "failed to get info items", "invoice-lineItems", iv.LineItems)
		return nil, err
	}

	iv.Bonus = c.getInvoiceBonus(invoiceItems)
	iv.TotalWithoutBonus = iv.Total - iv.Bonus

	if err := c.generateInvoicePDF(l, iv, invoiceItems); err != nil {
		l.Error(err, "failed to generate Invoice PDF")
		return nil, err
	}

	conversionAmount, rate, err := c.service.Wise.Convert(iv.Total, iv.Bank.Currency.Name, "VND")
	if err != nil {
		l.Error(err, "failed to convert currency")
		return nil, err
	}

	am := model.NewVietnamDong(int64(conversionAmount))
	iv.ConversionAmount = float64(am)
	iv.ConversionRate = rate

	savedInvoice, err := c.store.Invoice.Save(c.repo.DB(), iv)
	if err != nil {
		l.Errorf(err, "failed to create invoice", "invoice", iv.Number)
		return nil, err
	}
	iv.ID = savedInvoice.ID

	if err := c.store.InvoiceNumberCaching.UpdateInvoiceCachingNumber(c.repo.DB(), time.Now(), iv.Project.Code); err != nil {
		l.Errorf(err, "failed to update invoice caching number", "project", iv.Project.Code)
		return nil, err
	}

	errsCh := make(chan error)
	var amountGr = 0
	if iv.Status != model.InvoiceStatusDraft {
		amountGr += 2
		fn := strconv.FormatInt(rand.Int63(), 10) + "_" + iv.Number + ".pdf"

		invoiceFilePath := fmt.Sprintf("https://storage.googleapis.com/%s/invoices/%s", c.config.Google.GCSBucketName, fn)
		iv.InvoiceFileURL = invoiceFilePath

		go func() {
			err = c.service.GoogleDrive.UploadInvoicePDF(iv, "Sent")
			if err != nil {
				l.Errorf(err, "failed to upload invoice")
				errsCh <- err
				return
			}

			errsCh <- nil
		}()

		go func() {
			threadID, err := c.service.GoogleMail.SendInvoiceMail(iv)
			if err != nil {
				l.Errorf(err, "failed to send invoice mail")
				errsCh <- err
				return
			}

			iv.ThreadID = threadID
			_, err = c.store.Invoice.UpdateSelectedFieldsByID(c.repo.DB(), iv.ID.String(), *iv, "thread_id")
			if err != nil {
				l.Errorf(err, "failed to update invoice thread id", "thread_id", threadID)
				errsCh <- err
				return
			}

			attachmentSgID, err := c.service.Basecamp.Attachment.Create("application/pdf", fn, iv.InvoiceFileContent)
			if err != nil {
				l.Errorf(err, "failed to create Basecamp Attachment", "invoice", iv)
				errsCh <- err
				return
			}

			iv.TodoAttachment = fmt.Sprintf(`<bc-attachment sgid="%v" caption="My photo"></bc-attachment>`, attachmentSgID)

			bucketID, todoID, err := c.getInvoiceTodo(iv)
			if err != nil {
				l.Errorf(err, "failed to get invoice todo", "invoice", iv)
				errsCh <- err
				return
			}

			msg := fmt.Sprintf(`#Invoice %v has been sent
	
			Confirm Command: Paid @Giang #%v`, iv.Number, iv.Number)

			c.worker.Enqueue(bcModel.BasecampCommentMsg, c.service.Basecamp.BuildCommentMessage(bucketID, todoID, msg, ""))

			errsCh <- nil
		}()
	}

	var count int
	for e := range errsCh {
		if e != nil {
			close(errsCh)
			return nil, err
		}
		count++
		if count == amountGr {
			close(errsCh)
			return iv, nil
		}
	}

	return iv, nil
}

func (c *controller) generateInvoicePDF(l logger.Logger, invoice *model.Invoice, items []model.InvoiceItem) error {
	pound := money.New(1, invoice.Project.BankAccount.Currency.Name)

	companyInfo, err := invoice.Project.GetCompanyContactInfo()
	if err != nil {
		l.Errorf(err, "failed to get company contact info", "project", invoice.Project)
		return err
	}

	var haveDiscountColumn bool
	for i := range items {
		if items[i].Discount != 0 {
			haveDiscountColumn = true
		}
	}

	haveRouting := invoice.Bank.RoutingNumber != ""
	haveSwiftCode := invoice.Bank.SwiftCode != ""
	haveUKSortCode := invoice.Bank.UKSortCode != ""
	haveIntermediaryBankName := invoice.Bank.IntermediaryBankName != ""
	haveIntermediaryBankAddress := invoice.Bank.IntermediaryBankAddress != ""

	data := &struct {
		Path                        string
		Invoice                     *model.Invoice
		HaveRouting                 bool
		HaveUKSortCode              bool
		HaveSWIFTCode               bool
		HaveIntermediaryBankName    bool
		HaveIntermediaryBankAddress bool
		CompanyContactInfo          *model.CompanyContactInfo
		InvoiceItem                 []model.InvoiceItem
		IntermediaryBankName        string
	}{
		Path:                        c.config.Invoice.TemplatePath,
		Invoice:                     invoice,
		HaveRouting:                 haveRouting,
		HaveUKSortCode:              haveUKSortCode,
		HaveSWIFTCode:               haveSwiftCode,
		HaveIntermediaryBankName:    haveIntermediaryBankName,
		HaveIntermediaryBankAddress: haveIntermediaryBankAddress,
		CompanyContactInfo:          companyInfo,
		InvoiceItem:                 items,
	}

	funcMap := template.FuncMap{
		"toString": func(month int) string {
			return time.Month(month).String()
		},
		"formatDate": func(t *time.Time) string {
			return timeutil.FormatDatetime(*t)
		},
		"lastDayOfMonth": func() string {
			return timeutil.
				FormatDatetime(timeutil.LastDayOfMonth(invoice.Month, invoice.Year))
		},
		"formatMoney": func(money float64) string {
			var result string
			tmpValue := money * math.Pow(10, float64(pound.Currency().Fraction))
			result = pound.Multiply(int64(tmpValue)).Display()

			return result
		},
		"haveDescription": func(description string) bool {
			return description != ""
		},
		"haveNote": func(note string) bool {
			return note != ""
		},
		"haveDiscountColumn": func() bool {
			return haveDiscountColumn
		},
		"float": func(n float64) string {
			return fmt.Sprintf("%.2f", n)
		},
	}

	if c.config.Env == "local" {
		data.Path = os.Getenv("GOPATH") + "/src/github.com/dwarvesf/fortress-api/pkg/templates"
	}

	tmpl, err := template.New("invoicePDF").Funcs(funcMap).ParseFiles(filepath.Join(data.Path, "invoice.html"))
	if err != nil {
		l.Errorf(err, "failed to parse template", "path", data.Path, "filename", "invoice.html")
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Funcs(funcMap).ExecuteTemplate(&buf, "invoice.html", data); err != nil {
		l.Errorf(err, "failed to execute template", "data", data, "path", data.Path, "filename", "invoice.html")
		return err
	}

	pdfg, err := toPdf.NewPDFGenerator()
	if err != nil {
		l.Errorf(err, "failed to create pdf generator")
		return err
	}

	t := toPdf.NewPageReader(&buf)
	t.Zoom.Set(1.45)
	t.EnableLocalFileAccess.Set(true)
	pdfg.AddPage(t)
	pdfg.Dpi.Set(600)
	pdfg.PageSize.Set("A4")

	if err := pdfg.Create(); err != nil {
		l.Errorf(err, "failed to create invoice pdf", "invoice", invoice)
		return err
	}

	invoice.InvoiceFileContent = pdfg.Buffer().Bytes()

	return nil
}

func (c *controller) getInvoiceBonus(items []model.InvoiceItem) float64 {
	var bonus float64
	for _, item := range items {
		if strings.Contains(strings.ToLower(item.Description), "bonus") {
			bonus += item.Cost
		}
	}
	return bonus
}

```

# pkg/controller/invoice/new.go

```go
package invoice

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"github.com/dwarvesf/fortress-api/pkg/worker"
)

type controller struct {
	store   *store.Store
	service *service.Service
	worker  *worker.Worker
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, worker *worker.Worker, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
		worker:  worker,
	}
}

type IController interface {
	GetTemplate(in GetInvoiceInput) (nextInvoiceNumber string, lastInvoice *model.Invoice, p *model.Project, err error)
	List(in GetListInvoiceInput) ([]*model.Invoice, int64, error)
	MarkInvoiceAsError(invoice *model.Invoice) (*model.Invoice, error)
	MarkInvoiceAsPaid(invoice *model.Invoice, sendThankYouEmail bool) (*model.Invoice, error)
	MarkInvoiceAsPaidByBasecampWebhookMessage(invoice *model.Invoice, msg *model.BasecampWebhookMessage) (*model.Invoice, error)
	Send(iv *model.Invoice) (*model.Invoice, error)
	UpdateStatus(in UpdateStatusInput) (*model.Invoice, error)
}

```

# pkg/controller/invoice/list.go

```go
package invoice

import (
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/store/invoice"
)

type GetListInvoiceInput struct {
	model.Pagination
	ProjectIDs []string
	Statuses   []string
}

func (c *controller) List(in GetListInvoiceInput) ([]*model.Invoice, int64, error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "invoice",
		"method":     "List",
		"input":      in,
	})

	invoices, total, err := c.store.Invoice.All(c.repo.DB(), invoice.GetInvoicesFilter{
		Preload:    true,
		ProjectIDs: in.ProjectIDs,
		Statuses:   in.Statuses,
	}, in.Pagination)
	if err != nil {
		l.Error(err, "failed to get invoice list")
		return nil, 0, err
	}

	return invoices, total, nil
}

```

# pkg/controller/invoice/get_template.go

```go
package invoice

import (
	"errors"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type GetInvoiceInput struct {
	Now       *time.Time
	ProjectID string
}

func (c *controller) GetTemplate(in GetInvoiceInput) (string, *model.Invoice, *model.Project, error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "invoice",
		"method":     "GetTemplate",
		"input":      in,
	})

	// check project existence
	p, err := c.store.Project.One(c.repo.DB(), in.ProjectID, true)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(ErrProjectNotFound, "project not found")
		return "", nil, nil, ErrProjectNotFound
	}

	if err != nil {
		return "", nil, nil, err
	}

	nextInvoiceNumber, err := c.store.Invoice.GetNextInvoiceNumber(c.repo.DB(), in.Now.Year(), p.Code)
	if err != nil {
		l.Error(err, "failed to get next invoice Number")
		return "", nil, nil, ErrCouldNotGetTheNextInvoiceNumber
	}

	lastInvoice, err := c.store.Invoice.GetLatestInvoiceByProject(c.repo.DB(), in.ProjectID)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(err, "failed to get the latest invoice")
		return "", nil, nil, ErrCouldNotGetTheLatestInvoice
	}

	if errors.Is(err, gorm.ErrRecordNotFound) {
		lastInvoice = nil
	}

	return *nextInvoiceNumber, lastInvoice, p, nil
}

```

# pkg/controller/invoice/errors.go

```go
package invoice

import "errors"

var (
	ErrBankAccountNotFound             = errors.New("bank account not found")
	ErrCouldNotGetTheLatestInvoice     = errors.New("could not get the latest invoice")
	ErrCouldNotGetTheNextInvoiceNumber = errors.New("could not get the next invoice number")
	ErrInvoiceNotFound                 = errors.New("invoice not found")
	ErrInvoiceStatusAlready            = errors.New("invoice status already")
	ErrProjectNotFound                 = errors.New("project not found")
	ErrSenderNotFound                  = errors.New("sender not found")
)

```

# pkg/controller/invoice/commission.go

```go
package invoice

import (
	"fmt"
	"sync"

	"github.com/shopspring/decimal"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	bcConst "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

const (
	hiringCommissionRate       int64 = 2
	saleReferralCommissionRate int64 = 10
)

type pic struct {
	ID             model.UUID
	CommissionRate decimal.Decimal
	ChargeRate     float64
	Note           string
}

type pics struct {
	devLeads         []pic
	accountManagers  []pic
	deliveryManagers []pic
	sales            []pic
	suppliers        []pic
	upsells          []pic
	saleReferers     []pic
	upsellReferers   []pic
}

func (c *controller) storeCommission(db *gorm.DB, l logger.Logger, invoice *model.Invoice) ([]model.EmployeeCommission, error) {
	if invoice.Project.Type != model.ProjectTypeTimeMaterial {
		return nil, nil
	}
	employeeCommissions, err := c.calculateCommissionFromInvoice(db, l, invoice)
	if err != nil {
		l.Errorf(err, "failed to create commission for invoice(%s)", invoice.ID.String())
		return nil, err
	}

	if len(employeeCommissions) == 0 {
		return []model.EmployeeCommission{}, nil
	}

	return c.store.EmployeeCommission.Create(db, employeeCommissions)
}

func (c *controller) calculateCommissionFromInvoice(db *gorm.DB, l logger.Logger, invoice *model.Invoice) ([]model.EmployeeCommission, error) {
	projectMembers, err := c.store.ProjectMember.GetAssignedMembers(db, invoice.ProjectID.String(), model.ProjectMemberStatusActive.String(), true)
	if err != nil {
		l.Errorf(err, "failed to calculate account manager commission rate for project(%s)", invoice.ProjectID.String())
		return nil, err
	}

	// Get list of project head who will get the commission from this invoice
	pics := c.getPICs(invoice, projectMembers)
	var res []model.EmployeeCommission
	if len(pics.devLeads) > 0 {
		c, err := c.calculateHeadCommission(pics.devLeads, invoice, invoice.TotalWithoutBonus)
		if err != nil {
			l.Errorf(err, "failed to calculate dev lead commission rate for project(%s)", invoice.ProjectID.String())
			return nil, err
		}
		res = append(res, c...)
	}

	if len(pics.accountManagers) > 0 {
		c, err := c.calculateHeadCommission(pics.accountManagers, invoice, invoice.TotalWithoutBonus)
		if err != nil {
			l.Errorf(err, "failed to calculate account manager commission rate for project(%s)", invoice.ProjectID.String())
			return nil, err
		}
		res = append(res, c...)
	}

	if len(pics.deliveryManagers) > 0 {
		c, err := c.calculateHeadCommission(pics.deliveryManagers, invoice, invoice.TotalWithoutBonus)
		if err != nil {
			l.Errorf(err, "failed to calculate delivery manager commission rate for project(%s)", invoice.ProjectID.String())
			return nil, err
		}
		res = append(res, c...)
	}

	if len(pics.sales) > 0 {
		c, err := c.calculateHeadCommission(pics.sales, invoice, invoice.TotalWithoutBonus)
		if err != nil {
			l.Errorf(err, "failed to calculate sales commission rate for project(%s)", invoice.ProjectID.String())
			return nil, err
		}

		res = append(res, c...)
	}

	if len(pics.upsells) > 0 {
		c, err := c.calculateRefBonusCommission(pics.upsells, invoice)
		if err != nil {
			l.Errorf(err, "failed to calculate upsells commission rate for project(%s)", invoice.ProjectID.String())
			return nil, err
		}
		res = append(res, c...)
	}

	if len(pics.suppliers) > 0 {
		c, err := c.calculateRefBonusCommission(pics.suppliers, invoice)
		if err != nil {
			l.Errorf(err, "failed to calculate supplier commission rate for project(%s)", invoice.ProjectID.String())
			return nil, err
		}
		res = append(res, c...)
	}

	if len(pics.saleReferers) > 0 {
		c, err := c.calculateSaleReferralCommission(pics.saleReferers, invoice)
		if err != nil {
			l.Errorf(err, "failed to calculate sale refereral commission rate for project(%s)", invoice.ProjectID.String())
			return nil, err
		}
		res = append(res, c...)
	}

	if len(pics.upsellReferers) > 0 {
		c, err := c.calculateUpsellSaleReferralCommission(pics.upsellReferers, invoice)
		if err != nil {
			l.Errorf(err, "failed to calculate upsell refereral commission rate for project(%s)", invoice.ProjectID.String())
			return nil, err
		}
		res = append(res, c...)
	}

	return res, nil
}

func (c *controller) getPICs(invoice *model.Invoice, projectMembers []*model.ProjectMember) *pics {
	var (
		devLeads         []pic
		accountManagers  []pic
		deliveryManagers []pic
		sales            []pic
		upsells          []pic
		suppliers        []pic
		saleReferers     []pic
		upsellReferers   []pic
	)

	for _, itm := range invoice.Project.Heads {
		switch itm.Position {
		case model.HeadPositionTechnicalLead:
			devLeads = append(devLeads, pic{
				ID:             itm.EmployeeID,
				CommissionRate: itm.CommissionRate,
				ChargeRate:     invoice.Total,
				Note:           "Lead",
			})
		case model.HeadPositionAccountManager:
			accountManagers = append(accountManagers, pic{
				ID:             itm.EmployeeID,
				CommissionRate: itm.CommissionRate,
				ChargeRate:     invoice.Total,
				Note:           "Account Manager",
			})
		case model.HeadPositionDeliveryManager:
			deliveryManagers = append(deliveryManagers, pic{
				ID:             itm.EmployeeID,
				CommissionRate: itm.CommissionRate,
				ChargeRate:     invoice.Total,
				Note:           "Delivery Manager",
			})
		case model.HeadPositionSalePerson:
			sales = append(sales, pic{
				ID:             itm.EmployeeID,
				CommissionRate: itm.CommissionRate,
				ChargeRate:     invoice.Total,
				Note:           "Sales",
			})

			// UPDATE:
			// If sale person earn commission from project. The person who refer the sale person will earn commission too.
			// The commission rate is 10% of the sale person commission rate.
			salePersonDetail, err := c.store.Employee.One(c.repo.DB(), itm.EmployeeID.String(), false)
			if err != nil {
				continue
			}

			if salePersonDetail.Referrer == nil {
				continue
			}
			saleReferers = append(saleReferers, pic{
				ID:             salePersonDetail.Referrer.ID,
				CommissionRate: decimal.NewFromInt(saleReferralCommissionRate),
				ChargeRate:     decimal.NewFromFloat(invoice.Total).Mul(itm.CommissionRate).Div(decimal.NewFromInt(100)).InexactFloat64(),
				Note:           fmt.Sprintf("Sale Referral - %s", salePersonDetail.FullName),
			})
		}
	}

	for _, pm := range projectMembers {
		if pm.DeploymentType != model.MemberDeploymentTypeOfficial {
			continue
		}

		if !pm.UpsellCommissionRate.IsZero() {
			upsells = append(upsells, pic{
				ID:             pm.UpsellPersonID,
				CommissionRate: pm.UpsellCommissionRate,
				ChargeRate:     pm.Rate.InexactFloat64(),
				Note:           "Upsell",
			})

			upsellPersonDetail, err := c.store.Employee.One(c.repo.DB(), pm.UpsellPersonID.String(), false)
			if err != nil {
				continue
			}

			if upsellPersonDetail.Referrer != nil {
				upsellReferers = append(upsellReferers, pic{
					ID:             upsellPersonDetail.Referrer.ID,
					CommissionRate: decimal.NewFromInt(saleReferralCommissionRate),
					ChargeRate:     decimal.NewFromFloat(pm.Rate.InexactFloat64()).Mul(pm.UpsellCommissionRate).Div(decimal.NewFromInt(100)).InexactFloat64(),
					Note:           fmt.Sprintf("Sale Referral - %s Upsell %s", upsellPersonDetail.FullName, pm.Employee.FullName),
				})
			}
		}

		if pm.Employee.Referrer != nil {
			if pm.Employee.Referrer.WorkingStatus != model.WorkingStatusLeft {
				suppliers = append(suppliers, pic{
					ID:             pm.Employee.Referrer.ID,
					CommissionRate: decimal.NewFromInt(hiringCommissionRate),
					ChargeRate:     pm.Rate.InexactFloat64(),
					Note:           fmt.Sprintf("Hiring - %s", pm.Employee.FullName),
				})
			}
		}
	}

	return &pics{
		devLeads:         devLeads,
		accountManagers:  accountManagers,
		deliveryManagers: deliveryManagers,
		sales:            sales,
		upsells:          upsells,
		suppliers:        suppliers,
		saleReferers:     saleReferers,
		upsellReferers:   upsellReferers,
	}
}

func (c *controller) movePaidInvoiceGDrive(l logger.Logger, wg *sync.WaitGroup, req *processPaidInvoiceRequest) {
	msg := c.service.Basecamp.BuildCommentMessage(req.InvoiceBucketID, req.InvoiceTodoID, bcConst.CommentMoveInvoicePDFToPaidDirSuccessfully, bcModel.CommentMsgTypeCompleted)

	defer func() {
		c.worker.Enqueue(bcModel.BasecampCommentMsg, msg)
		wg.Done()
	}()

	err := c.service.GoogleDrive.MoveInvoicePDF(req.Invoice, "Sent", "Paid")
	if err != nil {
		l.Errorf(err, "failed to move invoice pdf from sent to paid folder for invoice(%v)", req.Invoice.ID.String())
		msg = c.service.Basecamp.BuildCommentMessage(req.InvoiceBucketID, req.InvoiceTodoID, bcConst.CommentMoveInvoicePDFToPaidDirFailed, bcModel.CommentMsgTypeFailed)
		return
	}
}

func (c *controller) calculateHeadCommission(beneficiaries []pic, invoice *model.Invoice, invoiceTotal float64) ([]model.EmployeeCommission, error) {
	// NOTE:
	// CR is Commission Rate
	// IV is Invoice Value
	// RCR is Referral Commission Rate
	// VAL is Charge Rate the value before the commission
	// RATE is Conversion Rate

	rs := make([]model.EmployeeCommission, 0)
	for _, beneficiary := range beneficiaries {
		if !beneficiary.CommissionRate.GreaterThan(decimal.NewFromInt(0)) {
			continue
		}

		crPercentage := beneficiary.CommissionRate.Div(decimal.NewFromInt(100))
		commissionValue, _ := crPercentage.Mul(decimal.NewFromFloat(invoiceTotal)).Float64()
		convertedValue, rate, err := c.service.Wise.Convert(commissionValue, invoice.Project.BankAccount.Currency.Name, "VND")
		if err != nil {
			return nil, err
		}

		if convertedValue > 0 {
			rs = append(rs, model.EmployeeCommission{
				EmployeeID:     beneficiary.ID,
				Amount:         model.NewVietnamDong(int64(convertedValue)),
				Project:        invoice.Project.Name,
				ConversionRate: rate,
				InvoiceID:      invoice.ID,
				Formula:        fmt.Sprintf("%v%%(CR) * %v(IV) * %v(RATE)", beneficiary.CommissionRate, invoiceTotal, rate),
				Note:           beneficiary.Note,
			})
		}
	}

	return rs, nil
}

func (c *controller) calculateRefBonusCommission(pics []pic, invoice *model.Invoice) ([]model.EmployeeCommission, error) {
	// conversionRate by percentage
	var rs []model.EmployeeCommission
	for _, pic := range pics {
		percentage := pic.CommissionRate.Div(decimal.NewFromInt(100))
		commissionValue, _ := percentage.Mul(decimal.NewFromFloat(pic.ChargeRate)).Float64()
		convertedValue, rate, err := c.service.Wise.Convert(commissionValue, invoice.Project.BankAccount.Currency.Name, "VND")
		if err != nil {
			return nil, err
		}

		rs = append(rs, model.EmployeeCommission{
			EmployeeID:     pic.ID,
			Amount:         model.NewVietnamDong(int64(convertedValue)),
			Project:        invoice.Project.Name,
			ConversionRate: rate,
			InvoiceID:      invoice.ID,
			Formula:        fmt.Sprintf("%v%%(RCR) * %v(VAL) * %v(RATE)", pic.CommissionRate, pic.ChargeRate, rate),
			Note:           pic.Note,
		})
	}

	return rs, nil
}

func (c *controller) calculateSaleReferralCommission(pics []pic, invoice *model.Invoice) ([]model.EmployeeCommission, error) {
	// conversionRate by percentage
	var rs []model.EmployeeCommission
	for _, pic := range pics {
		percentage := pic.CommissionRate.Div(decimal.NewFromInt(100))
		commissionValue, _ := percentage.Mul(decimal.NewFromFloat(pic.ChargeRate)).Float64()
		convertedValue, rate, err := c.service.Wise.Convert(commissionValue, invoice.Project.BankAccount.Currency.Name, "VND")
		if err != nil {
			return nil, err
		}

		rs = append(rs, model.EmployeeCommission{
			EmployeeID:     pic.ID,
			Amount:         model.NewVietnamDong(int64(convertedValue)),
			Project:        invoice.Project.Name,
			ConversionRate: rate,
			InvoiceID:      invoice.ID,
			Formula:        fmt.Sprintf("%v%%(RCR) * %v(VAL) * %v(RATE)", pic.CommissionRate, commissionValue, rate),
			Note:           pic.Note,
		})
	}

	return rs, nil
}

func (c *controller) calculateUpsellSaleReferralCommission(pics []pic, invoice *model.Invoice) ([]model.EmployeeCommission, error) {
	var rs []model.EmployeeCommission
	for _, pic := range pics {
		percentage := pic.CommissionRate.Div(decimal.NewFromInt(100))
		commissionValue, _ := percentage.Mul(decimal.NewFromFloat(pic.ChargeRate)).Float64()
		convertedValue, rate, err := c.service.Wise.Convert(commissionValue, invoice.Project.BankAccount.Currency.Name, "VND")
		if err != nil {
			return nil, err
		}

		rs = append(rs, model.EmployeeCommission{
			EmployeeID:     pic.ID,
			Amount:         model.NewVietnamDong(int64(convertedValue)),
			Project:        invoice.Project.Name,
			ConversionRate: rate,
			InvoiceID:      invoice.ID,
			Formula:        fmt.Sprintf("%v%%(RCR) * %v(VAL) * %v(RATE)", pic.CommissionRate, commissionValue, rate),
			Note:           pic.Note,
		})
	}

	return rs, nil
}

```

# pkg/controller/earn/new.go

```go
package earn

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	config  *config.Config
	repo    store.DBRepo
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		service: service,
		logger:  logger,
		config:  cfg,
		repo:    repo,
	}
}

```

# pkg/controller/earn/interface.go

```go
package earn

import (
	"context"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type IController interface {
	ListEarn(ctx context.Context) ([]model.Earn, error)
}

```

# pkg/controller/earn/earn.go

```go
package earn

import (
	"context"
	"io"
	"net/http"
	"strings"

	"golang.org/x/net/html"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

const memoURL = "https://memo.d.foundation"

func (c *controller) ListEarn(ctx context.Context) ([]model.Earn, error) {
	htmlContent, err := fetchHTML(memoURL + "/earn")
	if err != nil {
		return nil, err
	}

	doc, err := html.Parse(strings.NewReader(htmlContent))
	if err != nil {
		return nil, err
	}

	earns := parseEarnTable(doc)

	picIDs := make([]string, 0)
	for _, earn := range earns {
		picIDs = append(picIDs, earn.PICs...)
	}

	pics, err := c.store.DiscordAccount.ListByMemoUsername(c.repo.DB(), picIDs)
	if err != nil {
		return nil, err
	}

	picDiscordIDMap := make(map[string]string)
	for _, pic := range pics {
		key := pic.DiscordUsername
		if key == "" {
			key = pic.MemoUsername
		}

		picDiscordIDMap[key] = pic.DiscordID
	}

	for i, earn := range earns {
		for j, picID := range earn.PICs {
			if val, ok := picDiscordIDMap[picID]; ok {
				earn.PICs[j] = val
			}
		}
		earns[i] = earn
	}

	return earns, nil
}

func fetchHTML(url string) (string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	return string(body), nil
}

func parseEarnTable(node *html.Node) []model.Earn {
	var earns []model.Earn
	var currentEarn model.Earn
	var isHeader bool
	var fieldIndex int

	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "tr" {
			isHeader = false
			fieldIndex = 0
			for c := n.FirstChild; c != nil; c = c.NextSibling {
				if c.Type == html.ElementNode && c.Data == "th" {
					isHeader = true
					break
				}
			}
			if !isHeader {
				for c := n.FirstChild; c != nil; c = c.NextSibling {
					if c.Type == html.ElementNode && c.Data == "td" {
						text := getText(c)
						switch fieldIndex {
						case 0:
							if linkNode := findLinkNode(c); linkNode != nil {
								currentEarn.URL = memoURL + getAttr(linkNode, "href")
								currentEarn.Title = getText(linkNode)
							} else {
								currentEarn.Title = text
							}
						case 1:
							currentEarn.Bounty = text
						case 2:
							currentEarn.Status = text
						case 3:
							pics := strings.Split(text, ",")
							for _, pic := range pics {
								if pic != "" {
									currentEarn.PICs = append(currentEarn.PICs, pic)
								}
							}
						case 4:
							currentEarn.Function = text
						}
						fieldIndex++
					}
				}
				earns = append(earns, currentEarn)
				currentEarn = model.Earn{}
			}
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(node)

	return earns
}

func findLinkNode(n *html.Node) *html.Node {
	var linkNode *html.Node
	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "a" {
			linkNode = n
			return
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(n)
	return linkNode
}

func getAttr(n *html.Node, attrName string) string {
	for _, attr := range n.Attr {
		if attr.Key == attrName {
			return attr.Val
		}
	}
	return ""
}

func getText(n *html.Node) string {
	var buf strings.Builder
	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.TextNode {
			buf.WriteString(n.Data)
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(n)
	return buf.String()
}

```

# pkg/controller/deliverymetrics/sync.go

```go
package deliverymetrics

import (
	"errors"
	"strings"
	"time"

	"github.com/shopspring/decimal"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/store/employee"
)

func (c controller) Sync() error {
	l := c.logger.Fields(logger.Fields{
		"controller": "deliverymetrics",
		"method":     "Create",
	})

	latestItem, err := c.store.DeliveryMetric.GetLatest(c.repo.DB())
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		l.Errorf(err, "failed to get latest item")
		return err
	}

	maxIdx := 0
	if errors.Is(err, gorm.ErrRecordNotFound) {
		maxIdx = 2
	} else {
		maxIdx = latestItem.Ref + 1
	}

	sheetData, err := c.service.GoogleSheet.FetchSheetContent(maxIdx)
	if err != nil {
		l.Errorf(err, "failed to fetch sheet content")
		return err
	}

	employees, err := c.store.Employee.GetRawList(c.repo.DB(), employee.EmployeeFilter{})
	if err != nil {
		l.Errorf(err, "failed to fetch employee")
		return err
	}
	employeeMap := model.Employees(employees).ToTeamEmailIDMap()

	projects, err := c.store.Project.GetRawList(c.repo.DB())
	if err != nil {
		l.Errorf(err, "failed to fetch project")
		return err
	}

	projectMap := model.Projects(projects).ToNameIDMap()

	deliveryMetrics := make([]model.DeliveryMetric, 0)
	for _, row := range sheetData {
		defaultVal := decimal.NewFromInt(0)
		weight, err := decimal.NewFromString(strings.ReplaceAll(row.Weight, ",", "."))
		if err != nil {
			weight = defaultVal
		}

		effort, err := decimal.NewFromString(strings.ReplaceAll(row.Effort, ",", "."))
		if err != nil {
			effort = defaultVal
		}

		effectiveness, err := decimal.NewFromString(strings.ReplaceAll(row.Effectiveness, ",", "."))
		if err != nil {
			effectiveness = defaultVal
		}

		date, err := time.Parse("01-02-2006", row.Date)
		if err != nil {
			continue
		}

		projectName := row.Project
		if row.Project == "Internal" {
			projectName = "Fortress v2.0"
		}

		projectID := projectMap[projectName]
		employeeID := employeeMap[row.Email]

		dm := model.DeliveryMetric{
			Weight:        weight,
			Effort:        effort,
			Effectiveness: effectiveness,
			EmployeeID:    employeeID,
			ProjectID:     projectID,
			Date:          &date,
			Ref:           maxIdx,
		}

		deliveryMetrics = append(deliveryMetrics, dm)
		maxIdx++
	}

	if len(deliveryMetrics) > 0 {
		_, err = c.store.DeliveryMetric.Create(c.repo.DB(), deliveryMetrics)
		if err != nil {
			l.Errorf(err, "failed to create delivery metric")
			return err
		}
	}

	return nil
}

```

# pkg/controller/deliverymetrics/new.go

```go
package deliverymetrics

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type IController interface {
	GetWeeklyReport() (*model.WeeklyReport, error)
	GetMonthlyReport() (*model.MonthlyReport, error)
	GetWeeklyLeaderBoard() (*model.LeaderBoard, error)
	GetMonthlyLeaderBoard(month *time.Time) (*model.LeaderBoard, error)

	Sync() error
}

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

```

# pkg/controller/deliverymetrics/leaderboard.go

```go
package deliverymetrics

import (
	"time"

	"github.com/pkg/errors"
	"github.com/shopspring/decimal"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

func (c controller) GetWeeklyLeaderBoard() (*model.LeaderBoard, error) {
	w, err := c.store.DeliveryMetric.GetLatestWeek(c.repo.DB())
	if err != nil {
		return nil, errors.Wrap(err, "failed to get latest week")
	}

	// Get top 10 users with highest points
	metrics, err := c.store.DeliveryMetric.GetTopWeighMetrics(c.repo.DB(), w, 5)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get top users with highest points")
	}

	items := make([]model.LeaderBoardItem, 0, len(metrics))
	// Get user info
	for _, m := range metrics {
		e, err := c.store.Employee.One(c.repo.DB(), m.EmployeeID.String(), false)
		if err != nil {
			return nil, errors.Wrap(err, "failed to get employee "+m.EmployeeID.String())
		}

		// Get discord acc
		d, err := c.store.DiscordAccount.One(c.repo.DB(), e.DiscordAccountID.String())
		if err != nil {
			return nil, errors.Wrap(err, "failed to get discord account "+e.DiscordAccountID.String()+" of employee "+e.ID.String())
		}

		item := model.LeaderBoardItem{
			EmployeeID:      e.ID.String(),
			EmployeeName:    e.DisplayName,
			Points:          m.SumWeight,
			DiscordID:       d.DiscordID,
			DiscordUsername: d.DiscordUsername,
		}
		if m.SumEffort.IsZero() {
			item.Effectiveness = decimal.NewFromFloat(0)
		} else {
			item.Effectiveness = m.SumWeight.DivRound(m.SumEffort, 2)
		}

		items = append(items, item)
	}

	return &model.LeaderBoard{
		Date:  w,
		Items: rankItems(items),
	}, nil
}

func (c controller) GetMonthlyLeaderBoard(month *time.Time) (*model.LeaderBoard, error) {
	m := month
	if m == nil {
		var err error
		m, err = c.store.DeliveryMetric.GetLatestMonth(c.repo.DB())
		if err != nil {
			return nil, errors.Wrap(err, "failed to get latest month")
		}
	}

	// Get top 10 users with highest points
	metrics, err := c.store.DeliveryMetric.GetTopMonthlyWeighMetrics(c.repo.DB(), m, 10)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get top users with highest points")
	}

	items := make([]model.LeaderBoardItem, 0, len(metrics))
	// Get user info
	for _, m := range metrics {
		e, err := c.store.Employee.One(c.repo.DB(), m.EmployeeID.String(), false)
		if err != nil {
			return nil, errors.Wrap(err, "failed to get employee "+m.EmployeeID.String())
		}

		item := model.LeaderBoardItem{
			EmployeeID:    e.ID.String(),
			EmployeeName:  e.DisplayName,
			Points:        m.Weight,
			Effectiveness: m.Effectiveness,
		}

		// Get discord acc
		if !e.DiscordAccountID.IsZero() {
			d, err := c.store.DiscordAccount.One(c.repo.DB(), e.DiscordAccountID.String())
			if err != nil {
				return nil, errors.Wrap(err, "failed to get discord account "+e.DiscordAccountID.String()+" of employee "+e.ID.String())
			}
			if d != nil {
				item.DiscordID = d.DiscordID
				item.DiscordUsername = d.DiscordUsername
			}
		}

		items = append(items, item)
	}

	return &model.LeaderBoard{
		Date:  m,
		Items: rankItems(items),
	}, nil
}

func rankItems(data []model.LeaderBoardItem) []model.LeaderBoardItem {
	// Set the rank for each employee
	for i := range data {
		if i > 0 && data[i].Points.Equal(data[i-1].Points) && data[i].Effectiveness.Equal(data[i-1].Effectiveness) {
			data[i].Rank = data[i-1].Rank
		} else {
			data[i].Rank = i + 1
		}
	}

	return data
}

```

# pkg/controller/deliverymetrics/get.go

```go
package deliverymetrics

import (
	"errors"
	"math"

	"github.com/shopspring/decimal"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

func (c controller) GetWeeklyReport() (*model.WeeklyReport, error) {
	return GetWeeklyReport(c.store, c.repo.DB())
}

func GetWeeklyReport(s *store.Store, db *gorm.DB) (*model.WeeklyReport, error) {
	// Get data of latest week
	metrics, err := s.WeeklyDeliveryMetric.GetLast(db, 2)
	if err != nil {
		return nil, err
	}
	if len(metrics) < 2 {
		return nil, errors.New("not enough data")
	}

	currentReport := metrics[0]
	lastWeekReport := metrics[1]

	report := &model.WeeklyReport{
		LastWeek: model.WeekReport{
			Date:        lastWeekReport.Date,
			TotalPoints: decimalToRoundedFloat32(lastWeekReport.SumWeight),
			Effort:      decimalToRoundedFloat32(lastWeekReport.SumEffort),
		},
		CurrentWeek: model.WeekReport{
			Date:        currentReport.Date,
			TotalPoints: decimalToRoundedFloat32(currentReport.SumWeight),
			Effort:      decimalToRoundedFloat32(currentReport.SumEffort),
		},
	}

	// Avg
	avgMetric, err := s.WeeklyDeliveryMetric.Avg(db)
	if err != nil {
		return nil, err
	}
	report.CurrentWeek.AvgPoint = decimalToRoundedFloat32(avgMetric.Weight)
	report.CurrentWeek.AvgEffort = decimalToRoundedFloat32(avgMetric.Effort)

	avgWithoutLatestWeek, err := s.WeeklyDeliveryMetric.AvgWithoutLatestWeek(db)
	if err != nil {
		return nil, err
	}
	report.LastWeek.AvgPoint = decimalToRoundedFloat32(avgWithoutLatestWeek.Weight)
	report.LastWeek.AvgEffort = decimalToRoundedFloat32(avgWithoutLatestWeek.Effort)

	// Compare data of current week and last week
	report.TotalPointChangePercentage = roundFloat32To2Decimals(
		(report.CurrentWeek.TotalPoints - report.LastWeek.TotalPoints) / report.LastWeek.TotalPoints * 100)
	report.EffortChangePercentage = roundFloat32To2Decimals(
		(report.CurrentWeek.Effort - report.LastWeek.Effort) / report.LastWeek.Effort * 100)
	report.AvgPointChangePercentage = roundFloat32To2Decimals(
		(report.CurrentWeek.AvgPoint - report.LastWeek.AvgPoint) / report.LastWeek.AvgPoint * 100)
	report.AvgEffortChangePercentage = roundFloat32To2Decimals(
		(report.CurrentWeek.AvgEffort - report.LastWeek.AvgEffort) / report.LastWeek.AvgEffort * 100)

	return report, nil
}

func (c controller) GetMonthlyReport() (*model.MonthlyReport, error) {
	return GetMonthlyReport(c.store, c.repo.DB(), 3) // 1 current month could be not completed yet
}

func GetMonthlyReport(s *store.Store, db *gorm.DB, monthNumToTake int) (*model.MonthlyReport, error) {
	// Get data of the latest month
	metrics, err := s.MonthlyDeliveryMetric.GetLast(db, monthNumToTake)
	if err != nil {
		return nil, err
	}
	if len(metrics) < 2 {
		return nil, errors.New("not enough data")
	}

	reports := make([]model.MonthReport, 0, monthNumToTake)
	for _, m := range metrics {
		r := model.MonthReport{
			Month:       m.Month,
			TotalWeight: decimalToRoundedFloat32(m.SumWeight),
			Effort:      decimalToRoundedFloat32(m.SumEffort),
		}

		// Avg monthly
		avgMetric, err := s.MonthlyDeliveryMetric.AvgTo(db, m.Month)
		if err != nil {
			return nil, err
		}
		r.AvgWeight = decimalToRoundedFloat32(avgMetric.Weight)
		r.AvgEffort = decimalToRoundedFloat32(avgMetric.Effort)

		// Avg month weekly
		if m.Month != nil {
			avgMonthWeekly, err := s.WeeklyDeliveryMetric.AvgByMonth(db, *m.Month)
			if err != nil {
				return nil, err
			}
			if len(avgMonthWeekly) == 0 {
				return nil, errors.New("missing month weekly data")
			}
			r.AvgWeeklyWeight = decimalToRoundedFloat32(avgMonthWeekly[0].Weight)
			r.AvgWeeklyEffort = decimalToRoundedFloat32(avgMonthWeekly[0].Effort)
		}

		reports = append(reports, r)
	}

	// Calculate change with previous month
	for i := 0; i < len(reports)-1; i++ {
		currentReport := reports[i]
		prevMonthReport := reports[i+1]

		currentReport.TotalPointChangePercentage = roundFloat32To2Decimals(
			(currentReport.TotalWeight - prevMonthReport.TotalWeight) / prevMonthReport.TotalWeight * 100)
		currentReport.EffortChangePercentage = roundFloat32To2Decimals(
			(currentReport.Effort - prevMonthReport.Effort) / prevMonthReport.Effort * 100)

		currentReport.AvgWeightChangePercentage = roundFloat32To2Decimals(
			(currentReport.AvgWeight - prevMonthReport.AvgWeight) / prevMonthReport.AvgWeight * 100)
		currentReport.AvgEffortChangePercentage = roundFloat32To2Decimals(
			(currentReport.AvgEffort - prevMonthReport.AvgEffort) / prevMonthReport.AvgEffort * 100)

		currentReport.AvgWeeklyPointChangePercentage = roundFloat32To2Decimals(
			(currentReport.AvgWeeklyWeight - prevMonthReport.AvgWeeklyWeight) / prevMonthReport.AvgWeeklyWeight * 100)
		currentReport.AvgWeeklyEffortChangePercentage = roundFloat32To2Decimals(
			(currentReport.AvgWeeklyEffort - prevMonthReport.AvgWeeklyEffort) / prevMonthReport.AvgWeeklyEffort * 100)

		// Update new value to slice
		reports[i] = currentReport
	}

	return &model.MonthlyReport{
		Reports: reports,
	}, nil
}

func decimalToRoundedFloat32(d decimal.Decimal) float32 {
	f, _ := d.Float64()
	rounded := math.Round(f*100) / 100
	return float32(rounded)
}

func roundFloat32To2Decimals(f float32) float32 {
	rounded := math.Round(float64(f)*100) / 100
	return float32(rounded)
}

```

# pkg/controller/discord/new.go

```go
package discord

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type IController interface {
	Log(in model.LogDiscordInput) error
	PublicAdvanceSalaryLog(in model.LogDiscordInput) error
	ListDiscordResearchTopics(ctx context.Context, days, limit, offset int) ([]model.DiscordResearchTopic, int64, error)
	UserOgifStats(ctx context.Context, discordID string, after time.Time) (OgifStats, error)
	GetOgifLeaderboard(ctx context.Context, after time.Time, limit int) ([]model.OgifLeaderboardRecord, error)
}

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	config  *config.Config
	repo    store.DBRepo
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		service: service,
		logger:  logger,
		config:  cfg,
		repo:    repo,
	}
}

func (c *controller) Log(in model.LogDiscordInput) error {
	// Get discord template
	template, err := c.store.DiscordLogTemplate.GetTemplateByType(c.repo.DB(), in.Type)
	if err != nil {
		c.logger.Field("err", err.Error()).Warn("Get Discord Template failed")
		return err
	}

	data := in.Data.(map[string]interface{})

	// get employee_id in discord format if any
	if employeeID, ok := data["employee_id"]; ok {
		employee, err := c.store.Employee.One(c.repo.DB(), employeeID.(string), false)
		if err != nil {
			c.logger.Field("err", err.Error()).Warn("Get Employee failed")
			return err
		}

		accountID := employee.DisplayName
		if employee.DiscordAccount != nil && employee.DiscordAccount.DiscordID != "" {
			accountID = fmt.Sprintf("<@%s>", employee.DiscordAccount.DiscordID)
		}

		data["employee_id"] = accountID
	}

	if updatedEmployeeID, ok := data["updated_employee_id"]; ok {
		updatedEmployee, err := c.store.Employee.One(c.repo.DB(), updatedEmployeeID.(string), false)
		if err != nil {
			c.logger.Field("err", err.Error()).Warn("Get Employee failed")
			return err
		}

		accountID := updatedEmployee.DisplayName
		if updatedEmployee.DiscordAccount != nil && updatedEmployee.DiscordAccount.DiscordID != "" {
			accountID = fmt.Sprintf("<@%s>", updatedEmployee.DiscordAccount.DiscordID)
		}

		data["updated_employee_id"] = accountID
	}

	// Replace template
	content := template.Content
	for k, v := range data {
		content = strings.ReplaceAll(content, fmt.Sprintf("{{ %s }}", k), fmt.Sprintf("%v", v))
	}

	// log discord
	_, err = c.service.Discord.SendMessage(model.DiscordMessage{
		Content: content,
	}, c.config.Discord.Webhooks.AuditLog)
	if err != nil {
		c.logger.Field("err", err.Error()).Warn("Log failed")
		return err
	}

	return nil
}

func (c *controller) PublicAdvanceSalaryLog(in model.LogDiscordInput) error {
	data := in.Data.(map[string]interface{})

	icyAmount := data["icy_amount"]
	usdAmount := data["usd_amount"]

	desc := fmt.Sprintf("🧊 %v ICY (%v) has been sent to an anonymous peep as a salary advance.\n", icyAmount, usdAmount)
	desc += "\nFull-time peeps can use `?salary advance` to take a short-term credit benefit."

	embedMessage := model.DiscordMessageEmbed{
		Author:      model.DiscordMessageAuthor{},
		Title:       "💸 New ICY Payment 💸",
		URL:         "",
		Description: desc,
		Color:       3447003,
		Fields:      nil,
		Thumbnail:   model.DiscordMessageImage{},
		Image:       model.DiscordMessageImage{},
		Footer: model.DiscordMessageFooter{
			IconURL: "https://cdn.discordapp.com/avatars/564764617545482251/9c9bd4aaba164fc0b92f13f052405b4d.webp?size=160",
			Text:    "?help to see all commands",
		},
		Timestamp: time.Now().Format("2006-01-02T15:04:05.000+07:00"),
	}

	// log discord
	_, err := c.service.Discord.SendMessage(model.DiscordMessage{
		Embeds: []model.DiscordMessageEmbed{embedMessage},
	}, c.config.Discord.Webhooks.ICYPublicLog)
	if err != nil {
		c.logger.Field("err", err.Error()).Warn("Log failed")
		return err
	}

	return nil
}

func (c *controller) ListDiscordResearchTopics(ctx context.Context, days, limit, offset int) ([]model.DiscordResearchTopic, int64, error) {
	topics, err := c.service.Discord.ListActiveThreadsByChannelID(c.config.Discord.IDs.DwarvesGuild, c.config.Discord.IDs.ResearchChannel)
	if err != nil {
		c.logger.Error(err, "Fetch list research topics failed")
		return nil, 0, err
	}

	type result struct {
		topic model.DiscordResearchTopic
		err   error
	}

	topicCh := make(chan string, len(topics))
	resultCh := make(chan result, len(topics))
	workers := 5

	var wg sync.WaitGroup
	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for topicID := range topicCh {
				totalMsgCount, topUsers, lastActiveTime, err := c.topicPopularity(topicID, days)
				if err != nil {
					c.logger.Error(err, "Build research topic model failed")
					resultCh <- result{err: err}
					continue
				}
				if totalMsgCount == 0 {
					continue
				}

				resultCh <- result{
					topic: model.DiscordResearchTopic{
						Name:              topicID, // Assume topic.Name is topicID for this example
						URL:               fmt.Sprintf("https://discord.com/channels/%s/%s", c.config.Discord.IDs.DwarvesGuild, topicID),
						MsgCount:          totalMsgCount,
						SortedActiveUsers: topUsers,
						LastActiveTime:    lastActiveTime,
					},
				}
			}
		}()
	}

	for _, topic := range topics {
		topicCh <- topic.ID
	}
	close(topicCh)

	go func() {
		wg.Wait()
		close(resultCh)
	}()

	finalResults := make([]model.DiscordResearchTopic, 0)
	for res := range resultCh {
		if res.err != nil {
			return nil, 0, res.err
		}
		finalResults = append(finalResults, res.topic)
	}

	sort.Slice(finalResults, func(i, j int) bool {
		return finalResults[i].MsgCount > finalResults[j].MsgCount
	})

	total := int64(len(finalResults))

	// Apply pagination
	if int64(offset) >= total {
		return []model.DiscordResearchTopic{}, total, nil
	}
	end := offset + limit
	if end > len(finalResults) {
		end = len(finalResults)
	}

	finalResults = finalResults[offset:end]

	return finalResults, total, nil
}

func (c *controller) topicPopularity(topicID string, days int) (int64, []model.DiscordTopicActiveUser, time.Time, error) {
	var totalMessages int64
	var beforeID string
	var lastActiveTime time.Time

	lastNDays := time.Now().AddDate(0, 0, -days)
	userMessageCount := make(map[string]int64)
	limit := 100

	for {
		messages, err := c.service.Discord.GetChannelMessages(topicID, beforeID, "", limit)
		if err != nil {
			return 0, nil, time.Now(), err
		}
		if len(messages) == 0 {
			break
		}

		if beforeID == "" {
			lastActiveTime = messages[0].Timestamp
		}

		for _, msg := range messages {
			if days != 0 && msg.Timestamp.Before(lastNDays) {
				break
			}

			userMessageCount[msg.Author.ID]++
			totalMessages++
		}

		if len(messages) < limit {
			break
		}

		beforeID = messages[len(messages)-1].ID
	}

	var userCounts []model.DiscordTopicActiveUser
	for userID, count := range userMessageCount {
		userCounts = append(userCounts, model.DiscordTopicActiveUser{UserID: userID, MsgCount: count})
	}

	sort.Slice(userCounts, func(i, j int) bool {
		return userCounts[i].MsgCount > userCounts[j].MsgCount
	})

	var result []model.DiscordTopicActiveUser
	for i := 0; i < 3 && i < len(userCounts); i++ {
		result = append(result, userCounts[i])
	}

	return totalMessages, result, lastActiveTime, nil
}

// OgifStats contains list of ogif and some stats
type OgifStats struct {
	OgifList               []model.EventSpeaker `json:"ogifList"`
	UserAllTimeSpeaksCount int64                `json:"userAllTimeSpeaksCount"`
	UserAllTimeRank        int64                `json:"userAllTimeRank"`
	UserCurrentSpeaksCount int64                `json:"userCurrentSpeaksCount"`
	UserCurrentRank        int64                `json:"userCurrentRank"`
	TotalSpeakCount        int64                `json:"totalSpeakCount"`
	CurrentSpeakCount      int64                `json:"currentSpeakCount"`
}

// UserOgifStats returns list ogif with some stats
func (c *controller) UserOgifStats(ctx context.Context, discordID string, after time.Time) (OgifStats, error) {
	logger := c.logger.AddField("discordID", discordID).AddField("after", after)

	ogftList, err := c.store.EventSpeaker.List(c.repo.DB(), discordID, &after, "ogif")
	if err != nil {
		logger.Error(err, "error when retrieving list event speaker")
		return OgifStats{}, err
	}

	ogifStats, err := c.store.EventSpeaker.GetSpeakerStats(c.repo.DB(), discordID, &after, "ogif")
	if err != nil {
		logger.Error(err, "error when retrieving speaker stats")
	}

	allTimeOgifStats, err := c.store.EventSpeaker.GetSpeakerStats(c.repo.DB(), discordID, nil, "ogif")
	if err != nil {
		logger.Error(err, "error when retrieving all time speaker stats")
		return OgifStats{}, err
	}

	allTimeTotalCount, err := c.store.EventSpeaker.Count(c.repo.DB(), "", nil, "ogif")
	if err != nil {
		logger.Error(err, "error when counting all time total speak")
	}

	return OgifStats{
		OgifList:               ogftList,
		UserAllTimeSpeaksCount: allTimeOgifStats.TotalSpeakCount,
		UserAllTimeRank:        allTimeOgifStats.SpeakRank,
		UserCurrentSpeaksCount: ogifStats.TotalSpeakCount,
		UserCurrentRank:        ogifStats.SpeakRank,
		TotalSpeakCount:        allTimeTotalCount,
		CurrentSpeakCount:      int64(len(ogftList)),
	}, nil
}

// GetOgifLeaderboard returns the OGIF leaderboard
func (c *controller) GetOgifLeaderboard(ctx context.Context, after time.Time, limit int) ([]model.OgifLeaderboardRecord, error) {
	logger := c.logger.AddField("after", after).AddField("limit", limit)

	leaderboard, err := c.store.EventSpeaker.GetLeaderboard(c.repo.DB(), &after, limit, "ogif")
	if err != nil {
		logger.Error(err, "error when retrieving OGIF leaderboard")
		return nil, err
	}

	return leaderboard, nil
}

```

# pkg/controller/employee/upload_avatar.go

```go
package employee

import (
	"fmt"
	"mime/multipart"
	"path/filepath"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type UploadAvatarInput struct {
	ID string
}

func (r *controller) UploadAvatar(uuidUserID model.UUID, file *multipart.FileHeader, params UploadAvatarInput) (string, error) {
	fileName := file.Filename
	fileExtension := model.ContentExtension(filepath.Ext(fileName))
	fileSize := file.Size
	fileType := "image"
	filePath := fmt.Sprintf("https://storage.googleapis.com/%s/employees/%s/images/%s", r.config.Google.GCSBucketName, params.ID, fileName)
	gcsPath := fmt.Sprintf("employees/%s/images/%s", params.ID, fileName)

	// 2.1 validate
	if !fileExtension.ImageValid() {
		return "", ErrInvalidFileExtension
	}
	if fileExtension == model.ContentExtensionJpg || fileExtension == model.ContentExtensionPng {
		if fileSize > model.MaxFileSizeImage {
			return "", ErrInvalidFileSize
		}
	}

	tx, done := r.repo.NewTransaction()

	// 2.2 check employee existed
	emp, err := r.store.Employee.One(tx.DB(), params.ID, false)
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return "", done(ErrEmployeeNotFound)
		}
		return "", done(err)
	}

	// 2.3 check file name exist
	_, err = r.store.Content.OneByPath(tx.DB(), filePath)
	if err != nil && err != gorm.ErrRecordNotFound {
		return "", done(err)
	}
	if err != nil && err == gorm.ErrRecordNotFound {
		// not found => create and upload content to GCS
		_, err = r.store.Content.Create(tx.DB(), model.Content{
			Type:      fileType,
			Extension: fileExtension.String(),
			Path:      filePath,
			TargetID:  emp.ID,
			UploadBy:  uuidUserID,
		})
		if err != nil {
			return "", done(err)
		}

		multipart, err := file.Open()
		if err != nil {
			return "", done(err)
		}

		err = r.service.GoogleStorage.UploadContentGCS(multipart, gcsPath)
		if err != nil {
			return "", done(err)
		}
	}

	// 3. update avatar field
	_, err = r.store.Employee.UpdateSelectedFieldsByID(tx.DB(), emp.ID.String(), model.Employee{
		Avatar: filePath,
	}, "avatar")
	if err != nil {
		return "", done(err)
	}

	return filePath, done(nil)
}

```

# pkg/controller/employee/update_skills.go

```go
package employee

import (
	"errors"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type UpdateSkillsInput struct {
	Positions       []model.UUID
	LeadingChapters []model.UUID
	Chapters        []model.UUID
	Seniority       model.UUID
	Stacks          []model.UUID
}

func (r *controller) UpdateSkills(l logger.Logger, employeeID string, body UpdateSkillsInput) (*model.Employee, error) {
	emp, err := r.store.Employee.One(r.repo.DB(), employeeID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrEmployeeNotFound
		}
		return nil, err
	}

	// Check chapter existence
	chapters, err := r.store.Chapter.All(r.repo.DB())
	if err != nil {
		return nil, err
	}

	chapterMap := model.ToChapterMap(chapters)
	for _, sID := range body.Chapters {
		_, ok := chapterMap[sID]
		if !ok {
			l.Errorf(ErrChapterNotFound, "chapter not found with id ", sID.String())
			return nil, ErrChapterNotFound
		}
	}

	// Check seniority existence
	exist, err := r.store.Seniority.IsExist(r.repo.DB(), body.Seniority.String())
	if err != nil {
		return nil, err
	}

	if !exist {
		return nil, ErrSeniorityNotFound
	}

	// Check stack existence
	_, stacks, err := r.store.Stack.All(r.repo.DB(), "", nil)
	if err != nil {
		return nil, err
	}

	stackMap := model.ToStackMap(stacks)
	for _, sID := range body.Stacks {
		_, ok := stackMap[sID]
		if !ok {
			l.Errorf(ErrStackNotFound, "stack not found with id ", sID.String())
			return nil, ErrStackNotFound
		}
	}

	// Check position existence
	positions, err := r.store.Position.All(r.repo.DB())
	if err != nil {
		return nil, err
	}

	positionMap := model.ToPositionMap(positions)
	for _, pID := range body.Positions {
		_, ok := positionMap[pID]

		if !ok {
			l.Errorf(ErrPositionNotFound, "position not found with id ", pID.String())
			return nil, ErrPositionNotFound
		}
	}

	// Begin transaction
	tx, done := r.repo.NewTransaction()

	// Delete all exist employee positions
	if err := r.store.EmployeePosition.DeleteByEmployeeID(tx.DB(), employeeID); err != nil {
		return nil, done(err)
	}

	// Create new employee position
	for _, positionID := range body.Positions {
		_, err := r.store.EmployeePosition.Create(tx.DB(), &model.EmployeePosition{
			EmployeeID: model.MustGetUUIDFromString(employeeID),
			PositionID: positionID,
		})
		if err != nil {
			return nil, done(err)
		}
	}

	// Delete all exist employee stack
	if err := r.store.EmployeeStack.DeleteByEmployeeID(tx.DB(), employeeID); err != nil {
		return nil, done(err)
	}

	// Create new employee stack
	for _, stackID := range body.Stacks {
		_, err := r.store.EmployeeStack.Create(tx.DB(), &model.EmployeeStack{
			EmployeeID: model.MustGetUUIDFromString(employeeID),
			StackID:    stackID,
		})
		if err != nil {
			return nil, done(err)
		}
	}

	// Delete all exist employee stack
	if err := r.store.EmployeeChapter.DeleteByEmployeeID(tx.DB(), employeeID); err != nil {
		return nil, done(err)
	}

	// Create new employee stack
	for _, chapterID := range body.Chapters {
		_, err := r.store.EmployeeChapter.Create(tx.DB(), &model.EmployeeChapter{
			EmployeeID: model.MustGetUUIDFromString(employeeID),
			ChapterID:  chapterID,
		})
		if err != nil {
			return nil, done(err)
		}
	}

	// Remove all chapter lead by employee
	leadingChapters, err := r.store.Chapter.GetAllByLeadID(tx.DB(), employeeID)
	if err != nil {
		return nil, done(err)
	}

	for _, lChapter := range leadingChapters {
		if err := r.store.Chapter.UpdateChapterLead(tx.DB(), lChapter.ID.String(), nil); err != nil {
			return nil, done(err)
		}
	}

	// Create new chapter
	leader := model.MustGetUUIDFromString(employeeID)
	for _, lChapter := range body.LeadingChapters {
		if err := r.store.Chapter.UpdateChapterLead(tx.DB(), lChapter.String(), &leader); err != nil {
			return nil, done(err)
		}
	}

	// Update employee information
	emp.SeniorityID = body.Seniority

	_, err = r.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, *emp, "chapter_id", "seniority_id")
	if err != nil {
		return nil, done(err)
	}

	return emp, done(nil)
}

```

# pkg/controller/employee/update_role.go

```go
package employee

import (
	"errors"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type UpdateRoleBody struct {
	Roles []model.UUID
}

type UpdateRoleInput struct {
	EmployeeID string
	Body       UpdateRoleBody
}

func (r *controller) UpdateRole(userID string, input UpdateRoleInput) (err error) {
	loggedInUser, err := r.store.Employee.One(r.repo.DB(), userID, false)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		return ErrEmployeeNotFound
	}

	if err != nil {
		return err
	}

	empl, err := r.store.Employee.One(r.repo.DB(), input.EmployeeID, false)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		return ErrEmployeeNotFound
	}

	if err != nil {
		return err
	}

	// Check role exists
	roles, err := r.store.Role.GetByIDs(r.repo.DB(), input.Body.Roles)
	if err != nil {
		return err
	}

	for _, role := range roles {
		if role.Level <= loggedInUser.EmployeeRoles[0].Role.Level &&
			loggedInUser.EmployeeRoles[0].Role.Code != model.AccountRoleAdmin.String() {
			return ErrInvalidAccountRole
		}
	}

	if empl.EmployeeRoles[0].Role.Level == loggedInUser.EmployeeRoles[0].Role.Level &&
		loggedInUser.EmployeeRoles[0].Role.Code != model.AccountRoleAdmin.String() {
		return ErrInvalidAccountRole
	}

	// Begin transaction
	tx, done := r.repo.NewTransaction()

	if err := r.store.EmployeeRole.HardDeleteByEmployeeID(tx.DB(), input.EmployeeID); err != nil {
		return done(err)
	}

	for _, role := range roles {
		_, err = r.store.EmployeeRole.Create(tx.DB(), &model.EmployeeRole{
			EmployeeID: model.MustGetUUIDFromString(input.EmployeeID),
			RoleID:     role.ID,
		})
		if err != nil {
			r.logger.Fields(logger.Fields{
				"emlID":  input.EmployeeID,
				"roleID": role.ID,
			}).Error(err, "failed to create employee role")
			return done(err)
		}
	}

	return done(nil)
}

```

# pkg/controller/employee/update_personal_info.go

```go
package employee

import (
	"errors"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

type UpdatePersonalInfoInput struct {
	DoB              *time.Time
	Gender           string
	PlaceOfResidence string
	Address          string
	PersonalEmail    string
	Country          string
	City             string
	Lat              string
	Long             string
}

func (r *controller) UpdatePersonalInfo(employeeID string, body UpdatePersonalInfoInput) (*model.Employee, error) {
	emp, err := r.store.Employee.One(r.repo.DB(), employeeID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrEmployeeNotFound
		}
		return nil, err
	}

	// validate personal email
	_, err = r.store.Employee.OneByEmail(r.repo.DB(), body.PersonalEmail)
	if emp.PersonalEmail != body.PersonalEmail && body.PersonalEmail != "" && !errors.Is(err, gorm.ErrRecordNotFound) {
		if err == nil {
			return nil, err
		}
		return nil, err
	}

	emp.DateOfBirth = body.DoB
	emp.Gender = body.Gender
	emp.Address = body.Address
	emp.PlaceOfResidence = body.PlaceOfResidence
	emp.PersonalEmail = body.PersonalEmail
	emp.Country = body.Country
	emp.City = body.City
	emp.Lat = body.Lat
	emp.Long = body.Long

	updatedField := []string{
		"date_of_birth",
		"gender",
		"address",
		"place_of_residence",
		"personal_email",
		"country",
		"city",
		"lat",
		"long",
	}

	emp,
		err = r.store.Employee.UpdateSelectedFieldsByID(r.repo.DB(), employeeID, *emp, updatedField...)
	if err != nil {
		return nil, err
	}

	return emp, nil
}

```

# pkg/controller/employee/update_general_info.go

```go
package employee

import (
	"errors"
	"strings"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type UpdateEmployeeGeneralInfoInput struct {
	FullName           string
	Email              string
	Phone              string
	LineManagerID      model.UUID
	DisplayName        string
	GithubID           string
	NotionID           string
	NotionName         string
	NotionEmail        string
	DiscordName        string
	LinkedInName       string
	LeftDate           string
	JoinedDate         string
	OrganizationIDs    []model.UUID
	ReferredBy         model.UUID
	WiseRecipientID    string
	WiseRecipientEmail string
	WiseRecipientName  string
	WiseAccountNumber  string
	WiseCurrency       string
} // @name UpdateEmployeeGeneralInfoInput

func (r *controller) UpdateGeneralInfo(employeeID string, body UpdateEmployeeGeneralInfoInput) (*model.Employee, error) {
	l := r.logger.Fields(logger.Fields{
		"controller": "employee",
		"method":     "UpdateGeneralInfo",
	})

	tx, done := r.repo.NewTransaction()

	// check line manager existence
	if !body.LineManagerID.IsZero() {
		exist, err := r.store.Employee.IsExist(tx.DB(), body.LineManagerID.String())
		if err != nil {
			l.Errorf(err, "failed to check line manager existence")
			return nil, done(err)
		}

		if !exist {
			return nil, done(ErrLineManagerNotFound)
		}
	}

	// check referrer existence
	if !body.ReferredBy.IsZero() {
		exist, err := r.store.Employee.IsExist(tx.DB(), body.ReferredBy.String())
		if err != nil {
			l.Errorf(err, "failed to check referer existence")
			return nil, done(err)
		}

		if !exist {
			return nil, done(ErrReferrerNotFound)
		}

		if employeeID == body.ReferredBy.String() {
			return nil, done(ErrCannotSelfReferral)
		}
	}

	emp, err := r.store.Employee.One(tx.DB(), employeeID, true)
	if err != nil {
		l.Errorf(err, "failed to get employee")
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, done(ErrEmployeeNotFound)
		}
		return nil, done(err)
	}

	if emp.TeamEmail != "" && emp.TeamEmail != body.Email {
		_, err = r.store.Employee.OneByEmail(r.repo.DB(), body.Email)
		if !errors.Is(err, gorm.ErrRecordNotFound) {
			if err == nil {
				return nil, ErrEmailExisted
			}
			return nil, err
		}
	}

	// 3. update information and return nil, done(err)

	if strings.TrimSpace(body.FullName) != "" {
		emp.FullName = body.FullName
	}

	if strings.TrimSpace(body.Email) != "" {
		emp.TeamEmail = body.Email
	}

	if strings.TrimSpace(body.Phone) != "" {
		emp.PhoneNumber = body.Phone
	}

	if strings.TrimSpace(body.DisplayName) != "" {
		emp.DisplayName = body.DisplayName
	}

	if strings.TrimSpace(body.JoinedDate) != "" {
		joinedDate, err := time.Parse("2006-01-02", body.JoinedDate)
		if err != nil {
			return nil, done(ErrInvalidJoinedDate)
		}
		emp.JoinedDate = &joinedDate
	}

	if strings.TrimSpace(body.LeftDate) != "" {
		leftDate, err := time.Parse("2006-01-02", body.LeftDate)
		if err != nil {
			return nil, done(ErrInvalidLeftDate)
		}
		emp.LeftDate = &leftDate
	}

	if emp.JoinedDate != nil && emp.LeftDate != nil {
		if emp.LeftDate.Before(*emp.JoinedDate) {
			return nil, done(ErrLeftDateBeforeJoinedDate)
		}
	}

	emp.LineManagerID = body.LineManagerID
	emp.ReferredBy = body.ReferredBy
	if strings.TrimSpace(body.WiseRecipientID) != "" {
		emp.WiseRecipientID = body.WiseRecipientID
	}

	if strings.TrimSpace(body.WiseAccountNumber) != "" {
		emp.WiseAccountNumber = body.WiseAccountNumber
	}

	if strings.TrimSpace(body.WiseRecipientEmail) != "" {
		emp.WiseRecipientEmail = body.WiseRecipientEmail
	}

	if strings.TrimSpace(body.WiseRecipientName) != "" {
		emp.WiseRecipientName = body.WiseRecipientName
	}

	if strings.TrimSpace(body.WiseCurrency) != "" {
		emp.WiseCurrency = body.WiseCurrency
	}

	discordID := ""
	if strings.TrimSpace(body.DiscordName) != "" {
		// Get discord info
		discordMember, err := r.service.Discord.GetMemberByUsername(body.DiscordName)
		if err != nil {
			l.Errorf(err, "failed to discord member member by discord name", "discordName", body.DiscordName)
			return nil, done(err)
		}

		if discordMember == nil {
			return nil, done(ErrCouldNotFoundDiscordMemberInGuild)
		}

		discordID = discordMember.User.ID
	}

	accountInUsed := false
	tmpE, err := r.store.Employee.GetByDiscordID(tx.DB(), discordID, false)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		l.Errorf(err, "failed to get employee by discord id", "discordID", discordID)
		return nil, done(err)
	}

	if !errors.Is(err, gorm.ErrRecordNotFound) {
		if tmpE.ID != emp.ID {
			accountInUsed = true
		}
	}

	if accountInUsed {
		return nil, done(ErrDiscordAccountAlreadyUsedByAnotherEmployee)
	}

	discordAccountInput := &model.DiscordAccount{
		DiscordID:       discordID,
		DiscordUsername: body.DiscordName,
	}

	discordAccount, err := r.store.DiscordAccount.Upsert(tx.DB(), discordAccountInput)
	if err != nil {
		l.Errorf(err, "failed to upsert discord account", "discordAccount", discordAccountInput)
		return nil, done(err)
	}

	emp.DiscordAccountID = discordAccount.ID

	// Update social accounts
	saInput := model.SocialAccountInput{
		GithubID:     body.GithubID,
		NotionID:     body.NotionID,
		NotionName:   body.NotionName,
		NotionEmail:  body.NotionEmail,
		LinkedInName: body.LinkedInName,
	}

	if err := r.updateSocialAccounts(tx.DB(), saInput, emp.ID); err != nil {
		l.Errorf(err, "failed to update social account", "socialAccount", saInput)
		return nil, done(err)
	}

	_, err = r.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, *emp,
		"full_name",
		"team_email",
		"phone_number",
		"line_manager_id",
		"display_name",
		"joined_date",
		"left_date",
		"referred_by",
		"wise_recipient_id",
		"wise_account_number",
		"wise_recipient_email",
		"wise_recipient_name",
		"wise_currency",
		"discord_account_id",
	)
	if err != nil {
		return nil, done(err)
	}

	if len(body.OrganizationIDs) > 0 {
		// Check organizations existence
		organizations, err := r.store.Organization.All(tx.DB())
		if err != nil {
			return nil, done(err)
		}

		orgMaps := model.ToOrganizationMap(organizations)
		for _, sID := range body.OrganizationIDs {
			_, ok := orgMaps[sID]
			if !ok {
				l.Errorf(ErrOrganizationNotFound, "organization not found with id: ", sID.String())
				return nil, done(ErrOrganizationNotFound)
			}
		}

		// Delete all exist employee organizations
		if err := r.store.EmployeeOrganization.DeleteByEmployeeID(tx.DB(), employeeID); err != nil {
			return nil, done(err)
		}

		// Create new employee position
		for _, orgID := range body.OrganizationIDs {
			_, err := r.store.EmployeeOrganization.Create(tx.DB(), &model.EmployeeOrganization{
				EmployeeID:     model.MustGetUUIDFromString(employeeID),
				OrganizationID: orgID,
			})
			if err != nil {
				return nil, done(err)
			}
		}
	}

	emp, err = r.store.Employee.One(tx.DB(), employeeID, true)
	if err != nil {
		return nil, done(err)
	}

	return emp, done(nil)
}

func (r *controller) updateSocialAccounts(db *gorm.DB, input model.SocialAccountInput, employeeID model.UUID) error {
	l := r.logger.Fields(logger.Fields{
		"handler":    "employee",
		"method":     "updateSocialAccounts",
		"input":      input,
		"employeeID": employeeID,
	})

	accounts, err := r.store.SocialAccount.GetByEmployeeID(db, employeeID.String())
	if err != nil {
		l.Error(err, "failed to get social accounts by employeeID")
		return err
	}

	accountsInput := map[model.SocialAccountType]model.SocialAccount{
		model.SocialAccountTypeGitHub: {
			Type:       model.SocialAccountTypeGitHub,
			EmployeeID: employeeID,
			AccountID:  input.GithubID,
			Name:       input.GithubID,
		},
		model.SocialAccountTypeNotion: {
			Type:       model.SocialAccountTypeNotion,
			EmployeeID: employeeID,
			AccountID:  input.NotionID,
			Name:       input.NotionName,
			Email:      input.NotionEmail,
		},
		model.SocialAccountTypeLinkedIn: {
			Type:       model.SocialAccountTypeLinkedIn,
			EmployeeID: employeeID,
			AccountID:  input.LinkedInName,
			Name:       input.LinkedInName,
		},
	}

	for _, account := range accounts {
		delete(accountsInput, account.Type)

		switch account.Type {
		case model.SocialAccountTypeGitHub:
			account.AccountID = input.GithubID
			account.Name = input.GithubID
		case model.SocialAccountTypeNotion:
			account.Name = input.NotionName
			account.Email = input.NotionEmail
		case model.SocialAccountTypeLinkedIn:
			account.AccountID = input.LinkedInName
			account.Name = input.LinkedInName
		default:
			continue
		}

		if _, err := r.store.SocialAccount.UpdateSelectedFieldsByID(db, account.ID.String(), *account, "account_id", "name", "email"); err != nil {
			l.Errorf(err, "failed to update social account %s", account.ID)
			return err
		}
	}

	for _, account := range accountsInput {
		if _, err := r.store.SocialAccount.Create(db, &account); err != nil {
			l.AddField("account", account).Error(err, "failed to create social account")
			return err
		}
	}

	return nil
}

```

# pkg/controller/employee/update_employee_status.go

```go
package employee

import (
	"context"
	"errors"
	"time"

	"gorm.io/gorm"
	"gorm.io/gorm/utils"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type UpdateWorkingStatusInput struct {
	EmployeeStatus model.WorkingStatus
}

func (r *controller) UpdateEmployeeStatus(employeeID string, body UpdateWorkingStatusInput) (*model.Employee, error) {
	l := r.logger.Fields(logger.Fields{
		"controller": "employee",
		"method":     "UpdateEmployeeStatus",
	})

	now := time.Now()
	e, err := r.store.Employee.One(r.repo.DB(), employeeID, true)
	if err != nil {
		l.Errorf(err, "failed to get Employee ", employeeID)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrEmployeeNotFound
		}
		return nil, err
	}

	e.WorkingStatus = body.EmployeeStatus
	e.LeftDate = &now

	if body.EmployeeStatus != model.WorkingStatusLeft {
		e.LeftDate = nil
	}

	tx, done := r.repo.NewTransaction()
	defer func() {
		_ = done(nil)
	}()

	_, err = r.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, *e, "working_status", "left_date")
	if err != nil {
		return nil, done(err)
	}

	//If employee working status is left, do off-boarding flow
	if body.EmployeeStatus == model.WorkingStatusLeft {
		err = r.store.ProjectMember.UpdateMemberToInActiveByID(tx.DB(), employeeID, &now)
		if err != nil {
			return nil, done(err)
		}

		// Do Off-boarding process
		r.processOffBoardingEmployee(l, e)
	}

	return e, err
}

func (r *controller) processOffBoardingEmployee(l logger.Logger, e *model.Employee) {
	if e.DiscordAccount != nil {
		err := r.removeDiscordRoles(e.DiscordAccount.DiscordID)
		if err != nil {
			l.Errorf(err, "failed to update discord roles", "employeeID", e.ID.String(), "discordID", e.DiscordAccount.DiscordID)
		}
	}

	err := r.removeBasecampAccess(e.BasecampID)
	if err != nil {
		l.Errorf(err, "failed to remove basecamp access", "employeeID", e.ID.String(), "basecampID", e.BasecampID)
	}

	err = r.removeTeamEmailForward(e.TeamEmail)
	if err != nil {
		l.Errorf(err, "failed to remove team email forward", "employeeID", e.ID.String(), "email", e.TeamEmail)
	}

	err = r.removeTeamEmail(e.TeamEmail)
	if err != nil {
		l.Errorf(err, "failed to delete google account", "employeeID", e.ID.String(), "email", e.TeamEmail)
	}

	err = r.removeGithubFromOrganization(e)
	if err != nil {
		l.Errorf(err, "failed to remove github user from organization", "employeeID", e.ID.String())
	}
}

func (r *controller) removeDiscordRoles(discordUserID string) error {
	if discordUserID == "" {
		return nil
	}

	roles, err := r.service.Discord.GetRoles()
	if err != nil {
		return err
	}

	dfRoles := roles.DwarvesRoles()

	discordMember, err := r.service.Discord.GetMember(discordUserID)
	if err != nil {
		return err
	}

	for _, role := range dfRoles {
		if utils.Contains(discordMember.Roles, role.ID) {
			err = r.service.Discord.RemoveRole(discordUserID, role.ID)
			if err != nil {
				return err
			}
		}
	}

	// Assign alumni role
	alumniRole := roles.ByCode("alumni")
	err = r.service.Discord.AddRole(discordUserID, alumniRole.ID)
	if err != nil {
		return err
	}

	return nil
}

func (r *controller) removeBasecampAccess(baseCampID int) error {
	if r.config.Env != "prod" {
		return nil
	}

	err := r.service.Basecamp.People.Remove(int64(baseCampID))
	if err != nil {
		return err
	}

	return nil
}

func (r *controller) removeTeamEmailForward(teamEmail string) error {
	if r.config.Env != "prod" {
		return nil
	}

	err := r.service.ImprovMX.DeleteAccount(teamEmail)
	if err != nil {
		return err
	}

	return nil
}

func (r *controller) removeTeamEmail(teamEmail string) error {
	if r.config.Env != "prod" {
		return nil
	}

	err := r.service.GoogleAdmin.DeleteAccount(teamEmail)
	if err != nil {
		return err
	}

	return nil
}

func (r *controller) removeGithubFromOrganization(e *model.Employee) error {
	if r.config.Env != "prod" {
		return nil
	}

	githubSA := model.SocialAccounts(e.SocialAccounts).GetGithub()
	if githubSA != nil {
		if githubSA.AccountID == "" {
			return nil
		}

		err := r.service.Github.RemoveFromOrganizationByUsername(context.Background(), githubSA.AccountID)
		if err != nil {
			return err
		}
	}

	return nil
}

```

# pkg/controller/employee/update_base_salary.go

```go
package employee

import (
	"errors"
	"time"

	"gorm.io/gorm"
	
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type UpdateBaseSalaryInput struct {
	ContractAmount        int64
	CompanyAccountAmount  int64
	PersonalAccountAmount int64
	InsuranceAmount       int64
	CurrencyCode          string
	Batch                 int
	EffectiveDate         *time.Time
}

func (r *controller) UpdateBaseSalary(l logger.Logger, employeeID string, body UpdateBaseSalaryInput) (*model.BaseSalary, error) {
	currency, err := r.store.Currency.GetByName(r.repo.DB(), body.CurrencyCode)
	if err != nil {
		return nil, err
	}

	exists, err := r.store.Employee.IsExist(r.repo.DB(), employeeID)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, ErrEmployeeNotFound
	}

	bs, err := r.store.BaseSalary.OneByEmployeeID(r.repo.DB(), employeeID)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		return nil, err
	}

	euuid, err := model.UUIDFromString(employeeID)
	if err != nil {
		return nil, err
	}

	newBS := &model.BaseSalary{
		BaseModel: model.BaseModel{
			ID: bs.ID,
		},
		EmployeeID:            euuid,
		ContractAmount:        body.ContractAmount,
		CompanyAccountAmount:  body.CompanyAccountAmount,
		PersonalAccountAmount: body.PersonalAccountAmount,
		InsuranceAmount:       model.NewVietnamDong(body.InsuranceAmount),
		CurrencyID:            currency.ID,
		Batch:                 body.Batch,
		EffectiveDate:         body.EffectiveDate,
	}

	err = r.store.BaseSalary.Save(r.repo.DB(), newBS)
	if err != nil {
		return nil, err
	}

	return newBS, nil
}

```

# pkg/controller/employee/salary_advance.go

```go
package employee

import (
	"errors"
	"fmt"
	"math"
	"strconv"
	"time"

	"github.com/Rhymond/go-money"
	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils"
)

type SalaryAdvanceResponse struct {
	EmployeeID      string
	AmountICY       string
	AmountUSD       string
	TransactionID   string
	TransactionHash string
}

func (r *controller) SalaryAdvance(discordID string, amount int64) (*SalaryAdvanceResponse, error) {
	icyUsdRateConfig, err := r.store.Config.OneByKey(r.repo.DB(), model.ConfigKeyIcyUSDRate)
	if err != nil {
		return nil, err
	}
	icyUsdRate, err := strconv.ParseFloat(icyUsdRateConfig.Value, 64)
	if err != nil {
		return nil, err
	}

	// Get employee by discord id
	employee, err := r.store.Employee.GetByDiscordID(r.repo.DB(), discordID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrEmployeeNotFound
		}
		return nil, err
	}

	err = r.checkFullTimeRole(employee)
	if err != nil {
		return nil, err
	}

	salaryAdvances, err := r.store.SalaryAdvance.ListNotPayBackByEmployeeID(r.repo.DB(), employee.ID.String())
	if err != nil {
		return nil, err
	}

	// calculate number of not paid back advance salary
	var notPaidBackAmount int64
	for _, salaryAdvance := range salaryAdvances {
		if !salaryAdvance.IsPaidBack {
			notPaidBackAmount = notPaidBackAmount + salaryAdvance.AmountIcy
		}
	}

	// Get employee's salary
	salary, err := r.store.BaseSalary.OneByEmployeeID(r.repo.DB(), employee.ID.String())
	if err != nil {
		return nil, err
	}

	// Calculate advance amount
	maxAdvanceAmountIcy, err := r.calculateMaxAdvanceAmountIcy(salary, icyUsdRate)
	if err != nil {
		return nil, err
	}

	// Check if amount exceed amount can be advanced
	if amount > maxAdvanceAmountIcy-notPaidBackAmount {
		return nil, errors.Join(ErrSalaryAdvanceExceedAmount, errors.New("amount can be advanced is "+utils.FormatNumber(maxAdvanceAmountIcy-notPaidBackAmount)))
	}

	// Create advance salary record
	amountUSD := float64(amount) * icyUsdRate
	baseAmount, rate, err := r.service.Wise.Convert(amountUSD, "USD", salary.Currency.Name)
	if err != nil {
		return nil, err
	}

	tx, done := r.repo.NewTransaction()
	salaryAdvance := &model.SalaryAdvance{
		EmployeeID:     employee.ID,
		AmountIcy:      amount,
		AmountUSD:      amountUSD,
		BaseAmount:     baseAmount,
		ConversionRate: rate,
		CurrencyID:     salary.CurrencyID,
	}
	if err := r.store.SalaryAdvance.Save(tx.DB(), salaryAdvance); err != nil {
		return nil, done(err)
	}

	// Make advance salary request
	currentMonth := time.Now().Month()
	description := fmt.Sprintf("%s Addvance Salary in %s", discordID, currentMonth.String())
	references := "Advance Salary"
	txs, err := r.service.Mochi.SendFromAccountToUser(float64(amount), discordID, description, references)
	if err != nil {
		return nil, done(err)
	}

	if len(txs) == 0 {
		return nil, done(ErrNoTransactionFound)
	}

	response := &SalaryAdvanceResponse{
		EmployeeID:      employee.ID.String(),
		AmountICY:       utils.FormatNumber(amount),
		AmountUSD:       utils.FormatMoney(amountUSD, money.USD),
		TransactionID:   strconv.Itoa(int(txs[0].TransactionID)),
		TransactionHash: txs[0].RecipientID,
	}

	return response, done(nil)
}

func (r *controller) CheckSalaryAdvance(discordID string) (amountIcy string, amountUSD string, error error) {
	icyUsdRateConfig, err := r.store.Config.OneByKey(r.repo.DB(), model.ConfigKeyIcyUSDRate)
	if err != nil {
		return "", "", err
	}
	icyUsdRate, err := strconv.ParseFloat(icyUsdRateConfig.Value, 64)
	if err != nil {
		return "", "", err
	}

	// Get employee by discord id
	employee, err := r.store.Employee.GetByDiscordID(r.repo.DB(), discordID, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return "", "", ErrEmployeeNotFound
		}
		return "", "", err
	}

	err = r.checkFullTimeRole(employee)
	if err != nil {
		return "", "", err
	}

	salaryAdvances, err := r.store.SalaryAdvance.ListNotPayBackByEmployeeID(r.repo.DB(), employee.ID.String())
	if err != nil {
		return "", "", err
	}

	// calculate number of not paid back advance salary
	var notPaidBackAmount int64
	for _, salaryAdvance := range salaryAdvances {
		if !salaryAdvance.IsPaidBack {
			notPaidBackAmount = notPaidBackAmount + salaryAdvance.AmountIcy
		}
	}

	// Get employee's salary
	salary, err := r.store.BaseSalary.OneByEmployeeID(r.repo.DB(), employee.ID.String())
	if err != nil {
		return "", "", err
	}

	// Calculate advance amount
	advanceAmountIcy, err := r.calculateMaxAdvanceAmountIcy(salary, icyUsdRate)
	if err != nil {
		return "", "", err
	}

	advanceAmountUSD := float64(advanceAmountIcy-notPaidBackAmount) * icyUsdRate

	return utils.FormatNumber(advanceAmountIcy - notPaidBackAmount),
		utils.FormatMoney(advanceAmountUSD, money.USD),
		nil
}

func (r *controller) checkFullTimeRole(employee *model.Employee) error {
	fullTimeRole, err := r.store.Role.GetByCode(r.repo.DB(), model.RoleFullTimeCode)
	if err != nil {
		return err
	}

	var highestEmployeeLevel int64 = 10000
	for _, role := range employee.Roles {
		if role.Level < highestEmployeeLevel {
			highestEmployeeLevel = role.Level
		}
	}

	// check if employee is full time or higher
	if highestEmployeeLevel > fullTimeRole.Level {
		return ErrEmployeeNotFullTime
	}
	return nil
}

func (r *controller) calculateMaxAdvanceAmountIcy(salary *model.BaseSalary, icyUsdRate float64) (int64, error) {
	// Get advance salary max cap
	salaryAdvanceMaxCap, err := r.store.Config.OneByKey(r.repo.DB(), model.ConfigKeySalaryAdvanceMaxCap)
	if err != nil {
		return 0, err
	}

	// Check if advance salary max cap is number and in range of 0 - 100
	maxCap, err := strconv.Atoi(salaryAdvanceMaxCap.Value)
	if err != nil || maxCap < 0 || maxCap > 100 {
		return 0, ErrSalaryAdvanceMaxCapInvalid
	}

	var advanceAmountUSD float64
	advanceableAmount := float64(salary.ContractAmount+salary.PersonalAccountAmount) * (float64(maxCap) / 100)
	if salary.Currency.Name == "USD" {
		advanceAmountUSD = advanceableAmount
	} else {
		convertedValue, _, err := r.service.Wise.Convert(advanceableAmount, salary.Currency.Name, "USD")
		if err != nil {
			return 0, err
		}
		advanceAmountUSD = convertedValue
	}

	advanceAmountIcy := advanceAmountUSD / icyUsdRate

	return int64(math.Round(advanceAmountIcy/10) * 10), nil
}

type ListAggregatedSalaryAdvanceInput struct {
	model.Pagination
	model.SortOrder

	IsPaid *bool
}

func (r *controller) ListAggregatedSalaryAdvance(input ListAggregatedSalaryAdvanceInput) (*model.SalaryAdvanceReport, error) {
	list, err := r.store.SalaryAdvance.ListAggregatedSalaryAdvance(r.repo.DB(), input.IsPaid, input.Pagination, input.SortOrder)
	if err != nil {
		return nil, err
	}

	for i, row := range list {
		employee, err := r.store.Employee.One(r.repo.DB(), row.EmployeeID, false)
		if err != nil {
			return nil, err
		}

		list[i].Employee = employee
	}

	count, totalICY, totalUSD, err := r.store.SalaryAdvance.TotalAggregatedSalaryAdvance(r.repo.DB(), input.IsPaid)
	if err != nil {
		return nil, err
	}

	report := &model.SalaryAdvanceReport{
		SalaryAdvances: list,
		TotalICY:       totalICY,
		TotalUSD:       totalUSD,
		Count:          count,
	}

	return report, nil
}

```

# pkg/controller/employee/new.go

```go
package employee

import (
	"mime/multipart"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

type IController interface {
	List(workingStatuses []string, body GetListEmployeeInput, userInfo *model.CurrentLoggedUserInfo) (employees []*model.Employee, tptal int64, err error)
	Details(id string, userInfo *model.CurrentLoggedUserInfo) (employee *model.Employee, err error)
	UpdateEmployeeStatus(employeeID string, body UpdateWorkingStatusInput) (employee *model.Employee, err error)
	UpdateGeneralInfo(employeeID string, body UpdateEmployeeGeneralInfoInput) (employee *model.Employee, err error)
	Create(userID string, body CreateEmployeeInput) (employee *model.Employee, err error)
	UpdateSkills(l logger.Logger, employeeID string, body UpdateSkillsInput) (employee *model.Employee, err error)
	UpdatePersonalInfo(employeeID string, body UpdatePersonalInfoInput) (employee *model.Employee, err error)
	UploadAvatar(uuidUserID model.UUID, file *multipart.FileHeader, params UploadAvatarInput) (filePath string, err error)
	UpdateRole(userID string, input UpdateRoleInput) (err error)
	GetLineManagers(userInfo *model.CurrentLoggedUserInfo) (employees []*model.Employee, err error)
	UpdateBaseSalary(l logger.Logger, employeeID string, body UpdateBaseSalaryInput) (employee *model.BaseSalary, err error)
	ListWithLocation() (employees []*model.Employee, err error)
	ListByDiscordRequest(discordID, email, key string, userInfo *model.CurrentLoggedUserInfo) ([]model.Employee, error)
	SalaryAdvance(discordID string, amount int64) (*SalaryAdvanceResponse, error)
	CheckSalaryAdvance(discordID string) (string, string, error)
	ListWithMMAScore() (employees []model.EmployeeMMAScoreData, err error)
	ListAggregatedSalaryAdvance(input ListAggregatedSalaryAdvanceInput) (*model.SalaryAdvanceReport, error)
	GetEmployeeEarnTransactions(discordID string, input GetEmployeeEarnTransactionsInput) (model.EmployeeEarnTransactions, int64, error)
	GetEmployeeTotalEarn(discordID string) (string, string, error)
	GetTotalEarn(from, to time.Time) (string, string, error)
	CheckIn(discordID string, t time.Time, amount float64) (*CheckinResponse, error)
}

```

# pkg/controller/employee/list.go

```go
package employee

import (
	"errors"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/store/employee"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
	"gorm.io/gorm"
)

type GetListEmployeeInput struct {
	model.Pagination

	WorkingStatuses []string
	Preload         bool
	Positions       []string
	Stacks          []string
	Projects        []string
	Chapters        []string
	Seniorities     []string
	Organizations   []string
	LineManagers    []string
	Keyword         string
}

func (r *controller) List(workingStatuses []string, body GetListEmployeeInput, userInfo *model.CurrentLoggedUserInfo) ([]*model.Employee, int64, error) {
	filter := employee.EmployeeFilter{
		Preload:        body.Preload,
		Keyword:        body.Keyword,
		Positions:      body.Positions,
		Stacks:         body.Stacks,
		Chapters:       body.Chapters,
		Seniorities:    body.Seniorities,
		Organizations:  body.Organizations,
		LineManagers:   body.LineManagers,
		JoinedDateSort: model.SortOrderDESC,
		Projects:       body.Projects,
	}

	// If user don't have this permission, they can only see employees in the project that they are in
	if !authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadReadActive) {
		projectIDs := make([]string, 0)
		for _, p := range userInfo.Projects {
			projectIDs = append(projectIDs, p.Code)
		}

		filter.Projects = []string{""}
		if len(projectIDs) > 0 {
			filter.Projects = projectIDs
		}
	}

	filter.WorkingStatuses = workingStatuses

	employees, total, err := r.store.Employee.All(r.repo.DB(), filter, body.Pagination)
	if err != nil {
		return nil, 0, err
	}

	return employees, total, nil
}

func (r *controller) ListWithLocation() ([]*model.Employee, error) {
	employees, err := r.store.Employee.SimpleList(r.repo.DB())
	if err != nil {
		return nil, err
	}

	return employees, nil
}

func (r *controller) ListWithMMAScore() (employees []model.EmployeeMMAScoreData, err error) {
	rs, err := r.store.Employee.ListWithMMAScore(r.repo.DB())
	if err != nil {
		return nil, err
	}

	return rs, nil
}

func (r *controller) ListByDiscordRequest(discordID, email, key string, userInfo *model.CurrentLoggedUserInfo) ([]model.Employee, error) {
	in := employee.DiscordRequestFilter{
		Email: email,
	}

	discordIDs := make([]string, 0)
	if discordID != "" {
		discordIDs = append(discordIDs, discordID)
	}

	if key != "" {
		dt, err := r.service.Discord.SearchMember(key)
		if err != nil {
			return nil, err
		}
		if len(dt) <= 0 {
			in.Keyword = key
		} else {
			for _, d := range dt {
				discordIDs = append(discordIDs, d.User.ID)
			}
		}
	}

	in.DiscordID = discordIDs

	if len(in.DiscordID) > 0 || in.Email != "" || in.Keyword != "" {
		rs, err := r.store.Employee.ListByDiscordRequest(r.repo.DB(), in, true)
		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return nil, ErrEmployeeNotFound
			}
			return nil, err
		}
		return rs, nil
	}

	return nil, ErrEmployeeNotFound
}

```

# pkg/controller/employee/get_line_managers.go

```go
package employee

import (
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
)

func (r *controller) GetLineManagers(userInfo *model.CurrentLoggedUserInfo) (employees []*model.Employee, err error) {
	var managers []*model.Employee

	if authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadLineManagerFullAccess) {
		managers, err = r.store.Employee.GetLineManagers(r.repo.DB())
		if err != nil {
			return nil, err
		}
	} else {
		managers, err = r.store.Employee.GetLineManagersOfPeers(r.repo.DB(), userInfo.UserID)
		if err != nil {
			return nil, err
		}
	}

	return managers, nil
}

```

# pkg/controller/employee/errors.go

```go
package employee

import (
	"errors"
)

var (
	ErrCannotSelfReferral                         = errors.New("cannot self referral")
	ErrCantFindLineManager                        = errors.New("can't find line manager with the input id")
	ErrChapterNotFound                            = errors.New("chapter not found")
	ErrCouldNotAssignRoleForSameLevelEmployee     = errors.New("could not assign role for the same level employee")
	ErrCouldNotMentorTheirMentor                  = errors.New("employee could not be mentor of their mentor")
	ErrCouldNotMentorThemselves                   = errors.New("employee could not be their own mentor")
	ErrCurrencyNotFound                           = errors.New("currency not found")
	ErrEmailExisted                               = errors.New("email already exists")
	ErrTeamEmailExisted                           = errors.New("team email already exists")
	ErrPersonalEmailExisted                       = errors.New("personal email already exists")
	ErrEmployeeExisted                            = errors.New("can't create existed employee")
	ErrEmployeeLeft                               = errors.New("employee is left")
	ErrEmployeeMenteeNotFound                     = errors.New("employee mentee not found")
	ErrEmployeeNotFound                           = errors.New("employee not found")
	ErrSalaryAdvanceNotPayBack                    = errors.New("employee not pay back salary advance")
	ErrSalaryAdvanceExceedAmount                  = errors.New("your request is exceed amount you can advance")
	ErrSalaryAdvanceMaxCapInvalid                 = errors.New("max cap salary invalid")
	ErrFileAlreadyExisted                         = errors.New("file already existed")
	ErrInvalidAccountRole                         = errors.New("invalid account role")
	ErrInvalidChapterCode                         = errors.New("invalid chapter code")
	ErrInvalidCountryOrCity                       = errors.New("invalid country or city")
	ErrInvalidEmailDomain                         = errors.New("invalid email domain")
	ErrInvalidEmployeeID                          = errors.New("invalid employee ID")
	ErrInvalidEmployeeStatus                      = errors.New("invalid value for employee status")
	ErrInvalidFileExtension                       = errors.New("invalid file extension")
	ErrInvalidFileSize                            = errors.New("invalid file size")
	ErrInvalidJoinedDate                          = errors.New("invalid joined date")
	ErrInvalidLeftDate                            = errors.New("invalid left date")
	ErrInvalidMenteeID                            = errors.New("invalid mentee ID")
	ErrInvalidMentorID                            = errors.New("invalid mentor ID")
	ErrInvalidOrganizationCode                    = errors.New("invalid organization code")
	ErrInvalidPositionCode                        = errors.New("invalid position code")
	ErrInvalidPositionID                          = errors.New("invalid position ID")
	ErrInvalidProjectCode                         = errors.New("invalid project code")
	ErrInvalidProjectID                           = errors.New("invalid project ID")
	ErrInvalidSeniorityCode                       = errors.New("invalid seniority code")
	ErrInvalidStackCode                           = errors.New("invalid stack code")
	ErrInvalidStackID                             = errors.New("invalid stack ID")
	ErrLeftDateBeforeJoinedDate                   = errors.New("left date could not be before joined date")
	ErrLineManagerNotFound                        = errors.New("line manager not found")
	ErrMenteeLeft                                 = errors.New("mentee is left")
	ErrMenteeNotFound                             = errors.New("mentee not found")
	ErrOrganizationNotFound                       = errors.New("organization not found")
	ErrPositionNotFound                           = errors.New("position not found")
	ErrPositionNotfound                           = errors.New("position not found")
	ErrReferrerNotFound                           = errors.New("referrer not found")
	ErrRoleNotFound                               = errors.New("role not found")
	ErrRoleNotfound                               = errors.New("role not found")
	ErrSeniorityNotFound                          = errors.New("seniority not found")
	ErrSeniorityNotfound                          = errors.New("seniority not found")
	ErrStackNotFound                              = errors.New("stack not found")
	ErrDiscordAccountNotFound                     = errors.New("discord account not found")
	ErrDiscordAccountAlreadyUsedByAnotherEmployee = errors.New("discord account already used by another employee")
	ErrCouldNotFoundDiscordMemberInGuild          = errors.New("could not found discord member in the guild")
	ErrEmployeeNotFullTime                        = errors.New("employee is not full time")
	ErrNoTransactionFound                         = errors.New("no transaction found")
	ErrAlreadyCheckedIn                           = errors.New("already checked in")
)

```

# pkg/controller/employee/earns.go

```go
package employee

import (
	"math"
	"math/big"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/mochipay"
	"github.com/dwarvesf/fortress-api/pkg/utils"
)

type GetEmployeeEarnTransactionsInput struct {
	model.Pagination
}

func (r *controller) GetEmployeeEarnTransactions(discordID string, input GetEmployeeEarnTransactionsInput) (model.EmployeeEarnTransactions, int64, error) {
	profile, err := r.service.MochiProfile.GetProfileByDiscordID(discordID)
	if err != nil {
		return nil, 0, err
	}

	isSender := false

	txns, err := r.service.MochiPay.GetListTransactions(mochipay.ListTransactionsRequest{
		Type:         mochipay.TransactionTypeReceive,
		ActionList:   []mochipay.TransactionAction{mochipay.TransactionActionVaultTransfer},
		Status:       mochipay.TransactionStatusSuccess,
		TokenAddress: mochipay.ICYAddress,
		ChainIDs:     []string{mochipay.BASEChainID},
		ProfileID:    profile.ID,
		Page:         input.Page,
		Size:         input.Size,
		IsSender:     &isSender,
		SortBy:       "created_at-",
	})
	return txns.Data, txns.Pagination.Total, err
}

func (r *controller) GetEmployeeTotalEarn(discordID string) (string, string, error) {
	profile, err := r.service.MochiProfile.GetProfileByDiscordID(discordID)
	if err != nil {
		return "", "", err
	}

	isSender := false

	txns, err := r.service.MochiPay.GetListTransactions(mochipay.ListTransactionsRequest{
		Type:         mochipay.TransactionTypeReceive,
		ActionList:   []mochipay.TransactionAction{mochipay.TransactionActionVaultTransfer},
		Status:       mochipay.TransactionStatusSuccess,
		TokenAddress: mochipay.ICYAddress,
		ChainIDs:     []string{mochipay.BASEChainID},
		ProfileID:    profile.ID,
		Size:         math.MaxInt64,
		IsSender:     &isSender,
		SortBy:       "created_at-",
	})
	if err != nil {
		return "", "", err
	}

	earnsICY := big.NewFloat(0)
	earnsUSD := big.NewFloat(0)
	for _, txn := range txns.Data {
		if txn.Amount != "" && txn.Token != nil {
			earnsICY.Add(earnsICY, utils.ConvertFromString(txn.Amount, txn.Token.Decimal))
			earnsUSD.Add(earnsUSD, big.NewFloat(txn.UsdAmount))
		}
	}

	return earnsICY.String(), earnsUSD.String(), nil
}

func (r *controller) GetTotalEarn(from, to time.Time) (string, string, error) {
	// Step 1: Call to mochi-api to get vaults by df guild id -> vault ids
	vaults, err := r.service.Mochi.GetListVaults(false)
	if err != nil {
		return "", "", err
	}

	dfVaults := make(map[int64]bool, 0)
	for _, vault := range vaults {
		if vault.GuildID == r.config.Discord.IDs.DwarvesGuild {
			dfVaults[vault.ID] = true
		}
	}

	isSender := true

	// Step 2: Call to mochi-payment to get list txns
	// TODO: add filter for API get txn to filter by time
	txns, err := r.service.MochiPay.GetListTransactions(mochipay.ListTransactionsRequest{
		Type:         mochipay.TransactionTypeReceive,
		ActionList:   []mochipay.TransactionAction{mochipay.TransactionActionVaultTransfer},
		Status:       mochipay.TransactionStatusSuccess,
		TokenAddress: mochipay.ICYAddress,
		ChainIDs:     []string{mochipay.BASEChainID},
		Size:         math.MaxInt64,
		IsSender:     &isSender,
		SortBy:       "created_at-",
	})
	if err != nil {
		return "", "", err
	}

	earnsICY := big.NewFloat(0)
	earnsUSD := big.NewFloat(0)
	for _, txn := range txns.Data {
		if txn.Metadata["vault_request"] == nil {
			r.logger.Infof("txn %d has no vault_request", txn.Id)
			continue
		}

		vaultRequest := txn.Metadata["vault_request"].(map[string]interface{})
		vaultID, ok := vaultRequest["vault_id"].(float64)
		if !ok {
			r.logger.Infof("vault_id is not int64")
			continue
		}

		if _, ok := dfVaults[int64(vaultID)]; !ok {
			r.logger.Infof("vault_id %d is not in df vaults", int64(vaultID))
			continue
		}

		if txn.CreatedAt.Before(from) || txn.CreatedAt.After(to.Add(24*time.Hour)) {
			r.logger.Infof("txn %d is not in range", txn.Id)
			continue
		}

		if txn.Amount != "" && txn.Token != nil {
			earnsICY.Add(earnsICY, utils.ConvertFromString(txn.Amount, txn.Token.Decimal))
			earnsUSD.Add(earnsUSD, big.NewFloat(txn.UsdAmount))
		}
	}

	return earnsICY.String(), earnsUSD.String(), nil
}

```

# pkg/controller/employee/details.go

```go
package employee

import (
	"errors"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
)

func (r *controller) Details(id string, userInfo *model.CurrentLoggedUserInfo) (*model.Employee, error) {
	rs, err := r.store.Employee.One(r.repo.DB(), id, true)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrEmployeeNotFound
		}
		return nil, err
	}

	if rs.WorkingStatus == model.WorkingStatusLeft && !authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadFullAccess) {
		return nil, ErrEmployeeNotFound
	}

	mentees, err := r.store.Employee.GetMenteesByID(r.repo.DB(), rs.ID.String())
	if err != nil {
		return nil, err
	}

	if len(mentees) > 0 {
		rs.Mentees = mentees
	}

	return rs, nil
}

```

# pkg/controller/employee/create.go

```go
package employee

import (
	"errors"
	"fmt"
	"strings"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/currency"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
)

type CreateEmployeeInput struct {
	FullName      string
	DisplayName   string
	TeamEmail     string
	PersonalEmail string
	Positions     []model.UUID
	Salary        int64
	SeniorityID   model.UUID
	Roles         []model.UUID
	Status        string
	ReferredBy    model.UUID
	JoinDate      *time.Time
}

func (r *controller) Create(userID string, input CreateEmployeeInput) (*model.Employee, error) {
	l := r.logger.Fields(logger.Fields{
		"controller": "employee",
		"method":     "Create",
	})

	loggedInUser, err := r.store.Employee.One(r.repo.DB(), userID, false)
	if errors.Is(err, gorm.ErrRecordNotFound) {
		return nil, ErrEmployeeNotFound
	}
	if err != nil {
		return nil, err
	}

	// Check position existence
	positions, err := r.store.Position.All(r.repo.DB())
	if err != nil {
		return nil, err
	}

	positionsReq := make([]model.Position, 0)
	positionMap := model.ToPositionMap(positions)
	for _, pID := range input.Positions {
		_, ok := positionMap[pID]
		if !ok {
			l.Errorf(ErrPositionNotFound, "position not found with id ", pID.String())
			return nil, ErrPositionNotFound
		}

		positionsReq = append(positionsReq, positionMap[pID])
	}

	sen, err := r.store.Seniority.One(r.repo.DB(), input.SeniorityID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrSeniorityNotfound
		}
		return nil, err
	}

	roles, err := r.store.Role.GetByIDs(r.repo.DB(), input.Roles)
	if err != nil {
		l.Error(err, "failed to get roles by ids")
		return nil, err
	}

	for _, role := range roles {
		if role.Level <= loggedInUser.EmployeeRoles[0].Role.Level &&
			loggedInUser.EmployeeRoles[0].Role.Code != model.AccountRoleAdmin.String() {
			return nil, ErrInvalidAccountRole
		}
	}

	// get the username
	eml := &model.Employee{
		BaseModel: model.BaseModel{
			ID: model.NewUUID(),
		},
		FullName:      input.FullName,
		DisplayName:   input.DisplayName,
		TeamEmail:     input.TeamEmail,
		PersonalEmail: input.PersonalEmail,
		WorkingStatus: model.WorkingStatus(input.Status),
		JoinedDate:    input.JoinDate,
		SeniorityID:   sen.ID,
		Username:      strings.Split(input.TeamEmail, "@")[0],
	}

	if !input.ReferredBy.IsZero() {
		exists, err := r.store.Employee.IsExist(r.repo.DB(), input.ReferredBy.String())
		if err != nil {
			return nil, err
		}

		if !exists {
			return nil, ErrReferrerNotFound
		}

		eml.ReferredBy = input.ReferredBy
	}

	// 2.1 check employee exists -> raise error
	_, err = r.store.Employee.OneByEmail(r.repo.DB(), eml.TeamEmail)
	if !errors.Is(err, gorm.ErrRecordNotFound) {
		if err == nil {
			return nil, ErrTeamEmailExisted
		}
		return nil, err
	}

	_, err = r.store.Employee.OneByEmail(r.repo.DB(), eml.PersonalEmail)
	if !errors.Is(err, gorm.ErrRecordNotFound) {
		if err == nil {
			return nil, ErrPersonalEmailExisted
		}
		return nil, err
	}

	_, err = r.store.Employee.One(r.repo.DB(), eml.Username, false)
	if !errors.Is(err, gorm.ErrRecordNotFound) {
		if err == nil {
			return nil, ErrEmployeeExisted
		}
		return nil, err
	}

	tx, done := r.repo.NewTransaction()
	// 2.2 store employee
	eml, err = r.store.Employee.Create(tx.DB(), eml)
	if err != nil {
		l.Errorf(err, "failed to create employee", "employee", eml)
		return nil, done(err)
	}

	// 2.3 create employee position
	for _, p := range positionsReq {
		ep := &model.EmployeePosition{
			EmployeeID: eml.ID,
			PositionID: p.ID,
		}
		_, err = r.store.EmployeePosition.Create(tx.DB(), ep)
		if err != nil {
			l.Errorf(err, "failed to create employee position", "employee_position", ep)
			return nil, done(err)
		}
	}

	// 2.4 create employee roles
	for _, role := range roles {
		er := &model.EmployeeRole{
			EmployeeID: eml.ID,
			RoleID:     role.ID,
		}
		_, err = r.store.EmployeeRole.Create(tx.DB(), &model.EmployeeRole{
			EmployeeID: eml.ID,
			RoleID:     role.ID,
		})
		if err != nil {
			l.Errorf(err, "failed to create employee role", "employee_role", er)
			return nil, done(err)
		}
	}

	baseCurrency, err := r.store.Currency.GetByName(tx.DB(), currency.VNDCurrency)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, done(ErrCurrencyNotFound)
		}

		return nil, done(err)
	}

	salaryBatch := 1
	if input.JoinDate.Day() > 1 && input.JoinDate.Day() < 16 {
		salaryBatch = 15
	}

	// 2.4 create employee salary
	ebs := &model.BaseSalary{
		EmployeeID:            eml.ID,
		ContractAmount:        0,
		CompanyAccountAmount:  0,
		PersonalAccountAmount: input.Salary,
		InsuranceAmount:       0,
		Type:                  "",
		Category:              "",
		CurrencyID:            baseCurrency.ID,
		Batch:                 salaryBatch,
		EffectiveDate:         nil,
	}
	err = r.store.BaseSalary.Save(tx.DB(), ebs)
	if err != nil {
		l.Errorf(err, "failed to create employee base salary", "employee_base_salary", ebs)
		return nil, done(err)
	}

	// Create employee organization
	org, err := r.store.Organization.OneByCode(tx.DB(), model.OrganizationCodeDwarves)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, done(ErrOrganizationNotFound)
		}
		return nil, done(err)
	}

	eo := &model.EmployeeOrganization{
		EmployeeID:     eml.ID,
		OrganizationID: org.ID,
	}
	if _, err := r.store.EmployeeOrganization.Create(tx.DB(), eo); err != nil {
		l.Errorf(err, "failed to create employee organization", "employee_organization", eo)
		return nil, done(err)
	}

	authenticationInfo := model.AuthenticationInfo{
		UserID: eml.ID.String(),
		Avatar: eml.Avatar,
		Email:  eml.PersonalEmail,
	}

	jwt, err := authutils.GenerateJWTToken(&authenticationInfo, time.Now().Add(24*time.Hour).Unix(), r.config.JWTSecretKey)
	if err != nil {
		l.Errorf(err, "failed to generate jwt token", "authenticationInfo", authenticationInfo)
		return nil, done(err)
	}

	ei := model.EmployeeInvitation{
		EmployeeID:               eml.ID,
		InvitedBy:                loggedInUser.ID,
		InvitationCode:           jwt,
		IsCompleted:              false,
		IsInfoUpdated:            false,
		IsDiscordRoleAssigned:    false,
		IsBasecampAccountCreated: false,
		IsTeamEmailCreated:       false,
	}

	if _, err := r.store.EmployeeInvitation.Create(tx.DB(), &ei); err != nil {
		l.Errorf(err, "failed to create employee invitation", "employee_invitation", ei)
		return nil, done(err)
	}

	invitation := model.InvitationEmail{
		Email:   eml.PersonalEmail,
		Link:    fmt.Sprintf("%s/onboarding?code=%s", r.config.FortressURL, jwt),
		Inviter: loggedInUser.FullName,
	}

	if err := r.service.GoogleMail.SendInvitationMail(&invitation); err != nil {
		l.Errorf(err, "failed to send invitation mail", "invitationInfo", invitation)
		return nil, done(err)
	}

	return eml, done(nil)
}

```

# pkg/controller/employee/checkin.go

```go
package employee

import (
	"errors"
	"fmt"
	"strconv"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type CheckinResponse struct {
	EmployeeID      string
	IcyAmount       float64
	TransactionID   string
	TransactionHash string
}

func (r *controller) CheckIn(discordID string, t time.Time, amount float64) (*CheckinResponse, error) {
	l := r.logger.Fields(logger.Fields{
		"controller": "employee",
		"method":     "CheckIn",
	})

	// Get employee by discord id
	employee, err := r.store.Employee.GetByDiscordID(r.repo.DB(), discordID, true)
	if err != nil {
		l.Error(err, "failed to get employee by discord id")
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrEmployeeNotFound
		}
		return nil, err
	}

	checkinDate := t.Format("2006-01-02")

	// check if record already exists
	epc, err := r.store.PhysicalCheckin.GetByEmployeeIDAndDate(r.repo.DB(), employee.ID.String(), checkinDate)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		l.Error(err, "failed to get physical checkin by employee id and date")
		return nil, err
	}
	if !epc.ID.IsZero() {
		return nil, ErrAlreadyCheckedIn
	}

	err = r.checkFullTimeRole(employee)
	if err != nil {
		l.Error(err, "failed to check full time role")
		return nil, err
	}

	tx, done := r.repo.NewTransaction()
	pc := &model.PhysicalCheckinTransaction{
		ID:         model.NewUUID(),
		EmployeeID: employee.ID,
		IcyAmount:  amount,
		Date:       t,
	}
	if err := r.store.PhysicalCheckin.Save(tx.DB(), pc); err != nil {
		l.Error(err, "failed to save physical checkin")
		return nil, done(err)
	}

	// Make transaction request to mochi
	description := fmt.Sprintf("%s - Physical Checkin on %v", employee.DisplayName, checkinDate)
	references := "Physical Checkin"
	txs, err := r.service.Mochi.SendFromAccountToUser(amount, discordID, description, references)
	if err != nil {
		l.Error(err, "failed to request to mochi")
		return nil, done(err)
	}

	if len(txs) == 0 {
		return nil, done(ErrNoTransactionFound)
	}

	pc.MochiTxID = txs[0].TransactionID
	if err := r.store.PhysicalCheckin.Save(tx.DB(), pc); err != nil {
		l.Error(err, "failed to save physical checkin")
		return nil, done(err)
	}

	response := &CheckinResponse{
		EmployeeID:      employee.ID.String(),
		IcyAmount:       amount,
		TransactionID:   strconv.Itoa(int(txs[0].TransactionID)),
		TransactionHash: txs[0].RecipientID,
	}

	return response, done(nil)
}

```

# pkg/controller/conversionrate/sync.go

```go
package conversionrate

import (
	"github.com/gin-gonic/gin"
	"github.com/shopspring/decimal"
)

var destCurrencies = []string{"USD", "VND"}

func (r *controller) Sync(c *gin.Context) error {
	tx, done := r.repo.NewTransaction()

	// Get list conversion rate
	conversionRates, err := r.store.ConversionRate.GetList(tx.DB())
	if err != nil {
		return done(err)
	}

	currencyRateMap := make(map[string]float64)
	for _, conversionRate := range conversionRates {
		srcCurrency := conversionRate.Currency.Name
		for _, destCurrency := range destCurrencies {
			rate, err := r.service.Wise.GetRate(srcCurrency, destCurrency)
			if err != nil {
				return done(err)
			}
			currencyRateMap[destCurrency] = rate
		}

		for k, v := range currencyRateMap {
			switch k {
			case "USD":
				conversionRate.ToUSD = decimal.NewFromFloat(v)
			case "VND":
				conversionRate.ToVND = decimal.NewFromFloat(v)
			}
		}

		if err := r.store.ConversionRate.Update(tx.DB(), &conversionRate); err != nil {
			return done(err)
		}
	}

	return done(nil)
}

```

# pkg/controller/conversionrate/new.go

```go
package conversionrate

import (
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

type IController interface {
	Sync(c *gin.Context) error
}

```

# pkg/controller/conversionrate/errors.go

```go
package conversionrate

var ()

```

# pkg/controller/communitynft/new.go

```go
package communitynft

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

type IController interface {
	GetNftMetadata(tokenId int) (metadata *model.NftMetadata, err error)
}

```

# pkg/controller/communitynft/metadata.go

```go
package communitynft

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/mochiprofile"
)

type role struct {
	Name string
}
type nftEmbedData struct {
	TokenId string

	// Profile Info
	DisplayName  string
	Username     string
	AvatarBase64 string
	JoinedDate   string

	// User stats
	GlobalXP     int
	ChatActivity int
	Level        int

	// User discord roles
	Roles []role
}

func (c *controller) GetNftMetadata(tokenId int) (*model.NftMetadata, error) {
	// 1 Get owner of an NFT
	addr, err := c.service.CommunityNft.OwnerOf(tokenId)
	if err != nil {
		return nil, ErrTokenNotFound
	}

	// 2 Get nft needed data
	// 2.1 get mochi profile of nft owner
	profile, err := c.service.MochiProfile.GetProfileByEvmAddress(addr)
	if err != nil {
		return nil, ErrMochiProfileNotFound
	}
	var discordProfile mochiprofile.AssociatedAccounts
	for _, acc := range profile.AssociatedAccounts {
		if acc.Platform == "discord" {
			discordProfile = acc
			break
		}
	}
	discordUsername, ok := discordProfile.PlatformMetadata["username"]
	if !ok {
		discordUsername = "unknown"
	}
	displayName := profile.ProfileName
	if displayName == "" {
		displayName = strings.ToTitle(fmt.Sprintf("%s", discordUsername))
	}
	joinedDate := profile.CreatedAt.Format("May 02, 2006")
	userAvatar, err := c.userAvatarBase64(profile.Avatar)
	if err != nil {
		return nil, err
	}

	// 2.2 get tono guild user stats of mochi profile
	dfGuildId := "462663954813157376"
	guildProfile, err := c.service.Tono.GetGuildUserProfile(profile.ID, dfGuildId)
	if err != nil {
		return nil, err
	}

	// 2.3 get user discord roles
	// TODO: get user discord roles
	roles := []role{{Name: "peeps"}}

	// 2.4 compose nft embed data
	embedData := nftEmbedData{
		TokenId:      fmt.Sprintf("#%d", tokenId),
		DisplayName:  displayName,
		Username:     fmt.Sprintf("@%s", discordUsername),
		JoinedDate:   joinedDate,
		GlobalXP:     guildProfile.GuildXP,
		ChatActivity: guildProfile.NrOfActions,
		Level:        guildProfile.CurrentLevel.Level,
		Roles:        roles,
		AvatarBase64: userAvatar,
	}

	// 3. Generate image from embed data
	img, err := c.nftImage(embedData)
	if err != nil {
		return nil, err
	}

	// 4. Compose metadata
	metadata := &model.NftMetadata{
		Name:            embedData.DisplayName,
		Description:     "Dwarves Foundation NFT",
		Image:           img,
		BackgroundColor: "F0F4FC",
		Attributes: []model.NftAttribute{
			{
				TraitType: "Global XP",
				Value:     fmt.Sprint(embedData.GlobalXP),
			},
			{
				TraitType: "Chat Activity",
				Value:     fmt.Sprint(embedData.ChatActivity),
			},
			{
				TraitType: "Level",
				Value:     fmt.Sprint(embedData.Level),
			},
		},
	}

	return metadata, nil
}

func (c *controller) nftImage(data nftEmbedData) (string, error) {
	templatePath := c.config.Invoice.TemplatePath
	if c.config.Env == "local" || templatePath == "" {
		pwd, err := os.Getwd()
		if err != nil {
			pwd = os.Getenv("GOPATH") + "/src/github.com/dwarvesf/fortress-api"
		}
		templatePath = filepath.Join(pwd, "pkg/templates")
	}
	tmplFileName := "community_nft.tpl"
	tmpl, err := template.New("nft").ParseFiles(filepath.Join(templatePath, tmplFileName))
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	if err := tmpl.ExecuteTemplate(&buf, tmplFileName, data); err != nil {
		return "", err
	}
	img := base64.StdEncoding.EncodeToString(buf.Bytes())
	return fmt.Sprintf("data:image/svg+xml;base64,%s", img), nil
}

func (c *controller) userAvatarBase64(avatarURL string) (string, error) {
	if avatarURL == "" {
		return "", nil
	}
	client := http.Client{
		Timeout: 10 * time.Second,
	}
	resp, err := client.Get(avatarURL)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	contentType := http.DetectContentType(data)
	imgB64Str := base64.StdEncoding.EncodeToString(data)
	return fmt.Sprintf("data:%s;base64,%s", contentType, imgB64Str), nil
}

```

# pkg/controller/communitynft/errors.go

```go
package communitynft

import "errors"

var (
	ErrInvalidTokenID       = errors.New("invalid token id")
	ErrTokenNotFound        = errors.New("token not found")
	ErrMochiProfileNotFound = errors.New("mochi profile not found")
)

```

# pkg/controller/companyinfo/new.go

```go
package companyinfo

import (
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

type IController interface {
	List(c *gin.Context) ([]*model.CompanyInfo, error)
}

```

# pkg/controller/companyinfo/list.go

```go
package companyinfo

import (
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

func (r *controller) List(c *gin.Context) ([]*model.CompanyInfo, error) {
	companyInfos, err := r.store.CompanyInfo.All(r.repo.DB())
	if err != nil {
		return nil, err
	}

	return companyInfos, nil
}

```

# pkg/controller/brainerylogs/new.go

```go
package brainerylogs

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
	"time"
)

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

type IController interface {
	Create(log model.BraineryLog) (model.BraineryLog, error)
	GetMetrics(selectedDate time.Time, queryView string) (latestPosts []*model.BraineryLog, logs []*model.BraineryLog, ncids []string, err error)
}

```

# pkg/controller/brainerylogs/get_metrics.go

```go
package brainerylogs

import (
	"errors"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
)

// GetMetrics returns brainery metrics
func (c *controller) GetMetrics(selectedDate time.Time, queryView string) (latestPosts []*model.BraineryLog, logs []*model.BraineryLog, ncids []string, err error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "brainerylogs",
		"method":     "GetBraineryMetrics",
	})

	end := timeutil.GetEndDayOfWeek(selectedDate)
	start := timeutil.GetStartDayOfWeek(selectedDate)
	if queryView == "monthly" {
		start = timeutil.FirstDayOfMonth(int(selectedDate.Month()), selectedDate.Year())
		end = timeutil.LastDayOfMonth(int(selectedDate.Month()), selectedDate.Year())
	}

	// latest 10 posts
	latestPosts, err = c.store.BraineryLog.GetLimitByTimeRange(c.repo.DB(), &time.Time{}, &end, 10)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		l.Errorf(err, "failed to get latest posts by time range", "start", start, "end", end)
		return nil, nil, nil, err
	}

	// weekly or monthly posts
	logs, err = c.store.BraineryLog.GetLimitByTimeRange(c.repo.DB(), &start, &end, 1000)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		l.Errorf(err, "failed to get logs by time range", "start", start, "end", end)
		return nil, nil, nil, err
	}

	// ncids = new contributor discord IDs
	ncids, err = c.store.BraineryLog.GetNewContributorDiscordIDs(c.repo.DB(), &start, &end)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		l.Errorf(err, "failed to get new contributor discord IDs by time range", "start", start, "end", end)
		return nil, nil, nil, err
	}

	return latestPosts, logs, ncids, nil
}

```

# pkg/controller/brainerylogs/create.go

```go
package brainerylogs

import (
	"errors"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"gorm.io/gorm"
)

// Create creates a new brainery log
func (c *controller) Create(log model.BraineryLog) (model.BraineryLog, error) {
	emp, err := c.store.Employee.GetByDiscordID(c.repo.DB(), log.DiscordID, false)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		c.logger.Errorf(err, "failed to get employee by discordID", "discordID", log.DiscordID)
		return model.BraineryLog{}, err
	}

	if !errors.Is(err, gorm.ErrRecordNotFound) {
		log.EmployeeID = emp.ID
	}

	_, err = c.store.BraineryLog.Create(c.repo.DB(), []model.BraineryLog{log})
	if err != nil {
		c.logger.Errorf(err, "failed to create brainery logs", "braineryLog", log)
		return model.BraineryLog{}, err
	}

	return log, nil
}

```

# pkg/controller/auth/new.go

```go
package auth

import (
	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

type IController interface {
	Auth(in AuthenticationInput) (employee *model.Employee, jwt string, err error)
	Me(userID string) (employee *model.Employee, perms []*model.Permission, err error)
	CreateAPIKey(roleID string) (string, error)
}

```

# pkg/controller/auth/me.go

```go
package auth

import (
	"errors"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

func (c *controller) Me(userID string) (*model.Employee, []*model.Permission, error) {
	e, err := c.store.Employee.One(c.repo.DB(), userID, false)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil, ErrUserNotFound
		}

		return nil, nil, err
	}

	perms, err := c.store.Permission.GetByEmployeeID(c.repo.DB(), userID)
	if err != nil {
		return nil, nil, err
	}

	return e, perms, nil
}

```

# pkg/controller/auth/errors.go

```go
package auth

import "errors"

var (
	ErrUserInactivated   = errors.New("user is inactivated")
	ErrEmptyPrimaryEmail = errors.New("empty primary email")
	ErrUserNotFound      = errors.New("user is not found")
	ErrRoleNotfound      = errors.New("role is not found")
)

```

# pkg/controller/auth/create_apikey.go

```go
package auth

import (
	"encoding/base64"
	"errors"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
)

func (c *controller) CreateAPIKey(roleID string) (string, error) {
	clientID, err := authutils.GenerateUniqueNanoID(authutils.ClientIDLength)
	if err != nil {
		return "", err
	}
	key, err := authutils.GenerateUniqueNanoID(authutils.SecretKeyLength)
	if err != nil {
		return "", err
	}

	hashedKey, err := authutils.GenerateHashedKey(key)
	if err != nil {
		return "", err
	}

	roleIDUUID, err := model.UUIDFromString(roleID)
	if err != nil {
		return "", err
	}

	tx, done := c.repo.NewTransaction()

	role, err := c.store.Role.One(tx.DB(), roleIDUUID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return "", done(ErrRoleNotfound)
		}
		return "", done(err)
	}

	apikey, err := c.store.APIKey.Create(tx.DB(), &model.APIKey{
		ClientID:  clientID,
		SecretKey: hashedKey,
		Status:    model.ApikeyStatusValid,
	})
	if err != nil {
		return "", done(err)
	}

	_, err = c.store.APIKeyRole.Create(tx.DB(), &model.APIKeyRole{
		APIKeyID: apikey.ID,
		RoleID:   role.ID,
	})
	if err != nil {
		return "", done(err)
	}

	return base64.URLEncoding.EncodeToString([]byte(clientID + key)), done(nil)
}

```

# pkg/controller/auth/auth.go

```go
package auth

import (
	"errors"
	"time"

	"gorm.io/gorm"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
)

type AuthenticationInput struct {
	Code        string
	RedirectURL string
}

func (c *controller) Auth(in AuthenticationInput) (*model.Employee, string, error) {
	l := c.logger.Fields(logger.Fields{
		"controller": "auth",
		"method":     "Auth",
	})

	accessToken, err := c.service.Google.GetAccessToken(in.Code, in.RedirectURL)
	if err != nil {
		l.Errorf(err, "failed to get access token")
		return nil, "", err
	}

	// 2.2 get login user email from access token
	primaryEmail := ""
	if c.config.Env == "prod" {
		primaryEmail, err = c.service.Google.GetGoogleEmailLegacy(accessToken)
		if err != nil {
			l.Errorf(err, "failed to get google email legacy")
			return nil, "", err
		}
	} else {
		primaryEmail, err = c.service.Google.GetGoogleEmail(accessToken)
		if err != nil {
			l.Errorf(err, "failed to get google email")
			return nil, "", err
		}
	}

	// 2.3 double check empty primary email
	if primaryEmail == "" {
		return nil, "", ErrEmptyPrimaryEmail
	}

	// 2.4 check user is active
	employee, err := c.store.Employee.OneByEmail(c.repo.DB(), primaryEmail)
	if err != nil {
		l.Errorf(err, "failed to employee by email")
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, "", ErrUserInactivated
		}
		return nil, "", err
	}

	if employee.WorkingStatus == model.WorkingStatusLeft || employee.WorkingStatus == model.WorkingStatusOnBoarding {
		return nil, "", ErrUserInactivated
	}

	// 2.5 generate jwt bearer token
	authenticationInfo := model.AuthenticationInfo{
		UserID: employee.ID.String(),
		Avatar: employee.Avatar,
		Email:  primaryEmail,
	}

	jwt, err := authutils.GenerateJWTToken(&authenticationInfo, time.Now().Add(24*365*time.Hour).Unix(), c.config.JWTSecretKey)
	if err != nil {
		l.Errorf(err, "failed to generate jwt token")
		return nil, "", err
	}

	return employee, jwt, nil
}

```

# pkg/controller/client/update.go

```go
package client

import (
	"encoding/json"
	"errors"
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/handler/client/request"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/gin-gonic/gin"
	"gorm.io/datatypes"
	"gorm.io/gorm"
)

func (r *controller) Update(c *gin.Context, clientID string, input request.UpdateClientInput) (int, error) {
	tx, done := r.repo.NewTransaction()

	// Get client by id
	client, err := r.store.Client.One(tx.DB(), clientID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return http.StatusNotFound, done(ErrClientNotFound)
		}

		return http.StatusInternalServerError, done(err)
	}

	// Update client
	client.Name = input.Name
	client.Description = input.Description
	client.RegistrationNumber = input.RegistrationNumber
	client.Address = input.Address
	client.Country = input.Country
	client.Industry = input.Industry
	client.Website = input.Website

	_, err = r.store.Client.UpdateSelectedFieldsByID(tx.DB(), clientID, *client,
		"name",
		"description",
		"registration_number",
		"address",
		"country",
		"industry",
		"website")

	if err != nil {
		return http.StatusInternalServerError, done(err)
	}

	// Delete all client contacts
	if err = r.store.ClientContact.DeleteByClientID(tx.DB(), clientID); err != nil {
		return http.StatusInternalServerError, done(err)
	}

	// Create client contact
	for _, clientContact := range input.Contacts {
		// parse struct email to json
		emails, err := json.Marshal(model.ClientEmail{Emails: clientContact.Emails})
		if err != nil {
			return http.StatusInternalServerError, done(err)
		}

		_, err = r.store.ClientContact.Create(tx.DB(), &model.ClientContact{
			ClientID:      model.MustGetUUIDFromString(clientID),
			Name:          clientContact.Name,
			Role:          clientContact.Role,
			Emails:        datatypes.JSON(emails),
			IsMainContact: clientContact.IsMainContact,
		})

		if err != nil {
			return http.StatusInternalServerError, done(err)
		}
	}

	return http.StatusOK, done(nil)
}

```

# pkg/controller/client/new.go

```go
package client

import (
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/client/request"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service"
	"github.com/dwarvesf/fortress-api/pkg/store"
)

type controller struct {
	store   *store.Store
	service *service.Service
	logger  logger.Logger
	repo    store.DBRepo
	config  *config.Config
}

func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController {
	return &controller{
		store:   store,
		repo:    repo,
		service: service,
		logger:  logger,
		config:  cfg,
	}
}

type IController interface {
	Create(c *gin.Context, input request.CreateClientRequest) (client *model.Client, err error)
	List(c *gin.Context) (client []*model.Client, err error)
	Detail(c *gin.Context, clientID string) (client *model.Client, err error)
	Update(c *gin.Context, clientID string, input request.UpdateClientInput) (errCode int, err error)
	Delete(c *gin.Context, clientID string) (errCode int, err error)
	PublicList(c *gin.Context) (client []*model.Client, err error)
}

```

# pkg/controller/client/list.go

```go
package client

import (
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

func (r *controller) List(c *gin.Context) ([]*model.Client, error) {
	clients, err := r.store.Client.All(r.repo.DB(), false, false)
	if err != nil {
		return nil, err
	}

	return clients, nil
}

func (r *controller) PublicList(c *gin.Context) ([]*model.Client, error) {
	clients, err := r.store.Client.All(r.repo.DB(), true, true)
	if err != nil {
		return nil, err
	}

	return clients, nil
}

```

# pkg/controller/client/errors.go

```go
package client

import "errors"

var (
	ErrInvalidClientID        = errors.New("invalid client id")
	ErrInvalidClientContactID = errors.New("invalid client contact id")
	ErrClientNotFound         = errors.New("client not found")
	ErrClientContactNotFound  = errors.New("client contact not found")
	ErrMismatchClientID       = errors.New("mismatch client id")
)

```

# pkg/controller/client/detail.go

```go
package client

import (
	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/model"
)

func (r *controller) Detail(c *gin.Context, clientID string) (*model.Client, error) {
	client, err := r.store.Client.One(r.repo.DB(), clientID)
	if err != nil {
		return nil, err
	}
	return client, nil
}

```

# pkg/controller/client/delete.go

```go
package client

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func (r *controller) Delete(c *gin.Context, clientID string) (int, error) {
	// Check client existence
	exists, err := r.store.Client.IsExist(r.repo.DB(), clientID)
	if err != nil {
		return http.StatusInternalServerError, err
	}

	if !exists {
		return http.StatusNotFound, ErrClientNotFound
	}

	tx, done := r.repo.NewTransaction()

	// Delete client
	if err = r.store.Client.Delete(tx.DB(), clientID); err != nil {
		return http.StatusInternalServerError, done(err)
	}

	// Delete client contacts
	if err = r.store.ClientContact.DeleteByClientID(tx.DB(), clientID); err != nil {
		return http.StatusInternalServerError, done(err)
	}

	return http.StatusOK, done(nil)
}

```

# pkg/controller/client/create.go

```go
package client

import (
	"encoding/json"

	"github.com/gin-gonic/gin"
	"gorm.io/datatypes"

	"github.com/dwarvesf/fortress-api/pkg/handler/client/request"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

func (r *controller) Create(c *gin.Context, input request.CreateClientRequest) (*model.Client, error) {
	tx, done := r.repo.NewTransaction()

	// Create client
	client, err := r.store.Client.Create(tx.DB(), &model.Client{
		Name:               input.Name,
		Description:        input.Description,
		RegistrationNumber: input.RegistrationNumber,
		Address:            input.Address,
		Country:            input.Country,
		Industry:           input.Industry,
		Website:            input.Website,
	})

	if err != nil {
		return nil, done(err)
	}

	// Create client contact
	for _, clientContact := range input.Contacts {
		// parse struct email to json
		emails, err := json.Marshal(model.ClientEmail{Emails: clientContact.Emails})
		if err != nil {
			return nil, done(err)
		}

		contact, err := r.store.ClientContact.Create(tx.DB(), &model.ClientContact{
			ClientID:      client.ID,
			Name:          clientContact.Name,
			Role:          clientContact.Role,
			Emails:        datatypes.JSON(emails),
			IsMainContact: clientContact.IsMainContact,
		})

		if err != nil {
			return nil, done(err)
		}

		client.Contacts = append(client.Contacts, *contact)
	}

	return client, done(nil)
}

```

# pkg/service/basecamp/webhook/webhook.go

```go
package webhook

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type WebhookService struct {
	client client.Service
}

func NewService(client client.Service) Service {
	return &WebhookService{
		client: client,
	}
}

func (w *WebhookService) FindWebHook(projectID int, hookID int) (*model.Hook, error) {
	url := fmt.Sprintf("%v/%v/buckets/%v/webhooks/%v.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, hookID)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	res, err := w.client.Do(req)
	if err != nil {
		return nil, err
	}

	defer res.Body.Close()
	rs := model.Hook{}
	if err := json.NewDecoder(res.Body).Decode(&rs); err != nil {
		return nil, err
	}
	return &rs, nil
}

func (w *WebhookService) UpdateWebHook(projectID, hookID int, hookBody model.Hook) error {
	url := fmt.Sprintf("%v/%v/buckets/%v/webhooks/%v.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, hookID)

	jsonHook, err := json.Marshal(hookBody)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonHook))
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")
	res, err := w.client.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	return nil
}

```

# pkg/service/basecamp/webhook/service.go

```go
package webhook

import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"

type Service interface {
	FindWebHook(projectID int, hookID int) (result *model.Hook, err error)
	UpdateWebHook(projectID int, hookID int, hookBody model.Hook) (err error)
}

```

# pkg/service/basecamp/todo/todo.go

```go
package todo

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/config"
	pkgmodel "github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/utils/timeutil"
)

type TodoService struct {
	client client.Service
	cfg    *config.Config
}

func NewService(c client.Service, cfg *config.Config) Service {
	return &TodoService{
		client: c,
		cfg:    cfg,
	}
}

func (t *TodoService) CreateList(projectID int, todoSetID int, todoList model.TodoList) (*model.TodoList, error) {
	url := fmt.Sprintf("%v/%v/buckets/%v/todosets/%v/todolists.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todoSetID)
	jsonTodo, err := json.Marshal(todoList)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonTodo))
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")
	res, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	var result model.TodoList
	if err = json.NewDecoder(res.Body).Decode(&result); err != nil {
		return nil, err
	}

	return &result, nil
}

func (t *TodoService) CreateGroup(projectID int, todoListID int, group model.TodoGroup) (*model.TodoGroup, error) {
	url := fmt.Sprintf("%v/%v/buckets/%v/todolists/%v/groups.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todoListID)
	jsonGroup, err := json.Marshal(group)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonGroup))
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	res, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	rs := &model.TodoGroup{}
	if err := json.NewDecoder(res.Body).Decode(&rs); err != nil {
		return nil, err
	}

	return rs, err
}

func (t *TodoService) Create(projectID int, todoListID int, todo model.Todo) (*model.Todo, error) {
	url := fmt.Sprintf("%v/%v/buckets/%v/todolists/%v/todos.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todoListID)
	jsonGroup, err := json.Marshal(todo)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonGroup))
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	resp, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	res := &model.Todo{}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal(body, res); err != nil {
		return nil, err
	}

	return res, nil
}

func (t *TodoService) Get(url string) (*model.Todo, error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Content-Type", "application/json")

	res, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	rs := &model.Todo{}
	if err := json.NewDecoder(res.Body).Decode(&rs); err != nil {
		return nil, err
	}
	return rs, nil
}

func (t *TodoService) GetAllInList(todoListID, projectID int, query ...string) ([]model.Todo, error) {
	url := fmt.Sprintf(`https://3.basecampapi.com/%d/buckets/%d/todolists/%d/todos.json`,
		consts.CompanyBasecampID,
		projectID,
		todoListID)

	for _, v := range query {
		url += v
	}

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	res, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	rs := []model.Todo{}
	if err := json.NewDecoder(res.Body).Decode(&rs); err != nil {
		return nil, err
	}

	link := res.Header.Get("Link")
	page := 2
	for link != "" {
		request, err := http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil)
		if err != nil {
			return nil, err
		}
		request.Header.Add("Content-Type", "application/json")
		response, err := t.client.Do(request)
		if err != nil {
			return nil, err
		}
		defer response.Body.Close()

		ss := []model.Todo{}
		if err := json.NewDecoder(response.Body).Decode(&ss); err != nil {
			if err == io.EOF {
				break
			}
			return nil, err
		}
		rs = append(rs, ss...)

		link = response.Header.Get("Link")
		page++
	}

	return rs, nil
}

func (t *TodoService) GetGroups(todoListID, projectID int) ([]model.TodoGroup, error) {
	url := fmt.Sprintf(`https://3.basecampapi.com/%d/buckets/%d/todolists/%d/groups.json`,
		consts.CompanyBasecampID,
		projectID,
		todoListID)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	res, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	rs := []model.TodoGroup{}
	if err := json.NewDecoder(res.Body).Decode(&rs); err != nil {
		return nil, err
	}
	return rs, nil
}

func (t *TodoService) GetLists(projectID, todoSetsID int) ([]model.TodoList, error) {
	url := fmt.Sprintf("%v/%v/buckets/%v/todosets/%v/todolists.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todoSetsID)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	res, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	todoLists := []model.TodoList{}
	if err := json.NewDecoder(res.Body).Decode(&todoLists); err != nil {
		return nil, err
	}

	link := res.Header.Get("Link")
	page := 2
	for link != "" {
		request, err := http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil)
		if err != nil {
			return nil, err
		}
		request.Header.Add("Content-Type", "application/json")
		response, err := t.client.Do(request)
		if err != nil {
			return nil, err
		}
		defer response.Body.Close()

		ss := []model.TodoList{}
		if err := json.NewDecoder(response.Body).Decode(&ss); err != nil {
			if err == io.EOF {
				break
			}
			return nil, err
		}
		todoLists = append(todoLists, ss...)

		link = response.Header.Get("Link")
		page++
	}

	return todoLists, nil
}

func (t *TodoService) GetList(url string) (*model.TodoList, error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Content-Type", "application/json")

	res, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	b, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	rs := &model.TodoList{}
	if err := json.Unmarshal(b, rs); err != nil {
		return nil, err
	}
	return rs, nil
}

func (t *TodoService) GetProjectsLatestIssue(projectNames []string) ([]*pkgmodel.ProjectIssue, error) {
	issues := make([]*pkgmodel.ProjectIssue, len(projectNames))
	todoGroups, err := t.GetGroups(consts.ProjectManagementID, consts.OperationID)
	if err != nil {
		return nil, err
	}

	for i := range todoGroups {
		for j, v := range projectNames {
			if strings.Contains(strings.ToLower(todoGroups[i].Title), strings.ToLower(v)) {
				todos, err := t.GetAllInList(todoGroups[i].ID, consts.OperationID)
				if err != nil {
					return nil, err
				}
				for k := range todos {
					if !todos[k].Completed {
						issues[j] = &pkgmodel.ProjectIssue{ID: todos[k].ID, Name: todos[k].Content, Link: todos[k].AppURL}
					}
				}
			}
		}
	}
	return issues, nil
}

func (t *TodoService) CreateHiring(cv *pkgmodel.Candidate) error {
	hiringID := consts.HiringID
	hiringTodoSetID := consts.HiringTodoSetID
	runMode := t.cfg.Env
	if runMode != "prod" {
		hiringID = consts.PlaygroundID
		hiringTodoSetID = consts.PlaygroundTodoID
	}

	now := time.Now()
	currentQuarter := fmt.Sprintf(`Q%d/%d`, timeutil.GetQuarterFromMonth(now.Month()), now.Year())
	todoList, err := t.FirstOrCreateList(hiringID, hiringTodoSetID, currentQuarter)
	if err != nil {
		return err
	}

	todoGroup, err := t.FirstOrCreateGroup(hiringID, todoList.ID, pkgmodel.GroupRole(cv.Role))
	if err != nil {
		return err
	}

	todo := model.Todo{Content: cv.Name,
		AssigneeIDs: []int{cv.FindHiringInCharge(), consts.HelenBasecampID},
		Description: cv.Note,
		Notify:      (runMode != "local"),
	}

	if cv.IsReferral {
		todo.Content = fmt.Sprintf("Referral: %v", cv.Name)
	}

	res, err := t.Create(hiringID, todoGroup.ID, todo)
	if err != nil {
		return err
	}

	cv.BasecampTodoID = res.ID

	return nil
}

func (t *TodoService) FirstOrCreateList(projectID, todoSetID int, todoListName string) (*model.TodoList, error) {
	todoLists, err := t.GetLists(projectID, todoSetID)
	if err != nil {
		return nil, err
	}
	for i := range todoLists {
		if todoLists[i].Title == todoListName {
			return &todoLists[i], nil
		}
	}
	return t.CreateList(projectID, todoSetID, model.TodoList{Name: todoListName})
}

func (t *TodoService) FirstOrCreateGroup(projectID, todoListID int, todoGroupName string) (*model.TodoGroup, error) {
	todoGroups, err := t.GetGroups(todoListID, projectID)
	if err != nil {
		return nil, err
	}
	for i := range todoGroups {
		if todoGroups[i].Title == todoGroupName {
			return &todoGroups[i], nil
		}
	}
	return t.CreateGroup(projectID, todoListID, model.TodoGroup{Name: todoGroupName})
}

func (t *TodoService) FirstOrCreateTodo(projectID, todoListID int, todoName string) (*model.Todo, error) {
	todos, err := t.GetAllInList(todoListID, projectID)
	if err != nil {
		return nil, err
	}

	for i := range todos {
		// if same project, proceed
		if todos[i].Title == todoName {
			return &todos[i], err
		}
	}
	return t.Create(projectID, todoListID, model.Todo{Content: todoName})
}

func (t *TodoService) FirstOrCreateInvoiceTodo(projectID, todoListID int, invoice *pkgmodel.Invoice) (*model.Todo, error) {
	invoiceTodoName := fmt.Sprintf(`%v %v/%v - #%v`, invoice.Project.Name, invoice.Month, invoice.Year, invoice.Number)
	todos, err := t.GetAllInList(todoListID, projectID)
	if err != nil {
		return nil, err
	}

	re, err := regexp.Compile(utils.RemoveAllSpace(fmt.Sprintf(`%v (%v|0%v)\/%v$`, invoice.Project.Name, invoice.Month, invoice.Month, invoice.Year)))
	if err != nil {
		return nil, err
	}

	for i := range todos {
		if todos[i].Title == invoiceTodoName {
			return &todos[i], nil
		}
		// if same project, proceed
		if re.MatchString(utils.RemoveAllSpace(todos[i].Title)) {
			todos[i].Content = invoiceTodoName
			todos[i].Description = fmt.Sprintf(`<div>%v%v</div>`, todos[i].Description, invoice.TodoAttachment)
			return t.Update(projectID, todos[i])
		}
	}
	return t.Create(projectID, todoListID, model.Todo{Content: invoiceTodoName, Description: fmt.Sprintf(`<div>%v</div>`, invoice.TodoAttachment)})
}

func (t *TodoService) Update(projectID int, todo model.Todo) (*model.Todo, error) {
	url := fmt.Sprintf("%v/%v/buckets/%v/todos/%v.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todo.ID)
	jsonGroup, err := json.Marshal(todo)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonGroup))
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")

	resp, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	res := &model.Todo{}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal(body, res); err != nil {
		return nil, err
	}

	return res, nil
}

func (t *TodoService) Complete(projectID, todoID int) error {
	url := fmt.Sprintf("%v/%v/buckets/%v/todos/%v/completion.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todoID)

	req, err := http.NewRequest("POST", url, nil)
	if err != nil {
		return err
	}

	resp, err := t.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNoContent {
		return fmt.Errorf(`complete req failed with code: %v`, resp.StatusCode)
	}

	return nil
}

```

# pkg/service/basecamp/todo/service.go

```go
package todo

import (
	pkgmodel "github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type Service interface {
	CreateList(projectID int, todoSetID int, todoList model.TodoList) (result *model.TodoList, err error)
	CreateGroup(projectID int, todoListID int, group model.TodoGroup) (result *model.TodoGroup, err error)
	Create(projectID int, todoListID int, todo model.Todo) (result *model.Todo, err error)
	Get(url string) (result *model.Todo, err error)
	GetAllInList(todoListID int, projectID int, query ...string) (result []model.Todo, err error)
	GetGroups(todoListID int, projectID int) (result []model.TodoGroup, err error)
	GetLists(projectID int, todoSetID int) (result []model.TodoList, err error)
	GetList(url string) (result *model.TodoList, err error)
	GetProjectsLatestIssue(projectNames []string) (result []*pkgmodel.ProjectIssue, err error)
	CreateHiring(cv *pkgmodel.Candidate) (err error)
	FirstOrCreateList(projectID int, todoSetID int, todoListName string) (result *model.TodoList, err error)
	FirstOrCreateGroup(projectID int, todoListID int, todoGroupName string) (result *model.TodoGroup, err error)
	FirstOrCreateInvoiceTodo(projectID, todoListID int, invoice *pkgmodel.Invoice) (result *model.Todo, err error)
	Update(projectID int, todo model.Todo) (result *model.Todo, err error)
	FirstOrCreateTodo(projectID, todoListID int, todoName string) (result *model.Todo, err error)
	Complete(projectID, todoID int) (err error)
}

```

# pkg/service/basecamp/subscription/subscription.go

```go
package subscription

import (
	"bytes"
	"encoding/json"
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type SubscriptionService struct {
	client client.Service
}

func NewService(client client.Service) Service {
	return &SubscriptionService{
		client: client,
	}
}

func (s *SubscriptionService) Subscribe(url string, list *model.SubscriptionList) error {
	json, err := json.Marshal(list)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("PUT", url, bytes.NewBuffer(json))
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")
	resp, err := s.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

```

# pkg/service/basecamp/subscription/service.go

```go
package subscription

import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"

type Service interface {
	Subscribe(url string, list *model.SubscriptionList) (err error)
}

```

# pkg/service/basecamp/schedule/service.go

```go
package schedule

import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"

type Service interface {
	CreateScheduleEntry(projectID int64, scheduleID int64, scheduleEntry model.ScheduleEntry) (res *model.ScheduleEntry, err error)
	GetScheduleEntries(projectID int64, scheduleID int64) (res []*model.ScheduleEntry, err error)
	UpdateSheduleEntry(projectID int64, se *model.ScheduleEntry) (err error)
}

```

# pkg/service/basecamp/schedule/schedule.go

```go
package schedule

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type ScheduleService struct {
	client client.Service
	logger logger.Logger
}

func NewService(client client.Service, logger logger.Logger) Service {
	return &ScheduleService{
		client: client,
		logger: logger,
	}
}

func (s *ScheduleService) CreateScheduleEntry(projectID int64, scheduleID int64, scheduleEntry model.ScheduleEntry) (*model.ScheduleEntry, error) {
	url := fmt.Sprintf("%v/%v/buckets/%v/schedules/%v/entries.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, scheduleID)
	jsonTodo, err := json.Marshal(scheduleEntry)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonTodo))
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", "application/json")
	resp, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	res := &model.ScheduleEntry{}
	err = json.Unmarshal(b, res)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (s *ScheduleService) GetScheduleEntries(projectID, scheduleID int64) ([]*model.ScheduleEntry, error) {
	url := fmt.Sprintf("%v/%v/buckets/%v/schedules/%v/entries.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, scheduleID)

	res := []*model.ScheduleEntry{}
	get := func(page int) (bool, error) {
		req, err := http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil)
		if err != nil {
			s.logger.AddField("url", url).Error(err, "failed to create req")
			return false, err
		}
		resp, err := s.client.Do(req)
		if err != nil {
			s.logger.Error(err, "failed to send req")
			return false, err
		}
		defer resp.Body.Close()

		if resp.StatusCode/100 > 2 {
			err = fmt.Errorf("failed to get schedule entries")
			s.logger.Fields(logger.Fields{
				"StatusCode": resp.StatusCode,
				"ProjectID":  projectID,
				"ScheduleID": scheduleID,
			}).Error(err, "request failed")
			return false, err
		}

		entries, err := responseToScheduleEntries(resp)
		if err != nil {
			return false, err
		}
		res = append(res, entries...)

		return (resp.Header.Get("Link") != ""), nil
	}

	page := 1
	for {
		morePage, err := get(page)
		if err != nil {
			return nil, err
		}
		if !morePage {
			return res, nil
		}
		page++
	}
}

func responseToScheduleEntries(res *http.Response) ([]*model.ScheduleEntry, error) {
	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	var scheduleEntries []*model.ScheduleEntry
	err = json.Unmarshal(body, &scheduleEntries)
	if err != nil {
		logger.L.AddField("body", string(body)).Error(err, "failed to unmarshal body")
		return nil, err
	}

	return scheduleEntries, nil
}

func (s *ScheduleService) UpdateSheduleEntry(projectID int64, se *model.ScheduleEntry) error {
	url := fmt.Sprintf("%v/%v/buckets/%v/schedule_entries/%v.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, se.ID)
	jsonTodo, err := json.Marshal(se)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonTodo))
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")
	resp, err := s.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return err
}

```

# pkg/service/basecamp/recording/service.go

```go
package recording

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type Service interface {
	GetFrom(from time.Time, recordingType string) ([]model.Recording, error)
	GetEvents(from time.Time, projectID, recordingID int) ([]model.Event, error)
	Trash(projectID string, recordingID string) (err error)
	Archive(projectID, recordingID int) error
	TryToGetInvoiceImageURL(url string) (res string, err error)
}

```

# pkg/service/basecamp/recording/recording.go

```go
package recording

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/antchfx/htmlquery"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type RecordingService struct {
	client client.Service
}

func NewService(client client.Service) Service {
	return &RecordingService{
		client: client,
	}
}

func (r *RecordingService) Trash(projectID, recordingID string) error {
	url := fmt.Sprintf("%v/%v/buckets/%v/recordings/%v/status/trashed.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, recordingID)

	req, err := http.NewRequest("PUT", url, nil)
	if err != nil {
		return err
	}

	res, err := r.client.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	return nil
}

func (r *RecordingService) TryToGetInvoiceImageURL(url string) (string, error) {
	resp, err := r.client.Get(url)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	tmp := make(map[string]interface{})
	err = json.NewDecoder(resp.Body).Decode(&tmp)
	if err != nil {
		return "", err
	}

	strI, ok := tmp["description"]
	if !ok {
		return "", nil
	}
	str, ok := strI.(string)
	if !ok {
		return "", nil
	}

	return ensureToGetImageURLFromRawHTML(str), nil
}

func ensureToGetImageURLFromRawHTML(raw string) string {
	doc, err := htmlquery.Parse(strings.NewReader(raw))
	if err != nil {
		return ""
	}

	// try to get first img url from raw html
	node := htmlquery.FindOne(doc, "//img")
	if node == nil {
		return ""
	}
	for _, v := range node.Attr {
		if v.Key == "src" {
			return v.Val
		}
	}

	return ""
}

func (r *RecordingService) Archive(projectID, recordingID int) error {
	url := fmt.Sprintf("%v/%v/buckets/%d/recordings/%d/status/archived.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, recordingID)

	req, err := http.NewRequest("PUT", url, nil)
	if err != nil {
		return err
	}

	res, err := r.client.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	return nil
}

func (r *RecordingService) GetFrom(from time.Time, recordingType string) ([]model.Recording, error) {
	url := fmt.Sprintf("%v/%v/projects/recordings.json?type=%v&sort=updated_at", model.BasecampAPIEndpoint, model.CompanyID, recordingType)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	res, err := r.client.Do(req)
	if err != nil {
		return nil, err
	}

	defer res.Body.Close()

	var recordings, result []model.Recording
	if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
		return nil, err
	}
	for _, recording := range recordings {
		if recording.UpdatedAt.Before(from) {
			return result, nil
		}
		result = append(result, recording)
	}
	link := res.Header.Get("Link")
	page := 2
	for link != "" {
		var request *http.Request
		request, err = http.NewRequest("GET", fmt.Sprintf("%v&page=%v", url, page), nil)
		if err != nil {
			return nil, err
		}

		var response *http.Response
		response, err = r.client.Do(request)
		if err != nil {
			return nil, err
		}
		defer response.Body.Close()

		ss := []model.Recording{}
		if err := json.NewDecoder(response.Body).Decode(&ss); err != nil {
			return nil, err
		}
		for _, recording := range ss {
			if recording.UpdatedAt.Before(from) {
				return result, nil
			}
			result = append(result, recording)
		}

		link = response.Header.Get("Link")
		page++
	}

	return result, nil
}

func (r *RecordingService) GetEvents(from time.Time, projectID, recordingID int) ([]model.Event, error) {
	url := fmt.Sprintf("%v/%v/buckets/%v/recordings/%v/events.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, recordingID)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	res, err := r.client.Do(req)
	if err != nil {
		return nil, err
	}

	defer res.Body.Close()

	var events, result []model.Event
	if err := json.NewDecoder(res.Body).Decode(&events); err != nil {
		return nil, err
	}
	for _, event := range events {
		if event.CreatedAt.Before(from) {
			return result, nil
		}
		result = append(result, event)
	}
	link := res.Header.Get("Link")
	page := 2
	for link != "" {
		var request *http.Request
		request, err = http.NewRequest("GET", fmt.Sprintf("%v&page=%v", url, page), nil)
		if err != nil {
			return nil, err
		}

		var response *http.Response
		response, err = r.client.Do(request)
		if err != nil {
			return nil, err
		}
		defer response.Body.Close()

		ss := []model.Event{}
		if err := json.NewDecoder(response.Body).Decode(&ss); err != nil {
			return nil, err
		}
		for _, event := range ss {
			if event.CreatedAt.Before(from) {
				return result, nil
			}
			result = append(result, event)
		}

		link = response.Header.Get("Link")
		page++
	}

	return result, nil
}

```

# pkg/service/basecamp/project/service.go

```go
package project

import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"

type Service interface {
	GetAll() (result []model.Project, err error)
	Get(id int) (result model.Project, err error)
}

```

# pkg/service/basecamp/project/project.go

```go
package project

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type ProjectService struct {
	client client.Service
}

func NewService(client client.Service) Service {
	return &ProjectService{
		client: client,
	}
}

func (p *ProjectService) GetAll() ([]model.Project, error) {
	url := fmt.Sprintf(`https://3.basecampapi.com/%d/projects.json`, consts.CompanyBasecampID)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	res, err := p.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	var result []model.Project
	if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result, nil
}

func (p *ProjectService) Get(id int) (model.Project, error) {
	var result model.Project
	url := fmt.Sprintf(`https://3.basecampapi.com/%d/projects/%d.json`, consts.CompanyBasecampID, id)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return result, err
	}

	res, err := p.client.Do(req)
	if err != nil {
		return result, err
	}
	defer res.Body.Close()

	if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
		return result, err
	}

	return result, nil
}

```

# pkg/service/basecamp/people/service.go

```go
package people

import (
	"errors"

	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

var (
	ErrNotInProject = errors.New("this account does not belong to this project")
)

type Service interface {
	GetByID(id int) (res *model.Person, err error)
	GetInfo() (res *model.UserInfo, err error)
	Create(name string, email string, orgnization string) (id int64, sgID string, err error)
	Remove(userID int64) (err error)
	UpdateInProject(projectID int64, peopleEntry model.PeopleEntry) (id int64, sgID string, err error)
	GetAllOnProject(projectID int) (result []model.Person, err error)
}

```

# pkg/service/basecamp/people/people.go

```go
package people

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/project"
)

type PeopleService struct {
	client client.Service
}

func NewService(client client.Service) Service {
	return &PeopleService{
		client: client,
	}
}

func (p *PeopleService) GetByID(id int) (*model.Person, error) {
	url := fmt.Sprintf(`https://3.basecampapi.com/%d/people/%d.json`, consts.CompanyBasecampID, id)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	res, err := p.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	var person model.Person
	if err := json.NewDecoder(res.Body).Decode(&person); err != nil {
		return nil, err
	}

	return &person, nil
}

// GetUserInfo get UserInfo func
func (p *PeopleService) GetInfo() (*model.UserInfo, error) {
	req, err := http.NewRequest("GET", model.GetBasecampUserInfoURL, nil)
	if err != nil {
		return nil, err
	}

	res, err := p.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	var result model.UserInfo
	if err = json.NewDecoder(res.Body).Decode(&result); err != nil {
		return nil, err
	}

	return &result, nil
}

func (p *PeopleService) Create(name, email, organization string) (id int64, sgID string, err error) {
	woodlandEntry := model.PeopleEntry{
		Create: []model.PeopleCreate{
			{
				Name:         name,
				EmailAddress: email,
				CompanyName:  organization,
			},
		},
	}
	return p.UpdateInProject(consts.WoodlandID, woodlandEntry)
}

func (p *PeopleService) UpdateInProject(projectID int64, peopleEntry model.PeopleEntry) (int64, string, error) {
	url := fmt.Sprintf("%v/%v/projects/%v/people/users.json", model.BasecampAPIEndpoint, model.CompanyID, projectID)
	jsonAdd, err := json.Marshal(peopleEntry)
	if err != nil {
		return 0, "", err
	}

	req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonAdd))
	if err != nil {
		return 0, "", err
	}

	req.Header.Add("Content-Type", "application/json")

	res, err := p.client.Do(req)
	if err != nil {
		return 0, "", err
	}
	defer res.Body.Close()

	response := struct {
		Granted []struct {
			ID   int64  `json:"id"`
			SgID string `json:"attachable_sgid"`
		} `json:"granted"`
		Revoked []struct {
			ID   int64  `json:"id"`
			SgID string `json:"attachable_sgid"`
		} `json:"revoked"`
	}{}
	err = json.NewDecoder(res.Body).Decode(&response)
	if err != nil {
		return 0, "", err
	}
	if len(response.Granted) == 0 && len(response.Revoked) == 0 {
		return 0, "", ErrNotInProject
	}
	if len(response.Granted) == 0 {
		return response.Revoked[0].ID, response.Revoked[0].SgID, nil
	}

	return response.Granted[0].ID, response.Granted[0].SgID, nil
}

func (p *PeopleService) Remove(userID int64) error {
	projects, err := project.NewService(p.client).GetAll()
	if err != nil {
		return err
	}
	peopleEntry := model.PeopleEntry{
		Revoke: []int64{userID},
	}
	for i := range projects {
		_, _, err = p.UpdateInProject(projects[i].ID, peopleEntry)
		if err != nil && err != ErrNotInProject {
			return err
		}
	}
	return nil
}

func (p *PeopleService) GetAllOnProject(projectID int) ([]model.Person, error) {
	url := fmt.Sprintf(`https://3.basecampapi.com/%d/projects/%d/people.json`, consts.CompanyBasecampID, projectID)

	var people []model.Person
	get := func(page int) (bool, error) {
		req, err := http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil)
		if err != nil {
			return false, err
		}
		res, err := p.client.Do(req)
		if err != nil {
			return false, err
		}
		defer res.Body.Close()

		var p []model.Person
		b, err := io.ReadAll(res.Body)
		if err != nil {
			return false, err
		}
		if err := json.Unmarshal(b, &p); err != nil {
			return false, err
		}
		people = append(people, p...)

		return (res.Header.Get("Link") != ""), nil
	}

	page := 1
	for {
		morePage, err := get(page)
		if err != nil {
			return nil, err
		}
		if !morePage {
			return people, nil
		}
		page++
	}
}

```

# pkg/service/basecamp/messageboard/service.go

```go
package messageboard

import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"

// Service -- message board service
type Service interface {
	Create(message *model.Message, projectID, messageBoardID int) (err error)
	GetList(projectID int, messageBoardID int) (messages []model.Message, err error)
	Get(projectID int, messageID int) (message model.Message, err error)
}

```

# pkg/service/basecamp/messageboard/message_board.go

```go
package messageboard

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type messageBoard struct {
	client client.Service
}

// NewService -- create new message board service
func NewService(client client.Service) Service {
	return &messageBoard{
		client: client,
	}
}

func (m *messageBoard) Create(message *model.Message, projectID int, messageBoardID int) error {
	url := fmt.Sprintf("%v/%v/buckets/%v/message_boards/%v/messages.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, messageBoardID)
	jsonMessage, err := json.Marshal(message)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonMessage))
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")
	res, err := m.client.Do(req)
	if err != nil {
		return err
	}

	b, err := io.ReadAll(res.Body)
	if err != nil {
		return err
	}

	if res.StatusCode != http.StatusCreated {
		err = errors.New(string(b))
		return err
	}

	if err = json.Unmarshal(b, message); err != nil {
		return err
	}
	defer res.Body.Close()

	return nil
}

func (m *messageBoard) Get(projectID int, messageID int) (message model.Message, err error) {
	res := model.Message{}
	url := fmt.Sprintf("%v/%v/buckets/%v/messages/%v.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, messageID)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return res, err
	}
	resp, err := m.client.Do(req)
	if err != nil {
		return res, err
	}
	if resp.StatusCode != http.StatusOK {
		b, err := io.ReadAll(resp.Body)
		if err != nil {
			return res, err
		}
		return res, errors.New(string(b))
	}
	defer resp.Body.Close()

	if err := json.NewDecoder(resp.Body).Decode(&res); err != nil {
		return res, err
	}

	return res, nil
}

func (m *messageBoard) GetList(projectID int, messageBoardID int) ([]model.Message, error) {
	url := fmt.Sprintf("%v/%v/buckets/%v/message_boards/%v/messages.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, messageBoardID)

	res := []model.Message{}
	get := func(page int) (bool, error) {
		req, err := http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil)
		if err != nil {
			return false, err
		}
		resp, err := m.client.Do(req)
		if err != nil {
			return false, err
		}
		if resp.StatusCode != http.StatusOK {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return false, err
			}
			return false, errors.New(string(b))
		}
		defer resp.Body.Close()

		var msg []model.Message
		if err := json.NewDecoder(resp.Body).Decode(&msg); err != nil {
			return false, err
		}
		res = append(res, msg...)

		return (resp.Header.Get("Link") != ""), nil
	}

	page := 1
	for {
		morePage, err := get(page)
		if err != nil {
			return nil, err
		}
		if !morePage {
			return res, nil
		}
		page++
	}
}

```

# pkg/service/basecamp/model/model.go

```go
package model

import (
	"encoding/json"
	"time"
)

const (
	CompanyID              = "4108948"
	GetBasecampUserInfoURL = "https://launchpad.37signals.com/authorization.json"
	BasecampEndpoint       = "https://launchpad.37signals.com/authorization"
	BasecampAPIEndpoint    = "https://3.basecampapi.com"
)

type Person struct {
	ID             int    `json:"id"`
	AttachableSgID string `json:"attachable_sgid"`
	Name           string `json:"name"`
	EmailAddress   string `json:"email_address"`
	Title          string `json:"title"`
	Bio            string `json:"bio"`
}

// UserInfo fully define basecamp user info struct
type UserInfo struct {
	ExpiresAt time.Time `json:"expires_at"`
	Identity  Identity  `json:"identity"`
}

// Identity define User Identity
type Identity struct {
	ID           int    `json:"id"`
	FirstName    string `json:"first_name"`
	LastName     string `json:"last_name"`
	EmailAddress string `json:"email_address"`
}

// AuthenticationResponse define basecamp auth response
type AuthenticationResponse struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
	ExpiresIn    int    `json:"expires_in"`
}

// Basecamp define basecamp config struct
type Basecamp struct {
	ClientID     string
	ClientSecret string
	RedirectURI  string
}

type SubscriptionList struct {
	Subscriptions   []int `json:"subscriptions"`
	Unsubscriptions []int `json:"unsubscriptions"`
}

type TodoList struct {
	ID              int     `json:"id"`
	Name            string  `json:"name"`
	Description     string  `json:"description"`
	Title           string  `json:"title"`
	Type            string  `json:"type"`
	CreatedAt       string  `json:"created_at"`
	TodosURL        string  `json:"todos_url"`
	UpdatedAt       string  `json:"updated_at"`
	Parent          *Parent `json:"parent"`
	SubscriptionURL string  `json:"subscription_url"`
}

type TodoGroup struct {
	ID             int       `json:"id"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
	Title          string    `json:"title"`
	InheritsStatus bool      `json:"inherits_status"`
	Type           string    `json:"type"`
	Parent         *Parent   `json:"parent"`
	Completed      bool      `json:"completed"`
	CompletedRatio string    `json:"completed_ratio"`
	SubscriberIDs  []int     `json:"subscriber_ids"`
	Name           string    `json:"name"`
}

type Todo struct {
	ID                    int          `json:"id"`
	Title                 string       `json:"title"`
	Type                  string       `json:"type"`
	Assignees             []Assignee   `json:"assignees"`
	AssigneeIDs           []int        `json:"assignee_ids"`
	CompletionSubscribers []Subscriber `json:"completion_subscribers"`
	Completed             bool         `json:"completed"`
	AppURL                string       `json:"app_url"`
	Content               string       `json:"content"`
	CommentsURL           string       `json:"comments_url"`
	Description           string       `json:"description"`
	DueOn                 string       `json:"due_on"`
	InheritsStatus        bool         `json:"inherits_status"`
	StartsOn              string       `json:"starts_on"`
	Status                string       `json:"status"`
	Parent                *Parent      `json:"parent"`
	SubscriptionURL       string       `json:"subscription_url"`
	CreatedAt             string       `json:"created_at"`
	UpdatedAt             string       `json:"updated_at"`
	Notify                bool         `json:"notify"`
	Bucket                Bucket       `json:"bucket"`
}

type Subscriber struct {
	ID             int       `json:"id"`
	Name           string    `json:"name"`
	EmailAddress   string    `json:"email_address"`
	PersonableType string    `json:"personable_type"`
	Title          string    `json:"title"`
	Bio            string    `json:"bio"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
	Admin          bool      `json:"admin"`
	Owner          bool      `json:"owner"`
	TimeZone       string    `json:"time_zone"`
	AvatarURL      string    `json:"avatar_url"`
}

type Comment struct {
	ID             int64     `json:"id"`
	Status         string    `json:"status"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
	Title          string    `json:"title"`
	InheritsStatus bool      `json:"inherits_status"`
	Type           string    `json:"type"`
	URL            string    `json:"url"`
	AppURL         string    `json:"app_url"`
	BookmarkURL    string    `json:"bookmark_url"`
	Parent         Parent    `json:"parent"`
	Bucket         Bucket    `json:"bucket"`
	Creator        Assignee  `json:"creator"`
	Content        string    `json:"content"`
}

type Parent struct {
	ID    int    `json:"id"`
	Title string `json:"title"`
	Type  string `json:"type"`
	URL   string `json:"url"`
}

type Bucket struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
	Type string `json:"type"`
}

type Assignee struct {
	Admin          bool        `json:"admin"`
	AttachableSgid string      `json:"attachable_sgid"`
	AvatarURL      string      `json:"avatar_url"`
	Bio            interface{} `json:"bio"`
	CreatedAt      string      `json:"created_at"`
	EmailAddress   string      `json:"email_address"`
	ID             int         `json:"id"`
	Name           string      `json:"name"`
	Owner          bool        `json:"owner"`
	PersonableType string      `json:"personable_type"`
	TimeZone       string      `json:"time_zone"`
	Title          string      `json:"title"`
	UpdatedAt      string      `json:"updated_at"`
}

type Project struct {
	CreatedAt   string        `json:"created_at"`
	Description string        `json:"description"`
	Dock        []ProjectDock `json:"dock"`
	ID          int64         `json:"id"`
	Name        string        `json:"name"`
	Purpose     string        `json:"purpose"`
	Status      string        `json:"status"`
	UpdatedAt   string        `json:"updated_at"`
	URL         string        `json:"url"`
}

type ProjectDock struct {
	AppURL   string `json:"app_url"`
	Enabled  bool   `json:"enabled"`
	ID       int    `json:"id"`
	Name     string `json:"name"`
	Position int    `json:"position"`
	Title    string `json:"title"`
	URL      string `json:"url"`
}

type ScheduleEntry struct {
	ID                 json.Number         `json:"id"`
	Summary            string              `json:"summary"`
	Description        string              `json:"description"`
	ParticipantIDs     []int               `json:"participant_ids"`
	Participants       []*Assignee         `json:"participants"`
	AllDay             bool                `json:"all_day"`
	Notify             bool                `json:"notify"`
	AppUrl             string              `json:"app_url"`
	StartsAt           string              `json:"starts_at"`
	EndsAt             string              `json:"ends_at"`
	RecurrenceSchedule *RecurrenceSchedule `json:"recurrence_schedule"`
	SubscriptionUrl    string              `json:"subscription_url"`
}

type RecurrenceSchedule struct {
	Days         []int  `json:"days"`
	WeekInstance int    `json:"week_instance"`
	Frequency    string `json:"frequency"`
	StartDate    string `json:"start_date"`
	EndDate      string `json:"end_date"`
}

type PeopleCreate struct {
	Name         string `json:"name"`
	EmailAddress string `json:"email_address"`
	CompanyName  string `json:"company_name"`
}

type PeopleEntry struct {
	Grant  []int64        `json:"grant"`
	Revoke []int64        `json:"revoke"`
	Create []PeopleCreate `json:"create"`
}

type CampfireLine struct {
	Content string `json:"content"`
}

type Hook struct {
	ID         int       `json:"id"`
	Active     bool      `json:"active"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
	PayloadURL string    `json:"payload_url"`
	Types      []string  `json:"types"`
	URL        string    `json:"url"`
	AppURL     string    `json:"app_url"`
}

type Message struct {
	ID          int        `json:"id"`
	Subject     string     `json:"subject"`
	Content     string     `json:"content"`
	Status      string     `json:"status"`
	AppURL      string     `json:"app_url"`
	CommentsURL string     `json:"comments_url"`
	CreatedAt   *time.Time `json:"created_at"`
}

type Recording struct {
	ID               int       `json:"id"`
	Status           string    `json:"status"`
	VisibleToClients bool      `json:"visible_to_clients"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
	Title            string    `json:"title"`
	InheritsStatus   bool      `json:"inherits_status"`
	Type             string    `json:"type"`
	URL              string    `json:"url"`
	AppURL           string    `json:"app_url"`
	BookmarkURL      string    `json:"bookmark_url"`
	SubscriptionURL  string    `json:"subscription_url"`
	CommentsCount    int       `json:"comments_count"`
	CommentsURL      string    `json:"comments_url"`
	Position         int       `json:"position,omitempty"`
	Parent           Parent    `json:"parent"`
	Bucket           Bucket    `json:"bucket"`
	Creator          Person    `json:"creator"`
	Description      string    `json:"description"`
	Completed        bool      `json:"completed"`
	Content          string    `json:"content"`
	StartsOn         string    `json:"starts_on"`
	DueOn            string    `json:"due_on"`
}

type Event struct {
	ID          int       `json:"id"`
	RecordingID int       `json:"recording_id"`
	Action      string    `json:"action"`
	CreatedAt   time.Time `json:"created_at"`
	Creator     Person    `json:"creator"`
}

// below is list of message model, use with caution
const (
	BasecampCommentMsg    string = "basecamp_comment"
	BasecampTodoMsg       string = "basecamp_todo"
	BasecampHiringTodoMsg string = "basecamp_todo_hiring"
)

const (
	CommentMsgTypeFailed    string = "failed"
	CommentMsgTypeCompleted string = "completed"
)

// BasecampCommentMessage is use for worker to create a basecamp comment
type BasecampCommentMessage struct {
	ProjectID   int
	RecordingID int
	Payload     *Comment
}

type BasecampTodoMessageModel struct {
	ProjectID int
	ListID    int
	Payload   Todo
}

```

# pkg/service/basecamp/consts/consts.go

```go
package consts

// Define basecamp resource id
const (
	WoodlandScheduleID             int64 = 1346305137
	PlaygroundScheduleID           int64 = 1941398077
	WoodlandID                           = 9403032
	PlaygroundID                         = 12984857
	PlaygroundCampfireID                 = 1941398072
	HiringID                             = 13171568
	HiringScheduleID                     = 1974612191
	PlaygroundTodoID                     = 1941398075
	PlaygroundDynamicsTodoID             = 2235833582
	PlaygroundExpenseTodoID              = 2436015405
	FoundationID                         = 9405283
	FoundationTodoID                     = 1346687281
	FoundationCampfireID                 = 1346687275
	WoodlandDynamicsTodoID               = 2566078344
	VenturesID                           = 13484002
	DesignID                             = 9404034
	OperationID                          = 9403043
	ManagementID                         = 15240223
	AccountingID                         = 15258324
	TechRadarID                          = 13307382
	ReadifyID                            = 16277845
	ReadifyCampfireID                    = 2502884934
	HookID                               = 393058
	WoodlandTodoID                       = 1346305133
	OperationTodoID                      = 1346306047
	ManagementTodoID                     = 2326974480
	AccountingTodoID                     = 2329633561
	ExpenseTodoID                        = 2353511928
	AutoBotID                            = 25727627
	WoodlandMessageBoardID               = 1346305130
	PlaygroundMessageBoardID             = 1941398073
	HiringMessageBoardID                 = 1974612189
	CompanyBasecampID                    = 4108948
	ProjectManagementID                  = 1970322248
	TechRadarProjectID                   = 13307382
	TechRadarMessageBoardID              = 1998256729
	TechRadarTodoSetID                   = 1998256730
	TechRadarAssessTodoListID            = 1998259939 // temporary hardcode
	HiringTodoSetID                      = 1974612190
	HRTodoID                             = 2040601263
	TechRadarCampfireID                  = 1998256728
	OperationCampfireID                  = 1346306044
	WoodlandCampfireID                   = 1346305126
	FortressCampfireID                   = 1347531395
	HiringCampfireID                     = 1974612188
	FortressID                           = 9410372
	OnleaveID                            = 6935836756
	OnleavePlaygroundID                  = 2243342506
	WarehouseID                          = 15921521
	PlaygroundHRTodoID                   = 2475678340
	BirthdayGift2020                     = 2576503375
	BirthdayGift2021                     = 3338845535
	PaperTrailTodoListID                 = 2685205937
	PlaygroundPaperTrailTodoListID       = 2685503124
	ShareholderID                        = 16944388
	ShareholderCampfireID                = 2635581864
	SudoID                               = 16473245
	SudoCampfireID                       = 2538063314
	OpsExpenseTodoID                     = 4665885355
	PlaygroundBirthdayTodoID             = 3942871393
	BirthdayToDoListID                   = 3941578970

	// People
	LyBasecampID           = 21564173
	HanBasecampID          = 21562923
	QuangBasecampID        = 22659105
	AnBasecampID           = 21562943
	HuyNguyenBasecampID    = 22658825
	HuyGiangBasecampID     = 22658816
	MinhTranBasecampID     = 21564151
	NamTranBasecampID      = 21675130
	DuyenBasecampID        = 26160403
	TrungPhanBasecampID    = 21574701
	PhuongTruongBasecampID = 21842626
	ThanhNguyenBasecampID  = 21572501
	VanNguyenBasecampID    = 26595807
	KhaiLeBasecampID       = 24006290
	KhanhTruongBasecampID  = 24419646
	GiangThanBasecampID    = 26160802
	HelenBasecampID        = 40439249
	ThuongBasecampID       = 38246363
	NamNguyenBasecampID    = 21581534

	// BucketName
	BucketNameWoodLand   = "Woodland"
	BucketNamePlayGround = "Fortress | Playground"

	// OrgChart
	ManagementLevel = 3

	// Basecamp kind list
	TodoCreate         = "todo_created"
	TodoComplete       = "todo_completed"
	TodoUncomplete     = "todo_uncompleted"
	CommentCreate      = "comment_created"
	MessageBoardCreate = "message_created"
	MessageBoardActive = "message_active"

	AutoBotSgID = "BAh7CEkiCGdpZAY6BkVUSSIpZ2lkOi8vYmMzL1BlcnNvbi8yNTcyNzYyNz9leHBpcmVzX2luBjsAVEkiDHB1cnBvc2UGOwBUSSIPYXR0YWNoYWJsZQY7AFRJIg9leHBpcmVzX2F0BjsAVDA=--5a1528460315bfd57bc41cf6bd3f899b1c346e7b"

	// Basecamp Comment Message
	CommentThankYouEmailSent                      = "Thank you email has been sent"
	CommentThankYouEmailFailed                    = "Unable to send thank you email invoice."
	CommentUpdateInvoiceSuccessfully              = "Invoice status has been set to paid"
	CommentUpdateInvoiceFailed                    = `Unable to update invoice status`
	CommentMoveInvoicePDFToPaidDirSuccessfully    = "GDrive file has been updated"
	CommentMoveInvoicePDFToPaidDirFailed          = "Unable to move invoice pdf to paid directory"
	CommentCantFindInvoice                        = "Invoice not found"
	CommentInvoiceFileMoved                       = "Invoice file has been moved to Paid folder in Google Drive"
	CommentUnableToUpdateGDLoc                    = "Unable to update Google Drive location"
	CommentMissingConfirmation                    = "Missing Confirmation"
	CommentInvalidOnLeaveFormat                   = "Invalid on leave format"
	CommentCreateScheduleSuccessfully             = "Create schedule successfully"
	CommentCreateScheduleFailed                   = "Unable to create schedule"
	CommentCreateExpenseSuccessfully              = "Create expense successfully"
	CommentCreateExpenseFailed                    = "Unable to create expense"
	CommentDeleteExpenseSuccessfully              = "Delete expense successfully"
	CommentDeleteExpenseFailed                    = "Delete expense failed"
	CommentStoreAccountingTransactionFailed       = "Store accounting transaction failed"
	CommentStoreAccountingTransactionSuccessfully = "Store accounting transaction successfully"
	CommentProbationReviewSuccessfully            = "Probation review succeed"
	CommentThankYouEmailSentSuccessfully          = "Thank you email sent successfully"
	CommentOfferEmailSentSuccessfully             = "Offer email sent successfully"
	CommentHiringNoActionTaken                    = "Neither Offered nor Fail, no action taken"
	CommentHiredCandidate                         = "Candidate hired"
	CommentRejectedCandidate                      = "Candidate rejected"
)

```

# pkg/service/basecamp/comment/service.go

```go
package comment

import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"

type Service interface {
	Create(projectID int, recordingID int, comment *model.Comment) (err error)
	Gets(projectID int, recordingID int) (res []model.Comment, err error)
}

```

# pkg/service/basecamp/comment/comment.go

```go
package comment

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type CommentService struct {
	client client.Service
}

func NewService(client client.Service) Service {
	return &CommentService{
		client: client,
	}
}

func (c *CommentService) Create(projectID int, recordingID int, comment *model.Comment) error {
	url := fmt.Sprintf("%v/%v/buckets/%v/recordings/%v/comments.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, recordingID)
	jsonGroup, err := json.Marshal(comment)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonGroup))
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")
	res, err := c.client.Do(req)
	if err != nil {
		return err
	}

	res.Body.Close()
	return nil
}

func (c *CommentService) Gets(projectID int, recordingID int) ([]model.Comment, error) {
	comments := []model.Comment{}
	url := fmt.Sprintf("%v/%v/buckets/%v/recordings/%v/comments.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, recordingID)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return comments, err
	}

	res, err := c.client.Do(req)
	if err != nil {
		return comments, err
	}
	defer res.Body.Close()

	if err = json.NewDecoder(res.Body).Decode(&comments); err != nil {
		return comments, err
	}
	link := res.Header.Get("Link")
	page := 2
	for link != "" {
		var request *http.Request
		request, err = http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil)
		if err != nil {
			return nil, err
		}
		request.Header.Add("Content-Type", "application/json")

		var response *http.Response
		response, err = c.client.Do(request)
		if err != nil {
			return nil, err
		}
		defer response.Body.Close()

		ss := []model.Comment{}
		if err := json.NewDecoder(response.Body).Decode(&ss); err != nil {
			return nil, err
		}
		comments = append(comments, ss...)

		link = response.Header.Get("Link")
		page++
	}

	return comments, nil
}

```

# pkg/service/basecamp/campfire/service.go

```go
package campfire

type Service interface {
	CreateLine(projectID int, campfireID int, line string) (err error)
	BotCreateLine(projectID int, campfireID int, line string) (err error)
	BotReply(callbackURL string, message string) (err error)
}

```

# pkg/service/basecamp/campfire/campfire.go

```go
package campfire

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type CampfireService struct {
	client client.Service
	logger logger.Logger
	cfg    *config.Config
}

func NewService(client client.Service, logger logger.Logger, cfg *config.Config) Service {
	return &CampfireService{
		client: client,
		logger: logger,
		cfg:    cfg,
	}
}

func (c *CampfireService) CreateLine(projectID, campfireID int, line string) error {
	url := fmt.Sprintf("%v/%v/buckets/%v/chats/%v/lines.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, campfireID)

	jsonMessage, err := json.Marshal(model.CampfireLine{Content: line})
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonMessage))
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")
	res, err := c.client.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	return nil
}

func (c *CampfireService) BotCreateLine(projectID, campfireID int, line string) error {
	url := fmt.Sprintf("%v/%v/integrations/%v/buckets/%v/chats/%v/lines.json", model.BasecampAPIEndpoint, model.CompanyID, c.cfg.Basecamp.BotKey, projectID, campfireID)

	jsonMessage, err := json.Marshal(model.CampfireLine{Content: line})
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonMessage))
	if err != nil {
		return err
	}

	req.Header.Add("Content-Type", "application/json")
	res, err := c.client.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	return nil
}

func (c *CampfireService) BotReply(callbackURL string, message string) error {
	campfireMessage := model.CampfireLine{Content: message}
	jsonMessage, err := json.Marshal(campfireMessage)
	if err != nil {
		c.logger.AddField("message", campfireMessage).Error(err, "failed to marshal message")
		return err
	}
	resp, err := http.Post(callbackURL, "application/json", bytes.NewBuffer(jsonMessage))
	if err != nil {
		c.logger.Fields(logger.Fields{"message": campfireMessage, "url": callbackURL}).Error(err, "failed to send request")
		return err
	}
	defer resp.Body.Close()
	data, err := io.ReadAll(resp.Body)
	if err != nil {
		c.logger.Error(err, "read response body failed")
		return err
	}
	if resp.StatusCode/100 > 2 {
		err = fmt.Errorf(string(data))
		c.logger.Fields(logger.Fields{"code": resp.StatusCode}).Error(err, "request failed")
		return err
	}

	return nil
}

```

# pkg/service/basecamp/client/service.go

```go
package client

import "net/http"

type Service interface {
	Get(url string) (resp *http.Response, err error)
	Do(req *http.Request) (resp *http.Response, err error)
	GetAccessToken(code string, redirectURI string) (accessToken string, err error)
}

```

# pkg/service/basecamp/client/client.go

```go
package client

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/logger"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
	"golang.org/x/oauth2"
)

var (
	basecampOauthConfig = &oauth2.Config{
		Endpoint: oauth2.Endpoint{
			AuthURL:   "https://launchpad.37signals.com/authorization/new?type=refresh",
			TokenURL:  "https://launchpad.37signals.com/authorization/token?type=refresh",
			AuthStyle: oauth2.AuthStyleInParams,
		},
	}
)

// Client --
type Client struct {
	client   *http.Client
	basecamp *model.Basecamp
}

// NewClient --
func NewClient(bc *model.Basecamp, cfg *config.Config) (Service, error) {
	newToken, err := getAccessToken(cfg)
	if err != nil {
		logger.L.Error(err, "can't init basecamp service")
		return nil, err
	}

	return &Client{
		client:   basecampOauthConfig.Client(context.Background(), newToken),
		basecamp: bc,
	}, nil
}

func getAccessToken(cfg *config.Config) (*oauth2.Token, error) {
	basecampOauthConfig.ClientID = cfg.Basecamp.ClientID
	basecampOauthConfig.ClientSecret = cfg.Basecamp.ClientSecret

	refreshToken := cfg.Basecamp.OAuthRefreshToken
	if refreshToken == "" {
		return nil, errors.New("missing basecampapp_oauth_refresh_token env variable")
	}
	token := new(oauth2.Token)
	token.RefreshToken = refreshToken
	newToken, err := basecampOauthConfig.TokenSource(context.Background(), token).Token()
	if err != nil {
		return nil, err
	}

	return newToken, nil
}

// func (c *Client) intervalRefreshToken() {
// 	interval := time.Tick(15 * time.Minute)
// 	for {
// 		<-interval
// 		newToken, _ := getAccessToken()
// 		c.client = basecampOauthConfig.Client(oauth2.NoContext, newToken)
// 	}
// }

func (c *Client) Get(url string) (resp *http.Response, err error) {
	return c.client.Get(url)
}

func (c *Client) Do(req *http.Request) (resp *http.Response, err error) {
	return c.client.Do(req)
}

// New --
func New(clientID, clientSecret string) *model.Basecamp {
	return &model.Basecamp{
		ClientID:     clientID,
		ClientSecret: clientSecret,
	}
}

// GetAccessToken return Basecamp AccessToken
func (c *Client) GetAccessToken(code, redirectURI string) (string, error) {
	c.basecamp.RedirectURI = redirectURI
	url := fmt.Sprintf(model.BasecampEndpoint+"/token?type=web_server&client_id=%v&redirect_uri=%v&client_secret=%v&code=%v", c.basecamp.ClientID, redirectURI, c.basecamp.ClientSecret, code)

	r, err := http.Post(url, "application/json", nil)
	if err != nil {
		return "", err
	}

	body, err := io.ReadAll(r.Body)
	if err != nil {
		return "", err
	}
	defer r.Body.Close()

	var resp model.AuthenticationResponse
	if err = json.Unmarshal(body, &resp); err != nil {
		return "", err
	}

	return resp.AccessToken, nil
}

```

# pkg/service/basecamp/attachment/service.go

```go
package attachment

type Service interface {
	Create(contentType string, fileName string, file []byte) (id string, err error)
}

```

# pkg/service/basecamp/attachment/attachment.go

```go
package attachment

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"

	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/client"
	"github.com/dwarvesf/fortress-api/pkg/service/basecamp/model"
)

type AttachmentService struct {
	client client.Service
}

func NewService(client client.Service) Service {
	return &AttachmentService{
		client: client,
	}
}

func (a *AttachmentService) Create(contentType, fileName string, file []byte) (string, error) {
	url := fmt.Sprintf("%v/%v/attachments.json?name=%v", model.BasecampAPIEndpoint, model.CompanyID, url.QueryEscape(fileName))

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(file))
	if err != nil {
		return "", err
	}

	req.Header.Add("content-type", contentType)
	req.Header.Add("content-length", strconv.Itoa(len(file)))
	resp, err := a.client.Do(req)
	if err != nil {
		return "", err
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		return "", fmt.Errorf("create attachment failed")
	}

	attachRes := &struct {
		SgID string `json:"attachable_sgid"`
	}{}

	if err := json.NewDecoder(resp.Body).Decode(attachRes); err != nil {
		return "", err
	}
	defer resp.Body.Close()

	return attachRes.SgID, nil
}

```

# pkg/handler/survey/request/request.go

```go
package request

import (
	"time"

	"github.com/dwarvesf/fortress-api/pkg/handler/survey/errs"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type GetListSurveyInput struct {
	view.Pagination

	Subtype string `json:"subtype" form:"subtype" binding:"required"`
} // @name GetListSurveyInput

func (i *GetListSurveyInput) Validate() error {
	if i.Subtype == "" || !model.EventSubtype(i.Subtype).IsSurveyValid() {
		return errs.ErrInvalidEventType
	}

	return nil
}

type GetSurveyDetailQuery struct {
	view.Pagination
	Keyword  string   `json:"keyword" form:"keyword"`
	Status   string   `json:"status" form:"status"`
	Projects []string `json:"projects" form:"projects"`
} // @name GetSurveyDetailQuery

type GetSurveyDetailInput struct {
	EventID string
	Query   GetSurveyDetailQuery
}

func (i *GetSurveyDetailInput) Validate() error {
	if i.EventID == "" || !model.IsUUIDFromString(i.EventID) {
		return errs.ErrInvalidEventID
	}

	var projects []string
	for _, p := range i.Query.Projects {
		if p != "" {
			projects = append(projects, p)
		}
	}
	i.Query.Projects = projects

	return nil
}

type SendSurveyInput struct {
	Type     string      `json:"type" form:"type" binding:"required"`
	TopicIDs []view.UUID `json:"topicIDs" form:"topicIDs"`
} // @name SendSurveyInput

// CreateSurveyFeedbackInput view for create survey feedback
type CreateSurveyFeedbackInput struct {
	Quarter  string `json:"quarter"`
	Year     int    `json:"year"`
	Type     string `json:"type" binding:"required"`
	FromDate string `json:"fromDate"`
	ToDate   string `json:"toDate"`
} // @name CreateSurveyFeedbackInput

// Validate input for create survey feedback
func (i *CreateSurveyFeedbackInput) Validate() error {
	if !model.EventSubtype(i.Type).IsValidSurvey() {
		return errs.ErrInvalidEventSubType
	}

	if i.Type == model.EventSubtypeWork.String() {
		fromDate, err := time.Parse("2006-01-02", i.FromDate)
		if err != nil {
			return errs.ErrInvalidDate
		}

		toDate, err := time.Parse("2006-01-02", i.ToDate)
		if err != nil {
			return errs.ErrInvalidDate
		}

		if fromDate.After(toDate) {
			return errs.ErrInvalidDateRange
		}
	}

	return nil
}

type PeerReviewDetailInput struct {
	EventID string
	TopicID string
}

func (i *PeerReviewDetailInput) Validate() error {
	if i.EventID == "" || !model.IsUUIDFromString(i.EventID) {
		return errs.ErrInvalidFeedbackID
	}

	if i.TopicID == "" || !model.IsUUIDFromString(i.TopicID) {
		return errs.ErrInvalidTopicID
	}

	return nil
}

// UpdateTopicReviewersBody view for update topic reviewers
type UpdateTopicReviewersBody struct {
	ReviewerIDs []view.UUID `json:"reviewerIDs"`
} // @name UpdateTopicReviewersBody

// UpdateTopicReviewersInput input of update topic reviewers request
type UpdateTopicReviewersInput struct {
	EventID string
	TopicID string
	Body    UpdateTopicReviewersBody
}

func (i *UpdateTopicReviewersInput) Validate() error {
	if i.EventID == "" || !model.IsUUIDFromString(i.EventID) {
		return errs.ErrInvalidEventID
	}

	if i.TopicID == "" || !model.IsUUIDFromString(i.TopicID) {
		return errs.ErrInvalidTopicID
	}

	return nil
}

// DeleteTopicReviewersBody view for update topic reviewers
type DeleteTopicReviewersBody struct {
	ReviewerIDs []view.UUID `json:"reviewerIDs"`
} // @name DeleteTopicReviewersBody

// DeleteTopicReviewersInput input of update topic reviewers request
type DeleteTopicReviewersInput struct {
	EventID string
	TopicID string
	Body    DeleteTopicReviewersBody
}

func (i *DeleteTopicReviewersInput) Validate() error {
	if i.EventID == "" || !model.IsUUIDFromString(i.EventID) {
		return errs.ErrInvalidEventID
	}

	if i.TopicID == "" || !model.IsUUIDFromString(i.TopicID) {
		return errs.ErrInvalidTopicID
	}

	return nil
}

```

# pkg/handler/survey/errs/errors.go

```go
package errs

import (
	"errors"
	"fmt"
)

var (
	// record not found errors
	ErrEventNotFound         = errors.New("event not found")
	ErrProjectNotFound       = errors.New("project not found")
	ErrTopicNotFound         = errors.New("topic not found")
	ErrEmployeeNotFound      = errors.New("employee not found")
	ErrEventReviewerNotFound = errors.New("employee event reviewer not found")

	// invalid errors
	ErrInvalidEventID      = errors.New("invalid event id")
	ErrInvalidEventType    = errors.New("invalid event type")
	ErrInvalidReviewerID   = errors.New("invalid reviewer id")
	ErrInvalidFeedbackID   = errors.New("invalid feedback id")
	ErrInvalidTopicID      = errors.New("invalid topic id")
	ErrInvalidEventSubType = errors.New("invalid event subtype")
	ErrInvalidQuarter      = errors.New("invalid quarter")
	ErrInvalidYear         = errors.New("invalid year")
	ErrInvalidDate         = errors.New("invalid date")
	ErrInvalidDateRange    = errors.New("invalid date range")

	// other errors
	ErrEventAlreadyExisted      = errors.New("event already existed")
	ErrReviewAlreadySent        = errors.New("review already sent")
	ErrEmployeeNotReady         = errors.New("employee not ready")
	ErrCanNotUpdateParticipants = errors.New("can not update participants")
	ErrEventHasBeenDone         = errors.New("event has been done")
	ErrNoValidProjectForEvent   = errors.New("no valid project for event")
)

func ErrEventQuestionNotFound(id string) error {
	return fmt.Errorf("employee event question not found: %v", id)
}

```

# pkg/handler/project/request/request.go

```go
package request

import (
	"regexp"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/utils/authutils"
	"github.com/dwarvesf/fortress-api/pkg/view"

	"github.com/dwarvesf/fortress-api/pkg/handler/project/errs"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/shopspring/decimal"
)

const emailRegex = ".+@.+\\..+"

type GetListProjectInput struct {
	view.Pagination

	Name   string   `form:"name" json:"name"`
	Status []string `form:"status" json:"status"`
	Type   []string `form:"type" json:"type"`
} // @name GetListProjectInput

type UpdateProjectGeneralInfoRequest struct {
	Name           string      `form:"name" json:"name" binding:"required"`
	StartDate      string      `form:"startDate" json:"startDate"`
	CountryID      view.UUID   `form:"countryID" json:"countryID" binding:"required"`
	Function       string      `form:"function" json:"function" binding:"required"`
	AuditNotionID  view.UUID   `form:"auditNotionID" json:"auditNotionID"`
	Stacks         []view.UUID `form:"stacks" json:"stacks"`
	BankAccountID  view.UUID   `form:"bankAccountID" json:"bankAccountID"`
	ClientID       view.UUID   `form:"clientID" json:"clientID"`
	CompanyInfoID  view.UUID   `form:"companyInfoID" json:"companyInfoID"`
	OrganizationID view.UUID   `form:"organizationID" json:"organizationID"`
	AccountRating  int         `form:"accountRating" json:"accountRating" binding:"required,min=1,max=5"`
	DeliveryRating int         `form:"deliveryRating" json:"deliveryRating" binding:"required,min=1,max=5"`
	LeadRating     int         `form:"leadRating" json:"leadRating" binding:"required,min=1,max=5"`
	ImportantLevel string      `form:"importantLevel" json:"importantLevel" binding:"required"`
} // @name UpdateProjectGeneralInfoRequest

func (i UpdateProjectGeneralInfoRequest) GetStartDate() *time.Time {
	startDate, err := time.Parse("2006-01-02", i.StartDate)
	if i.StartDate == "" || err != nil {
		return nil
	}

	return &startDate
}

func (i UpdateProjectGeneralInfoRequest) Validate() error {
	if !model.ProjectFunction(i.Function).IsValid() {
		return errs.ErrInvalidProjectFunction
	}

	if !model.ProjectImportantLevel(i.ImportantLevel).IsValid() {
		return errs.ErrInvalidProjectImportantLevel
	}

	return nil
}

type UpdateProjectStatusBody struct {
	ProjectStatus ProjectStatus `json:"status"`
} // @name UpdateProjectStatusBody

type ProjectStatus string // @name ProjectStatus

const (
	ProjectStatusOnBoarding ProjectStatus = "on-boarding"
	ProjectStatusActive     ProjectStatus = "active"
	ProjectStatusPaused     ProjectStatus = "paused"
	ProjectStatusClosed     ProjectStatus = "closed"
)

func (e ProjectStatus) IsValid() bool {
	switch e {
	case
		ProjectStatusOnBoarding,
		ProjectStatusActive,
		ProjectStatusPaused,
		ProjectStatusClosed:
		return true
	}
	return false
}

func (e ProjectStatus) String() string {
	return string(e)
}

func (i *GetListProjectInput) StandardizeInput() {
	statuses := utils.RemoveEmptyString(i.Status)
	pagination := model.Pagination{
		Page: i.Page,
		Size: i.Size,
		Sort: i.Sort,
	}
	pagination.Standardize()
	i.Page = pagination.Page
	i.Size = pagination.Size
	i.Sort = pagination.Sort
	i.Status = statuses
}

func (i *GetListProjectInput) Validate() error {
	if len(i.Type) > 0 {
		for _, projectType := range i.Type {
			if utils.RemoveAllSpace(projectType) != "" && !model.ProjectType(projectType).IsValid() {
				return errs.ErrInvalidProjectType
			}
		}
	}
	if len(i.Status) > 0 {
		for _, status := range i.Status {
			if utils.RemoveAllSpace(status) != "" && !model.ProjectStatus(status).IsValid() {
				return errs.ErrInvalidProjectStatus
			}
		}
	}

	return nil
}

type CreateProjectRequest struct {
	Name             string                `form:"name" json:"name" binding:"required"`
	Status           string                `form:"status" json:"status" binding:"required"`
	Type             string                `form:"type" json:"type"`
	AccountManagers  []ProjectHeadRequest  `form:"accountManagers" json:"accountManagers"`
	DeliveryManagers []ProjectHeadRequest  `form:"deliveryManagers" json:"deliveryManagers"`
	SalePersons      []ProjectHeadRequest  `form:"salePersons" json:"salePersons"`
	CountryID        view.UUID             `form:"countryID" json:"countryID" binding:"required"`
	StartDate        string                `form:"startDate" json:"startDate"`
	Members          []AssignMemberRequest `form:"members" json:"members"`
	ClientEmail      []string              `form:"clientEmail" json:"clientEmail"`
	ProjectEmail     string                `form:"projectEmail" json:"projectEmail"`
	Code             string                `form:"code" json:"code"`
	Function         string                `form:"function" json:"function" binding:"required"`
	AuditNotionID    view.UUID             `form:"auditNotionID" json:"auditNotionID"`
	BankAccountID    view.UUID             `form:"bankAccountID" json:"bankAccountID"`
	ClientID         view.UUID             `form:"clientID" json:"clientID"`
	OrganizationID   view.UUID             `form:"organizationID" json:"organizationID"`
} // @name CreateProjectRequest

func (i *CreateProjectRequest) Validate() error {
	if i.Type == "" {
		i.Type = model.ProjectTypeDwarves.String()
	}

	if !model.ProjectType(i.Type).IsValid() {
		return errs.ErrInvalidProjectType
	}

	if !model.ProjectStatus(i.Status).IsValid() {
		return errs.ErrInvalidProjectStatus
	}

	_, err := time.Parse("2006-01-02", i.StartDate)
	if i.StartDate != "" && err != nil {
		return errs.ErrInvalidStartDate
	}

	for _, member := range i.Members {
		if err := member.Validate(); err != nil {
			return err
		}
	}

	regex, _ := regexp.Compile(emailRegex)
	for _, v := range i.ClientEmail {
		if !regex.MatchString(v) {
			return errs.ErrInvalidEmailDomainForClient
		}
	}

	if i.ProjectEmail != "" && !regex.MatchString(i.ProjectEmail) {
		return errs.ErrInvalidEmailDomainForProject
	}

	if !model.ProjectFunction(i.Function).IsValid() {
		return errs.ErrInvalidProjectFunction
	}

	if len(i.AccountManagers) == 0 {
		return errs.ErrAccountManagerRequired
	}

	return nil
}

func (i *CreateProjectRequest) GetStartDate() *time.Time {
	startDate, err := time.Parse("2006-01-02", i.StartDate)
	if i.StartDate == "" || err != nil {
		return nil
	}

	return &startDate
}

type GetListStaffInput struct {
	view.Pagination

	Status   string `form:"status" json:"status"`
	Preload  bool   `json:"preload" form:"preload,default=true"`
	Distinct bool   `json:"distinct" form:"distinct,default=false"`
}

func (i *GetListStaffInput) Validate() error {
	if i.Status != "" && !model.ProjectMemberStatus(i.Status).IsValid() {
		return errs.ErrInvalidProjectMemberStatus
	}
	return nil
}

type UpdateMemberRequest struct {
	ProjectSlotID        view.UUID       `from:"projectSlotID" json:"projectSlotID" binding:"required"`
	ProjectMemberID      view.UUID       `from:"projectMemberID" json:"projectMemberID"`
	EmployeeID           view.UUID       `form:"employeeID" json:"employeeID"`
	SeniorityID          view.UUID       `form:"seniorityID" json:"seniorityID" binding:"required"`
	UpsellPersonID       view.UUID       `form:"upsellPersonID" json:"upsellPersonID"`
	UpsellCommissionRate decimal.Decimal `form:"upsellCommissionRate" json:"upsellCommissionRate"`
	LeadCommissionRate   decimal.Decimal `form:"leadCommissionRate" json:"leadCommissionRate"`
	Positions            []view.UUID     `form:"positions" json:"positions" binding:"required"`
	DeploymentType       string          `form:"deploymentType" json:"deploymentType" binding:"required"`
	Status               string          `form:"status" json:"status" binding:"required"`
	StartDate            string          `form:"startDate" json:"startDate"`
	EndDate              string          `form:"endDate" json:"endDate"`
	Rate                 decimal.Decimal `form:"rate" json:"rate" binding:"required"`
	Discount             decimal.Decimal `form:"discount" json:"discount"`
	IsLead               bool            `form:"isLead" json:"isLead"`
	Note                 string          `form:"note" json:"note"`
} // @name UpdateMemberRequest

func (i *UpdateMemberRequest) Validate() error {
	if i.DeploymentType != "" && !model.DeploymentType(i.DeploymentType).IsValid() {
		return errs.ErrInvalidDeploymentType
	}

	if i.Status != "" && !model.ProjectMemberStatus(i.Status).IsValid() {
		return errs.ErrInvalidProjectMemberStatus
	}

	_, err := time.Parse("2006-01-02", i.StartDate)
	if i.StartDate != "" && err != nil {
		return errs.ErrInvalidStartDate
	}

	_, err = time.Parse("2006-01-02", i.EndDate)
	if i.EndDate != "" && err != nil {
		return errs.ErrInvalidEndDate
	}

	if i.GetStartDate() != nil &&
		i.GetEndDate() != nil &&
		!i.GetStartDate().Before(*i.GetEndDate()) {
		return errs.ErrInvalidEndDate
	}

	if i.GetEndDate() != nil && i.GetEndDate().Before(time.Now()) {
		i.Status = model.ProjectMemberStatusInactive.String()
	}

	return nil
}

func (i *UpdateMemberRequest) GetStartDate() *time.Time {
	date, err := time.Parse("2006-01-02", i.StartDate)
	if i.StartDate == "" || err != nil {
		return nil
	}

	return &date
}

func (i *UpdateMemberRequest) GetEndDate() *time.Time {
	date, err := time.Parse("2006-01-02", i.EndDate)
	if i.EndDate == "" || err != nil {
		return nil
	}

	return &date
}

type AssignMemberRequest struct {
	EmployeeID           view.UUID       `form:"employeeID" json:"employeeID"`
	SeniorityID          view.UUID       `form:"seniorityID" json:"seniorityID" binding:"required"`
	Positions            []view.UUID     `form:"positions" json:"positions" binding:"required"`
	DeploymentType       string          `form:"deploymentType" json:"deploymentType" binding:"required"`
	Status               string          `form:"status" json:"status" binding:"required"`
	StartDate            string          `form:"startDate" json:"startDate"`
	EndDate              string          `form:"endDate" json:"endDate"`
	Rate                 decimal.Decimal `form:"rate" json:"rate" binding:"required"`
	Discount             decimal.Decimal `form:"discount" json:"discount"`
	LeadCommissionRate   decimal.Decimal `form:"leadCommissionRate" json:"leadCommissionRate"`
	IsLead               bool            `form:"isLead" json:"isLead"`
	UpsellPersonID       view.UUID       `form:"upsellPersonID" json:"upsellPersonID"`
	UpsellCommissionRate decimal.Decimal `form:"upsellCommissionRate" json:"upsellCommissionRate"`
	Note                 string          `form:"note" json:"note"`
} // @name AssignMemberRequest

func (i *AssignMemberRequest) Validate() error {
	if i.DeploymentType == "" || !model.DeploymentType(i.DeploymentType).IsValid() {
		return errs.ErrInvalidDeploymentType
	}

	if i.Status == "" ||
		!model.ProjectMemberStatus(i.Status).IsValid() ||
		i.Status == model.ProjectMemberStatusInactive.String() {
		return errs.ErrInvalidProjectMemberStatus
	}

	if len(i.Positions) == 0 {
		return errs.ErrPositionsIsEmpty
	}

	_, err := time.Parse("2006-01-02", i.StartDate)
	if i.StartDate != "" && err != nil {
		return errs.ErrInvalidStartDate
	}

	_, err = time.Parse("2006-01-02", i.EndDate)
	if i.EndDate != "" && err != nil {
		return errs.ErrInvalidEndDate
	}

	if i.Status == model.ProjectMemberStatusPending.String() && !i.EmployeeID.IsZero() {
		i.Status = model.ProjectStatusActive.String()
	}

	return nil
}

func (i *AssignMemberRequest) GetStartDate() *time.Time {
	date, err := time.Parse("2006-01-02", i.StartDate)
	if i.StartDate == "" || err != nil {
		return nil
	}

	return &date
}

func (i *AssignMemberRequest) GetEndDate() *time.Time {
	date, err := time.Parse("2006-01-02", i.EndDate)
	if i.EndDate == "" || err != nil {
		return nil
	}

	return &date
}

func (i *AssignMemberRequest) GetStatus() model.ProjectMemberStatus {
	if i.EmployeeID.IsZero() {
		return model.ProjectMemberStatusPending
	}

	if !i.EmployeeID.IsZero() && i.Status == model.ProjectMemberStatusPending.String() {
		return model.ProjectMemberStatusActive
	}

	return model.ProjectMemberStatus(i.Status)
}

func (i *AssignMemberRequest) RestrictPermission(userInfo *model.CurrentLoggedUserInfo) {
	if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) {
		i.LeadCommissionRate = decimal.Zero
	}

	if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) {
		i.Rate = decimal.Zero
		i.Discount = decimal.Zero
	}
}

type DeleteMemberInput struct {
	ProjectID string
	MemberID  string
}

func (input DeleteMemberInput) Validate() error {
	if input.ProjectID == "" {
		return errs.ErrInvalidProjectID
	}

	if input.MemberID == "" {
		return errs.ErrInvalidMemberID
	}

	return nil
}

type DeleteSlotInput struct {
	ProjectID string
	SlotID    string
}

func (input DeleteSlotInput) Validate() error {
	if input.ProjectID == "" {
		return errs.ErrInvalidProjectID
	}

	if input.SlotID == "" {
		return errs.ErrInvalidSlotID
	}

	return nil
}

type ProjectHeadRequest struct {
	EmployeeID     view.UUID       `json:"employeeID" form:"employeeID"`
	CommissionRate decimal.Decimal `json:"commissionRate" form:"commissionRate"`
} // @name ProjectHeadRequest

type UpdateContactInfoRequest struct {
	ClientEmail      []string             `form:"clientEmail" json:"clientEmail"`
	ProjectEmail     string               `form:"projectEmail" json:"projectEmail"`
	AccountManagers  []ProjectHeadRequest `form:"accountManagers" json:"accountManagers"`
	DeliveryManagers []ProjectHeadRequest `form:"deliveryManagers" json:"deliveryManagers"`
	SalePersons      []ProjectHeadRequest `form:"salePersons" json:"salePersons"`
} // @name UpdateContactInfoRequest

func (i UpdateContactInfoRequest) Validate() error {
	regex, _ := regexp.Compile(emailRegex)
	for _, v := range i.ClientEmail {
		if !regex.MatchString(v) {
			return errs.ErrInvalidEmailDomainForClient
		}
	}

	if i.ProjectEmail != "" && !regex.MatchString(i.ProjectEmail) {
		return errs.ErrInvalidEmailDomainForProject
	}

	if len(i.AccountManagers) == 0 {
		return errs.ErrAccountManagerRequired
	}

	return nil
}

type UnassignMemberInput struct {
	ProjectID string
	MemberID  string
}

func (input UnassignMemberInput) Validate() error {
	if input.ProjectID == "" || !model.IsUUIDFromString(input.ProjectID) {
		return errs.ErrInvalidProjectID
	}

	if input.MemberID == "" || !model.IsUUIDFromString(input.MemberID) {
		return errs.ErrInvalidMemberID
	}

	return nil
}

type CreateWorkUnitInput struct {
	ProjectID string
	Body      CreateWorkUnitRequest
}

type CreateWorkUnitRequest struct {
	Name    string      `json:"name" form:"name" binding:"required"`
	Type    string      `json:"type" form:"type" binding:"required"`
	Status  string      `json:"status" form:"status" binding:"required"`
	Members []view.UUID `json:"members" form:"members"`
	Stacks  []view.UUID `json:"stacks" form:"stacks" binding:"required"`
	URL     string      `json:"url" form:"url"`
} // @name CreateWorkUnitRequest

func (i *CreateWorkUnitInput) Validate() error {
	if i.ProjectID == "" || !model.IsUUIDFromString(i.ProjectID) {
		return errs.ErrInvalidProjectID
	}

	return i.Body.Validate()
}

func (i *CreateWorkUnitRequest) Validate() error {
	if i.Type == "" || !model.WorkUnitType(i.Type).IsValid() {
		return errs.ErrInvalidWorkUnitType
	}

	if i.Status == "" || !model.WorkUnitStatus(i.Status).IsValid() {
		return errs.ErrInvalidWorkUnitStatus
	}

	if len(i.Stacks) == 0 {
		return errs.ErrInvalidWorkUnitStacks
	}

	return nil
}

type UpdateWorkUnitInput struct {
	ProjectID  string
	WorkUnitID string
	Body       UpdateWorkUnitRequest
}

type UpdateWorkUnitRequest struct {
	Name    string            `form:"name" json:"name" binding:"required,max=100"`
	Type    view.WorkUnitType `form:"type" json:"type" binding:"required"`
	Members []view.UUID       `form:"members" json:"members"`
	Stacks  []view.UUID       `form:"stacks" json:"stacks" binding:"required"`
	URL     string            `form:"url" json:"url"`
} // @name UpdateWorkUnitRequest

func (i *UpdateWorkUnitInput) Validate() error {
	if i.ProjectID == "" || !model.IsUUIDFromString(i.ProjectID) {
		return errs.ErrInvalidProjectID
	}

	if i.WorkUnitID == "" || !model.IsUUIDFromString(i.WorkUnitID) {
		return errs.ErrInvalidWorkUnitID
	}

	return i.Body.Validate()
}

func (i *UpdateWorkUnitRequest) Validate() error {
	if !i.Type.IsValid() {
		return errs.ErrInvalidWorkUnitType
	}

	if len(i.Stacks) == 0 {
		return errs.ErrInvalidWorkUnitStacks
	}

	return nil
}

type ArchiveWorkUnitInput struct {
	ProjectID  string
	WorkUnitID string
}

func (i *ArchiveWorkUnitInput) Validate() error {
	if i.ProjectID == "" || !model.IsUUIDFromString(i.ProjectID) {
		return errs.ErrInvalidProjectID
	}

	if i.WorkUnitID == "" || !model.IsUUIDFromString(i.WorkUnitID) {
		return errs.ErrInvalidWorkUnitID
	}

	return nil
}

type GetListWorkUnitInput struct {
	ProjectID string
	Query     GetListWorkUnitQuery
} // @name GetListWorkUnitInput

type GetListWorkUnitQuery struct {
	Status WorkUnitStatus `form:"status" json:"status"`
} // @name GetListWorkUnitQuery

type WorkUnitStatus string // @name WorkUnitStatus

const (
	WorkUnitStatusActive   WorkUnitStatus = "active"
	WorkUnitStatusArchived WorkUnitStatus = "archived"
)

func (e WorkUnitStatus) IsValid() bool {
	switch e {
	case
		WorkUnitStatusActive,
		WorkUnitStatusArchived:
		return true
	}
	return false
}

func (e WorkUnitStatus) String() string {
	return string(e)
}

func (i GetListWorkUnitInput) Validate() error {
	if i.ProjectID == "" || !model.IsUUIDFromString(i.ProjectID) {
		return errs.ErrInvalidProjectID
	}

	return i.Query.Validate()
}

func (i GetListWorkUnitQuery) Validate() error {
	if i.Status != "" && !i.Status.IsValid() {
		return errs.ErrInvalidWorkUnitStatus
	}

	return nil
}

type UpdateSendingSurveyInput struct {
	AllowsSendingSurvey bool `form:"allowsSendingSurvey" json:"allowsSendingSurvey"`
}

```

# pkg/handler/project/errs/errors.go

```go
package errs

import (
	"errors"
	"fmt"
)

var (
	ErrInvalidProjectID             = errors.New("invalid project ID")
	ErrInvalidProjectType           = errors.New("invalid project type")
	ErrInvalidProjectStatus         = errors.New("invalid project status")
	ErrInvalidProjectMemberStatus   = errors.New("invalid project member status")
	ErrInvalidDeploymentType        = errors.New("invalid deployment type")
	ErrInvalidStartDate             = errors.New("invalid start date")
	ErrInvalidEndDate               = errors.New("invalid end date")
	ErrInvalidMemberID              = errors.New("invalid member ID")
	ErrInvalidSlotID                = errors.New("invalid slot ID")
	ErrInvalidWorkUnitID            = errors.New("invalid work unit ID")
	ErrInvalidWorkUnitType          = errors.New("invalid work unit type")
	ErrInvalidWorkUnitStatus        = errors.New("invalid work unit status")
	ErrInvalidWorkUnitStacks        = errors.New("invalid work unit stacks")
	ErrInvalidInActiveMember        = errors.New("member is not active in work unit")
	ErrMemberIsNotProjectLead       = errors.New("project is not managed by signed-in user")
	ErrInvalidProjectFunction       = errors.New("invalid project function value")
	ErrInvalidProjectImportantLevel = errors.New("invalid project important level value")

	ErrProjectNotFound         = errors.New("project not found")
	ErrProjectNotionNotFound   = errors.New("project notion not found")
	ErrCountryNotFound         = errors.New("country not found")
	ErrBankAccountNotFound     = errors.New("bank account not found")
	ErrEmployeeNotFound        = errors.New("employee not found")
	ErrSeniorityNotFound       = errors.New("seniority not found")
	ErrProjectSlotNotFound     = errors.New("project slot not found")
	ErrProjectMemberNotFound   = errors.New("project member not found")
	ErrAccountManagerNotFound  = errors.New("account manager not found")
	ErrDeliveryManagerNotFound = errors.New("delivery manager not found")
	ErrWorkUnitNotFound        = errors.New("work unit not found")
	ErrClientNotFound          = errors.New("client not found")
	ErrOrganizationNotFound    = errors.New("organization not found")
	ErrProjectNotExisted       = errors.New("project not existed")
	ErrCompanyInfoNotFound     = errors.New("company info not found")

	ErrMemberIsInactive                 = errors.New("member is inactive")
	ErrEmployeeWorkedOnTheProject       = errors.New("employee worked on the project")
	ErrPositionsIsEmpty                 = errors.New("positions is empty")
	ErrMemberIsNotActiveInProject       = errors.New("member is not active in project")
	ErrFailToCheckInputExistence        = errors.New("failed to check input existence")
	ErrFailToDeleteWorkUnitStack        = errors.New("failed to delete work unit stack in database")
	ErrFailedToCreateWorkUnitStack      = errors.New("failed to create work unit stack")
	ErrFailedToGetWorkUnitMember        = errors.New("failed to get work unit member")
	ErrFailedToUpdateWorkUnitMember     = errors.New("failed to update work unit member in database")
	ErrFailedToSoftDeleteWorkUnitMember = errors.New("failed to soft delete work unit member")
	ErrFailedToGetProjectMember         = errors.New("failed to get project member in database")
	ErrFailedToCreateWorkUnitMember     = errors.New("failed to create work unit member")
	ErrSlotAlreadyContainsAnotherMember = errors.New("slot already contains another member")
	ErrDuplicateProjectCode             = errors.New("project code is duplicated")
	ErrAccountManagerRequired           = errors.New("account manager is required")

	ErrInvalidFileExtension         = errors.New("invalid file extension")
	ErrInvalidFileSize              = errors.New("invalid file size")
	ErrInvalidEmailDomainForClient  = errors.New("invalid email domain for client")
	ErrInvalidEmailDomainForProject = errors.New("invalid email domain for project")
)

// ErrPositionNotFoundWithID returns unauthorized custom error
func ErrPositionNotFoundWithID(id string) error {
	return fmt.Errorf("position not found: %v", id)
}

func ErrStackNotFoundWithID(id string) error {
	return fmt.Errorf("stack not found: %v", id)
}

```

# pkg/handler/profile/request/request.go

```go
package request

import (
	"strings"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/handler/profile/errs"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

// UpdateInfoInput input model for update profile
type UpdateInfoInput struct {
	PersonalEmail      string `form:"personalEmail" json:"personalEmail" binding:"required,email"`
	PhoneNumber        string `form:"phoneNumber" json:"phoneNumber" binding:"required,max=18,min=8"`
	PlaceOfResidence   string `form:"placeOfResidence" json:"placeOfResidence" binding:"required"`
	Address            string `form:"address" json:"address"`
	Country            string `form:"country" json:"country" binding:"required"`
	City               string `form:"city" json:"city" binding:"required"`
	Lat                string `form:"lat" json:"lat"`
	Long               string `form:"long" json:"long"`
	GithubID           string `form:"githubID" json:"githubID"`
	NotionID           string `form:"notionID" json:"notionID"`
	NotionName         string `form:"notionName" json:"notionName"`
	NotionEmail        string `form:"notionEmail" json:"notionEmail"`
	DiscordName        string `form:"discordName" json:"discordName"`
	LinkedInName       string `form:"linkedInName" json:"linkedInName"`
	WiseRecipientID    string `form:"wiseRecipientID" json:"wiseRecipientID"`
	WiseRecipientEmail string `form:"wiseRecipientEmail" json:"wiseRecipientEmail" binding:"email"`
	WiseRecipientName  string `form:"wiseRecipientName" json:"wiseRecipientName"`
	WiseAccountNumber  string `form:"wiseAccountNumber" json:"wiseAccountNumber"`
	WiseCurrency       string `form:"wiseCurrency" json:"wiseCurrency"`
} // @name UpdateInfoInput

func (i UpdateInfoInput) ToEmployeeModel(employee *model.Employee) {
	employee.PersonalEmail = i.PersonalEmail
	employee.PhoneNumber = i.PhoneNumber
	employee.PlaceOfResidence = i.PlaceOfResidence
	employee.Address = i.Address
	employee.City = i.City
	employee.Country = i.Country
	employee.Lat = i.Lat
	employee.Long = i.Long

	if strings.TrimSpace(i.WiseRecipientID) != "" {
		employee.WiseRecipientID = i.WiseRecipientID
	}
	if strings.TrimSpace(i.WiseRecipientEmail) != "" {
		employee.WiseRecipientEmail = i.WiseRecipientEmail
	}
	if strings.TrimSpace(i.WiseRecipientName) != "" {
		employee.WiseRecipientName = i.WiseRecipientName
	}
	if strings.TrimSpace(i.WiseAccountNumber) != "" {
		employee.WiseAccountNumber = i.WiseAccountNumber
	}
	if strings.TrimSpace(i.WiseCurrency) != "" {
		employee.WiseCurrency = i.WiseCurrency
	}
}

type SubmitOnboardingFormRequest struct {
	Avatar                 string     `json:"avatar"`
	Address                string     `json:"address" binding:"required"`
	City                   string     `json:"city" binding:"required"`
	Country                string     `json:"country" binding:"required"`
	Lat                    string     `json:"lat"`
	Long                   string     `json:"long"`
	DateOfBirth            *time.Time `json:"dateOfBirth" binding:"required"`
	Gender                 string     `json:"gender" binding:"required"`
	Horoscope              string     `json:"horoscope" binding:"required"`
	MBTI                   string     `json:"mbti" binding:"required"`
	PhoneNumber            string     `json:"phoneNumber" binding:"required,max=18,min=8"`
	PlaceOfResidence       string     `json:"placeOfResidence" binding:"required"`
	PassportPhotoFront     string     `json:"passportPhotoFront"`
	PassportPhotoBack      string     `json:"passportPhotoBack"`
	IdentityCardPhotoFront string     `json:"identityCardPhotoFront"`
	IdentityCardPhotoBack  string     `json:"identityCardPhotoBack"`

	LocalBankBranch        string `json:"localBankBranch" binding:"required"`
	LocalBankCurrency      string `json:"localBankCurrency" binding:"required"`
	LocalBankNumber        string `json:"localBankNumber" binding:"required"`
	LocalBankRecipientName string `json:"localBankRecipientName" binding:"required"`
	LocalBranchName        string `json:"localBranchName" binding:"required"`

	DiscordName  string `json:"discordName" binding:"required"`
	GithubID     string `json:"githubID"`
	LinkedInName string `json:"linkedInName"`
	NotionName   string `json:"notionName"`
} // @name SubmitOnboardingFormRequest

func (i *SubmitOnboardingFormRequest) Validate() error {
	if i.DateOfBirth.After(time.Now()) {
		return errs.ErrInvalidDate
	}

	if i.PassportPhotoBack == "" || i.PassportPhotoFront == "" {
		if i.IdentityCardPhotoFront == "" || i.IdentityCardPhotoBack == "" {
			return errs.ErrMissingDocuments
		}
	}

	if i.IdentityCardPhotoFront == "" || i.IdentityCardPhotoBack == "" {
		if i.PassportPhotoBack == "" || i.PassportPhotoFront == "" {
			return errs.ErrMissingDocuments
		}
	}

	return nil
}

func (i *SubmitOnboardingFormRequest) ToEmployeeModel() *model.Employee {
	return &model.Employee{
		Avatar:                 i.Avatar,
		Address:                i.Address,
		Lat:                    i.Lat,
		Long:                   i.Long,
		City:                   i.City,
		Country:                i.Country,
		DateOfBirth:            i.DateOfBirth,
		Gender:                 i.Gender,
		Horoscope:              i.Horoscope,
		PassportPhotoFront:     strings.TrimSpace(i.PassportPhotoFront),
		PassportPhotoBack:      strings.TrimSpace(i.PassportPhotoBack),
		IdentityCardPhotoFront: strings.TrimSpace(i.IdentityCardPhotoFront),
		IdentityCardPhotoBack:  strings.TrimSpace(i.IdentityCardPhotoBack),
		LocalBranchName:        i.LocalBranchName,
		LocalBankBranch:        i.LocalBankBranch,
		LocalBankCurrency:      i.LocalBankCurrency,
		LocalBankNumber:        i.LocalBankNumber,
		LocalBankRecipientName: i.LocalBankRecipientName,
		MBTI:                   i.MBTI,
		PhoneNumber:            i.PhoneNumber,
		PlaceOfResidence:       i.PlaceOfResidence,
		WorkingStatus:          model.WorkingStatusProbation,
	}
}

```

# pkg/handler/payroll/errs/errors.go

```go
package errs

import "errors"

var (
	ErrBadRequest                    = errors.New("bad request")
	ErrInvalidYear                   = errors.New("invalid year, must be current year")
	ErrCannotReadProjectBonusExplain = errors.New("cannot read project bonus explain")
	ErrPayrollNotSnapshotted         = errors.New("payroll not snapshotted")
)

```

# pkg/handler/profile/errs/errors.go

```go
package errs

import "errors"

var (
	ErrEmployeeNotFound                           = errors.New("employee not found")
	ErrCountryNotFound                            = errors.New("country not found")
	ErrInvalidCountryOrCity                       = errors.New("invalid country or city")
	ErrInvalidFileExtension                       = errors.New("invalid file extension")
	ErrInvalidDocumentType                        = errors.New("invalid document type")
	ErrInvalidFileType                            = errors.New("invalid file type")
	ErrInvalidFileSize                            = errors.New("invalid file size")
	ErrFileAlreadyExisted                         = errors.New("file already existed")
	ErrEmailExisted                               = errors.New("email already exists")
	ErrOnboardingFormAlreadyDone                  = errors.New("onboarding form already done")
	ErrMissingDocuments                           = errors.New("missing id/passport documents")
	ErrInvalidDate                                = errors.New("invalid date")
	ErrInvalidDiscordMemberInfo                   = errors.New("invalid discord member info")
	ErrDiscordAccountAlreadyUsedByAnotherEmployee = errors.New("discord account already used by another employee")
	ErrCouldNotFoundDiscordMemberInGuild          = errors.New("could not found discord member in the guild")
	ErrCityDoesNotBelongToCountry                 = errors.New("city does not belong to country")
)

```

# pkg/handler/metadata/errs/errs.go

```go
package errs

import "errors"

var (
	ErrInvalidStackID    = errors.New("invalid stack ID")
	ErrStackNotFound     = errors.New("stack not found")
	ErrInvalidPositionID = errors.New("invalid Position ID")
	ErrPositionNotFound  = errors.New("position not found")
	ErrEmployeeNotFound  = errors.New("employee not found")
)

```

# pkg/handler/metadata/request/request.go

```go
package request

import (
	"github.com/dwarvesf/fortress-api/pkg/handler/metadata/errs"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type UpdateStackBody struct {
	Name   string `json:"name"`
	Code   string `json:"code"`
	Avatar string `json:"avatar"`
} // @name UpdateStackBody

type UpdateStackInput struct {
	ID   string
	Body UpdateStackBody
} // @name UpdateStackInput

func (i UpdateStackInput) Validate() error {
	if i.ID == "" || !model.IsUUIDFromString(i.ID) {
		return errs.ErrInvalidStackID
	}

	return nil
}

type CreateStackInput struct {
	Name   string `json:"name" binding:"required"`
	Code   string `json:"code" binding:"required"`
	Avatar string `json:"avatar"`
} // @name CreateStackInput

type UpdatePositionBody struct {
	Name string `json:"name"`
	Code string `json:"code"`
} // @name UpdatePositionBody

type UpdatePositionInput struct {
	ID   string
	Body UpdatePositionBody
} // @name UpdatePositionInput

func (i UpdatePositionInput) Validate() error {
	if i.ID == "" || !model.IsUUIDFromString(i.ID) {
		return errs.ErrInvalidPositionID
	}

	return nil
}

type CreatePositionInput struct {
	Name string `json:"name" binding:"required"`
	Code string `json:"code" binding:"required"`
} // @name CreatePositionInput

type GetStacksInput struct {
	model.Pagination
	Keyword string `json:"keyword" form:"keyword"`
}

type GetBankRequest struct {
	ID        string `json:"id" form:"id" `
	Bin       string `json:"bin" form:"bin"`
	SwiftCode string `json:"swiftCode" form:"swiftCode"`
}

```

# pkg/handler/memologs/request/request.go

```go
package request

import (
	"github.com/shopspring/decimal"
)

type CreateMemoLogsRequest []MemoLogItem // @name CreateMemoLogsRequest

type MemoLogItem struct {
	Title       string          `json:"title" binding:"required"`
	URL         string          `json:"url" binding:"required"`
	Authors     []string        `json:"authors"`
	Tags        []string        `json:"tags"`
	Description string          `json:"description"`
	PublishedAt string          `json:"publishedAt"`
	Reward      decimal.Decimal `json:"reward"`
}

```

# pkg/handler/memologs/errs/errors.go

```go
package errs

import "errors"

var (
	ErrInvalidPublishedAt = errors.New("cannot parse publishedAt")
	ErrInvalidDateFormat  = errors.New("invalid date format")
)

```

# pkg/handler/invoice/request/request.go

```go
package request

import (
	"encoding/json"
	"math"
	"strings"
	"time"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/config"
	"github.com/dwarvesf/fortress-api/pkg/handler/invoice/errs"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/utils"
	"github.com/dwarvesf/fortress-api/pkg/utils/mailutils"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type UpdateStatusRequest struct {
	Status            model.InvoiceStatus `json:"status"`
	SendThankYouEmail bool                `json:"sendThankYouEmail"`
}

func (r *UpdateStatusRequest) Validate() error {
	if r.Status != "" && !r.Status.IsValid() {
		return errs.ErrInvalidInvoiceStatus
	}

	return nil
}

type GetInvoiceInput struct {
	ProjectID string `json:"projectID" form:"projectID"`
}

type GetListInvoiceInput struct {
	view.Pagination
	ProjectID []string `json:"projectID" form:"projectID"`
	Status    []string `json:"status" form:"status"`
}

func (r *GetListInvoiceInput) StandardizeInput() model.Pagination {
	statuses := utils.RemoveEmptyString(r.Status)
	projectsIDs := utils.RemoveEmptyString(r.ProjectID)

	pagination := model.Pagination{
		Page: r.Page,
		Size: r.Size,
		Sort: r.Sort,
	}
	pagination.Standardize()
	r.Status = statuses
	r.ProjectID = projectsIDs

	return pagination
}

func (r *GetListInvoiceInput) Validate() error {
	for _, status := range r.Status {
		if !model.InvoiceStatus(status).IsValid() {
			return errs.ErrInvalidInvoiceStatus
		}
	}

	for _, ids := range r.ProjectID {
		if _, err := model.UUIDFromString(ids); err != nil {
			return errs.ErrInvalidProjectID
		}
	}

	return nil
}

type SendInvoiceRequest struct {
	IsDraft     bool          `json:"isDraft"`
	ProjectID   view.UUID     `json:"projectID" binding:"required"`
	BankID      view.UUID     `json:"bankID" binding:"required"`
	Description string        `json:"description"`
	Note        string        `json:"note"`
	CC          []string      `json:"cc"`
	LineItems   []InvoiceItem `json:"lineItems"`
	Email       string        `json:"email" binding:"required,email"`
	Total       float64       `json:"total" binding:"gte=0"`
	Discount    float64       `json:"discount" binding:"gte=0"`
	Tax         float64       `json:"tax" binding:"gte=0"`
	SubTotal    float64       `json:"subtotal" binding:"gte=0"`
	InvoiceDate string        `json:"invoiceDate" binding:"required"`
	DueDate     string        `json:"dueDate" binding:"required"`
	Month       int           `json:"invoiceMonth" binding:"gte=0,lte=11"`
	Year        int           `json:"invoiceYear" binding:"gte=0"`
	Number      string
} // @name SendInvoiceRequest

type InvoiceItem struct {
	Quantity    float64 `json:"quantity"`
	UnitCost    float64 `json:"unitCost"`
	Discount    float64 `json:"discount"`
	Cost        float64 `json:"cost"`
	Description string  `json:"description"`
	IsExternal  bool    `json:"isExternal"`
} // @name InvoiceItem

func toInvoiceItemsModel(lineItems []InvoiceItem) []model.InvoiceItem {
	var items []model.InvoiceItem
	for _, item := range lineItems {
		items = append(items, model.InvoiceItem{
			Quantity:    math.Round(item.Quantity*100) / 100,
			UnitCost:    math.Round(item.UnitCost*100) / 100,
			Discount:    math.Round(item.Discount*100) / 100,
			Cost:        math.Round(item.Cost*100) / 100,
			Description: item.Description,
			IsExternal:  item.IsExternal,
		})
	}

	return items
}

func (i *SendInvoiceRequest) ValidateAndMappingRequest(c *gin.Context, cfg *config.Config) error {
	if err := c.ShouldBindJSON(&i); err != nil {
		return err
	}

	var ccList []string
	for _, cc := range i.CC {
		if strings.TrimSpace(cc) == "" {
			continue
		}
		ccList = append(ccList, cc)
	}

	i.CC = ccList

	if cfg.Env == "prod" {
		return nil
	}

	if !mailutils.IsDwarvesMail(i.Email) {
		return errs.ErrInvalidDeveloperEmail
	}

	for _, v := range i.CC {
		if !mailutils.IsDwarvesMail(v) {
			return errs.ErrInvalidDeveloperEmail
		}
	}

	return nil
}

func (i *SendInvoiceRequest) ToInvoiceModel(sentByID string) (*model.Invoice, error) {
	lineItems, err := json.Marshal(toInvoiceItemsModel(i.LineItems))
	if err != nil {
		return nil, err
	}

	dueAt, err := time.Parse("2006-01-02", i.DueDate)
	if err != nil {
		return nil, err
	}

	invoiceAt, err := time.Parse("2006-01-02", i.InvoiceDate)
	if err != nil {
		return nil, err
	}

	defaultStatus := model.InvoiceStatusSent
	if i.IsDraft {
		defaultStatus = model.InvoiceStatusDraft
	}

	cc, err := json.Marshal(i.CC)
	if err != nil {
		return nil, err
	}

	var senderID *model.UUID
	if sentByID != "" {
		s, err := model.UUIDFromString(sentByID)
		if err != nil {
			return nil, err
		}
		senderID = &s
	}

	return &model.Invoice{
		ProjectID:   model.UUID(i.ProjectID),
		BankID:      model.UUID(i.BankID),
		Description: i.Description,
		Note:        i.Note,
		LineItems:   lineItems,
		Email:       i.Email,
		CC:          cc,
		Total:       math.Round(i.Total*100) / 100,
		Discount:    math.Round(i.Discount*100) / 100,
		Tax:         i.Tax,
		SubTotal:    math.Round(i.SubTotal*100) / 100,
		Month:       i.Month + 1,
		Year:        i.Year,
		Status:      defaultStatus,
		SentBy:      senderID,
		DueAt:       &dueAt,
		InvoicedAt:  &invoiceAt,
	}, nil
}

```

# pkg/handler/invoice/errs/errors.go

```go
package errs

import (
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/controller/invoice"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

var (
	ErrInvalidDueAt          = errors.New("invalid due at")
	ErrInvalidPaidAt         = errors.New("invalid paid at")
	ErrInvalidInvoiceStatus  = errors.New("invalid invoice status")
	ErrInvalidInvoiceID      = errors.New("invalid invoice id")
	ErrInvalidProjectID      = errors.New("invalid project id")
	ErrInvalidDeveloperEmail = errors.New("invalid developer email in dev mode")
	ErrSenderNotFound        = errors.New("sender not found")
	ErrBankAccountNotFound   = errors.New("bank account not found")
	ErrProjectNotFound       = errors.New("project not found")
)

func ConvertControllerErr(c *gin.Context, err error) {
	if err == nil {
		return
	}

	var status int

	switch err {
	case
		invoice.ErrInvoiceNotFound:
		status = http.StatusNotFound
	case invoice.ErrProjectNotFound:
		status = http.StatusNotFound
	case invoice.ErrSenderNotFound:
		status = http.StatusNotFound
	case invoice.ErrBankAccountNotFound:
		status = http.StatusNotFound
	case invoice.ErrInvoiceStatusAlready:
		status = http.StatusInternalServerError

	default:
		status = http.StatusInternalServerError
	}

	c.JSON(status, view.CreateResponse[any](nil, nil, err, nil, ""))
}

```

# pkg/handler/feedback/request/request.go

```go
package request

import (
	"github.com/dwarvesf/fortress-api/pkg/handler/feedback/errs"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type GetListFeedbackInput struct {
	view.Pagination

	Status string `json:"status" form:"status"`
}

func (i *GetListFeedbackInput) Validate() error {
	if i.Status != "" && !model.EventReviewerStatus(i.Status).IsValid() {
		return errs.ErrInvalidReviewerStatus
	}

	return nil
}

type DetailInput struct {
	EventID string
	TopicID string
}

func (i *DetailInput) Validate() error {
	if i.EventID == "" || !model.IsUUIDFromString(i.EventID) {
		return errs.ErrInvalidFeedbackID
	}

	if i.TopicID == "" || !model.IsUUIDFromString(i.TopicID) {
		return errs.ErrInvalidTopicID
	}

	return nil
}

type BasicEventQuestionRequest struct {
	EventQuestionID model.UUID `json:"eventQuestionID" form:"eventQuestionID" binding:"required"`
	Answer          string     `json:"answer" form:"answer"`
	Note            string     `json:"note" form:"note"`
} // @name BasicEventQuestionRequest

type SubmitFeedbackRequest struct {
	Answers []BasicEventQuestionRequest `json:"answers" form:"answers" binding:"required"`
	Status  model.EventReviewerStatus   `json:"status" form:"status" binding:"required"`
} // @name SubmitFeedbackRequest

func (i *SubmitFeedbackRequest) Validate() error {
	if !i.Status.IsValid() {
		return errs.ErrInvalidReviewerStatus
	}

	return nil
}

type SubmitInput struct {
	Body    SubmitFeedbackRequest
	EventID string
	TopicID string
}

func (i *SubmitInput) Validate() error {
	if i.EventID == "" || !model.IsUUIDFromString(i.EventID) {
		return errs.ErrInvalidEventID
	}

	if i.TopicID == "" || !model.IsUUIDFromString(i.TopicID) {
		return errs.ErrInvalidTopicID
	}

	return i.Body.Validate()
}

```

# pkg/handler/feedback/errs/errors.go

```go
package errs

import (
	"errors"
	"fmt"
)

var (
	ErrEventNotFound                 = errors.New("event not found")
	ErrReviewerNotFound              = errors.New("reviewer not found")
	ErrProjectNotFound               = errors.New("project not found")
	ErrEmployeeEventReviewerNotFound = errors.New("employee event reviewer not found")
	ErrInvalidEventType              = errors.New("invalid event type")
	ErrInvalidReviewerID             = errors.New("invalid reviewer id")
	ErrInvalidFeedbackID             = errors.New("invalid feedback id")
	ErrTopicNotFound                 = errors.New("topic not found")
	ErrEventReviewerNotFound         = errors.New("employee event reviewer not found")
	ErrEventAlreadyExisted           = errors.New("event already existed")

	ErrInvalidAnswers              = errors.New("invalid answers data")
	ErrInvalidAnswerForLikertScale = errors.New("invalid answer for likert-scale question")
	ErrInvalidEventID              = errors.New("invalid event id")
	ErrInvalidReviewerStatus       = errors.New("invalid reviewer status")
	ErrReviewAlreadySent           = errors.New("review already sent")

	ErrUnansweredquestions      = errors.New("must answer all questions")
	ErrCouldNotEditDoneFeedback = errors.New("could not edit the feedback marked as done")
	ErrInvalidTopicID           = errors.New("invalid topic id")
	ErrInvalidEventSubType      = errors.New("invalid event subtype")
	ErrInvalidQuarter           = errors.New("invalid quarter")
	ErrEmployeeNotFound         = errors.New("employee not found")
	ErrEmployeeNotReady         = errors.New("employee not ready")
	ErrAlreadySent              = errors.New("surveys already sent to all participants")
	ErrUnfinishedReviewer       = errors.New("all reviewers have to finish before marked done")
)

func ErrEventQuestionNotFound(id string) error {
	return fmt.Errorf("employee event question not found: %v", id)
}

```

# pkg/handler/employee/request/request.go

```go
package request

import (
	"regexp"
	"strings"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/handler/employee/errs"
	"github.com/dwarvesf/fortress-api/pkg/model"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

type GetListEmployeeQuery struct {
	view.Pagination

	WorkingStatuses []string `json:"workingStatuses" form:"workingStatuses"`
	Preload         bool     `json:"preload" form:"preload,default=true"`
	Positions       []string `json:"positions" form:"positions"`
	Stacks          []string `json:"stacks" form:"stacks"`
	Projects        []string `json:"projects" form:"projects"`
	Chapters        []string `json:"chapters" form:"chapters"`
	Seniorities     []string `json:"seniorities" form:"seniorities"`
	Organizations   []string `json:"organizations" form:"organizations"`
	LineManagers    []string `json:"lineManagers" form:"lineManagers"`
	Keyword         string   `json:"keyword" form:"keyword"`
} // @name GetListEmployeeQuery

type UpdateEmployeeGeneralInfoRequest struct {
	FullName           string      `form:"fullName" json:"fullName" binding:"required,max=99"`
	Email              string      `form:"email" json:"email" binding:"required,email"`
	Phone              string      `form:"phone" json:"phone" binding:"required,max=18,min=9"`
	LineManagerID      view.UUID   `form:"lineManagerID" json:"lineManagerID"`
	DisplayName        string      `form:"displayName" json:"displayName"`
	GithubID           string      `form:"githubID" json:"githubID"`
	NotionID           string      `form:"notionID" json:"notionID"`
	NotionName         string      `form:"notionName" json:"notionName"`
	NotionEmail        string      `form:"notionEmail" json:"notionEmail"`
	DiscordID          string      `form:"discordID" json:"discordID"`
	DiscordName        string      `form:"discordName" json:"discordName"`
	LinkedInName       string      `form:"linkedInName" json:"linkedInName"`
	LeftDate           string      `form:"leftDate" json:"leftDate"`
	JoinedDate         string      `form:"joinedDate" json:"joinedDate"`
	OrganizationIDs    []view.UUID `form:"organizationIDs" json:"organizationIDs"`
	ReferredBy         view.UUID   `form:"referredBy" json:"referredBy"`
	WiseRecipientID    string      `form:"wiseRecipientID" json:"wiseRecipientID"`
	WiseRecipientEmail string      `form:"wiseRecipientEmail" json:"wiseRecipientEmail"`
	WiseRecipientName  string      `form:"wiseRecipientName" json:"wiseRecipientName"`
	WiseAccountNumber  string      `form:"wiseAccountNumber" json:"wiseAccountNumber"`
	WiseCurrency       string      `form:"wiseCurrency" json:"wiseCurrency"`
} // @name UpdateEmployeeGeneralInfoRequest
type UpdateBaseSalaryRequest struct {
	ContractAmount        int64      `form:"contractAmount" json:"contractAmount" binding:"gte=0"`
	CompanyAccountAmount  int64      `form:"companyAccountAmount" json:"companyAccountAmount" binding:"gte=0"`
	PersonalAccountAmount int64      `form:"personalAccountAmount" json:"personalAccountAmount" binding:"gte=0"`
	CurrencyCode          string     `form:"currencyCode" json:"currencyCode" binding:"required"`
	EffectiveDate         *time.Time `form:"effectiveDate" json:"effectiveDate"`
	Batch                 int        `form:"batch" json:"batch" binding:"required,eq=1|eq=15"`
} // @name UpdateBaseSalaryRequest

type AddMenteeInput struct {
	MenteeID model.UUID `form:"menteeID" json:"menteeID" binding:"required"`
}

type DeleteMenteeInput struct {
	MentorID string
	MenteeID string
}

func (e *DeleteMenteeInput) Validate() error {
	if e.MentorID == "" || !model.IsUUIDFromString(e.MentorID) {
		return errs.ErrInvalidEmployeeID
	}

	if e.MenteeID == "" || !model.IsUUIDFromString(e.MenteeID) {
		return errs.ErrInvalidEmployeeID
	}

	return nil
}

// CreateEmployeeRequest view for create new employee
type CreateEmployeeRequest struct {
	FullName      string       `json:"fullName" binding:"required,max=100"`
	DisplayName   string       `json:"displayName" binding:"required"`
	TeamEmail     string       `json:"teamEmail" binding:"required"`
	PersonalEmail string       `json:"personalEmail" binding:"required,email"`
	Positions     []model.UUID `form:"positions" json:"positions" binding:"required"`
	Salary        int64        `json:"salary" binding:"required"`
	SeniorityID   model.UUID   `json:"seniorityID" binding:"required"`
	Roles         []model.UUID `json:"roles" binding:"required"`
	Status        string       `json:"status" binding:"required"`
	ReferredBy    model.UUID   `json:"referredBy"`
	JoinedDate    string       `json:"joinedDate" binding:"required"`
} // @name CreateEmployeeRequest

type UpdateSkillsRequest struct {
	Positions       []model.UUID `form:"positions" json:"positions" binding:"required"`
	LeadingChapters []model.UUID `form:"leadingChapters" json:"leadingChapters"`
	Chapters        []model.UUID `form:"chapters" json:"chapters" binding:"required"`
	Seniority       model.UUID   `form:"seniority" json:"seniority" binding:"required"`
	Stacks          []model.UUID `form:"stacks" json:"stacks" binding:"required"`
} // @name UpdateSkillsRequest

type UpdatePersonalInfoRequest struct {
	DoB              *time.Time `form:"dob" json:"dob" binding:"required"`
	Gender           string     `form:"gender" json:"gender" binding:"required"`
	PlaceOfResidence string     `form:"placeOfResidence" json:"placeOfResidence"`
	Address          string     `form:"address" json:"address" binding:"required,max=200"`
	PersonalEmail    string     `form:"personalEmail" json:"personalEmail" binding:"required,email"`
	Country          string     `form:"country" json:"country" binding:"required"`
	City             string     `form:"city" json:"city" binding:"required"`
} // @name UpdatePersonalInfoRequest

type UpdateWorkingStatusRequest struct {
	EmployeeStatus WorkingStatus `json:"employeeStatus"`
} // @name UpdateWorkingStatusRequest

type WorkingStatus string // @name WorkingStatus

const (
	WorkingStatusOnBoarding WorkingStatus = "on-boarding"
	WorkingStatusLeft       WorkingStatus = "left"
	WorkingStatusProbation  WorkingStatus = "probation"
	WorkingStatusFullTime   WorkingStatus = "full-time"
	WorkingStatusContractor WorkingStatus = "contractor"
)

func (e WorkingStatus) IsValid() bool {
	switch e {
	case
		WorkingStatusOnBoarding,
		WorkingStatusContractor,
		WorkingStatusLeft,
		WorkingStatusProbation,
		WorkingStatusFullTime:
		return true
	}
	return false
}

// String returns the string type from the WorkingStatus type
func (e WorkingStatus) String() string {
	return string(e)
}

func (i *UpdateWorkingStatusRequest) Validate() error {
	if !i.EmployeeStatus.IsValid() {
		return errs.ErrInvalidEmployeeStatus
	}

	return nil
}

func (input *GetListEmployeeQuery) Validate() error {
	if len(input.Positions) > 0 {
		for _, p := range input.Positions {
			if strings.TrimSpace(p) == "" {
				return errs.ErrInvalidPositionCode
			}
		}
	}
	if len(input.Stacks) > 0 {
		for _, s := range input.Stacks {
			if strings.TrimSpace(s) == "" {
				return errs.ErrInvalidStackCode
			}
		}
	}
	if len(input.Projects) > 0 {
		for _, p := range input.Projects {
			if strings.TrimSpace(p) == "" {
				return errs.ErrInvalidProjectCode
			}
		}
	}
	if len(input.Chapters) > 0 {
		for _, c := range input.Chapters {
			if strings.TrimSpace(c) == "" {
				return errs.ErrInvalidChapterCode
			}
		}
	}
	if len(input.Seniorities) > 0 {
		for _, s := range input.Seniorities {
			if strings.TrimSpace(s) == "" {
				return errs.ErrInvalidSeniorityCode
			}
		}
	}
	if len(input.Organizations) > 0 {
		for _, v := range input.Organizations {
			if strings.TrimSpace(v) == "" {
				return errs.ErrInvalidOrganizationCode
			}
		}
	}

	return nil
}

func (i *CreateEmployeeRequest) Validate() error {
	teamEmailRegex := ".+@((dwarvesv\\.com)|(d\\.foundation))"
	regex, _ := regexp.Compile(teamEmailRegex)
	if i.TeamEmail != "" && !regex.MatchString(i.TeamEmail) {
		return errs.ErrInvalidEmailDomain
	}

	if !model.WorkingStatus(i.Status).IsValid() {
		return errs.ErrInvalidEmployeeStatus
	}

	if len(i.Roles) == 0 {
		return errs.ErrRoleCannotBeEmpty
	}

	_, err := time.Parse("2006-01-02", i.JoinedDate)
	if i.JoinedDate != "" && err != nil {
		return errs.ErrInvalidJoinedDate
	}

	return nil
}

func (i *CreateEmployeeRequest) GetJoinedDate() *time.Time {
	date, err := time.Parse("2006-01-02", i.JoinedDate)
	if i.JoinedDate == "" || err != nil {
		return nil
	}

	return &date
}

type UpdateRoleRequest struct {
	Roles []model.UUID `form:"roles" json:"roles" binding:"required"`
} // @name UpdateRoleRequest

type UpdateRoleInput struct {
	EmployeeID string
	Body       UpdateRoleRequest
}

func (i UpdateRoleInput) Validate() error {
	if i.EmployeeID == "" || !model.IsUUIDFromString(i.EmployeeID) {
		return errs.ErrInvalidEmployeeID
	}

	if len(i.Body.Roles) == 0 {
		return errs.ErrRoleCannotBeEmpty
	}

	return nil
}

type SalaryAdvanceRequest struct {
	DiscordID string `json:"discordID"`
	Amount    string `json:"amount"`
} // @name SalaryAdvanceRequest

type SalaryAdvanceReportRequest struct {
	view.Pagination
	model.SortOrder `json:"sortOrder" form:"sortOrder"`

	IsPaid *bool `json:"isPaid" form:"isPaid"`
} // @name SalaryAdvanceReportRequest

type GetEmployeeEarnTransactionsRequest struct {
	view.Pagination
} // @name GetEmployeeEarnTransactionsRequest

type CheckInRequest struct {
	CheckIns []CheckIn `json:"check_ins" binding:"required,dive,required"`
} // @name CheckInRequest

type CheckIn struct {
	DiscordID string    `json:"discord_id" binding:"required"`
	Time      time.Time `json:"time" binding:"required"`
}

```

# pkg/handler/employee/errs/errors.go

```go
package errs

import (
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/controller/employee"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

var (
	ErrInvalidEmployeeID          = errors.New("invalid employee ID")
	ErrInvalidEmployeeStatus      = errors.New("invalid value for employee status")
	ErrInvalidJoinedDate          = errors.New("invalid join date")
	ErrInvalidPositionCode        = errors.New("invalid position code")
	ErrInvalidStackCode           = errors.New("invalid stack code")
	ErrInvalidProjectCode         = errors.New("invalid project code")
	ErrInvalidChapterCode         = errors.New("invalid chapter code")
	ErrInvalidSeniorityCode       = errors.New("invalid seniority code")
	ErrInvalidOrganizationCode    = errors.New("invalid organization code")
	ErrInvalidEmailDomain         = errors.New("invalid email domain")
	ErrRoleCannotBeEmpty          = errors.New("role cannot be empty")
	ErrCountryNotFound            = errors.New("country not found")
	ErrCityDoesNotBelongToCountry = errors.New("city does not belong to country")
	ErrInvalidLineManagerID       = errors.New("invalid line manager ID")
	ErrInvalidOrganizationID      = errors.New("invalid organization ID")
	ErrInvalidReferredBy          = errors.New("invalid referred by")
	ErrInvalidSortType            = errors.New("invalid sort type")
)

func ConvertControllerErr(c *gin.Context, err error) {
	if err == nil {
		return
	}

	var status int

	switch {
	case errors.Is(err, employee.ErrEmployeeNotFound),
		errors.Is(err, employee.ErrLineManagerNotFound),
		errors.Is(err, employee.ErrRoleNotfound),
		errors.Is(err, employee.ErrSeniorityNotfound),
		errors.Is(err, employee.ErrReferrerNotFound),
		errors.Is(err, employee.ErrOrganizationNotFound),
		errors.Is(err, employee.ErrStackNotFound),
		errors.Is(err, employee.ErrPositionNotFound):
		status = http.StatusNotFound

	case errors.Is(err, employee.ErrInvalidJoinedDate),
		errors.Is(err, employee.ErrInvalidLeftDate),
		errors.Is(err, employee.ErrLeftDateBeforeJoinedDate),
		errors.Is(err, employee.ErrEmployeeExisted),
		errors.Is(err, employee.ErrInvalidCountryOrCity),
		errors.Is(err, employee.ErrInvalidFileExtension),
		errors.Is(err, employee.ErrInvalidFileSize),
		errors.Is(err, employee.ErrInvalidAccountRole),
		errors.Is(err, employee.ErrEmailExisted),
		errors.Is(err, employee.ErrTeamEmailExisted),
		errors.Is(err, employee.ErrSalaryAdvanceExceedAmount),
		errors.Is(err, employee.ErrEmployeeNotFullTime),
		errors.Is(err, employee.ErrPersonalEmailExisted):
		status = http.StatusBadRequest

	default:
		status = http.StatusInternalServerError
	}

	c.JSON(status, view.CreateResponse[any](nil, nil, err, nil, ""))
}

```

# pkg/handler/engagement/request/request.go

```go
package request

import "errors"

var ErrInvalidCount = errors.New("message count or reaction count should be >0")

type UpsertRollupRequest struct {
	DiscordUserID string `json:"discordUserID" binding:"required"`
	LastMessageID string `json:"lastMessageID" binding:"required"`
	ChannelID     string `json:"channelID" binding:"required"`
	CategoryID    string `json:"categoryID"`
	MessageCount  int    `json:"messageCount"`
	ReactionCount int    `json:"reactionCount"`
} // @name UpsertRollupRequest

func (r UpsertRollupRequest) Validate() error {
	if r.MessageCount == 0 && r.ReactionCount == 0 {
		return ErrInvalidCount
	}
	return nil
}

```

# pkg/handler/discord/request/request.go

```go
package request

import (
	"errors"
	"strings"
	"time"

	"github.com/dwarvesf/fortress-api/pkg/handler/discord/errs"
	"github.com/dwarvesf/fortress-api/pkg/model"
)

type BraineryReportInput struct {
	View      string `json:"view" binding:"required"`
	ChannelID string `json:"channelID" binding:"required"`
}

func (input BraineryReportInput) Validate() error {
	if len(input.View) == 0 {
		return errs.ErrEmptyReportView
	}

	if len(input.ChannelID) == 0 {
		return errs.ErrEmptyChannelID
	}
	return nil
}

type DeliveryMetricReportInput struct {
	View               string `json:"view" binding:"required"`
	ChannelID          string `json:"channelID" binding:"required"`
	OnlyCompletedMonth bool   `json:"onlyCompletedMonth"`
	Sync               bool   `json:"sync"`
}

func (input DeliveryMetricReportInput) Validate() error {
	if len(input.View) == 0 {
		return errs.ErrEmptyReportView
	}

	if len(input.ChannelID) == 0 {
		return errs.ErrEmptyChannelID
	}
	return nil
}

type DiscordEventInput struct {
	ID               string    `json:"id"`
	Name             string    `json:"name"`
	Description      string    `json:"description"`
	Date             time.Time `json:"date"`
	Image            string    `json:"image"`
	DiscordEventID   string    `json:"discord_event_id"`
	DiscordChannelID string    `json:"discord_channel_id"`
	DiscordCreatorID string    `json:"discord_creator_id"`
	DiscordMessageID string    `json:"discord_message_id"`
}

func (input DiscordEventInput) Validate() error {
	if len(input.Name) == 0 {
		return errs.ErrEmptyName
	}
	if len(input.DiscordChannelID) == 0 {
		return errs.ErrEmptyChannelID
	}
	if len(input.DiscordCreatorID) == 0 {
		return errs.ErrEmptyCreatorID
	}
	return nil
}

func (in DiscordEventInput) EventType() (model.DiscordScheduledEventType, error) {
	switch {
	case strings.Contains(strings.ToLower(in.Description), "demo"),
		strings.Contains(strings.ToLower(in.Name), "demo"),
		strings.Contains(strings.ToLower(in.Description), "showcase"),
		strings.Contains(strings.ToLower(in.Name), "showcase"):
		return model.DiscordScheduledEventTypeDemo, nil
	case strings.Contains(strings.ToLower(in.Description), "ogif"),
		strings.Contains(strings.ToLower(in.Name), "ogif"):
		return model.DiscordScheduledEventTypeOGIF, nil
	default:
		return model.DiscordScheduledEventType(""), errors.New("invalid event type")
	}
}

type DiscordEventSpeakerInput struct {
	ID    string `json:"id"`
	Topic string `json:"topic"`
}

func (input DiscordEventSpeakerInput) Validate() error {
	if len(input.ID) == 0 {
		return errs.ErrEmptyID
	}
	if len(input.Topic) == 0 {
		return errs.ErrEmptyTopic
	}
	return nil
}

```

# pkg/handler/discord/errs/errors.go

```go
package errs

import "errors"

var (
	ErrEmptyReportView = errors.New("view is empty")
	ErrEmptyChannelID  = errors.New("channelID is empty")
	ErrEmptyGuildID    = errors.New("guildID is empty")
	ErrEmptyCreatorID  = errors.New("creatorID is empty")
	ErrEmptyName       = errors.New("name is empty")
	ErrEmptyDate       = errors.New("date is nil")
	ErrEmptyID         = errors.New("discord user id is nil")
	ErrEmptyTopic      = errors.New("topic is nil")
)

```

# pkg/handler/dashboard/util/util.go

```go
package util

import "time"

type util struct{}

func New() IUtil {
	return &util{}
}

func (u *util) TimeNow() time.Time {
	return time.Now()
}

```

# pkg/handler/dashboard/util/interface.go

```go
package util

import "time"

type IUtil interface {
	TimeNow() time.Time
}

```

# pkg/handler/dashboard/request/request.go

```go
package request

import "github.com/dwarvesf/fortress-api/pkg/model"

type WorkSurveysInput struct {
	ProjectID string `json:"projectID" form:"projectID"`
}
type ActionItemInput struct {
	ProjectID string `json:"projectID" form:"projectID"`
}
type GetEngagementDashboardDetailRequest struct {
	Filter    string `form:"filter" json:"filter"`
	StartDate string `form:"startDate" json:"startDate"`
}

type WorkUnitDistributionInput struct {
	Sort model.SortOrder    `json:"sort" form:"sort"`
	Type model.WorkUnitType `json:"type" form:"type"`
	Name string             `json:"name" form:"name"`
}

type GetResourceWorkSurveySummariesInput struct {
	model.Pagination
	Keyword string `json:"keyword" form:"keyword"`
}

```

# pkg/handler/dashboard/errs/errors.go

```go
package errs

import "errors"

var (
	ErrInvalidProjectID                 = errors.New("invalid project ID")
	ErrProjectNotFound                  = errors.New("project not found")
	ErrEventNotFound                    = errors.New("event not found")
	ErrProjectNotionNotFound            = errors.New("project notion not found")
	ErrInvalidEngagementDashboardFilter = errors.New("invalid engagement dashboard filter")
	ErrInvalidStartDate                 = errors.New("invalid startDate")
	ErrInvalidWorkUnitDistributionType  = errors.New("invalid work unit distribution type")
	ErrInvalidWorkUnitDistributionSort  = errors.New("invalid sort value")
)

```

# pkg/handler/communitynft/errs/errors.go

```go
package errs

import "errors"

var (
	ErrInvalidTokenID        = errors.New("invalid token id")
	ErrTokenNotFound         = errors.New("token not found")
)

```

# pkg/handler/client/request/request.go

```go
package request

type CreateClientRequest struct {
	Name               string                      `json:"name"`
	Description        string                      `json:"description"`
	RegistrationNumber string                      `json:"registrationNumber"`
	Address            string                      `json:"address"`
	Country            string                      `json:"country"`
	Industry           string                      `json:"industry"`
	Website            string                      `json:"website"`
	Contacts           []*CreateClientContactInput `json:"contacts"`
} // @name CreateClientRequest

type CreateClientContactInput struct {
	Name          string   `json:"name"`
	Role          string   `json:"role"`
	Emails        []string `json:"emails"`
	IsMainContact bool     `json:"isMainContact"`
} // @name CreateClientContactInput

type UpdateClientInput struct {
	Name               string                      `json:"name"`
	Description        string                      `json:"description"`
	RegistrationNumber string                      `json:"registrationNumber"`
	Address            string                      `json:"address"`
	Country            string                      `json:"country"`
	Industry           string                      `json:"industry"`
	Website            string                      `json:"website"`
	Contacts           []*UpdateClientContactInput `json:"contacts"`
} // @name UpdateClientInput

type UpdateClientContactInput struct {
	Name          string   `json:"name"`
	Role          string   `json:"role"`
	Emails        []string `json:"emails"`
	IsMainContact bool     `json:"isMainContact"`
} // @name UpdateClientContactInput

```

# pkg/handler/brainerylogs/request/request.go

```go
package request

import (
	"time"

	"github.com/shopspring/decimal"

	"github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs/errs"
)

type CreateBraineryLogRequest struct {
	Title       string          `json:"title" binding:"required"`
	URL         string          `json:"url" binding:"required"`
	GithubID    string          `json:"githubID"`
	DiscordID   string          `json:"discordID" binding:"required"`
	Tags        []string        `json:"tags" binding:"required"`
	PublishedAt string          `json:"publishedAt" binding:"required"`
	Reward      decimal.Decimal `json:"reward" binding:"required"`
} // @name CreateBraineryLogRequest

func (r CreateBraineryLogRequest) Validate() error {
	if _, err := time.Parse(time.RFC3339Nano, r.PublishedAt); err != nil {
		return errs.ErrInvalidPublishedAt
	}
	return nil
}

type SyncBraineryLogs struct {
	StartMessageID string `json:"startMessageID"`
	EndMessageID   string `json:"endMessageID"`
}

```

# pkg/handler/client/errs/errors.go

```go
package errs

import "errors"

var (
	ErrInvalidClientID        = errors.New("invalid client id")
	ErrInvalidClientContactID = errors.New("invalid client contact id")
	ErrClientNotFound         = errors.New("client not found")
)

```

# pkg/handler/brainerylogs/errs/errors.go

```go
package errs

import "errors"

var (
	ErrInvalidPublishedAt = errors.New("cannot parse publishedAt")
	ErrInvalidDateFormat  = errors.New("invalid date format")
)

```

# pkg/handler/auth/request/request.go

```go
package request

type CreateAPIKeyInput struct {
	RoleID string `json:"roleID" form:"roleID"`
}

```

# pkg/handler/asset/errs/errors.go

```go
package errs

import "errors"

var (
	ErrEmployeeNotFound     = errors.New("employee not found")
	ErrProjectNotFound      = errors.New("project not found")
	ErrInvalidFileExtension = errors.New("invalid file extension")
	ErrInvalidFileType      = errors.New("invalid file type")
	ErrInvalidFileSize      = errors.New("invalid file size")
	ErrFileAlreadyExisted   = errors.New("file already existed")
)

```

# pkg/handler/auth/errs/errors.go

```go
package errs

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/dwarvesf/fortress-api/pkg/controller/auth"
	"github.com/dwarvesf/fortress-api/pkg/view"
)

func ConvertControllerErr(c *gin.Context, err error) {
	if err == nil {
		return
	}

	var status int

	switch err {
	case auth.ErrRoleNotfound:
		status = http.StatusNotFound
	case auth.ErrUserNotFound:
		status = http.StatusNotFound
	case auth.ErrUserInactivated:
		status = http.StatusBadRequest
	default:
		status = http.StatusInternalServerError
	}
	c.JSON(status, view.CreateResponse[any](nil, nil, err, nil, ""))
}

```

# pkg/handler/audit/errs/errors.go

```go
package errs

import "errors"

var (
	ErrFailedToGetFlag       = errors.New("failed to get flag")
	ErrMissingAuditorInAudit = errors.New("missing auditor in audit")
	ErrMissingProjectInAudit = errors.New("missing project in audit")
)

```

