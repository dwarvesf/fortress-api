# .aidigestignore

```
Dockerfile tools.Dockerfile .env go.* devbox.* .golangci.yml .gitignore .air.toml dbconfig.yml CODEOWNERS README.md docker-compose.yml Makefile .github/* docs/* cmd/server/main.go migrations/* pkg/controller/auth/* pkg/handler/auth/* pkg/handler/vault/* pkg/handler/healthz/* pkg/handler/dashboard/util/mocks/* pkg/config/* pkg/contracts/* pkg/logger/* pkg/mw/* pkg/utils/* pkg/view/* pkg/templates/* **_test.go **/testdata/*
```

# pkg/constant/constant.go

```go
package constant const ( RegexPatternDiscordChannelID = `<#(\d+)>` RegexPatternDiscordID = `<@(\d+)>` RegexPatternEmail = `\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]+\b` RegexPatternIcyReward = ` (\d+)` RegexPatternNumber = `\d{18,}` RegexPatternUrl = `((?:https?://)[^\s]+)` RegexPatternGithub = `gh:(\w+)` RegexPatternDescription = `d:"(.*?)"` RegexPatternTime = `t:(\w+)` )
```

# pkg/controller/brainerylogs/create.go

```go
package brainerylogs import ( "errors" "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) // Create creates a new brainery log func (c *controller) Create(log model.BraineryLog) (model.BraineryLog, error) { emp, err := c.store.Employee.GetByDiscordID(c.repo.DB(), log.DiscordID, false) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { c.logger.Errorf(err, "failed to get employee by discordID", "discordID", log.DiscordID) return model.BraineryLog{}, err } if !errors.Is(err, gorm.ErrRecordNotFound) { log.EmployeeID = emp.ID } _, err = c.store.BraineryLog.Create(c.repo.DB(), []model.BraineryLog{log}) if err != nil { c.logger.Errorf(err, "failed to create brainery logs", "braineryLog", log) return model.BraineryLog{}, err } return log, nil }
```

# pkg/controller/brainerylogs/get_metrics.go

```go
package brainerylogs import ( "errors" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" ) // GetMetrics returns brainery metrics func (c *controller) GetMetrics(selectedDate time.Time, queryView string) (latestPosts []*model.BraineryLog, logs []*model.BraineryLog, ncids []string, err error) { l := c.logger.Fields(logger.Fields{ "controller": "brainerylogs", "method": "GetBraineryMetrics", }) end := timeutil.GetEndDayOfWeek(selectedDate) start := timeutil.GetStartDayOfWeek(selectedDate) if queryView == "monthly" { start = timeutil.FirstDayOfMonth(int(selectedDate.Month()), selectedDate.Year()) end = timeutil.LastDayOfMonth(int(selectedDate.Month()), selectedDate.Year()) } // latest 10 posts latestPosts, err = c.store.BraineryLog.GetLimitByTimeRange(c.repo.DB(), &time.Time{}, &end, 10) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { l.Errorf(err, "failed to get latest posts by time range", "start", start, "end", end) return nil, nil, nil, err } // weekly or monthly posts logs, err = c.store.BraineryLog.GetLimitByTimeRange(c.repo.DB(), &start, &end, 1000) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { l.Errorf(err, "failed to get logs by time range", "start", start, "end", end) return nil, nil, nil, err } // ncids = new contributor discord IDs ncids, err = c.store.BraineryLog.GetNewContributorDiscordIDs(c.repo.DB(), &start, &end) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { l.Errorf(err, "failed to get new contributor discord IDs by time range", "start", start, "end", end) return nil, nil, nil, err } return latestPosts, logs, ncids, nil }
```

# pkg/controller/brainerylogs/new.go

```go
package brainerylogs import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "time" ) type controller struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } type IController interface { Create(log model.BraineryLog) (model.BraineryLog, error) GetMetrics(selectedDate time.Time, queryView string) (latestPosts []*model.BraineryLog, logs []*model.BraineryLog, ncids []string, err error) }
```

# pkg/controller/client/create.go

```go
package client import ( "encoding/json" "github.com/gin-gonic/gin" "gorm.io/datatypes" "github.com/dwarvesf/fortress-api/pkg/handler/client/request" "github.com/dwarvesf/fortress-api/pkg/model" ) func (r *controller) Create(c *gin.Context, input request.CreateClientRequest) (*model.Client, error) { tx, done := r.repo.NewTransaction() // Create client client, err := r.store.Client.Create(tx.DB(), &model.Client{ Name: input.Name, Description: input.Description, RegistrationNumber: input.RegistrationNumber, Address: input.Address, Country: input.Country, Industry: input.Industry, Website: input.Website, }) if err != nil { return nil, done(err) } // Create client contact for _, clientContact := range input.Contacts { // parse struct email to json emails, err := json.Marshal(model.ClientEmail{Emails: clientContact.Emails}) if err != nil { return nil, done(err) } contact, err := r.store.ClientContact.Create(tx.DB(), &model.ClientContact{ ClientID: client.ID, Name: clientContact.Name, Role: clientContact.Role, Emails: datatypes.JSON(emails), IsMainContact: clientContact.IsMainContact, }) if err != nil { return nil, done(err) } client.Contacts = append(client.Contacts, *contact) } return client, done(nil) }
```

# pkg/controller/client/delete.go

```go
package client import ( "net/http" "github.com/gin-gonic/gin" ) func (r *controller) Delete(c *gin.Context, clientID string) (int, error) { // Check client existence exists, err := r.store.Client.IsExist(r.repo.DB(), clientID) if err != nil { return http.StatusInternalServerError, err } if !exists { return http.StatusNotFound, ErrClientNotFound } tx, done := r.repo.NewTransaction() // Delete client if err = r.store.Client.Delete(tx.DB(), clientID); err != nil { return http.StatusInternalServerError, done(err) } // Delete client contacts if err = r.store.ClientContact.DeleteByClientID(tx.DB(), clientID); err != nil { return http.StatusInternalServerError, done(err) } return http.StatusOK, done(nil) }
```

# pkg/controller/client/detail.go

```go
package client import ( "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" ) func (r *controller) Detail(c *gin.Context, clientID string) (*model.Client, error) { client, err := r.store.Client.One(r.repo.DB(), clientID) if err != nil { return nil, err } return client, nil }
```

# pkg/controller/client/errors.go

```go
package client import "errors" var ( ErrInvalidClientID = errors.New("invalid client id") ErrInvalidClientContactID = errors.New("invalid client contact id") ErrClientNotFound = errors.New("client not found") ErrClientContactNotFound = errors.New("client contact not found") ErrMismatchClientID = errors.New("mismatch client id") )
```

# pkg/controller/client/list.go

```go
package client import ( "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" ) func (r *controller) List(c *gin.Context) ([]*model.Client, error) { clients, err := r.store.Client.All(r.repo.DB(), false, false) if err != nil { return nil, err } return clients, nil } func (r *controller) PublicList(c *gin.Context) ([]*model.Client, error) { clients, err := r.store.Client.All(r.repo.DB(), true, true) if err != nil { return nil, err } return clients, nil }
```

# pkg/controller/client/new.go

```go
package client import ( "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/handler/client/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type controller struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } type IController interface { Create(c *gin.Context, input request.CreateClientRequest) (client *model.Client, err error) List(c *gin.Context) (client []*model.Client, err error) Detail(c *gin.Context, clientID string) (client *model.Client, err error) Update(c *gin.Context, clientID string, input request.UpdateClientInput) (errCode int, err error) Delete(c *gin.Context, clientID string) (errCode int, err error) PublicList(c *gin.Context) (client []*model.Client, err error) }
```

# pkg/controller/client/update.go

```go
package client import ( "encoding/json" "errors" "net/http" "github.com/dwarvesf/fortress-api/pkg/handler/client/request" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/gin-gonic/gin" "gorm.io/datatypes" "gorm.io/gorm" ) func (r *controller) Update(c *gin.Context, clientID string, input request.UpdateClientInput) (int, error) { tx, done := r.repo.NewTransaction() // Get client by id client, err := r.store.Client.One(tx.DB(), clientID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return http.StatusNotFound, done(ErrClientNotFound) } return http.StatusInternalServerError, done(err) } // Update client client.Name = input.Name client.Description = input.Description client.RegistrationNumber = input.RegistrationNumber client.Address = input.Address client.Country = input.Country client.Industry = input.Industry client.Website = input.Website _, err = r.store.Client.UpdateSelectedFieldsByID(tx.DB(), clientID, *client, "name", "description", "registration_number", "address", "country", "industry", "website") if err != nil { return http.StatusInternalServerError, done(err) } // Delete all client contacts if err = r.store.ClientContact.DeleteByClientID(tx.DB(), clientID); err != nil { return http.StatusInternalServerError, done(err) } // Create client contact for _, clientContact := range input.Contacts { // parse struct email to json emails, err := json.Marshal(model.ClientEmail{Emails: clientContact.Emails}) if err != nil { return http.StatusInternalServerError, done(err) } _, err = r.store.ClientContact.Create(tx.DB(), &model.ClientContact{ ClientID: model.MustGetUUIDFromString(clientID), Name: clientContact.Name, Role: clientContact.Role, Emails: datatypes.JSON(emails), IsMainContact: clientContact.IsMainContact, }) if err != nil { return http.StatusInternalServerError, done(err) } } return http.StatusOK, done(nil) }
```

# pkg/controller/communitynft/errors.go

```go
package communitynft import "errors" var ( ErrInvalidTokenID = errors.New("invalid token id") ErrTokenNotFound = errors.New("token not found") ErrMochiProfileNotFound = errors.New("mochi profile not found") )
```

# pkg/controller/communitynft/metadata.go

```go
package communitynft import ( "bytes" "encoding/base64" "fmt" "io" "net/http" "os" "path/filepath" "strings" "text/template" "time" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/mochiprofile" ) type role struct { Name string } type nftEmbedData struct { TokenId string // Profile Info DisplayName string Username string AvatarBase64 string JoinedDate string // User stats GlobalXP int ChatActivity int Level int // User discord roles Roles []role } func (c *controller) GetNftMetadata(tokenId int) (*model.NftMetadata, error) { // 1 Get owner of an NFT addr, err := c.service.CommunityNft.OwnerOf(tokenId) if err != nil { return nil, ErrTokenNotFound } // 2 Get nft needed data // 2.1 get mochi profile of nft owner profile, err := c.service.MochiProfile.GetProfileByEvmAddress(addr) if err != nil { return nil, ErrMochiProfileNotFound } var discordProfile mochiprofile.AssociatedAccounts for _, acc := range profile.AssociatedAccounts { if acc.Platform == "discord" { discordProfile = acc break } } discordUsername, ok := discordProfile.PlatformMetadata["username"] if !ok { discordUsername = "unknown" } displayName := profile.ProfileName if displayName == "" { displayName = strings.ToTitle(fmt.Sprintf("%s", discordUsername)) } joinedDate := profile.CreatedAt.Format("May 02, 2006") userAvatar, err := c.userAvatarBase64(profile.Avatar) if err != nil { return nil, err } // 2.2 get tono guild user stats of mochi profile dfGuildId := "462663954813157376" guildProfile, err := c.service.Tono.GetGuildUserProfile(profile.ID, dfGuildId) if err != nil { return nil, err } // 2.3 get user discord roles // TODO: get user discord roles roles := []role{{Name: "peeps"}} // 2.4 compose nft embed data embedData := nftEmbedData{ TokenId: fmt.Sprintf("#%d", tokenId), DisplayName: displayName, Username: fmt.Sprintf("@%s", discordUsername), JoinedDate: joinedDate, GlobalXP: guildProfile.GuildXP, ChatActivity: guildProfile.NrOfActions, Level: guildProfile.CurrentLevel.Level, Roles: roles, AvatarBase64: userAvatar, } // 3. Generate image from embed data img, err := c.nftImage(embedData) if err != nil { return nil, err } // 4. Compose metadata metadata := &model.NftMetadata{ Name: embedData.DisplayName, Description: "Dwarves Foundation NFT", Image: img, BackgroundColor: "F0F4FC", Attributes: []model.NftAttribute{ { TraitType: "Global XP", Value: fmt.Sprint(embedData.GlobalXP), }, { TraitType: "Chat Activity", Value: fmt.Sprint(embedData.ChatActivity), }, { TraitType: "Level", Value: fmt.Sprint(embedData.Level), }, }, } return metadata, nil } func (c *controller) nftImage(data nftEmbedData) (string, error) { templatePath := c.config.Invoice.TemplatePath if c.config.Env == "local" || templatePath == "" { pwd, err := os.Getwd() if err != nil { pwd = os.Getenv("GOPATH") + "/src/github.com/dwarvesf/fortress-api" } templatePath = filepath.Join(pwd, "pkg/templates") } tmplFileName := "community_nft.tpl" tmpl, err := template.New("nft").ParseFiles(filepath.Join(templatePath, tmplFileName)) if err != nil { return "", err } var buf bytes.Buffer if err := tmpl.ExecuteTemplate(&buf, tmplFileName, data); err != nil { return "", err } img := base64.StdEncoding.EncodeToString(buf.Bytes()) return fmt.Sprintf("data:image/svg+xml;base64,%s", img), nil } func (c *controller) userAvatarBase64(avatarURL string) (string, error) { if avatarURL == "" { return "", nil } client := http.Client{ Timeout: 10 * time.Second, } resp, err := client.Get(avatarURL) if err != nil { return "", err } defer resp.Body.Close() data, err := io.ReadAll(resp.Body) if err != nil { return "", err } contentType := http.DetectContentType(data) imgB64Str := base64.StdEncoding.EncodeToString(data) return fmt.Sprintf("data:%s;base64,%s", contentType, imgB64Str), nil }
```

# pkg/controller/communitynft/new.go

```go
package communitynft import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type controller struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } type IController interface { GetNftMetadata(tokenId int) (metadata *model.NftMetadata, err error) }
```

# pkg/controller/companyinfo/list.go

```go
package companyinfo import ( "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" ) func (r *controller) List(c *gin.Context) ([]*model.CompanyInfo, error) { companyInfos, err := r.store.CompanyInfo.All(r.repo.DB()) if err != nil { return nil, err } return companyInfos, nil }
```

# pkg/controller/companyinfo/new.go

```go
package companyinfo import ( "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type controller struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } type IController interface { List(c *gin.Context) ([]*model.CompanyInfo, error) }
```

# pkg/controller/controller.go

```go
package controller import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller/auth" "github.com/dwarvesf/fortress-api/pkg/controller/brainerylogs" "github.com/dwarvesf/fortress-api/pkg/controller/client" "github.com/dwarvesf/fortress-api/pkg/controller/communitynft" "github.com/dwarvesf/fortress-api/pkg/controller/companyinfo" "github.com/dwarvesf/fortress-api/pkg/controller/conversionrate" "github.com/dwarvesf/fortress-api/pkg/controller/deliverymetrics" "github.com/dwarvesf/fortress-api/pkg/controller/discord" "github.com/dwarvesf/fortress-api/pkg/controller/earn" "github.com/dwarvesf/fortress-api/pkg/controller/employee" "github.com/dwarvesf/fortress-api/pkg/controller/event" "github.com/dwarvesf/fortress-api/pkg/controller/icy" "github.com/dwarvesf/fortress-api/pkg/controller/invoice" "github.com/dwarvesf/fortress-api/pkg/controller/memologs" "github.com/dwarvesf/fortress-api/pkg/controller/news" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/worker" ) type Controller struct { Auth auth.IController BraineryLog brainerylogs.IController Client client.IController CompanyInfo companyinfo.IController ConversionRate conversionrate.IController DeliveryMetric deliverymetrics.IController Employee employee.IController Invoice invoice.IController Discord discord.IController Icy icy.IController MemoLog memologs.IController CommunityNft communitynft.IController Earn earn.IController News news.IController Event event.IController } func New(store *store.Store, repo store.DBRepo, service *service.Service, worker *worker.Worker, logger logger.Logger, cfg *config.Config) *Controller { return &Controller{ Auth: auth.New(store, repo, service, logger, cfg), BraineryLog: brainerylogs.New(store, repo, service, logger, cfg), Client: client.New(store, repo, service, logger, cfg), CompanyInfo: companyinfo.New(store, repo, service, logger, cfg), ConversionRate: conversionrate.New(store, repo, service, logger, cfg), DeliveryMetric: deliverymetrics.New(store, repo, service, logger, cfg), Employee: employee.New(store, repo, service, logger, cfg), Invoice: invoice.New(store, repo, service, worker, logger, cfg), Discord: discord.New(store, repo, service, logger, cfg), Icy: icy.New(service, logger, cfg), MemoLog: memologs.New(store, repo, service, logger, cfg), CommunityNft: communitynft.New(store, repo, service, logger, cfg), Earn: earn.New(store, repo, service, logger, cfg), News: news.New(store, service, logger, cfg), Event: event.New(store, repo, service, logger, cfg), } }
```

# pkg/controller/conversionrate/errors.go

```go
package conversionrate var ()
```

# pkg/controller/conversionrate/new.go

```go
package conversionrate import ( "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type controller struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } type IController interface { Sync(c *gin.Context) error }
```

# pkg/controller/conversionrate/sync.go

```go
package conversionrate import ( "github.com/gin-gonic/gin" "github.com/shopspring/decimal" ) var destCurrencies = []string{"USD", "VND"} func (r *controller) Sync(c *gin.Context) error { tx, done := r.repo.NewTransaction() // Get list conversion rate conversionRates, err := r.store.ConversionRate.GetList(tx.DB()) if err != nil { return done(err) } currencyRateMap := make(map[string]float64) for _, conversionRate := range conversionRates { srcCurrency := conversionRate.Currency.Name for _, destCurrency := range destCurrencies { rate, err := r.service.Wise.GetRate(srcCurrency, destCurrency) if err != nil { return done(err) } currencyRateMap[destCurrency] = rate } for k, v := range currencyRateMap { switch k { case "USD": conversionRate.ToUSD = decimal.NewFromFloat(v) case "VND": conversionRate.ToVND = decimal.NewFromFloat(v) } } if err := r.store.ConversionRate.Update(tx.DB(), &conversionRate); err != nil { return done(err) } } return done(nil) }
```

# pkg/controller/deliverymetrics/get.go

```go
package deliverymetrics import ( "errors" "math" "github.com/shopspring/decimal" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/store" ) func (c controller) GetWeeklyReport() (*model.WeeklyReport, error) { return GetWeeklyReport(c.store, c.repo.DB()) } func GetWeeklyReport(s *store.Store, db *gorm.DB) (*model.WeeklyReport, error) { // Get data of latest week metrics, err := s.WeeklyDeliveryMetric.GetLast(db, 2) if err != nil { return nil, err } if len(metrics) < 2 { return nil, errors.New("not enough data") } currentReport := metrics[0] lastWeekReport := metrics[1] report := &model.WeeklyReport{ LastWeek: model.WeekReport{ Date: lastWeekReport.Date, TotalPoints: decimalToRoundedFloat32(lastWeekReport.SumWeight), Effort: decimalToRoundedFloat32(lastWeekReport.SumEffort), }, CurrentWeek: model.WeekReport{ Date: currentReport.Date, TotalPoints: decimalToRoundedFloat32(currentReport.SumWeight), Effort: decimalToRoundedFloat32(currentReport.SumEffort), }, } // Avg avgMetric, err := s.WeeklyDeliveryMetric.Avg(db) if err != nil { return nil, err } report.CurrentWeek.AvgPoint = decimalToRoundedFloat32(avgMetric.Weight) report.CurrentWeek.AvgEffort = decimalToRoundedFloat32(avgMetric.Effort) avgWithoutLatestWeek, err := s.WeeklyDeliveryMetric.AvgWithoutLatestWeek(db) if err != nil { return nil, err } report.LastWeek.AvgPoint = decimalToRoundedFloat32(avgWithoutLatestWeek.Weight) report.LastWeek.AvgEffort = decimalToRoundedFloat32(avgWithoutLatestWeek.Effort) // Compare data of current week and last week report.TotalPointChangePercentage = roundFloat32To2Decimals( (report.CurrentWeek.TotalPoints - report.LastWeek.TotalPoints) / report.LastWeek.TotalPoints * 100) report.EffortChangePercentage = roundFloat32To2Decimals( (report.CurrentWeek.Effort - report.LastWeek.Effort) / report.LastWeek.Effort * 100) report.AvgPointChangePercentage = roundFloat32To2Decimals( (report.CurrentWeek.AvgPoint - report.LastWeek.AvgPoint) / report.LastWeek.AvgPoint * 100) report.AvgEffortChangePercentage = roundFloat32To2Decimals( (report.CurrentWeek.AvgEffort - report.LastWeek.AvgEffort) / report.LastWeek.AvgEffort * 100) return report, nil } func (c controller) GetMonthlyReport() (*model.MonthlyReport, error) { return GetMonthlyReport(c.store, c.repo.DB(), 3) // 1 current month could be not completed yet } func GetMonthlyReport(s *store.Store, db *gorm.DB, monthNumToTake int) (*model.MonthlyReport, error) { // Get data of the latest month metrics, err := s.MonthlyDeliveryMetric.GetLast(db, monthNumToTake) if err != nil { return nil, err } if len(metrics) < 2 { return nil, errors.New("not enough data") } reports := make([]model.MonthReport, 0, monthNumToTake) for _, m := range metrics { r := model.MonthReport{ Month: m.Month, TotalWeight: decimalToRoundedFloat32(m.SumWeight), Effort: decimalToRoundedFloat32(m.SumEffort), } // Avg monthly avgMetric, err := s.MonthlyDeliveryMetric.AvgTo(db, m.Month) if err != nil { return nil, err } r.AvgWeight = decimalToRoundedFloat32(avgMetric.Weight) r.AvgEffort = decimalToRoundedFloat32(avgMetric.Effort) // Avg month weekly if m.Month != nil { avgMonthWeekly, err := s.WeeklyDeliveryMetric.AvgByMonth(db, *m.Month) if err != nil { return nil, err } if len(avgMonthWeekly) == 0 { return nil, errors.New("missing month weekly data") } r.AvgWeeklyWeight = decimalToRoundedFloat32(avgMonthWeekly[0].Weight) r.AvgWeeklyEffort = decimalToRoundedFloat32(avgMonthWeekly[0].Effort) } reports = append(reports, r) } // Calculate change with previous month for i := 0; i < len(reports)-1; i++ { currentReport := reports[i] prevMonthReport := reports[i+1] currentReport.TotalPointChangePercentage = roundFloat32To2Decimals( (currentReport.TotalWeight - prevMonthReport.TotalWeight) / prevMonthReport.TotalWeight * 100) currentReport.EffortChangePercentage = roundFloat32To2Decimals( (currentReport.Effort - prevMonthReport.Effort) / prevMonthReport.Effort * 100) currentReport.AvgWeightChangePercentage = roundFloat32To2Decimals( (currentReport.AvgWeight - prevMonthReport.AvgWeight) / prevMonthReport.AvgWeight * 100) currentReport.AvgEffortChangePercentage = roundFloat32To2Decimals( (currentReport.AvgEffort - prevMonthReport.AvgEffort) / prevMonthReport.AvgEffort * 100) currentReport.AvgWeeklyPointChangePercentage = roundFloat32To2Decimals( (currentReport.AvgWeeklyWeight - prevMonthReport.AvgWeeklyWeight) / prevMonthReport.AvgWeeklyWeight * 100) currentReport.AvgWeeklyEffortChangePercentage = roundFloat32To2Decimals( (currentReport.AvgWeeklyEffort - prevMonthReport.AvgWeeklyEffort) / prevMonthReport.AvgWeeklyEffort * 100) // Update new value to slice reports[i] = currentReport } return &model.MonthlyReport{ Reports: reports, }, nil } func decimalToRoundedFloat32(d decimal.Decimal) float32 { f, _ := d.Float64() rounded := math.Round(f*100) / 100 return float32(rounded) } func roundFloat32To2Decimals(f float32) float32 { rounded := math.Round(float64(f)*100) / 100 return float32(rounded) }
```

# pkg/controller/deliverymetrics/leaderboard.go

```go
package deliverymetrics import ( "time" "github.com/pkg/errors" "github.com/shopspring/decimal" "github.com/dwarvesf/fortress-api/pkg/model" ) func (c controller) GetWeeklyLeaderBoard() (*model.LeaderBoard, error) { w, err := c.store.DeliveryMetric.GetLatestWeek(c.repo.DB()) if err != nil { return nil, errors.Wrap(err, "failed to get latest week") } // Get top 10 users with highest points metrics, err := c.store.DeliveryMetric.GetTopWeighMetrics(c.repo.DB(), w, 5) if err != nil { return nil, errors.Wrap(err, "failed to get top users with highest points") } items := make([]model.LeaderBoardItem, 0, len(metrics)) // Get user info for _, m := range metrics { e, err := c.store.Employee.One(c.repo.DB(), m.EmployeeID.String(), false) if err != nil { return nil, errors.Wrap(err, "failed to get employee "+m.EmployeeID.String()) } // Get discord acc d, err := c.store.DiscordAccount.One(c.repo.DB(), e.DiscordAccountID.String()) if err != nil { return nil, errors.Wrap(err, "failed to get discord account "+e.DiscordAccountID.String()+" of employee "+e.ID.String()) } item := model.LeaderBoardItem{ EmployeeID: e.ID.String(), EmployeeName: e.DisplayName, Points: m.SumWeight, DiscordID: d.DiscordID, DiscordUsername: d.DiscordUsername, } if m.SumEffort.IsZero() { item.Effectiveness = decimal.NewFromFloat(0) } else { item.Effectiveness = m.SumWeight.DivRound(m.SumEffort, 2) } items = append(items, item) } return &model.LeaderBoard{ Date: w, Items: rankItems(items), }, nil } func (c controller) GetMonthlyLeaderBoard(month *time.Time) (*model.LeaderBoard, error) { m := month if m == nil { var err error m, err = c.store.DeliveryMetric.GetLatestMonth(c.repo.DB()) if err != nil { return nil, errors.Wrap(err, "failed to get latest month") } } // Get top 10 users with highest points metrics, err := c.store.DeliveryMetric.GetTopMonthlyWeighMetrics(c.repo.DB(), m, 10) if err != nil { return nil, errors.Wrap(err, "failed to get top users with highest points") } items := make([]model.LeaderBoardItem, 0, len(metrics)) // Get user info for _, m := range metrics { e, err := c.store.Employee.One(c.repo.DB(), m.EmployeeID.String(), false) if err != nil { return nil, errors.Wrap(err, "failed to get employee "+m.EmployeeID.String()) } item := model.LeaderBoardItem{ EmployeeID: e.ID.String(), EmployeeName: e.DisplayName, Points: m.Weight, Effectiveness: m.Effectiveness, } // Get discord acc if !e.DiscordAccountID.IsZero() { d, err := c.store.DiscordAccount.One(c.repo.DB(), e.DiscordAccountID.String()) if err != nil { return nil, errors.Wrap(err, "failed to get discord account "+e.DiscordAccountID.String()+" of employee "+e.ID.String()) } if d != nil { item.DiscordID = d.DiscordID item.DiscordUsername = d.DiscordUsername } } items = append(items, item) } return &model.LeaderBoard{ Date: m, Items: rankItems(items), }, nil } func rankItems(data []model.LeaderBoardItem) []model.LeaderBoardItem { // Set the rank for each employee for i := range data { if i > 0 && data[i].Points.Equal(data[i-1].Points) && data[i].Effectiveness.Equal(data[i-1].Effectiveness) { data[i].Rank = data[i-1].Rank } else { data[i].Rank = i + 1 } } return data }
```

# pkg/controller/deliverymetrics/new.go

```go
package deliverymetrics import ( "time" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type IController interface { GetWeeklyReport() (*model.WeeklyReport, error) GetMonthlyReport() (*model.MonthlyReport, error) GetWeeklyLeaderBoard() (*model.LeaderBoard, error) GetMonthlyLeaderBoard(month *time.Time) (*model.LeaderBoard, error) Sync() error } type controller struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, repo: repo, service: service, logger: logger, config: cfg, } }
```

# pkg/controller/deliverymetrics/sync.go

```go
package deliverymetrics import ( "errors" "strings" "time" "github.com/shopspring/decimal" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/store/employee" ) func (c controller) Sync() error { l := c.logger.Fields(logger.Fields{ "controller": "deliverymetrics", "method": "Create", }) latestItem, err := c.store.DeliveryMetric.GetLatest(c.repo.DB()) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { l.Errorf(err, "failed to get latest item") return err } maxIdx := 0 if errors.Is(err, gorm.ErrRecordNotFound) { maxIdx = 2 } else { maxIdx = latestItem.Ref + 1 } sheetData, err := c.service.GoogleSheet.FetchSheetContent(maxIdx) if err != nil { l.Errorf(err, "failed to fetch sheet content") return err } employees, err := c.store.Employee.GetRawList(c.repo.DB(), employee.EmployeeFilter{}) if err != nil { l.Errorf(err, "failed to fetch employee") return err } employeeMap := model.Employees(employees).ToTeamEmailIDMap() projects, err := c.store.Project.GetRawList(c.repo.DB()) if err != nil { l.Errorf(err, "failed to fetch project") return err } projectMap := model.Projects(projects).ToNameIDMap() deliveryMetrics := make([]model.DeliveryMetric, 0) for _, row := range sheetData { defaultVal := decimal.NewFromInt(0) weight, err := decimal.NewFromString(strings.ReplaceAll(row.Weight, ",", ".")) if err != nil { weight = defaultVal } effort, err := decimal.NewFromString(strings.ReplaceAll(row.Effort, ",", ".")) if err != nil { effort = defaultVal } effectiveness, err := decimal.NewFromString(strings.ReplaceAll(row.Effectiveness, ",", ".")) if err != nil { effectiveness = defaultVal } date, err := time.Parse("01-02-2006", row.Date) if err != nil { continue } projectName := row.Project if row.Project == "Internal" { projectName = "Fortress v2.0" } projectID := projectMap[projectName] employeeID := employeeMap[row.Email] dm := model.DeliveryMetric{ Weight: weight, Effort: effort, Effectiveness: effectiveness, EmployeeID: employeeID, ProjectID: projectID, Date: &date, Ref: maxIdx, } deliveryMetrics = append(deliveryMetrics, dm) maxIdx++ } if len(deliveryMetrics) > 0 { _, err = c.store.DeliveryMetric.Create(c.repo.DB(), deliveryMetrics) if err != nil { l.Errorf(err, "failed to create delivery metric") return err } } return nil }
```

# pkg/controller/discord/new.go

```go
package discord import ( "context" "fmt" "sort" "strings" "sync" "time" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type IController interface { Log(in model.LogDiscordInput) error PublicAdvanceSalaryLog(in model.LogDiscordInput) error ListDiscordResearchTopics(ctx context.Context, days, limit, offset int) ([]model.DiscordResearchTopic, int64, error) UserOgifStats(ctx context.Context, discordID string, after time.Time) (OgifStats, error) GetOgifLeaderboard(ctx context.Context, after time.Time, limit int) ([]model.OgifLeaderboardRecord, error) } type controller struct { store *store.Store service *service.Service logger logger.Logger config *config.Config repo store.DBRepo } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, service: service, logger: logger, config: cfg, repo: repo, } } func (c *controller) Log(in model.LogDiscordInput) error { // Get discord template template, err := c.store.DiscordLogTemplate.GetTemplateByType(c.repo.DB(), in.Type) if err != nil { c.logger.Field("err", err.Error()).Warn("Get Discord Template failed") return err } data := in.Data.(map[string]interface{}) // get employee_id in discord format if any if employeeID, ok := data["employee_id"]; ok { employee, err := c.store.Employee.One(c.repo.DB(), employeeID.(string), false) if err != nil { c.logger.Field("err", err.Error()).Warn("Get Employee failed") return err } accountID := employee.DisplayName if employee.DiscordAccount != nil && employee.DiscordAccount.DiscordID != "" { accountID = fmt.Sprintf("<@%s>", employee.DiscordAccount.DiscordID) } data["employee_id"] = accountID } if updatedEmployeeID, ok := data["updated_employee_id"]; ok { updatedEmployee, err := c.store.Employee.One(c.repo.DB(), updatedEmployeeID.(string), false) if err != nil { c.logger.Field("err", err.Error()).Warn("Get Employee failed") return err } accountID := updatedEmployee.DisplayName if updatedEmployee.DiscordAccount != nil && updatedEmployee.DiscordAccount.DiscordID != "" { accountID = fmt.Sprintf("<@%s>", updatedEmployee.DiscordAccount.DiscordID) } data["updated_employee_id"] = accountID } // Replace template content := template.Content for k, v := range data { content = strings.ReplaceAll(content, fmt.Sprintf("{{ %s }}", k), fmt.Sprintf("%v", v)) } // log discord _, err = c.service.Discord.SendMessage(model.DiscordMessage{ Content: content, }, c.config.Discord.Webhooks.AuditLog) if err != nil { c.logger.Field("err", err.Error()).Warn("Log failed") return err } return nil } func (c *controller) PublicAdvanceSalaryLog(in model.LogDiscordInput) error { data := in.Data.(map[string]interface{}) icyAmount := data["icy_amount"] usdAmount := data["usd_amount"] desc := fmt.Sprintf("ðŸ§Š %v ICY (%v) has been sent to an anonymous peep as a salary advance.\n", icyAmount, usdAmount) desc += "\nFull-time peeps can use `?salary advance` to take a short-term credit benefit." embedMessage := model.DiscordMessageEmbed{ Author: model.DiscordMessageAuthor{}, Title: "ðŸ’¸ New ICY Payment ðŸ’¸", URL: "", Description: desc, Color: 3447003, Fields: nil, Thumbnail: model.DiscordMessageImage{}, Image: model.DiscordMessageImage{}, Footer: model.DiscordMessageFooter{ IconURL: "https://cdn.discordapp.com/avatars/564764617545482251/9c9bd4aaba164fc0b92f13f052405b4d.webp?size=160", Text: "?help to see all commands", }, Timestamp: time.Now().Format("2006-01-02T15:04:05.000+07:00"), } // log discord _, err := c.service.Discord.SendMessage(model.DiscordMessage{ Embeds: []model.DiscordMessageEmbed{embedMessage}, }, c.config.Discord.Webhooks.ICYPublicLog) if err != nil { c.logger.Field("err", err.Error()).Warn("Log failed") return err } return nil } func (c *controller) ListDiscordResearchTopics(ctx context.Context, days, limit, offset int) ([]model.DiscordResearchTopic, int64, error) { topics, err := c.service.Discord.ListActiveThreadsByChannelID(c.config.Discord.IDs.DwarvesGuild, c.config.Discord.IDs.ResearchChannel) if err != nil { c.logger.Error(err, "Fetch list research topics failed") return nil, 0, err } type result struct { topic model.DiscordResearchTopic err error } topicCh := make(chan string, len(topics)) resultCh := make(chan result, len(topics)) workers := 5 var wg sync.WaitGroup for i := 0; i < workers; i++ { wg.Add(1) go func() { defer wg.Done() for topicID := range topicCh { totalMsgCount, topUsers, lastActiveTime, err := c.topicPopularity(topicID, days) if err != nil { c.logger.Error(err, "Build research topic model failed") resultCh <- result{err: err} continue } if totalMsgCount == 0 { continue } resultCh <- result{ topic: model.DiscordResearchTopic{ Name: topicID, // Assume topic.Name is topicID for this example URL: fmt.Sprintf("https://discord.com/channels/%s/%s", c.config.Discord.IDs.DwarvesGuild, topicID), MsgCount: totalMsgCount, SortedActiveUsers: topUsers, LastActiveTime: lastActiveTime, }, } } }() } for _, topic := range topics { topicCh <- topic.ID } close(topicCh) go func() { wg.Wait() close(resultCh) }() finalResults := make([]model.DiscordResearchTopic, 0) for res := range resultCh { if res.err != nil { return nil, 0, res.err } finalResults = append(finalResults, res.topic) } sort.Slice(finalResults, func(i, j int) bool { return finalResults[i].MsgCount > finalResults[j].MsgCount }) total := int64(len(finalResults)) // Apply pagination if int64(offset) >= total { return []model.DiscordResearchTopic{}, total, nil } end := offset + limit if end > len(finalResults) { end = len(finalResults) } finalResults = finalResults[offset:end] return finalResults, total, nil } func (c *controller) topicPopularity(topicID string, days int) (int64, []model.DiscordTopicActiveUser, time.Time, error) { var totalMessages int64 var beforeID string var lastActiveTime time.Time lastNDays := time.Now().AddDate(0, 0, -days) userMessageCount := make(map[string]int64) limit := 100 for { messages, err := c.service.Discord.GetChannelMessages(topicID, beforeID, "", limit) if err != nil { return 0, nil, time.Now(), err } if len(messages) == 0 { break } if beforeID == "" { lastActiveTime = messages[0].Timestamp } for _, msg := range messages { if days != 0 && msg.Timestamp.Before(lastNDays) { break } userMessageCount[msg.Author.ID]++ totalMessages++ } if len(messages) < limit { break } beforeID = messages[len(messages)-1].ID } var userCounts []model.DiscordTopicActiveUser for userID, count := range userMessageCount { userCounts = append(userCounts, model.DiscordTopicActiveUser{UserID: userID, MsgCount: count}) } sort.Slice(userCounts, func(i, j int) bool { return userCounts[i].MsgCount > userCounts[j].MsgCount }) var result []model.DiscordTopicActiveUser for i := 0; i < 3 && i < len(userCounts); i++ { result = append(result, userCounts[i]) } return totalMessages, result, lastActiveTime, nil } // OgifStats contains list of ogif and some stats type OgifStats struct { OgifList []model.EventSpeaker `json:"ogifList"` UserAllTimeSpeaksCount int64 `json:"userAllTimeSpeaksCount"` UserAllTimeRank int64 `json:"userAllTimeRank"` UserCurrentSpeaksCount int64 `json:"userCurrentSpeaksCount"` UserCurrentRank int64 `json:"userCurrentRank"` TotalSpeakCount int64 `json:"totalSpeakCount"` CurrentSpeakCount int64 `json:"currentSpeakCount"` } // UserOgifStats returns list ogif with some stats func (c *controller) UserOgifStats(ctx context.Context, discordID string, after time.Time) (OgifStats, error) { logger := c.logger.AddField("discordID", discordID).AddField("after", after) ogftList, err := c.store.EventSpeaker.List(c.repo.DB(), discordID, &after, "ogif") if err != nil { logger.Error(err, "error when retrieving list event speaker") return OgifStats{}, err } ogifStats, err := c.store.EventSpeaker.GetSpeakerStats(c.repo.DB(), discordID, &after, "ogif") if err != nil { logger.Error(err, "error when retrieving speaker stats") } allTimeOgifStats, err := c.store.EventSpeaker.GetSpeakerStats(c.repo.DB(), discordID, nil, "ogif") if err != nil { logger.Error(err, "error when retrieving all time speaker stats") return OgifStats{}, err } allTimeTotalCount, err := c.store.EventSpeaker.Count(c.repo.DB(), "", nil, "ogif") if err != nil { logger.Error(err, "error when counting all time total speak") } return OgifStats{ OgifList: ogftList, UserAllTimeSpeaksCount: allTimeOgifStats.TotalSpeakCount, UserAllTimeRank: allTimeOgifStats.SpeakRank, UserCurrentSpeaksCount: ogifStats.TotalSpeakCount, UserCurrentRank: ogifStats.SpeakRank, TotalSpeakCount: allTimeTotalCount, CurrentSpeakCount: int64(len(ogftList)), }, nil } // GetOgifLeaderboard returns the OGIF leaderboard func (c *controller) GetOgifLeaderboard(ctx context.Context, after time.Time, limit int) ([]model.OgifLeaderboardRecord, error) { logger := c.logger.AddField("after", after).AddField("limit", limit) leaderboard, err := c.store.EventSpeaker.GetLeaderboard(c.repo.DB(), &after, limit, "ogif") if err != nil { logger.Error(err, "error when retrieving OGIF leaderboard") return nil, err } return leaderboard, nil }
```

# pkg/controller/earn/earn.go

```go
package earn import ( "context" "io" "net/http" "strings" "golang.org/x/net/html" "github.com/dwarvesf/fortress-api/pkg/model" ) const memoURL = "https://memo.d.foundation" func (c *controller) ListEarn(ctx context.Context) ([]model.Earn, error) { htmlContent, err := fetchHTML(memoURL + "/earn") if err != nil { return nil, err } doc, err := html.Parse(strings.NewReader(htmlContent)) if err != nil { return nil, err } earns := parseEarnTable(doc) picIDs := make([]string, 0) for _, earn := range earns { picIDs = append(picIDs, earn.PICs...) } pics, err := c.store.DiscordAccount.ListByMemoUsername(c.repo.DB(), picIDs) if err != nil { return nil, err } picDiscordIDMap := make(map[string]string) for _, pic := range pics { key := pic.DiscordUsername if key == "" { key = pic.MemoUsername } picDiscordIDMap[key] = pic.DiscordID } for i, earn := range earns { for j, picID := range earn.PICs { if val, ok := picDiscordIDMap[picID]; ok { earn.PICs[j] = val } } earns[i] = earn } return earns, nil } func fetchHTML(url string) (string, error) { resp, err := http.Get(url) if err != nil { return "", err } defer resp.Body.Close() body, err := io.ReadAll(resp.Body) if err != nil { return "", err } return string(body), nil } func parseEarnTable(node *html.Node) []model.Earn { var earns []model.Earn var currentEarn model.Earn var isHeader bool var fieldIndex int var f func(*html.Node) f = func(n *html.Node) { if n.Type == html.ElementNode && n.Data == "tr" { isHeader = false fieldIndex = 0 for c := n.FirstChild; c != nil; c = c.NextSibling { if c.Type == html.ElementNode && c.Data == "th" { isHeader = true break } } if !isHeader { for c := n.FirstChild; c != nil; c = c.NextSibling { if c.Type == html.ElementNode && c.Data == "td" { text := getText(c) switch fieldIndex { case 0: if linkNode := findLinkNode(c); linkNode != nil { currentEarn.URL = memoURL + getAttr(linkNode, "href") currentEarn.Title = getText(linkNode) } else { currentEarn.Title = text } case 1: currentEarn.Bounty = text case 2: currentEarn.Status = text case 3: pics := strings.Split(text, ",") for _, pic := range pics { if pic != "" { currentEarn.PICs = append(currentEarn.PICs, pic) } } case 4: currentEarn.Function = text } fieldIndex++ } } earns = append(earns, currentEarn) currentEarn = model.Earn{} } } for c := n.FirstChild; c != nil; c = c.NextSibling { f(c) } } f(node) return earns } func findLinkNode(n *html.Node) *html.Node { var linkNode *html.Node var f func(*html.Node) f = func(n *html.Node) { if n.Type == html.ElementNode && n.Data == "a" { linkNode = n return } for c := n.FirstChild; c != nil; c = c.NextSibling { f(c) } } f(n) return linkNode } func getAttr(n *html.Node, attrName string) string { for _, attr := range n.Attr { if attr.Key == attrName { return attr.Val } } return "" } func getText(n *html.Node) string { var buf strings.Builder var f func(*html.Node) f = func(n *html.Node) { if n.Type == html.TextNode { buf.WriteString(n.Data) } for c := n.FirstChild; c != nil; c = c.NextSibling { f(c) } } f(n) return buf.String() }
```

# pkg/controller/earn/interface.go

```go
package earn import ( "context" "github.com/dwarvesf/fortress-api/pkg/model" ) type IController interface { ListEarn(ctx context.Context) ([]model.Earn, error) }
```

# pkg/controller/earn/new.go

```go
package earn import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type controller struct { store *store.Store service *service.Service logger logger.Logger config *config.Config repo store.DBRepo } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, service: service, logger: logger, config: cfg, repo: repo, } }
```

# pkg/controller/employee/checkin.go

```go
package employee import ( "errors" "fmt" "strconv" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) type CheckinResponse struct { EmployeeID string IcyAmount float64 TransactionID string TransactionHash string } func (r *controller) CheckIn(discordID string, t time.Time, amount float64) (*CheckinResponse, error) { l := r.logger.Fields(logger.Fields{ "controller": "employee", "method": "CheckIn", }) // Get employee by discord id employee, err := r.store.Employee.GetByDiscordID(r.repo.DB(), discordID, true) if err != nil { l.Error(err, "failed to get employee by discord id") if errors.Is(err, gorm.ErrRecordNotFound) { return nil, ErrEmployeeNotFound } return nil, err } checkinDate := t.Format("2006-01-02") // check if record already exists epc, err := r.store.PhysicalCheckin.GetByEmployeeIDAndDate(r.repo.DB(), employee.ID.String(), checkinDate) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "failed to get physical checkin by employee id and date") return nil, err } if !epc.ID.IsZero() { return nil, ErrAlreadyCheckedIn } // Check if employee is whitelisted isWhitelisted := r.isEmployeeWhitelisted(employee.ID) // If not whitelisted, check for full-time role if !isWhitelisted { err = r.checkFullTimeRole(employee) if err != nil { l.Error(err, "failed to check full time role") return nil, err } } l.AddField("name", employee.FullName).Info("Employee is whitelisted or full-time role") tx, done := r.repo.NewTransaction() pc := &model.PhysicalCheckinTransaction{ ID: model.NewUUID(), EmployeeID: employee.ID, IcyAmount: amount, Date: t, } if err := r.store.PhysicalCheckin.Save(tx.DB(), pc); err != nil { l.Error(err, "failed to save physical checkin") return nil, done(err) } // Make transaction request to mochi description := fmt.Sprintf("%s - Physical Checkin on %v", employee.DisplayName, checkinDate) references := "Physical Checkin" txs, err := r.service.Mochi.SendFromAccountToUser(amount, discordID, description, references) if err != nil { l.Error(err, "failed to request to mochi") return nil, done(err) } if len(txs) == 0 { return nil, done(ErrNoTransactionFound) } pc.MochiTxID = txs[0].TransactionID if err := r.store.PhysicalCheckin.Save(tx.DB(), pc); err != nil { l.Error(err, "failed to save physical checkin") return nil, done(err) } response := &CheckinResponse{ EmployeeID: employee.ID.String(), IcyAmount: amount, TransactionID: strconv.Itoa(int(txs[0].TransactionID)), TransactionHash: txs[0].RecipientID, } return response, done(nil) } // isEmployeeWhitelisted checks if an employee is whitelisted for check-in func (r *controller) isEmployeeWhitelisted(employeeID model.UUID) bool { for _, id := range r.config.CheckIn.WhitelistedEmployeeIDs { if id == employeeID.String() { return true } } return false }
```

# pkg/controller/employee/create.go

```go
package employee import ( "errors" "fmt" "strings" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/currency" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" ) type CreateEmployeeInput struct { FullName string DisplayName string TeamEmail string PersonalEmail string Positions []model.UUID Salary int64 SeniorityID model.UUID Roles []model.UUID Status string ReferredBy model.UUID JoinDate *time.Time } func (r *controller) Create(userID string, input CreateEmployeeInput) (*model.Employee, error) { l := r.logger.Fields(logger.Fields{ "controller": "employee", "method": "Create", }) loggedInUser, err := r.store.Employee.One(r.repo.DB(), userID, false) if errors.Is(err, gorm.ErrRecordNotFound) { return nil, ErrEmployeeNotFound } if err != nil { return nil, err } // Check position existence positions, err := r.store.Position.All(r.repo.DB()) if err != nil { return nil, err } positionsReq := make([]model.Position, 0) positionMap := model.ToPositionMap(positions) for _, pID := range input.Positions { _, ok := positionMap[pID] if !ok { l.Errorf(ErrPositionNotFound, "position not found with id ", pID.String()) return nil, ErrPositionNotFound } positionsReq = append(positionsReq, positionMap[pID]) } sen, err := r.store.Seniority.One(r.repo.DB(), input.SeniorityID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return nil, ErrSeniorityNotfound } return nil, err } roles, err := r.store.Role.GetByIDs(r.repo.DB(), input.Roles) if err != nil { l.Error(err, "failed to get roles by ids") return nil, err } for _, role := range roles { if role.Level <= loggedInUser.EmployeeRoles[0].Role.Level && loggedInUser.EmployeeRoles[0].Role.Code != model.AccountRoleAdmin.String() { return nil, ErrInvalidAccountRole } } // get the username eml := &model.Employee{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, FullName: input.FullName, DisplayName: input.DisplayName, TeamEmail: input.TeamEmail, PersonalEmail: input.PersonalEmail, WorkingStatus: model.WorkingStatus(input.Status), JoinedDate: input.JoinDate, SeniorityID: sen.ID, Username: strings.Split(input.TeamEmail, "@")[0], } if !input.ReferredBy.IsZero() { exists, err := r.store.Employee.IsExist(r.repo.DB(), input.ReferredBy.String()) if err != nil { return nil, err } if !exists { return nil, ErrReferrerNotFound } eml.ReferredBy = input.ReferredBy } // 2.1 check employee exists -> raise error _, err = r.store.Employee.OneByEmail(r.repo.DB(), eml.TeamEmail) if !errors.Is(err, gorm.ErrRecordNotFound) { if err == nil { return nil, ErrTeamEmailExisted } return nil, err } _, err = r.store.Employee.OneByEmail(r.repo.DB(), eml.PersonalEmail) if !errors.Is(err, gorm.ErrRecordNotFound) { if err == nil { return nil, ErrPersonalEmailExisted } return nil, err } _, err = r.store.Employee.One(r.repo.DB(), eml.Username, false) if !errors.Is(err, gorm.ErrRecordNotFound) { if err == nil { return nil, ErrEmployeeExisted } return nil, err } tx, done := r.repo.NewTransaction() // 2.2 store employee eml, err = r.store.Employee.Create(tx.DB(), eml) if err != nil { l.Errorf(err, "failed to create employee", "employee", eml) return nil, done(err) } // 2.3 create employee position for _, p := range positionsReq { ep := &model.EmployeePosition{ EmployeeID: eml.ID, PositionID: p.ID, } _, err = r.store.EmployeePosition.Create(tx.DB(), ep) if err != nil { l.Errorf(err, "failed to create employee position", "employee_position", ep) return nil, done(err) } } // 2.4 create employee roles for _, role := range roles { er := &model.EmployeeRole{ EmployeeID: eml.ID, RoleID: role.ID, } _, err = r.store.EmployeeRole.Create(tx.DB(), &model.EmployeeRole{ EmployeeID: eml.ID, RoleID: role.ID, }) if err != nil { l.Errorf(err, "failed to create employee role", "employee_role", er) return nil, done(err) } } baseCurrency, err := r.store.Currency.GetByName(tx.DB(), currency.VNDCurrency) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return nil, done(ErrCurrencyNotFound) } return nil, done(err) } salaryBatch := 1 if input.JoinDate.Day() > 1 && input.JoinDate.Day() < 16 { salaryBatch = 15 } // 2.4 create employee salary ebs := &model.BaseSalary{ EmployeeID: eml.ID, ContractAmount: 0, CompanyAccountAmount: 0, PersonalAccountAmount: input.Salary, InsuranceAmount: 0, Type: "", Category: "", CurrencyID: baseCurrency.ID, Batch: salaryBatch, EffectiveDate: nil, } err = r.store.BaseSalary.Save(tx.DB(), ebs) if err != nil { l.Errorf(err, "failed to create employee base salary", "employee_base_salary", ebs) return nil, done(err) } // Create employee organization org, err := r.store.Organization.OneByCode(tx.DB(), model.OrganizationCodeDwarves) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return nil, done(ErrOrganizationNotFound) } return nil, done(err) } eo := &model.EmployeeOrganization{ EmployeeID: eml.ID, OrganizationID: org.ID, } if _, err := r.store.EmployeeOrganization.Create(tx.DB(), eo); err != nil { l.Errorf(err, "failed to create employee organization", "employee_organization", eo) return nil, done(err) } authenticationInfo := model.AuthenticationInfo{ UserID: eml.ID.String(), Avatar: eml.Avatar, Email: eml.PersonalEmail, } jwt, err := authutils.GenerateJWTToken(&authenticationInfo, time.Now().Add(24*time.Hour).Unix(), r.config.JWTSecretKey) if err != nil { l.Errorf(err, "failed to generate jwt token", "authenticationInfo", authenticationInfo) return nil, done(err) } ei := model.EmployeeInvitation{ EmployeeID: eml.ID, InvitedBy: loggedInUser.ID, InvitationCode: jwt, IsCompleted: false, IsInfoUpdated: false, IsDiscordRoleAssigned: false, IsBasecampAccountCreated: false, IsTeamEmailCreated: false, } if _, err := r.store.EmployeeInvitation.Create(tx.DB(), &ei); err != nil { l.Errorf(err, "failed to create employee invitation", "employee_invitation", ei) return nil, done(err) } invitation := model.InvitationEmail{ Email: eml.PersonalEmail, Link: fmt.Sprintf("%s/onboarding?code=%s", r.config.FortressURL, jwt), Inviter: loggedInUser.FullName, } if err := r.service.GoogleMail.SendInvitationMail(&invitation); err != nil { l.Errorf(err, "failed to send invitation mail", "invitationInfo", invitation) return nil, done(err) } return eml, done(nil) }
```

# pkg/controller/employee/details.go

```go
package employee import ( "errors" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" ) func (r *controller) Details(id string, userInfo *model.CurrentLoggedUserInfo) (*model.Employee, error) { rs, err := r.store.Employee.One(r.repo.DB(), id, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return nil, ErrEmployeeNotFound } return nil, err } if rs.WorkingStatus == model.WorkingStatusLeft && !authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadFullAccess) { return nil, ErrEmployeeNotFound } mentees, err := r.store.Employee.GetMenteesByID(r.repo.DB(), rs.ID.String()) if err != nil { return nil, err } if len(mentees) > 0 { rs.Mentees = mentees } return rs, nil }
```

# pkg/controller/employee/earns.go

```go
package employee import ( "math" "math/big" "time" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/mochipay" "github.com/dwarvesf/fortress-api/pkg/utils" ) type GetEmployeeEarnTransactionsInput struct { model.Pagination } func (r *controller) GetEmployeeEarnTransactions(discordID string, input GetEmployeeEarnTransactionsInput) (model.EmployeeEarnTransactions, int64, error) { profile, err := r.service.MochiProfile.GetProfileByDiscordID(discordID) if err != nil { return nil, 0, err } isSender := false txns, err := r.service.MochiPay.GetListTransactions(mochipay.ListTransactionsRequest{ Type: mochipay.TransactionTypeReceive, ActionList: []mochipay.TransactionAction{mochipay.TransactionActionVaultTransfer}, Status: mochipay.TransactionStatusSuccess, TokenAddress: mochipay.ICYAddress, ChainIDs: []string{mochipay.BASEChainID}, ProfileID: profile.ID, Page: input.Page, Size: input.Size, IsSender: &isSender, SortBy: "created_at-", }) return txns.Data, txns.Pagination.Total, err } func (r *controller) GetEmployeeTotalEarn(discordID string) (string, string, error) { profile, err := r.service.MochiProfile.GetProfileByDiscordID(discordID) if err != nil { return "", "", err } isSender := false txns, err := r.service.MochiPay.GetListTransactions(mochipay.ListTransactionsRequest{ Type: mochipay.TransactionTypeReceive, ActionList: []mochipay.TransactionAction{mochipay.TransactionActionVaultTransfer}, Status: mochipay.TransactionStatusSuccess, TokenAddress: mochipay.ICYAddress, ChainIDs: []string{mochipay.BASEChainID}, ProfileID: profile.ID, Size: math.MaxInt64, IsSender: &isSender, SortBy: "created_at-", }) if err != nil { return "", "", err } earnsICY := big.NewFloat(0) earnsUSD := big.NewFloat(0) for _, txn := range txns.Data { if txn.Amount != "" && txn.Token != nil { earnsICY.Add(earnsICY, utils.ConvertFromString(txn.Amount, txn.Token.Decimal)) earnsUSD.Add(earnsUSD, big.NewFloat(txn.UsdAmount)) } } return earnsICY.String(), earnsUSD.String(), nil } func (r *controller) GetTotalEarn(from, to time.Time) (string, string, error) { // Step 1: Call to mochi-api to get vaults by df guild id -> vault ids vaults, err := r.service.Mochi.GetListVaults(false) if err != nil { return "", "", err } dfVaults := make(map[int64]bool, 0) for _, vault := range vaults { if vault.GuildID == r.config.Discord.IDs.DwarvesGuild { dfVaults[vault.ID] = true } } isSender := true // Step 2: Call to mochi-payment to get list txns // TODO: add filter for API get txn to filter by time txns, err := r.service.MochiPay.GetListTransactions(mochipay.ListTransactionsRequest{ Type: mochipay.TransactionTypeReceive, ActionList: []mochipay.TransactionAction{mochipay.TransactionActionVaultTransfer}, Status: mochipay.TransactionStatusSuccess, TokenAddress: mochipay.ICYAddress, ChainIDs: []string{mochipay.BASEChainID}, Size: math.MaxInt64, IsSender: &isSender, SortBy: "created_at-", }) if err != nil { return "", "", err } earnsICY := big.NewFloat(0) earnsUSD := big.NewFloat(0) for _, txn := range txns.Data { if txn.Metadata["vault_request"] == nil { r.logger.Infof("txn %d has no vault_request", txn.Id) continue } vaultRequest := txn.Metadata["vault_request"].(map[string]interface{}) vaultID, ok := vaultRequest["vault_id"].(float64) if !ok { r.logger.Infof("vault_id is not int64") continue } if _, ok := dfVaults[int64(vaultID)]; !ok { r.logger.Infof("vault_id %d is not in df vaults", int64(vaultID)) continue } if txn.CreatedAt.Before(from) || txn.CreatedAt.After(to.Add(24*time.Hour)) { r.logger.Infof("txn %d is not in range", txn.Id) continue } if txn.Amount != "" && txn.Token != nil { earnsICY.Add(earnsICY, utils.ConvertFromString(txn.Amount, txn.Token.Decimal)) earnsUSD.Add(earnsUSD, big.NewFloat(txn.UsdAmount)) } } return earnsICY.String(), earnsUSD.String(), nil }
```

# pkg/controller/employee/errors.go

```go
package employee import ( "errors" ) var ( ErrCannotSelfReferral = errors.New("cannot self referral") ErrCantFindLineManager = errors.New("can't find line manager with the input id") ErrChapterNotFound = errors.New("chapter not found") ErrCouldNotAssignRoleForSameLevelEmployee = errors.New("could not assign role for the same level employee") ErrCouldNotMentorTheirMentor = errors.New("employee could not be mentor of their mentor") ErrCouldNotMentorThemselves = errors.New("employee could not be their own mentor") ErrCurrencyNotFound = errors.New("currency not found") ErrEmailExisted = errors.New("email already exists") ErrTeamEmailExisted = errors.New("team email already exists") ErrPersonalEmailExisted = errors.New("personal email already exists") ErrEmployeeExisted = errors.New("can't create existed employee") ErrEmployeeLeft = errors.New("employee is left") ErrEmployeeMenteeNotFound = errors.New("employee mentee not found") ErrEmployeeNotFound = errors.New("employee not found") ErrSalaryAdvanceNotPayBack = errors.New("employee not pay back salary advance") ErrSalaryAdvanceExceedAmount = errors.New("your request is exceed amount you can advance") ErrSalaryAdvanceMaxCapInvalid = errors.New("max cap salary invalid") ErrFileAlreadyExisted = errors.New("file already existed") ErrInvalidAccountRole = errors.New("invalid account role") ErrInvalidChapterCode = errors.New("invalid chapter code") ErrInvalidCountryOrCity = errors.New("invalid country or city") ErrInvalidEmailDomain = errors.New("invalid email domain") ErrInvalidEmployeeID = errors.New("invalid employee ID") ErrInvalidEmployeeStatus = errors.New("invalid value for employee status") ErrInvalidFileExtension = errors.New("invalid file extension") ErrInvalidFileSize = errors.New("invalid file size") ErrInvalidJoinedDate = errors.New("invalid joined date") ErrInvalidLeftDate = errors.New("invalid left date") ErrInvalidMenteeID = errors.New("invalid mentee ID") ErrInvalidMentorID = errors.New("invalid mentor ID") ErrInvalidOrganizationCode = errors.New("invalid organization code") ErrInvalidPositionCode = errors.New("invalid position code") ErrInvalidPositionID = errors.New("invalid position ID") ErrInvalidProjectCode = errors.New("invalid project code") ErrInvalidProjectID = errors.New("invalid project ID") ErrInvalidSeniorityCode = errors.New("invalid seniority code") ErrInvalidStackCode = errors.New("invalid stack code") ErrInvalidStackID = errors.New("invalid stack ID") ErrLeftDateBeforeJoinedDate = errors.New("left date could not be before joined date") ErrLineManagerNotFound = errors.New("line manager not found") ErrMenteeLeft = errors.New("mentee is left") ErrMenteeNotFound = errors.New("mentee not found") ErrOrganizationNotFound = errors.New("organization not found") ErrPositionNotFound = errors.New("position not found") ErrPositionNotfound = errors.New("position not found") ErrReferrerNotFound = errors.New("referrer not found") ErrRoleNotFound = errors.New("role not found") ErrRoleNotfound = errors.New("role not found") ErrSeniorityNotFound = errors.New("seniority not found") ErrSeniorityNotfound = errors.New("seniority not found") ErrStackNotFound = errors.New("stack not found") ErrDiscordAccountNotFound = errors.New("discord account not found") ErrDiscordAccountAlreadyUsedByAnotherEmployee = errors.New("discord account already used by another employee") ErrCouldNotFoundDiscordMemberInGuild = errors.New("could not found discord member in the guild") ErrEmployeeNotFullTime = errors.New("employee is not full time") ErrNoTransactionFound = errors.New("no transaction found") ErrAlreadyCheckedIn = errors.New("already checked in") )
```

# pkg/controller/employee/get_line_managers.go

```go
package employee import ( "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" ) func (r *controller) GetLineManagers(userInfo *model.CurrentLoggedUserInfo) (employees []*model.Employee, err error) { var managers []*model.Employee if authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadLineManagerFullAccess) { managers, err = r.store.Employee.GetLineManagers(r.repo.DB()) if err != nil { return nil, err } } else { managers, err = r.store.Employee.GetLineManagersOfPeers(r.repo.DB(), userInfo.UserID) if err != nil { return nil, err } } return managers, nil }
```

# pkg/controller/employee/list.go

```go
package employee import ( "errors" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/store/employee" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" "gorm.io/gorm" ) type GetListEmployeeInput struct { model.Pagination WorkingStatuses []string Preload bool Positions []string Stacks []string Projects []string Chapters []string Seniorities []string Organizations []string LineManagers []string Keyword string } func (r *controller) List(workingStatuses []string, body GetListEmployeeInput, userInfo *model.CurrentLoggedUserInfo) ([]*model.Employee, int64, error) { filter := employee.EmployeeFilter{ Preload: body.Preload, Keyword: body.Keyword, Positions: body.Positions, Stacks: body.Stacks, Chapters: body.Chapters, Seniorities: body.Seniorities, Organizations: body.Organizations, LineManagers: body.LineManagers, JoinedDateSort: model.SortOrderDESC, Projects: body.Projects, } // If user don't have this permission, they can only see employees in the project that they are in if !authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadReadActive) { projectIDs := make([]string, 0) for _, p := range userInfo.Projects { projectIDs = append(projectIDs, p.Code) } filter.Projects = []string{""} if len(projectIDs) > 0 { filter.Projects = projectIDs } } filter.WorkingStatuses = workingStatuses employees, total, err := r.store.Employee.All(r.repo.DB(), filter, body.Pagination) if err != nil { return nil, 0, err } return employees, total, nil } func (r *controller) ListWithLocation() ([]*model.Employee, error) { employees, err := r.store.Employee.SimpleList(r.repo.DB()) if err != nil { return nil, err } return employees, nil } func (r *controller) ListWithMMAScore() (employees []model.EmployeeMMAScoreData, err error) { rs, err := r.store.Employee.ListWithMMAScore(r.repo.DB()) if err != nil { return nil, err } return rs, nil } func (r *controller) ListByDiscordRequest(discordID, email, key string, userInfo *model.CurrentLoggedUserInfo) ([]model.Employee, error) { in := employee.DiscordRequestFilter{ Email: email, } discordIDs := make([]string, 0) if discordID != "" { discordIDs = append(discordIDs, discordID) } if key != "" { dt, err := r.service.Discord.SearchMember(key) if err != nil { return nil, err } if len(dt) <= 0 { in.Keyword = key } else { for _, d := range dt { discordIDs = append(discordIDs, d.User.ID) } } } in.DiscordID = discordIDs if len(in.DiscordID) > 0 || in.Email != "" || in.Keyword != "" { rs, err := r.store.Employee.ListByDiscordRequest(r.repo.DB(), in, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return nil, ErrEmployeeNotFound } return nil, err } return rs, nil } return nil, ErrEmployeeNotFound }
```

# pkg/controller/employee/new.go

```go
package employee import ( "mime/multipart" "time" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type controller struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } type IController interface { List(workingStatuses []string, body GetListEmployeeInput, userInfo *model.CurrentLoggedUserInfo) (employees []*model.Employee, tptal int64, err error) Details(id string, userInfo *model.CurrentLoggedUserInfo) (employee *model.Employee, err error) UpdateEmployeeStatus(employeeID string, body UpdateWorkingStatusInput) (employee *model.Employee, err error) UpdateGeneralInfo(employeeID string, body UpdateEmployeeGeneralInfoInput) (employee *model.Employee, err error) Create(userID string, body CreateEmployeeInput) (employee *model.Employee, err error) UpdateSkills(l logger.Logger, employeeID string, body UpdateSkillsInput) (employee *model.Employee, err error) UpdatePersonalInfo(employeeID string, body UpdatePersonalInfoInput) (employee *model.Employee, err error) UploadAvatar(uuidUserID model.UUID, file *multipart.FileHeader, params UploadAvatarInput) (filePath string, err error) UpdateRole(userID string, input UpdateRoleInput) (err error) GetLineManagers(userInfo *model.CurrentLoggedUserInfo) (employees []*model.Employee, err error) UpdateBaseSalary(l logger.Logger, employeeID string, body UpdateBaseSalaryInput) (employee *model.BaseSalary, err error) ListWithLocation() (employees []*model.Employee, err error) ListByDiscordRequest(discordID, email, key string, userInfo *model.CurrentLoggedUserInfo) ([]model.Employee, error) SalaryAdvance(discordID string, amount int64) (*SalaryAdvanceResponse, error) CheckSalaryAdvance(discordID string) (string, string, error) ListWithMMAScore() (employees []model.EmployeeMMAScoreData, err error) ListAggregatedSalaryAdvance(input ListAggregatedSalaryAdvanceInput) (*model.SalaryAdvanceReport, error) GetEmployeeEarnTransactions(discordID string, input GetEmployeeEarnTransactionsInput) (model.EmployeeEarnTransactions, int64, error) GetEmployeeTotalEarn(discordID string) (string, string, error) GetTotalEarn(from, to time.Time) (string, string, error) CheckIn(discordID string, t time.Time, amount float64) (*CheckinResponse, error) }
```

# pkg/controller/employee/salary_advance.go

```go
package employee import ( "errors" "fmt" "math" "strconv" "time" "github.com/Rhymond/go-money" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/utils" ) type SalaryAdvanceResponse struct { EmployeeID string AmountICY string AmountUSD string TransactionID string TransactionHash string } func (r *controller) SalaryAdvance(discordID string, amount int64) (*SalaryAdvanceResponse, error) { icyUsdRateConfig, err := r.store.Config.OneByKey(r.repo.DB(), model.ConfigKeyIcyUSDRate) if err != nil { return nil, err } icyUsdRate, err := strconv.ParseFloat(icyUsdRateConfig.Value, 64) if err != nil { return nil, err } // Get employee by discord id employee, err := r.store.Employee.GetByDiscordID(r.repo.DB(), discordID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return nil, ErrEmployeeNotFound } return nil, err } err = r.checkFullTimeRole(employee) if err != nil { return nil, err } salaryAdvances, err := r.store.SalaryAdvance.ListNotPayBackByEmployeeID(r.repo.DB(), employee.ID.String()) if err != nil { return nil, err } // calculate number of not paid back advance salary var notPaidBackAmount int64 for _, salaryAdvance := range salaryAdvances { if !salaryAdvance.IsPaidBack { notPaidBackAmount = notPaidBackAmount + salaryAdvance.AmountIcy } } // Get employee's salary salary, err := r.store.BaseSalary.OneByEmployeeID(r.repo.DB(), employee.ID.String()) if err != nil { return nil, err } // Calculate advance amount maxAdvanceAmountIcy, err := r.calculateMaxAdvanceAmountIcy(salary, icyUsdRate) if err != nil { return nil, err } // Check if amount exceed amount can be advanced if amount > maxAdvanceAmountIcy-notPaidBackAmount { return nil, errors.Join(ErrSalaryAdvanceExceedAmount, errors.New("amount can be advanced is "+utils.FormatNumber(maxAdvanceAmountIcy-notPaidBackAmount))) } // Create advance salary record amountUSD := float64(amount) * icyUsdRate baseAmount, rate, err := r.service.Wise.Convert(amountUSD, "USD", salary.Currency.Name) if err != nil { return nil, err } tx, done := r.repo.NewTransaction() salaryAdvance := &model.SalaryAdvance{ EmployeeID: employee.ID, AmountIcy: amount, AmountUSD: amountUSD, BaseAmount: baseAmount, ConversionRate: rate, CurrencyID: salary.CurrencyID, } if err := r.store.SalaryAdvance.Save(tx.DB(), salaryAdvance); err != nil { return nil, done(err) } // Make advance salary request currentMonth := time.Now().Month() description := fmt.Sprintf("%s Addvance Salary in %s", discordID, currentMonth.String()) references := "Advance Salary" txs, err := r.service.Mochi.SendFromAccountToUser(float64(amount), discordID, description, references) if err != nil { return nil, done(err) } if len(txs) == 0 { return nil, done(ErrNoTransactionFound) } response := &SalaryAdvanceResponse{ EmployeeID: employee.ID.String(), AmountICY: utils.FormatNumber(amount), AmountUSD: utils.FormatMoney(amountUSD, money.USD), TransactionID: strconv.Itoa(int(txs[0].TransactionID)), TransactionHash: txs[0].RecipientID, } return response, done(nil) } func (r *controller) CheckSalaryAdvance(discordID string) (amountIcy string, amountUSD string, error error) { icyUsdRateConfig, err := r.store.Config.OneByKey(r.repo.DB(), model.ConfigKeyIcyUSDRate) if err != nil { return "", "", err } icyUsdRate, err := strconv.ParseFloat(icyUsdRateConfig.Value, 64) if err != nil { return "", "", err } // Get employee by discord id employee, err := r.store.Employee.GetByDiscordID(r.repo.DB(), discordID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return "", "", ErrEmployeeNotFound } return "", "", err } err = r.checkFullTimeRole(employee) if err != nil { return "", "", err } salaryAdvances, err := r.store.SalaryAdvance.ListNotPayBackByEmployeeID(r.repo.DB(), employee.ID.String()) if err != nil { return "", "", err } // calculate number of not paid back advance salary var notPaidBackAmount int64 for _, salaryAdvance := range salaryAdvances { if !salaryAdvance.IsPaidBack { notPaidBackAmount = notPaidBackAmount + salaryAdvance.AmountIcy } } // Get employee's salary salary, err := r.store.BaseSalary.OneByEmployeeID(r.repo.DB(), employee.ID.String()) if err != nil { return "", "", err } // Calculate advance amount advanceAmountIcy, err := r.calculateMaxAdvanceAmountIcy(salary, icyUsdRate) if err != nil { return "", "", err } advanceAmountUSD := float64(advanceAmountIcy-notPaidBackAmount) * icyUsdRate return utils.FormatNumber(advanceAmountIcy - notPaidBackAmount), utils.FormatMoney(advanceAmountUSD, money.USD), nil } func (r *controller) checkFullTimeRole(employee *model.Employee) error { fullTimeRole, err := r.store.Role.GetByCode(r.repo.DB(), model.RoleFullTimeCode) if err != nil { return err } var highestEmployeeLevel int64 = 10000 for _, role := range employee.Roles { if role.Level < highestEmployeeLevel { highestEmployeeLevel = role.Level } } // check if employee is full time or higher if highestEmployeeLevel > fullTimeRole.Level { return ErrEmployeeNotFullTime } return nil } func (r *controller) calculateMaxAdvanceAmountIcy(salary *model.BaseSalary, icyUsdRate float64) (int64, error) { // Get advance salary max cap salaryAdvanceMaxCap, err := r.store.Config.OneByKey(r.repo.DB(), model.ConfigKeySalaryAdvanceMaxCap) if err != nil { return 0, err } // Check if advance salary max cap is number and in range of 0 - 100 maxCap, err := strconv.Atoi(salaryAdvanceMaxCap.Value) if err != nil || maxCap < 0 || maxCap > 100 { return 0, ErrSalaryAdvanceMaxCapInvalid } var advanceAmountUSD float64 advanceableAmount := float64(salary.ContractAmount+salary.PersonalAccountAmount) * (float64(maxCap) / 100) if salary.Currency.Name == "USD" { advanceAmountUSD = advanceableAmount } else { convertedValue, _, err := r.service.Wise.Convert(advanceableAmount, salary.Currency.Name, "USD") if err != nil { return 0, err } advanceAmountUSD = convertedValue } advanceAmountIcy := advanceAmountUSD / icyUsdRate return int64(math.Round(advanceAmountIcy/10) * 10), nil } type ListAggregatedSalaryAdvanceInput struct { model.Pagination model.SortOrder IsPaid *bool } func (r *controller) ListAggregatedSalaryAdvance(input ListAggregatedSalaryAdvanceInput) (*model.SalaryAdvanceReport, error) { list, err := r.store.SalaryAdvance.ListAggregatedSalaryAdvance(r.repo.DB(), input.IsPaid, input.Pagination, input.SortOrder) if err != nil { return nil, err } for i, row := range list { employee, err := r.store.Employee.One(r.repo.DB(), row.EmployeeID, false) if err != nil { return nil, err } list[i].Employee = employee } count, totalICY, totalUSD, err := r.store.SalaryAdvance.TotalAggregatedSalaryAdvance(r.repo.DB(), input.IsPaid) if err != nil { return nil, err } report := &model.SalaryAdvanceReport{ SalaryAdvances: list, TotalICY: totalICY, TotalUSD: totalUSD, Count: count, } return report, nil }
```

# pkg/controller/employee/update_base_salary.go

```go
package employee import ( "errors" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) type UpdateBaseSalaryInput struct { ContractAmount int64 CompanyAccountAmount int64 PersonalAccountAmount int64 InsuranceAmount int64 CurrencyCode string Batch int EffectiveDate *time.Time } func (r *controller) UpdateBaseSalary(l logger.Logger, employeeID string, body UpdateBaseSalaryInput) (*model.BaseSalary, error) { currency, err := r.store.Currency.GetByName(r.repo.DB(), body.CurrencyCode) if err != nil { return nil, err } exists, err := r.store.Employee.IsExist(r.repo.DB(), employeeID) if err != nil { return nil, err } if !exists { return nil, ErrEmployeeNotFound } bs, err := r.store.BaseSalary.OneByEmployeeID(r.repo.DB(), employeeID) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { return nil, err } euuid, err := model.UUIDFromString(employeeID) if err != nil { return nil, err } newBS := &model.BaseSalary{ BaseModel: model.BaseModel{ ID: bs.ID, }, EmployeeID: euuid, ContractAmount: body.ContractAmount, CompanyAccountAmount: body.CompanyAccountAmount, PersonalAccountAmount: body.PersonalAccountAmount, InsuranceAmount: model.NewVietnamDong(body.InsuranceAmount), CurrencyID: currency.ID, Batch: body.Batch, EffectiveDate: body.EffectiveDate, } err = r.store.BaseSalary.Save(r.repo.DB(), newBS) if err != nil { return nil, err } return newBS, nil }
```

# pkg/controller/employee/update_employee_status.go

```go
package employee import ( "context" "errors" "fmt" "strings" "time" "gorm.io/gorm" "gorm.io/gorm/utils" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) type UpdateWorkingStatusInput struct { EmployeeStatus model.WorkingStatus IsKeepFwdEmail bool } func (r *controller) UpdateEmployeeStatus(employeeID string, body UpdateWorkingStatusInput) (*model.Employee, error) { l := r.logger.Fields(logger.Fields{ "controller": "employee", "method": "UpdateEmployeeStatus", }) now := time.Now() e, err := r.store.Employee.One(r.repo.DB(), employeeID, true) if err != nil { l.Errorf(err, "failed to get Employee ", employeeID) if errors.Is(err, gorm.ErrRecordNotFound) { return nil, ErrEmployeeNotFound } return nil, err } e.WorkingStatus = body.EmployeeStatus e.IsKeepFwdEmail = body.IsKeepFwdEmail e.LeftDate = &now if body.EmployeeStatus != model.WorkingStatusLeft { e.LeftDate = nil } tx, done := r.repo.NewTransaction() defer func() { _ = done(nil) }() _, err = r.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, *e, "working_status", "left_date", "is_keep_fwd_email") if err != nil { return nil, done(err) } //If employee working status is left, do off-boarding flow if body.EmployeeStatus == model.WorkingStatusLeft { err = r.store.ProjectMember.UpdateMemberToInActiveByID(tx.DB(), employeeID, &now) if err != nil { return nil, done(err) } // Do Off-boarding process r.processOffBoardingEmployee(l, e) if e.IsKeepFwdEmail { name := e.FullName if e.DisplayName != "" { name = strings.Split(e.DisplayName, " ")[0] } offboardingEmail := model.OffboardingEmail{ Name: name, TeamEmail: e.TeamEmail, PersonalEmail: e.PersonalEmail, } if err := r.service.GoogleMail.SendOffboardingMail(&offboardingEmail); err != nil { l.Errorf(err, "failed to send offboard mail", "employeeID", e.ID.String()) return nil, done(err) } } } return e, err } func (r *controller) processOffBoardingEmployee(l logger.Logger, e *model.Employee) { if e.DiscordAccount != nil { err := r.removeDiscordRoles(e) if err != nil { l.Errorf(err, "failed to update discord roles", "employeeID", e.ID.String(), "discordID", e.DiscordAccount.DiscordID) } } err := r.removeBasecampAccess(e.BasecampID) if err != nil { l.Errorf(err, "failed to remove basecamp access", "employeeID", e.ID.String(), "basecampID", e.BasecampID) } if !e.IsKeepFwdEmail { err = r.removeTeamEmailForward(e.TeamEmail) if err != nil { l.Errorf(err, "failed to remove team email forward", "employeeID", e.ID.String(), "email", e.TeamEmail) } } err = r.removeTeamEmail(e.TeamEmail) if err != nil { l.Errorf(err, "failed to delete google account", "employeeID", e.ID.String(), "email", e.TeamEmail) } err = r.removeGithubFromOrganization(e) if err != nil { l.Errorf(err, "failed to remove github user from organization", "employeeID", e.ID.String()) } } func (r *controller) removeDiscordRoles(e *model.Employee) error { if e.DiscordAccount == nil || e.DiscordAccount.DiscordID == "" { return nil } discordUserID := e.DiscordAccount.DiscordID roles, err := r.service.Discord.GetRoles() if err != nil { return err } dfRoles := roles.DwarvesRoles() discordMember, err := r.service.Discord.GetMember(discordUserID) if err != nil { return err } for _, role := range dfRoles { if utils.Contains(discordMember.Roles, role.ID) { err = r.service.Discord.RemoveRole(discordUserID, role.ID) if err != nil { return err } } } // Assign role based on IsKeepFwdEmail var targetRole string if e.IsKeepFwdEmail { targetRole = "1300823319511171082" // "veteran" } else { targetRole = "811268653517373540" // "alumni" } // Find the role by code and add it roleToAdd := roles.ByID(targetRole) if roleToAdd == nil { return fmt.Errorf("role %s not found", targetRole) } err = r.service.Discord.AddRole(discordUserID, roleToAdd.ID) if err != nil { return err } return nil } func (r *controller) removeBasecampAccess(baseCampID int) error { if r.config.Env != "prod" { return nil } err := r.service.Basecamp.People.Remove(int64(baseCampID)) if err != nil { return err } return nil } func (r *controller) removeTeamEmailForward(teamEmail string) error { if r.config.Env != "prod" { return nil } err := r.service.ImprovMX.DeleteAccount(teamEmail) if err != nil { return err } return nil } func (r *controller) removeTeamEmail(teamEmail string) error { if r.config.Env != "prod" { return nil } err := r.service.GoogleAdmin.DeleteAccount(teamEmail) if err != nil { return err } return nil } func (r *controller) removeGithubFromOrganization(e *model.Employee) error { if r.config.Env != "prod" { return nil } githubSA := model.SocialAccounts(e.SocialAccounts).GetGithub() if githubSA != nil { if githubSA.AccountID == "" { return nil } err := r.service.Github.RemoveFromOrganizationByUsername(context.Background(), githubSA.AccountID) if err != nil { return err } } return nil }
```

# pkg/controller/employee/update_general_info.go

```go
package employee import ( "errors" "strings" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) type UpdateEmployeeGeneralInfoInput struct { FullName string Email string Phone string LineManagerID model.UUID DisplayName string GithubID string NotionID string NotionName string NotionEmail string DiscordName string LinkedInName string LeftDate string JoinedDate string OrganizationIDs []model.UUID ReferredBy model.UUID WiseRecipientID string WiseRecipientEmail string WiseRecipientName string WiseAccountNumber string WiseCurrency string } // @name UpdateEmployeeGeneralInfoInput func (r *controller) UpdateGeneralInfo(employeeID string, body UpdateEmployeeGeneralInfoInput) (*model.Employee, error) { l := r.logger.Fields(logger.Fields{ "controller": "employee", "method": "UpdateGeneralInfo", }) tx, done := r.repo.NewTransaction() // check line manager existence if !body.LineManagerID.IsZero() { exist, err := r.store.Employee.IsExist(tx.DB(), body.LineManagerID.String()) if err != nil { l.Errorf(err, "failed to check line manager existence") return nil, done(err) } if !exist { return nil, done(ErrLineManagerNotFound) } } // check referrer existence if !body.ReferredBy.IsZero() { exist, err := r.store.Employee.IsExist(tx.DB(), body.ReferredBy.String()) if err != nil { l.Errorf(err, "failed to check referer existence") return nil, done(err) } if !exist { return nil, done(ErrReferrerNotFound) } if employeeID == body.ReferredBy.String() { return nil, done(ErrCannotSelfReferral) } } emp, err := r.store.Employee.One(tx.DB(), employeeID, true) if err != nil { l.Errorf(err, "failed to get employee") if errors.Is(err, gorm.ErrRecordNotFound) { return nil, done(ErrEmployeeNotFound) } return nil, done(err) } if emp.TeamEmail != "" && emp.TeamEmail != body.Email { _, err = r.store.Employee.OneByEmail(r.repo.DB(), body.Email) if !errors.Is(err, gorm.ErrRecordNotFound) { if err == nil { return nil, ErrEmailExisted } return nil, err } } // 3. update information and return nil, done(err) if strings.TrimSpace(body.FullName) != "" { emp.FullName = body.FullName } if strings.TrimSpace(body.Email) != "" { emp.TeamEmail = body.Email } if strings.TrimSpace(body.Phone) != "" { emp.PhoneNumber = body.Phone } if strings.TrimSpace(body.DisplayName) != "" { emp.DisplayName = body.DisplayName } if strings.TrimSpace(body.JoinedDate) != "" { joinedDate, err := time.Parse("2006-01-02", body.JoinedDate) if err != nil { return nil, done(ErrInvalidJoinedDate) } emp.JoinedDate = &joinedDate } if strings.TrimSpace(body.LeftDate) != "" { leftDate, err := time.Parse("2006-01-02", body.LeftDate) if err != nil { return nil, done(ErrInvalidLeftDate) } emp.LeftDate = &leftDate } if emp.JoinedDate != nil && emp.LeftDate != nil { if emp.LeftDate.Before(*emp.JoinedDate) { return nil, done(ErrLeftDateBeforeJoinedDate) } } emp.LineManagerID = body.LineManagerID emp.ReferredBy = body.ReferredBy if strings.TrimSpace(body.WiseRecipientID) != "" { emp.WiseRecipientID = body.WiseRecipientID } if strings.TrimSpace(body.WiseAccountNumber) != "" { emp.WiseAccountNumber = body.WiseAccountNumber } if strings.TrimSpace(body.WiseRecipientEmail) != "" { emp.WiseRecipientEmail = body.WiseRecipientEmail } if strings.TrimSpace(body.WiseRecipientName) != "" { emp.WiseRecipientName = body.WiseRecipientName } if strings.TrimSpace(body.WiseCurrency) != "" { emp.WiseCurrency = body.WiseCurrency } discordID := "" if strings.TrimSpace(body.DiscordName) != "" { // Get discord info discordMember, err := r.service.Discord.GetMemberByUsername(body.DiscordName) if err != nil { l.Errorf(err, "failed to discord member member by discord name", "discordName", body.DiscordName) return nil, done(err) } if discordMember == nil { return nil, done(ErrCouldNotFoundDiscordMemberInGuild) } discordID = discordMember.User.ID } accountInUsed := false tmpE, err := r.store.Employee.GetByDiscordID(tx.DB(), discordID, false) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { l.Errorf(err, "failed to get employee by discord id", "discordID", discordID) return nil, done(err) } if !errors.Is(err, gorm.ErrRecordNotFound) { if tmpE.ID != emp.ID { accountInUsed = true } } if accountInUsed { return nil, done(ErrDiscordAccountAlreadyUsedByAnotherEmployee) } discordAccountInput := &model.DiscordAccount{ DiscordID: discordID, DiscordUsername: body.DiscordName, } discordAccount, err := r.store.DiscordAccount.Upsert(tx.DB(), discordAccountInput) if err != nil { l.Errorf(err, "failed to upsert discord account", "discordAccount", discordAccountInput) return nil, done(err) } emp.DiscordAccountID = discordAccount.ID // Update social accounts saInput := model.SocialAccountInput{ GithubID: body.GithubID, NotionID: body.NotionID, NotionName: body.NotionName, NotionEmail: body.NotionEmail, LinkedInName: body.LinkedInName, } if err := r.updateSocialAccounts(tx.DB(), saInput, emp.ID); err != nil { l.Errorf(err, "failed to update social account", "socialAccount", saInput) return nil, done(err) } _, err = r.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, *emp, "full_name", "team_email", "phone_number", "line_manager_id", "display_name", "joined_date", "left_date", "referred_by", "wise_recipient_id", "wise_account_number", "wise_recipient_email", "wise_recipient_name", "wise_currency", "discord_account_id", ) if err != nil { return nil, done(err) } if len(body.OrganizationIDs) > 0 { // Check organizations existence organizations, err := r.store.Organization.All(tx.DB()) if err != nil { return nil, done(err) } orgMaps := model.ToOrganizationMap(organizations) for _, sID := range body.OrganizationIDs { _, ok := orgMaps[sID] if !ok { l.Errorf(ErrOrganizationNotFound, "organization not found with id: ", sID.String()) return nil, done(ErrOrganizationNotFound) } } // Delete all exist employee organizations if err := r.store.EmployeeOrganization.DeleteByEmployeeID(tx.DB(), employeeID); err != nil { return nil, done(err) } // Create new employee position for _, orgID := range body.OrganizationIDs { _, err := r.store.EmployeeOrganization.Create(tx.DB(), &model.EmployeeOrganization{ EmployeeID: model.MustGetUUIDFromString(employeeID), OrganizationID: orgID, }) if err != nil { return nil, done(err) } } } emp, err = r.store.Employee.One(tx.DB(), employeeID, true) if err != nil { return nil, done(err) } return emp, done(nil) } func (r *controller) updateSocialAccounts(db *gorm.DB, input model.SocialAccountInput, employeeID model.UUID) error { l := r.logger.Fields(logger.Fields{ "handler": "employee", "method": "updateSocialAccounts", "input": input, "employeeID": employeeID, }) accounts, err := r.store.SocialAccount.GetByEmployeeID(db, employeeID.String()) if err != nil { l.Error(err, "failed to get social accounts by employeeID") return err } accountsInput := map[model.SocialAccountType]model.SocialAccount{ model.SocialAccountTypeGitHub: { Type: model.SocialAccountTypeGitHub, EmployeeID: employeeID, AccountID: input.GithubID, Name: input.GithubID, }, model.SocialAccountTypeNotion: { Type: model.SocialAccountTypeNotion, EmployeeID: employeeID, AccountID: input.NotionID, Name: input.NotionName, Email: input.NotionEmail, }, model.SocialAccountTypeLinkedIn: { Type: model.SocialAccountTypeLinkedIn, EmployeeID: employeeID, AccountID: input.LinkedInName, Name: input.LinkedInName, }, } for _, account := range accounts { delete(accountsInput, account.Type) switch account.Type { case model.SocialAccountTypeGitHub: account.AccountID = input.GithubID account.Name = input.GithubID case model.SocialAccountTypeNotion: account.Name = input.NotionName account.Email = input.NotionEmail case model.SocialAccountTypeLinkedIn: account.AccountID = input.LinkedInName account.Name = input.LinkedInName default: continue } if _, err := r.store.SocialAccount.UpdateSelectedFieldsByID(db, account.ID.String(), *account, "account_id", "name", "email"); err != nil { l.Errorf(err, "failed to update social account %s", account.ID) return err } } for _, account := range accountsInput { if _, err := r.store.SocialAccount.Create(db, &account); err != nil { l.AddField("account", account).Error(err, "failed to create social account") return err } } return nil }
```

# pkg/controller/employee/update_personal_info.go

```go
package employee import ( "errors" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type UpdatePersonalInfoInput struct { DoB *time.Time Gender string PlaceOfResidence string Address string PersonalEmail string Country string City string Lat string Long string } func (r *controller) UpdatePersonalInfo(employeeID string, body UpdatePersonalInfoInput) (*model.Employee, error) { emp, err := r.store.Employee.One(r.repo.DB(), employeeID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return nil, ErrEmployeeNotFound } return nil, err } // validate personal email _, err = r.store.Employee.OneByEmail(r.repo.DB(), body.PersonalEmail) if emp.PersonalEmail != body.PersonalEmail && body.PersonalEmail != "" && !errors.Is(err, gorm.ErrRecordNotFound) { if err == nil { return nil, err } return nil, err } emp.DateOfBirth = body.DoB emp.Gender = body.Gender emp.Address = body.Address emp.PlaceOfResidence = body.PlaceOfResidence emp.PersonalEmail = body.PersonalEmail emp.Country = body.Country emp.City = body.City emp.Lat = body.Lat emp.Long = body.Long updatedField := []string{ "date_of_birth", "gender", "address", "place_of_residence", "personal_email", "country", "city", "lat", "long", } emp, err = r.store.Employee.UpdateSelectedFieldsByID(r.repo.DB(), employeeID, *emp, updatedField...) if err != nil { return nil, err } return emp, nil }
```

# pkg/controller/employee/update_role.go

```go
package employee import ( "errors" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) type UpdateRoleBody struct { Roles []model.UUID } type UpdateRoleInput struct { EmployeeID string Body UpdateRoleBody } func (r *controller) UpdateRole(userID string, input UpdateRoleInput) (err error) { loggedInUser, err := r.store.Employee.One(r.repo.DB(), userID, false) if errors.Is(err, gorm.ErrRecordNotFound) { return ErrEmployeeNotFound } if err != nil { return err } empl, err := r.store.Employee.One(r.repo.DB(), input.EmployeeID, false) if errors.Is(err, gorm.ErrRecordNotFound) { return ErrEmployeeNotFound } if err != nil { return err } // Check role exists roles, err := r.store.Role.GetByIDs(r.repo.DB(), input.Body.Roles) if err != nil { return err } for _, role := range roles { if role.Level <= loggedInUser.EmployeeRoles[0].Role.Level && loggedInUser.EmployeeRoles[0].Role.Code != model.AccountRoleAdmin.String() { return ErrInvalidAccountRole } } if empl.EmployeeRoles[0].Role.Level == loggedInUser.EmployeeRoles[0].Role.Level && loggedInUser.EmployeeRoles[0].Role.Code != model.AccountRoleAdmin.String() { return ErrInvalidAccountRole } // Begin transaction tx, done := r.repo.NewTransaction() if err := r.store.EmployeeRole.HardDeleteByEmployeeID(tx.DB(), input.EmployeeID); err != nil { return done(err) } for _, role := range roles { _, err = r.store.EmployeeRole.Create(tx.DB(), &model.EmployeeRole{ EmployeeID: model.MustGetUUIDFromString(input.EmployeeID), RoleID: role.ID, }) if err != nil { r.logger.Fields(logger.Fields{ "emlID": input.EmployeeID, "roleID": role.ID, }).Error(err, "failed to create employee role") return done(err) } } return done(nil) }
```

# pkg/controller/employee/update_skills.go

```go
package employee import ( "errors" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) type UpdateSkillsInput struct { Positions []model.UUID LeadingChapters []model.UUID Chapters []model.UUID Seniority model.UUID Stacks []model.UUID } func (r *controller) UpdateSkills(l logger.Logger, employeeID string, body UpdateSkillsInput) (*model.Employee, error) { emp, err := r.store.Employee.One(r.repo.DB(), employeeID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return nil, ErrEmployeeNotFound } return nil, err } // Check chapter existence chapters, err := r.store.Chapter.All(r.repo.DB()) if err != nil { return nil, err } chapterMap := model.ToChapterMap(chapters) for _, sID := range body.Chapters { _, ok := chapterMap[sID] if !ok { l.Errorf(ErrChapterNotFound, "chapter not found with id ", sID.String()) return nil, ErrChapterNotFound } } // Check seniority existence exist, err := r.store.Seniority.IsExist(r.repo.DB(), body.Seniority.String()) if err != nil { return nil, err } if !exist { return nil, ErrSeniorityNotFound } // Check stack existence _, stacks, err := r.store.Stack.All(r.repo.DB(), "", nil) if err != nil { return nil, err } stackMap := model.ToStackMap(stacks) for _, sID := range body.Stacks { _, ok := stackMap[sID] if !ok { l.Errorf(ErrStackNotFound, "stack not found with id ", sID.String()) return nil, ErrStackNotFound } } // Check position existence positions, err := r.store.Position.All(r.repo.DB()) if err != nil { return nil, err } positionMap := model.ToPositionMap(positions) for _, pID := range body.Positions { _, ok := positionMap[pID] if !ok { l.Errorf(ErrPositionNotFound, "position not found with id ", pID.String()) return nil, ErrPositionNotFound } } // Begin transaction tx, done := r.repo.NewTransaction() // Delete all exist employee positions if err := r.store.EmployeePosition.DeleteByEmployeeID(tx.DB(), employeeID); err != nil { return nil, done(err) } // Create new employee position for _, positionID := range body.Positions { _, err := r.store.EmployeePosition.Create(tx.DB(), &model.EmployeePosition{ EmployeeID: model.MustGetUUIDFromString(employeeID), PositionID: positionID, }) if err != nil { return nil, done(err) } } // Delete all exist employee stack if err := r.store.EmployeeStack.DeleteByEmployeeID(tx.DB(), employeeID); err != nil { return nil, done(err) } // Create new employee stack for _, stackID := range body.Stacks { _, err := r.store.EmployeeStack.Create(tx.DB(), &model.EmployeeStack{ EmployeeID: model.MustGetUUIDFromString(employeeID), StackID: stackID, }) if err != nil { return nil, done(err) } } // Delete all exist employee stack if err := r.store.EmployeeChapter.DeleteByEmployeeID(tx.DB(), employeeID); err != nil { return nil, done(err) } // Create new employee stack for _, chapterID := range body.Chapters { _, err := r.store.EmployeeChapter.Create(tx.DB(), &model.EmployeeChapter{ EmployeeID: model.MustGetUUIDFromString(employeeID), ChapterID: chapterID, }) if err != nil { return nil, done(err) } } // Remove all chapter lead by employee leadingChapters, err := r.store.Chapter.GetAllByLeadID(tx.DB(), employeeID) if err != nil { return nil, done(err) } for _, lChapter := range leadingChapters { if err := r.store.Chapter.UpdateChapterLead(tx.DB(), lChapter.ID.String(), nil); err != nil { return nil, done(err) } } // Create new chapter leader := model.MustGetUUIDFromString(employeeID) for _, lChapter := range body.LeadingChapters { if err := r.store.Chapter.UpdateChapterLead(tx.DB(), lChapter.String(), &leader); err != nil { return nil, done(err) } } // Update employee information emp.SeniorityID = body.Seniority _, err = r.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, *emp, "chapter_id", "seniority_id") if err != nil { return nil, done(err) } return emp, done(nil) }
```

# pkg/controller/employee/upload_avatar.go

```go
package employee import ( "fmt" "mime/multipart" "path/filepath" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type UploadAvatarInput struct { ID string } func (r *controller) UploadAvatar(uuidUserID model.UUID, file *multipart.FileHeader, params UploadAvatarInput) (string, error) { fileName := file.Filename fileExtension := model.ContentExtension(filepath.Ext(fileName)) fileSize := file.Size fileType := "image" filePath := fmt.Sprintf("https://storage.googleapis.com/%s/employees/%s/images/%s", r.config.Google.GCSBucketName, params.ID, fileName) gcsPath := fmt.Sprintf("employees/%s/images/%s", params.ID, fileName) // 2.1 validate if !fileExtension.ImageValid() { return "", ErrInvalidFileExtension } if fileExtension == model.ContentExtensionJpg || fileExtension == model.ContentExtensionPng { if fileSize > model.MaxFileSizeImage { return "", ErrInvalidFileSize } } tx, done := r.repo.NewTransaction() // 2.2 check employee existed emp, err := r.store.Employee.One(tx.DB(), params.ID, false) if err != nil { if err == gorm.ErrRecordNotFound { return "", done(ErrEmployeeNotFound) } return "", done(err) } // 2.3 check file name exist _, err = r.store.Content.OneByPath(tx.DB(), filePath) if err != nil && err != gorm.ErrRecordNotFound { return "", done(err) } if err != nil && err == gorm.ErrRecordNotFound { // not found => create and upload content to GCS _, err = r.store.Content.Create(tx.DB(), model.Content{ Type: fileType, Extension: fileExtension.String(), Path: filePath, TargetID: emp.ID, UploadBy: uuidUserID, }) if err != nil { return "", done(err) } multipart, err := file.Open() if err != nil { return "", done(err) } err = r.service.GoogleStorage.UploadContentGCS(multipart, gcsPath) if err != nil { return "", done(err) } } // 3. update avatar field _, err = r.store.Employee.UpdateSelectedFieldsByID(tx.DB(), emp.ID.String(), model.Employee{ Avatar: filePath, }, "avatar") if err != nil { return "", done(err) } return filePath, done(nil) }
```

# pkg/controller/event/event.go

```go
package event import ( "context" "strings" "time" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/service/mochipay" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/store/discordevent" "github.com/ethereum/go-ethereum/log" ) type IController interface { SweepOgifEvent(c context.Context) error } type controller struct { service *service.Service logger logger.Logger config *config.Config store *store.Store repo store.DBRepo } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, service: service, logger: logger, config: cfg, repo: repo, } } func (c *controller) SweepOgifEvent(ctx context.Context) error { isSender := true // Fetch latest 50 transactions txReq := mochipay.ListTransactionsRequest{ ActionList: []mochipay.TransactionAction{mochipay.TransactionActionVaultTransfer}, IsSender: &isSender, ProfileID: "1707664412564787200", Size: 100, SortBy: "created_at-", Status: mochipay.TransactionStatusSuccess, TokenAddress: mochipay.ICYAddress, } txResp, err := c.service.MochiPay.GetListTransactions(txReq) if err != nil { return err } if len(txResp.Data) == 0 { return nil // No transactions to process } // Get the time of the last transaction lastTxTime := txResp.Data[len(txResp.Data)-1].CreatedAt // Fetch all events after the last transaction time events, err := c.store.DiscordEvent.All(c.repo.DB(), &discordevent.Query{ After: &lastTxTime, Limit: 100, }, true) if err != nil { return err } txMap := make(map[string]bool) for _, tx := range txResp.Data { txMap[tx.Id] = false } for _, event := range events { if len(event.EventSpeakers) != 0 { continue } // Find transactions for this event for _, tx := range txResp.Data { if !strings.HasPrefix(strings.ToLower(tx.Metadata["message"].(string)), "ogif") { log.Debug("tx is not ogif") continue } txCreatedDate := time.Date(tx.CreatedAt.Year(), tx.CreatedAt.Month(), tx.CreatedAt.Day(), 0, 0, 0, 0, tx.CreatedAt.Location()) eventDate := time.Date(event.Date.Year(), event.Date.Month(), event.Date.Day(), 0, 0, 0, 0, event.Date.Location()) if txCreatedDate.Before(eventDate) { log.Debug("tx created before event date") continue } if txMap[tx.Id] { log.Debug("tx already processed") continue } profile, err := c.service.MochiProfile.GetProfile(tx.FromProfileId) if err != nil { txMap[tx.Id] = true c.logger.Error(err, "failed to get MochiProfile") continue } var discordID string for _, account := range profile.AssociatedAccounts { if account.Platform == "discord" { discordID = account.PlatformIdentifier break } } if discordID == "" { log.Debug("tx is not from discord") continue } discordAccount, err := c.store.DiscordAccount.OneByDiscordID(c.repo.DB(), discordID) if err != nil { c.logger.Error(err, "failed to get discordAccount") continue } speaker := &model.EventSpeaker{ EventID: event.ID, DiscordAccountID: discordAccount.ID, Topic: tx.Metadata["message"].(string), } _, err = c.store.EventSpeaker.Create(c.repo.DB(), speaker) if err != nil { c.logger.Error(err, "failed to create event speaker") continue } txMap[tx.Id] = true } } return nil }
```

# pkg/controller/icy/icy.go

```go
package icy import ( "math/big" "strings" "sync" "github.com/ethereum/go-ethereum/common" "github.com/ethereum/go-ethereum/common/math" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/service/icyswap" "github.com/dwarvesf/fortress-api/pkg/service/mochipay" "github.com/dwarvesf/fortress-api/pkg/service/mochiprofile" ) type IController interface { Accounting() (*model.IcyAccounting, error) } type controller struct { service *service.Service logger logger.Logger config *config.Config } func New(service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ service: service, logger: logger, config: cfg, } } func (c *controller) Accounting() (*model.IcyAccounting, error) { l := c.logger.Fields(logger.Fields{ "controller": "icy", "method": "Accounting", }) // 0.Prepare token and icyswapbtc contract data icy := c.icy() usdt := c.usdc() icySwap := c.icySwap() // 1.Get current conversion rate from icyswap contract conversionRate, err := c.service.IcySwap.ConversionRate() if err != nil { l.Error(err, "failed to get icy conversion rate") return nil, err } usdtDecimals := new(big.Float).SetInt(math.BigPow(10, int64(usdt.Decimals))) conversionRateFloat, _ := new(big.Float).Quo(new(big.Float).SetInt(conversionRate), usdtDecimals).Float32() // 2. Get current usdt fund in icyswap contract icyswapUsdtBal, err := c.service.IcySwap.UsdcFund() if err != nil { l.Error(err, "failed to get usdt fund in icyswap contract") return nil, err } // 3. Get Circulating Icy // circulating icy = total supply - icy in contract - icy of team - icy in mochi app - icy in vault // 3.1 Get total icy supply icyTotalSupply, _ := new(big.Int).SetString(icy.TotalSupply, 10) // 3.2 Get total locked icy amount lockedIcyAmount, err := c.lockedIcyAmount() if err != nil { c.logger.Error(err, "failed to get locked icy amount") return nil, err } // 3.3 Calculate circulating icy amount circulatingIcy := new(big.Int).Sub(icyTotalSupply, lockedIcyAmount) // 4.Get offset usdt // offset usd: circulating icy in usdt - usd fund in contract -> get how many usd left to redeem circulatingIcyInUsdt := new(big.Int).Mul(circulatingIcy, conversionRate) // continue to divide to 10^18 for get the amount in usdt decimals circulatingIcyInUsdt = new(big.Int).Div(circulatingIcyInUsdt, math.BigPow(10, 18)) offsetUsdt := new(big.Int).Sub(circulatingIcyInUsdt, icyswapUsdtBal) // 5. Return accounting result return &model.IcyAccounting{ ICY: &icy, USDT: &usdt, IcySwap: &icySwap, ConversionRate: conversionRateFloat, ContractFundInUSDT: icyswapUsdtBal.String(), CirculatingICY: circulatingIcy.String(), OffsetUSDT: offsetUsdt.String(), }, nil } func (c *controller) lockedIcyAmount() (*big.Int, error) { lockedIcyAmount := big.NewInt(0) // 0. fetch onchain locked icy amount onchainLockedAmount, err := c.onchainLockedIcyAmount() if err != nil { c.logger.Error(err, "failed to get onchain locked icy amount") return nil, err } lockedIcyAmount = new(big.Int).Add(lockedIcyAmount, onchainLockedAmount) // 1. fetch offchain locked icy amount offchainLockedAmount, err := c.offchainLockedIcyAmount() if err != nil { c.logger.Error(err, "failed to get offchain locked icy amount") return nil, err } lockedIcyAmount = new(big.Int).Add(lockedIcyAmount, offchainLockedAmount) // 2. return result return lockedIcyAmount, nil } func (c *controller) onchainLockedIcyAmount() (*big.Int, error) { icyAddress := common.HexToAddress(c.icy().Address) oldIcySwapContractAddr := common.HexToAddress("0xd327b6d878bcd9d5ec6a5bc99445985d75f0d6e5") icyswapAddr := common.HexToAddress(icyswap.ICYSwapAddress) teamAddr := common.HexToAddress("0x0762c4b40c9cb21Af95192a3Dc3EDd3043CF3d41") icyLockedAddrs := []common.Address{oldIcySwapContractAddr, icyswapAddr, teamAddr} type FetchResult struct { amount *big.Int err error } fetchIcyResults := make(chan FetchResult) wg := sync.WaitGroup{} wg.Add(len(icyLockedAddrs)) go func() { wg.Wait() close(fetchIcyResults) }() for _, lockedAddr := range icyLockedAddrs { go func(ownerAddr common.Address) { amount, err := c.service.BaseClient.ERC20Balance(icyAddress, ownerAddr) fetchIcyResults <- FetchResult{ amount: amount, err: err, } wg.Done() }(lockedAddr) } lockedIcyAmount := big.NewInt(0) for res := range fetchIcyResults { if res.err != nil { return nil, res.err } lockedIcyAmount = new(big.Int).Add(lockedIcyAmount, res.amount) } return lockedIcyAmount, nil } func (c *controller) offchainLockedIcyAmount() (*big.Int, error) { // 0. get all profile, which type is vault or app profileIds := make([]string, 0) const pageSize int64 = 50 var page int64 = 0 for { res, err := c.service.MochiProfile.GetListProfiles(mochiprofile.ListProfilesRequest{ Types: []mochiprofile.ProfileType{ mochiprofile.ProfileTypeApplication, mochiprofile.ProfileTypeVault, }, Page: page, Size: pageSize, }) if err != nil { return nil, err } for _, p := range res.Data { profileIds = append(profileIds, p.ID) } hasNext := res.Pagination.Total/pageSize-page > 0 if !hasNext { break } page += 1 } // 1. get balance of all profiles balRes, err := c.service.MochiPay.GetBatchBalances(profileIds) if err != nil { return nil, err } total := big.NewInt(0) icy := c.icy() for _, b := range balRes.Data { // filter token icy if strings.EqualFold(b.Token.Address, icy.Address) && strings.EqualFold(b.Token.ChainId, icy.ChainID) { amount, _ := new(big.Int).SetString(b.Amount, 10) total = new(big.Int).Add(total, amount) } } return total, nil } func (c *controller) icy() model.TokenInfo { return model.TokenInfo{ Name: "Icy", Symbol: "ICY", Address: mochipay.ICYAddress, Decimals: 18, Chain: mochipay.BASEChainID, ChainID: mochipay.BASEChainID, TotalSupply: "100000000000000000000000", } } func (c *controller) usdc() model.TokenInfo { return model.TokenInfo{ Name: "USD Base Coin", Symbol: "USDbC", Address: icyswap.USDCAddress, Decimals: 6, Chain: mochipay.BaseChainName, ChainID: mochipay.BASEChainID, } } func (c *controller) icySwap() model.ContractInfo { return model.ContractInfo{ Name: "IcySwap", Address: icyswap.ICYSwapAddress, Chain: mochipay.BaseChainName, } }
```

# pkg/controller/invoice/commission.go

```go
package invoice import ( "fmt" "sync" "github.com/shopspring/decimal" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" bcConst "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) const ( hiringCommissionRate int64 = 2 saleReferralCommissionRate int64 = 10 ) type pic struct { ID model.UUID CommissionRate decimal.Decimal ChargeRate float64 Note string } type pics struct { devLeads []pic accountManagers []pic deliveryManagers []pic sales []pic suppliers []pic upsells []pic saleReferers []pic upsellReferers []pic } func (c *controller) storeCommission(db *gorm.DB, l logger.Logger, invoice *model.Invoice) ([]model.EmployeeCommission, error) { if invoice.Project.Type != model.ProjectTypeTimeMaterial { return nil, nil } employeeCommissions, err := c.calculateCommissionFromInvoice(db, l, invoice) if err != nil { l.Errorf(err, "failed to create commission for invoice(%s)", invoice.ID.String()) return nil, err } if len(employeeCommissions) == 0 { return []model.EmployeeCommission{}, nil } return c.store.EmployeeCommission.Create(db, employeeCommissions) } func (c *controller) calculateCommissionFromInvoice(db *gorm.DB, l logger.Logger, invoice *model.Invoice) ([]model.EmployeeCommission, error) { projectMembers, err := c.store.ProjectMember.GetAssignedMembers(db, invoice.ProjectID.String(), model.ProjectMemberStatusActive.String(), true) if err != nil { l.Errorf(err, "failed to calculate account manager commission rate for project(%s)", invoice.ProjectID.String()) return nil, err } // Get list of project head who will get the commission from this invoice pics := c.getPICs(invoice, projectMembers) var res []model.EmployeeCommission if len(pics.devLeads) > 0 { c, err := c.calculateHeadCommission(pics.devLeads, invoice, invoice.TotalWithoutBonus) if err != nil { l.Errorf(err, "failed to calculate dev lead commission rate for project(%s)", invoice.ProjectID.String()) return nil, err } res = append(res, c...) } if len(pics.accountManagers) > 0 { c, err := c.calculateHeadCommission(pics.accountManagers, invoice, invoice.TotalWithoutBonus) if err != nil { l.Errorf(err, "failed to calculate account manager commission rate for project(%s)", invoice.ProjectID.String()) return nil, err } res = append(res, c...) } if len(pics.deliveryManagers) > 0 { c, err := c.calculateHeadCommission(pics.deliveryManagers, invoice, invoice.TotalWithoutBonus) if err != nil { l.Errorf(err, "failed to calculate delivery manager commission rate for project(%s)", invoice.ProjectID.String()) return nil, err } res = append(res, c...) } if len(pics.sales) > 0 { c, err := c.calculateHeadCommission(pics.sales, invoice, invoice.TotalWithoutBonus) if err != nil { l.Errorf(err, "failed to calculate sales commission rate for project(%s)", invoice.ProjectID.String()) return nil, err } res = append(res, c...) } if len(pics.upsells) > 0 { c, err := c.calculateRefBonusCommission(pics.upsells, invoice) if err != nil { l.Errorf(err, "failed to calculate upsells commission rate for project(%s)", invoice.ProjectID.String()) return nil, err } res = append(res, c...) } if len(pics.suppliers) > 0 { c, err := c.calculateRefBonusCommission(pics.suppliers, invoice) if err != nil { l.Errorf(err, "failed to calculate supplier commission rate for project(%s)", invoice.ProjectID.String()) return nil, err } res = append(res, c...) } if len(pics.saleReferers) > 0 { c, err := c.calculateSaleReferralCommission(pics.saleReferers, invoice) if err != nil { l.Errorf(err, "failed to calculate sale refereral commission rate for project(%s)", invoice.ProjectID.String()) return nil, err } res = append(res, c...) } if len(pics.upsellReferers) > 0 { c, err := c.calculateUpsellSaleReferralCommission(pics.upsellReferers, invoice) if err != nil { l.Errorf(err, "failed to calculate upsell refereral commission rate for project(%s)", invoice.ProjectID.String()) return nil, err } res = append(res, c...) } return res, nil } func (c *controller) getPICs(invoice *model.Invoice, projectMembers []*model.ProjectMember) *pics { var ( devLeads []pic accountManagers []pic deliveryManagers []pic sales []pic upsells []pic suppliers []pic saleReferers []pic upsellReferers []pic ) for _, itm := range invoice.Project.Heads { switch itm.Position { case model.HeadPositionTechnicalLead: devLeads = append(devLeads, pic{ ID: itm.EmployeeID, CommissionRate: itm.CommissionRate, ChargeRate: invoice.Total, Note: "Lead", }) case model.HeadPositionAccountManager: accountManagers = append(accountManagers, pic{ ID: itm.EmployeeID, CommissionRate: itm.CommissionRate, ChargeRate: invoice.Total, Note: "Account Manager", }) case model.HeadPositionDeliveryManager: deliveryManagers = append(deliveryManagers, pic{ ID: itm.EmployeeID, CommissionRate: itm.CommissionRate, ChargeRate: invoice.Total, Note: "Delivery Manager", }) case model.HeadPositionSalePerson: sales = append(sales, pic{ ID: itm.EmployeeID, CommissionRate: itm.CommissionRate, ChargeRate: invoice.Total, Note: "Sales", }) // UPDATE: // If sale person earn commission from project. The person who refer the sale person will earn commission too. // The commission rate is 10% of the sale person commission rate. salePersonDetail, err := c.store.Employee.One(c.repo.DB(), itm.EmployeeID.String(), false) if err != nil { continue } if salePersonDetail.Referrer == nil { continue } saleReferers = append(saleReferers, pic{ ID: salePersonDetail.Referrer.ID, CommissionRate: decimal.NewFromInt(saleReferralCommissionRate), ChargeRate: decimal.NewFromFloat(invoice.Total).Mul(itm.CommissionRate).Div(decimal.NewFromInt(100)).InexactFloat64(), Note: fmt.Sprintf("Sale Referral - %s", salePersonDetail.FullName), }) } } for _, pm := range projectMembers { if pm.DeploymentType != model.MemberDeploymentTypeOfficial { continue } if !pm.UpsellCommissionRate.IsZero() { upsells = append(upsells, pic{ ID: pm.UpsellPersonID, CommissionRate: pm.UpsellCommissionRate, ChargeRate: pm.Rate.InexactFloat64(), Note: "Upsell", }) upsellPersonDetail, err := c.store.Employee.One(c.repo.DB(), pm.UpsellPersonID.String(), false) if err != nil { continue } if upsellPersonDetail.Referrer != nil { upsellReferers = append(upsellReferers, pic{ ID: upsellPersonDetail.Referrer.ID, CommissionRate: decimal.NewFromInt(saleReferralCommissionRate), ChargeRate: decimal.NewFromFloat(pm.Rate.InexactFloat64()).Mul(pm.UpsellCommissionRate).Div(decimal.NewFromInt(100)).InexactFloat64(), Note: fmt.Sprintf("Sale Referral - %s Upsell %s", upsellPersonDetail.FullName, pm.Employee.FullName), }) } } if pm.Employee.Referrer != nil { if pm.Employee.Referrer.WorkingStatus != model.WorkingStatusLeft { suppliers = append(suppliers, pic{ ID: pm.Employee.Referrer.ID, CommissionRate: decimal.NewFromInt(hiringCommissionRate), ChargeRate: pm.Rate.InexactFloat64(), Note: fmt.Sprintf("Hiring - %s", pm.Employee.FullName), }) } } } return &pics{ devLeads: devLeads, accountManagers: accountManagers, deliveryManagers: deliveryManagers, sales: sales, upsells: upsells, suppliers: suppliers, saleReferers: saleReferers, upsellReferers: upsellReferers, } } func (c *controller) movePaidInvoiceGDrive(l logger.Logger, wg *sync.WaitGroup, req *processPaidInvoiceRequest) { msg := c.service.Basecamp.BuildCommentMessage(req.InvoiceBucketID, req.InvoiceTodoID, bcConst.CommentMoveInvoicePDFToPaidDirSuccessfully, bcModel.CommentMsgTypeCompleted) defer func() { c.worker.Enqueue(bcModel.BasecampCommentMsg, msg) wg.Done() }() err := c.service.GoogleDrive.MoveInvoicePDF(req.Invoice, "Sent", "Paid") if err != nil { l.Errorf(err, "failed to move invoice pdf from sent to paid folder for invoice(%v)", req.Invoice.ID.String()) msg = c.service.Basecamp.BuildCommentMessage(req.InvoiceBucketID, req.InvoiceTodoID, bcConst.CommentMoveInvoicePDFToPaidDirFailed, bcModel.CommentMsgTypeFailed) return } } func (c *controller) calculateHeadCommission(beneficiaries []pic, invoice *model.Invoice, invoiceTotal float64) ([]model.EmployeeCommission, error) { // NOTE: // CR is Commission Rate // IV is Invoice Value // RCR is Referral Commission Rate // VAL is Charge Rate the value before the commission // RATE is Conversion Rate rs := make([]model.EmployeeCommission, 0) for _, beneficiary := range beneficiaries { if !beneficiary.CommissionRate.GreaterThan(decimal.NewFromInt(0)) { continue } crPercentage := beneficiary.CommissionRate.Div(decimal.NewFromInt(100)) commissionValue, _ := crPercentage.Mul(decimal.NewFromFloat(invoiceTotal)).Float64() convertedValue, rate, err := c.service.Wise.Convert(commissionValue, invoice.Project.BankAccount.Currency.Name, "VND") if err != nil { return nil, err } if convertedValue > 0 { rs = append(rs, model.EmployeeCommission{ EmployeeID: beneficiary.ID, Amount: model.NewVietnamDong(int64(convertedValue)), Project: invoice.Project.Name, ConversionRate: rate, InvoiceID: invoice.ID, Formula: fmt.Sprintf("%v%%(CR) * %v(IV) * %v(RATE)", beneficiary.CommissionRate, invoiceTotal, rate), Note: beneficiary.Note, }) } } return rs, nil } func (c *controller) calculateRefBonusCommission(pics []pic, invoice *model.Invoice) ([]model.EmployeeCommission, error) { // conversionRate by percentage var rs []model.EmployeeCommission for _, pic := range pics { percentage := pic.CommissionRate.Div(decimal.NewFromInt(100)) commissionValue, _ := percentage.Mul(decimal.NewFromFloat(pic.ChargeRate)).Float64() convertedValue, rate, err := c.service.Wise.Convert(commissionValue, invoice.Project.BankAccount.Currency.Name, "VND") if err != nil { return nil, err } rs = append(rs, model.EmployeeCommission{ EmployeeID: pic.ID, Amount: model.NewVietnamDong(int64(convertedValue)), Project: invoice.Project.Name, ConversionRate: rate, InvoiceID: invoice.ID, Formula: fmt.Sprintf("%v%%(RCR) * %v(VAL) * %v(RATE)", pic.CommissionRate, pic.ChargeRate, rate), Note: pic.Note, }) } return rs, nil } func (c *controller) calculateSaleReferralCommission(pics []pic, invoice *model.Invoice) ([]model.EmployeeCommission, error) { // conversionRate by percentage var rs []model.EmployeeCommission for _, pic := range pics { percentage := pic.CommissionRate.Div(decimal.NewFromInt(100)) commissionValue, _ := percentage.Mul(decimal.NewFromFloat(pic.ChargeRate)).Float64() convertedValue, rate, err := c.service.Wise.Convert(commissionValue, invoice.Project.BankAccount.Currency.Name, "VND") if err != nil { return nil, err } rs = append(rs, model.EmployeeCommission{ EmployeeID: pic.ID, Amount: model.NewVietnamDong(int64(convertedValue)), Project: invoice.Project.Name, ConversionRate: rate, InvoiceID: invoice.ID, Formula: fmt.Sprintf("%v%%(RCR) * %v(VAL) * %v(RATE)", pic.CommissionRate, commissionValue, rate), Note: pic.Note, }) } return rs, nil } func (c *controller) calculateUpsellSaleReferralCommission(pics []pic, invoice *model.Invoice) ([]model.EmployeeCommission, error) { var rs []model.EmployeeCommission for _, pic := range pics { percentage := pic.CommissionRate.Div(decimal.NewFromInt(100)) commissionValue, _ := percentage.Mul(decimal.NewFromFloat(pic.ChargeRate)).Float64() convertedValue, rate, err := c.service.Wise.Convert(commissionValue, invoice.Project.BankAccount.Currency.Name, "VND") if err != nil { return nil, err } rs = append(rs, model.EmployeeCommission{ EmployeeID: pic.ID, Amount: model.NewVietnamDong(int64(convertedValue)), Project: invoice.Project.Name, ConversionRate: rate, InvoiceID: invoice.ID, Formula: fmt.Sprintf("%v%%(RCR) * %v(VAL) * %v(RATE)", pic.CommissionRate, commissionValue, rate), Note: pic.Note, }) } return rs, nil }
```

# pkg/controller/invoice/errors.go

```go
package invoice import "errors" var ( ErrBankAccountNotFound = errors.New("bank account not found") ErrCouldNotGetTheLatestInvoice = errors.New("could not get the latest invoice") ErrCouldNotGetTheNextInvoiceNumber = errors.New("could not get the next invoice number") ErrInvoiceNotFound = errors.New("invoice not found") ErrInvoiceStatusAlready = errors.New("invoice status already") ErrProjectNotFound = errors.New("project not found") ErrSenderNotFound = errors.New("sender not found") )
```

# pkg/controller/invoice/get_template.go

```go
package invoice import ( "errors" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) type GetInvoiceInput struct { Now *time.Time ProjectID string } func (c *controller) GetTemplate(in GetInvoiceInput) (string, *model.Invoice, *model.Project, error) { l := c.logger.Fields(logger.Fields{ "controller": "invoice", "method": "GetTemplate", "input": in, }) // check project existence p, err := c.store.Project.One(c.repo.DB(), in.ProjectID, true) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(ErrProjectNotFound, "project not found") return "", nil, nil, ErrProjectNotFound } if err != nil { return "", nil, nil, err } nextInvoiceNumber, err := c.store.Invoice.GetNextInvoiceNumber(c.repo.DB(), in.Now.Year(), p.Code) if err != nil { l.Error(err, "failed to get next invoice Number") return "", nil, nil, ErrCouldNotGetTheNextInvoiceNumber } lastInvoice, err := c.store.Invoice.GetLatestInvoiceByProject(c.repo.DB(), in.ProjectID) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "failed to get the latest invoice") return "", nil, nil, ErrCouldNotGetTheLatestInvoice } if errors.Is(err, gorm.ErrRecordNotFound) { lastInvoice = nil } return *nextInvoiceNumber, lastInvoice, p, nil }
```

# pkg/controller/invoice/list.go

```go
package invoice import ( "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/store/invoice" ) type GetListInvoiceInput struct { model.Pagination ProjectIDs []string Statuses []string } func (c *controller) List(in GetListInvoiceInput) ([]*model.Invoice, int64, error) { l := c.logger.Fields(logger.Fields{ "controller": "invoice", "method": "List", "input": in, }) invoices, total, err := c.store.Invoice.All(c.repo.DB(), invoice.GetInvoicesFilter{ Preload: true, ProjectIDs: in.ProjectIDs, Statuses: in.Statuses, }, in.Pagination) if err != nil { l.Error(err, "failed to get invoice list") return nil, 0, err } return invoices, total, nil }
```

# pkg/controller/invoice/new.go

```go
package invoice import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/worker" ) type controller struct { store *store.Store service *service.Service worker *worker.Worker logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, worker *worker.Worker, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, repo: repo, service: service, logger: logger, config: cfg, worker: worker, } } type IController interface { GetTemplate(in GetInvoiceInput) (nextInvoiceNumber string, lastInvoice *model.Invoice, p *model.Project, err error) List(in GetListInvoiceInput) ([]*model.Invoice, int64, error) MarkInvoiceAsError(invoice *model.Invoice) (*model.Invoice, error) MarkInvoiceAsPaid(invoice *model.Invoice, sendThankYouEmail bool) (*model.Invoice, error) MarkInvoiceAsPaidByBasecampWebhookMessage(invoice *model.Invoice, msg *model.BasecampWebhookMessage) (*model.Invoice, error) Send(iv *model.Invoice) (*model.Invoice, error) UpdateStatus(in UpdateStatusInput) (*model.Invoice, error) }
```

# pkg/controller/invoice/send.go

```go
package invoice import ( "bytes" "errors" "fmt" "math" "math/rand" "os" "path/filepath" "strconv" "strings" "text/template" "time" "github.com/Rhymond/go-money" toPdf "github.com/SebastiaanKlippert/go-wkhtmltopdf" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" ) func (c *controller) Send(iv *model.Invoice) (*model.Invoice, error) { now := time.Now() l := c.logger.Fields(logger.Fields{ "controller": "invoice", "method": "Send", }) // check sender existence exists, err := c.store.Employee.IsExist(c.repo.DB(), iv.SentBy.String()) if err != nil { l.Error(err, "failed to check sender existence") return nil, err } if !exists { l.Error(ErrSenderNotFound, "sender not exist") return nil, err } // check bank account existence b, err := c.store.BankAccount.One(c.repo.DB(), iv.BankID.String()) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(ErrBankAccountNotFound, "project not found") return nil, err } l.Error(err, "failed to check bank account existence") return nil, err } iv.Bank = b // check project existence p, err := c.store.Project.One(c.repo.DB(), iv.ProjectID.String(), true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(ErrProjectNotFound, "project not found") return nil, err } l.Error(err, "failed to check project existence") return nil, err } iv.Project = p nextInvoiceNumber, err := c.store.Invoice.GetNextInvoiceNumber(c.repo.DB(), now.Year(), p.Code) if err != nil { l.Error(err, "failed to get next invoice Number") return nil, err } iv.Number = *nextInvoiceNumber invoiceItems, err := model.GetInfoItems(iv.LineItems) if err != nil { l.Errorf(err, "failed to get info items", "invoice-lineItems", iv.LineItems) return nil, err } iv.Bonus = c.getInvoiceBonus(invoiceItems) iv.TotalWithoutBonus = iv.Total - iv.Bonus if err := c.generateInvoicePDF(l, iv, invoiceItems); err != nil { l.Error(err, "failed to generate Invoice PDF") return nil, err } conversionAmount, rate, err := c.service.Wise.Convert(iv.Total, iv.Bank.Currency.Name, "VND") if err != nil { l.Error(err, "failed to convert currency") return nil, err } am := model.NewVietnamDong(int64(conversionAmount)) iv.ConversionAmount = float64(am) iv.ConversionRate = rate savedInvoice, err := c.store.Invoice.Save(c.repo.DB(), iv) if err != nil { l.Errorf(err, "failed to create invoice", "invoice", iv.Number) return nil, err } iv.ID = savedInvoice.ID if err := c.store.InvoiceNumberCaching.UpdateInvoiceCachingNumber(c.repo.DB(), time.Now(), iv.Project.Code); err != nil { l.Errorf(err, "failed to update invoice caching number", "project", iv.Project.Code) return nil, err } errsCh := make(chan error) var amountGr = 0 if iv.Status != model.InvoiceStatusDraft { amountGr += 2 fn := strconv.FormatInt(rand.Int63(), 10) + "_" + iv.Number + ".pdf" invoiceFilePath := fmt.Sprintf("https://storage.googleapis.com/%s/invoices/%s", c.config.Google.GCSBucketName, fn) iv.InvoiceFileURL = invoiceFilePath go func() { err = c.service.GoogleDrive.UploadInvoicePDF(iv, "Sent") if err != nil { l.Errorf(err, "failed to upload invoice") errsCh <- err return } errsCh <- nil }() go func() { threadID, err := c.service.GoogleMail.SendInvoiceMail(iv) if err != nil { l.Errorf(err, "failed to send invoice mail") errsCh <- err return } iv.ThreadID = threadID _, err = c.store.Invoice.UpdateSelectedFieldsByID(c.repo.DB(), iv.ID.String(), *iv, "thread_id") if err != nil { l.Errorf(err, "failed to update invoice thread id", "thread_id", threadID) errsCh <- err return } attachmentSgID, err := c.service.Basecamp.Attachment.Create("application/pdf", fn, iv.InvoiceFileContent) if err != nil { l.Errorf(err, "failed to create Basecamp Attachment", "invoice", iv) errsCh <- err return } iv.TodoAttachment = fmt.Sprintf(`<bc-attachment sgid="%v" caption="My photo"></bc-attachment>`, attachmentSgID) bucketID, todoID, err := c.getInvoiceTodo(iv) if err != nil { l.Errorf(err, "failed to get invoice todo", "invoice", iv) errsCh <- err return } msg := fmt.Sprintf(`#Invoice %v has been sent Confirm Command: Paid @Giang #%v`, iv.Number, iv.Number) c.worker.Enqueue(bcModel.BasecampCommentMsg, c.service.Basecamp.BuildCommentMessage(bucketID, todoID, msg, "")) errsCh <- nil }() } var count int for e := range errsCh { if e != nil { close(errsCh) return nil, err } count++ if count == amountGr { close(errsCh) return iv, nil } } return iv, nil } func (c *controller) generateInvoicePDF(l logger.Logger, invoice *model.Invoice, items []model.InvoiceItem) error { pound := money.New(1, invoice.Project.BankAccount.Currency.Name) companyInfo, err := invoice.Project.GetCompanyContactInfo() if err != nil { l.Errorf(err, "failed to get company contact info", "project", invoice.Project) return err } var haveDiscountColumn bool for i := range items { if items[i].Discount != 0 { haveDiscountColumn = true } } haveRouting := invoice.Bank.RoutingNumber != "" haveSwiftCode := invoice.Bank.SwiftCode != "" haveUKSortCode := invoice.Bank.UKSortCode != "" haveIntermediaryBankName := invoice.Bank.IntermediaryBankName != "" haveIntermediaryBankAddress := invoice.Bank.IntermediaryBankAddress != "" data := &struct { Path string Invoice *model.Invoice HaveRouting bool HaveUKSortCode bool HaveSWIFTCode bool HaveIntermediaryBankName bool HaveIntermediaryBankAddress bool CompanyContactInfo *model.CompanyContactInfo InvoiceItem []model.InvoiceItem IntermediaryBankName string }{ Path: c.config.Invoice.TemplatePath, Invoice: invoice, HaveRouting: haveRouting, HaveUKSortCode: haveUKSortCode, HaveSWIFTCode: haveSwiftCode, HaveIntermediaryBankName: haveIntermediaryBankName, HaveIntermediaryBankAddress: haveIntermediaryBankAddress, CompanyContactInfo: companyInfo, InvoiceItem: items, } funcMap := template.FuncMap{ "toString": func(month int) string { return time.Month(month).String() }, "formatDate": func(t *time.Time) string { return timeutil.FormatDatetime(*t) }, "lastDayOfMonth": func() string { return timeutil. FormatDatetime(timeutil.LastDayOfMonth(invoice.Month, invoice.Year)) }, "formatMoney": func(money float64) string { var result string tmpValue := money * math.Pow(10, float64(pound.Currency().Fraction)) result = pound.Multiply(int64(tmpValue)).Display() return result }, "haveDescription": func(description string) bool { return description != "" }, "haveNote": func(note string) bool { return note != "" }, "haveDiscountColumn": func() bool { return haveDiscountColumn }, "float": func(n float64) string { return fmt.Sprintf("%.2f", n) }, } if c.config.Env == "local" { data.Path = os.Getenv("GOPATH") + "/src/github.com/dwarvesf/fortress-api/pkg/templates" } tmpl, err := template.New("invoicePDF").Funcs(funcMap).ParseFiles(filepath.Join(data.Path, "invoice.html")) if err != nil { l.Errorf(err, "failed to parse template", "path", data.Path, "filename", "invoice.html") return err } var buf bytes.Buffer if err := tmpl.Funcs(funcMap).ExecuteTemplate(&buf, "invoice.html", data); err != nil { l.Errorf(err, "failed to execute template", "data", data, "path", data.Path, "filename", "invoice.html") return err } pdfg, err := toPdf.NewPDFGenerator() if err != nil { l.Errorf(err, "failed to create pdf generator") return err } t := toPdf.NewPageReader(&buf) t.Zoom.Set(1.45) t.EnableLocalFileAccess.Set(true) pdfg.AddPage(t) pdfg.Dpi.Set(600) pdfg.PageSize.Set("A4") if err := pdfg.Create(); err != nil { l.Errorf(err, "failed to create invoice pdf", "invoice", invoice) return err } invoice.InvoiceFileContent = pdfg.Buffer().Bytes() return nil } func (c *controller) getInvoiceBonus(items []model.InvoiceItem) float64 { var bonus float64 for _, item := range items { if strings.Contains(strings.ToLower(item.Description), "bonus") { bonus += item.Cost } } return bonus }
```

# pkg/controller/invoice/update_status.go

```go
package invoice import ( "encoding/json" "errors" "fmt" "regexp" "strconv" "sync" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" sInvoice "github.com/dwarvesf/fortress-api/pkg/store/invoice" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" ) type UpdateStatusInput struct { InvoiceID string `json:"invoiceID"` Status model.InvoiceStatus `json:"status"` SendThankYouEmail bool `json:"sendThankYouEmail"` } func (c *controller) UpdateStatus(in UpdateStatusInput) (*model.Invoice, error) { l := c.logger.Fields(logger.Fields{ "controller": "invoice", "method": "UpdateStatus", "req": in, }) // check invoice existence invoice, err := c.store.Invoice.One(c.repo.DB(), &sInvoice.Query{ID: in.InvoiceID}) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(ErrInvoiceNotFound, "invoice not found") return nil, ErrInvoiceNotFound } l.Error(err, "failed to get invoice") return nil, err } if invoice.Status == in.Status { l.Error(ErrInvoiceStatusAlready, "invoice status already") return nil, ErrInvoiceStatusAlready } switch in.Status { case model.InvoiceStatusError: _, err = c.MarkInvoiceAsError(invoice) case model.InvoiceStatusPaid: _, err = c.MarkInvoiceAsPaid(invoice, in.SendThankYouEmail) default: _, err = c.store.Invoice.UpdateSelectedFieldsByID(c.repo.DB(), invoice.ID.String(), *invoice, "status") } if err != nil { l.Error(err, "failed to update invoice") return nil, err } return invoice, nil } func (c *controller) MarkInvoiceAsError(invoice *model.Invoice) (*model.Invoice, error) { l := c.logger.Fields(logger.Fields{ "controller": "invoice", "method": "MarkInvoiceAsError", "req": invoice, }) tx, done := c.repo.NewTransaction() invoice.Status = model.InvoiceStatusError iv, err := c.store.Invoice.UpdateSelectedFieldsByID(tx.DB(), invoice.ID.String(), *invoice, "status") if err != nil { l.Errorf(err, "failed to update invoice status to error") return nil, done(err) } err = c.store.InvoiceNumberCaching.UnCountErrorInvoice(tx.DB(), *invoice.InvoicedAt) if err != nil { l.Errorf(err, "failed to un-count error invoice") return nil, done(err) } if err := c.markInvoiceTodoAsError(invoice); err != nil { return nil, done(err) } if err := c.service.GoogleDrive.MoveInvoicePDF(invoice, "Sent", "Error"); err != nil { l.Errorf(err, "failed to upload invoice pdf to google drive") return nil, done(err) } return iv, done(nil) } func (c *controller) markInvoiceTodoAsError(invoice *model.Invoice) error { if invoice.Project == nil { return fmt.Errorf(`missing project info`) } bucketID, todoID, err := c.getInvoiceTodo(invoice) if err != nil { return err } c.worker.Enqueue(bcModel.BasecampCommentMsg, c.service.Basecamp.BuildCommentMessage(bucketID, todoID, "Invoice has been mark as error", "failed")) return c.service.Basecamp.Recording.Archive(bucketID, todoID) } type processPaidInvoiceRequest struct { Invoice *model.Invoice InvoiceTodoID int InvoiceBucketID int SentThankYouMail bool } func (c *controller) MarkInvoiceAsPaid(invoice *model.Invoice, sendThankYouEmail bool) (*model.Invoice, error) { l := c.logger.Fields(logger.Fields{ "controller": "invoice", "method": "MarkInvoiceAsPaid", "req": invoice, }) if invoice.Status != model.InvoiceStatusSent && invoice.Status != model.InvoiceStatusOverdue { err := fmt.Errorf(`unable to update invoice status, invoice have status %v`, invoice.Status) l.Errorf(err, "failed to update invoice", "invoiceID", invoice.ID.String()) return nil, err } invoice.Status = model.InvoiceStatusPaid bucketID, todoID, err := c.getInvoiceTodo(invoice) if err != nil { l.Errorf(err, "failed to get invoice todo", "invoiceID", invoice.ID.String()) return nil, err } err = c.service.Basecamp.Todo.Complete(bucketID, todoID) if err != nil { l.Errorf(err, "failed to complete invoice todo", "invoiceID", invoice.ID.String()) } c.processPaidInvoice(l, &processPaidInvoiceRequest{ Invoice: invoice, InvoiceTodoID: todoID, InvoiceBucketID: bucketID, SentThankYouMail: sendThankYouEmail, }) return invoice, nil } func (c *controller) MarkInvoiceAsPaidByBasecampWebhookMessage(invoice *model.Invoice, msg *model.BasecampWebhookMessage) (*model.Invoice, error) { l := c.logger.Fields(logger.Fields{ "controller": "invoice", "method": "MarkInvoiceAsPaidByBasecampWebhookMessage", "req": invoice, }) invoice.Status = model.InvoiceStatusPaid c.processPaidInvoice(l, &processPaidInvoiceRequest{ Invoice: invoice, InvoiceTodoID: msg.Recording.ID, InvoiceBucketID: msg.Recording.Bucket.ID, SentThankYouMail: true, }) return invoice, nil } func (c *controller) processPaidInvoice(l logger.Logger, req *processPaidInvoiceRequest) { wg := &sync.WaitGroup{} wg.Add(3) go func() { _ = c.processPaidInvoiceData(l, wg, req) }() go c.sendThankYouEmail(l, wg, req) go c.movePaidInvoiceGDrive(l, wg, req) wg.Wait() } func (c *controller) processPaidInvoiceData(l logger.Logger, wg *sync.WaitGroup, req *processPaidInvoiceRequest) error { // Start Transaction tx, done := c.repo.NewTransaction() msg := consts.CommentUpdateInvoiceFailed msgType := bcModel.CommentMsgTypeFailed defer func() { wg.Done() c.worker.Enqueue(bcModel.BasecampCommentMsg, c.service.Basecamp.BuildCommentMessage(req.InvoiceBucketID, req.InvoiceTodoID, msg, msgType)) }() now := time.Now() req.Invoice.PaidAt = &now _, err := c.store.Invoice.UpdateSelectedFieldsByID(tx.DB(), req.Invoice.ID.String(), *req.Invoice, "status", "paid_at") if err != nil { l.Errorf(err, "failed to update invoice status to paid", "invoice", req.Invoice) return done(err) } _, err = c.storeCommission(tx.DB(), l, req.Invoice) if err != nil { l.Errorf(err, "failed to store invoice commission", "invoice", req.Invoice) return done(err) } m := model.AccountingMetadata{ Source: "invoice", ID: req.Invoice.ID.String(), } bonusBytes, err := json.Marshal(&m) if err != nil { l.Errorf(err, "failed to process invoice accounting metadata", "invoiceNumber", req.Invoice.Number) return done(err) } projectOrg := "" if req.Invoice.Project.Organization != nil { projectOrg = req.Invoice.Project.Organization.Name } currencyName := "VND" currencyID := model.UUID{} if req.Invoice.Project.BankAccount.Currency != nil { currencyName = req.Invoice.Project.BankAccount.Currency.Name currencyID = req.Invoice.Project.BankAccount.Currency.ID } accountingTxn := &model.AccountingTransaction{ Name: req.Invoice.Number, Amount: req.Invoice.Total, Date: &now, ConversionAmount: model.VietnamDong(req.Invoice.ConversionAmount), Organization: projectOrg, Category: model.AccountingIn, Type: model.AccountingIncome, Currency: currencyName, CurrencyID: &currencyID, ConversionRate: req.Invoice.ConversionRate, Metadata: bonusBytes, } err = c.store.Accounting.CreateTransaction(tx.DB(), accountingTxn) if err != nil { l.Errorf(err, "failed to create accounting transaction", "Accounting Transaction", accountingTxn) return done(err) } msg = consts.CommentUpdateInvoiceSuccessfully msgType = bcModel.CommentMsgTypeCompleted return done(nil) } func (c *controller) sendThankYouEmail(l logger.Logger, wg *sync.WaitGroup, req *processPaidInvoiceRequest) { msg := c.service.Basecamp.BuildCommentMessage(req.InvoiceBucketID, req.InvoiceTodoID, consts.CommentThankYouEmailSent, bcModel.CommentMsgTypeCompleted) defer func() { c.worker.Enqueue(bcModel.BasecampCommentMsg, msg) wg.Done() }() err := c.service.GoogleMail.SendInvoiceThankYouMail(req.Invoice) if err != nil { l.Errorf(err, "failed to send invoice thank you mail", "invoice", req.Invoice) msg = c.service.Basecamp.BuildCommentMessage(req.InvoiceBucketID, req.InvoiceTodoID, consts.CommentThankYouEmailFailed, bcModel.CommentMsgTypeFailed) return } } func (c *controller) getInvoiceTodo(iv *model.Invoice) (bucketID, todoID int, err error) { if iv.Project == nil { return 0, 0, fmt.Errorf(`missing project info`) } accountingID := consts.AccountingID accountingTodoID := consts.AccountingTodoID if c.config.Env != "prod" { accountingID = consts.PlaygroundID accountingTodoID = consts.PlaygroundTodoID } re := regexp.MustCompile(`Accounting \| ([A-Za-z]+) ([0-9]{4})`) todoLists, err := c.service.Basecamp.Todo.GetLists(accountingID, accountingTodoID) if err != nil { return 0, 0, err } var todoList *bcModel.TodoList var latestListDate time.Time for i := range todoLists { info := re.FindStringSubmatch(todoLists[i].Title) if len(info) == 3 { month, err := timeutil.GetMonthFromString(info[1]) if err != nil { continue } year, _ := strconv.Atoi(info[2]) listDate := time.Date(year, time.Month(month), 1, 0, 0, 0, 0, time.UTC) if listDate.After(latestListDate) { todoList = &todoLists[i] latestListDate = listDate } } } if todoList == nil { month := iv.Month + 1 if month > 12 { month = 1 } todoList, err = c.service.Basecamp.Todo.CreateList( accountingID, accountingTodoID, bcModel.TodoList{Name: fmt.Sprintf( `Accounting | %v %v`, time.Month(month).String(), iv.Year)}, ) if err != nil { return 0, 0, err } } todoGroup, err := c.service.Basecamp.Todo.FirstOrCreateGroup( accountingID, todoList.ID, `In`) if err != nil { return 0, 0, err } todo, err := c.service.Basecamp.Todo.FirstOrCreateInvoiceTodo( accountingID, todoGroup.ID, iv) if err != nil { return 0, 0, err } return accountingID, todo.ID, nil }
```

# pkg/controller/memologs/new.go

```go
package memologs import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type controller struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } type IController interface { Sync() ([]model.MemoLog, error) Sweep() error ListOpenPullRequest() (map[string][]model.MemoPullRequest, error) }
```

# pkg/controller/memologs/pr.go

```go
package memologs import ( "context" "fmt" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) var ( repoMemos = []string{"brainery", "playground", "playbook"} dwarvesFoundationOrg = "dwarvesf" ) func (c controller) ListOpenPullRequest() (map[string][]model.MemoPullRequest, error) { l := c.logger.Fields(logger.Fields{ "controller": "memologs", "method": "ListOpenPullRequest", }) memoPrs := make(map[string][]model.MemoPullRequest, len(repoMemos)) // Get discord accounts discordAccounts, err := c.store.DiscordAccount.All(c.repo.DB()) if err != nil { l.Error(err, "failed to get discord accounts") return nil, fmt.Errorf("failed to get discord accounts: %w", err) } mapGithubWithDiscord := make(map[string]string, len(discordAccounts)) for _, dc := range discordAccounts { if dc != nil && dc.GithubUsername != "" { mapGithubWithDiscord[dc.GithubUsername] = dc.DiscordID } } for _, repo := range repoMemos { memoRepoName := fmt.Sprintf("%s/%s", dwarvesFoundationOrg, repo) prs, err := c.service.Github.FetchOpenPullRequest(context.Background(), repo) if err != nil { l.Errorf(err, "failed to fetch open pull requests for %s", repo) return memoPrs, err } memoPullRequest := make([]model.MemoPullRequest, 0, len(prs)) for _, pr := range prs { user := pr.GetUser() githubUserName := "" if user != nil { githubUserName = user.GetLogin() } discordID := mapGithubWithDiscord[githubUserName] prMap := model.MemoPullRequest{ Number: pr.GetNumber(), Title: pr.GetTitle(), Url: pr.GetHTMLURL(), DiscordId: discordID, GithubUserName: githubUserName, Timestamp: pr.GetCreatedAt().Time, } memoPullRequest = append(memoPullRequest, prMap) } memoPrs[memoRepoName] = memoPullRequest } return memoPrs, nil }
```

# pkg/controller/memologs/sweep.go

```go
package memologs import ( "encoding/xml" "net/http" "strings" "github.com/dwarvesf/fortress-api/pkg/model" ) func (c *controller) Sweep() error { // List memo logs without authors memoLogs, err := c.store.MemoLog.ListNonAuthor(c.repo.DB()) if err != nil { return err } // Fetch memo data from the RSS feed resp, err := http.Get(dfMemoRssURL) if err != nil { return err } defer resp.Body.Close() var feed struct { Items []struct { Link string `xml:"link"` Author string `xml:"author"` } `xml:"channel>item"` } if err := xml.NewDecoder(resp.Body).Decode(&feed); err != nil { return err } memoData := make(map[string][]string) for _, item := range feed.Items { authors := strings.Split(item.Author, ",") for i := 0; i < len(authors); i++ { authors[i] = strings.TrimSpace(authors[i]) if authors[i] == "" { authors = append(authors[:i], authors[i+1:]...) i-- } } if len(authors) == 0 { continue } memoData[item.Link] = authors } // Process each memo log for _, memoLog := range memoLogs { usernames := memoData[memoLog.URL] if len(usernames) == 0 { continue } // Fetch Discord accounts for the usernames discordAccounts, err := c.store.DiscordAccount.ListByMemoUsername(c.repo.DB(), usernames) if err != nil { return err } // Create memo authors for _, discordAccount := range discordAccounts { memoAuthor := &model.MemoAuthor{ MemoLogID: memoLog.ID, DiscordAccountID: discordAccount.ID, } if err := c.store.MemoLog.CreateMemoAuthor(c.repo.DB(), memoAuthor); err != nil { return err } } } return nil }
```

# pkg/controller/memologs/sync.go

```go
package memologs import ( "encoding/xml" "errors" "net/http" "strings" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/store/memolog" ) const ( dfMemoRssURL = "https://memo.d.foundation/index.xml" ) func (c *controller) Sync() ([]model.MemoLog, error) { l := c.logger.Fields(logger.Fields{ "controller": "memologs", "method": "Sync", }) last7days := time.Now().AddDate(0, 0, -7) latestMemos, err := c.store.MemoLog.List(c.repo.DB(), memolog.ListFilter{ From: &last7days, }) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { l.Errorf(err, "failed to get latest memo") return nil, err } latestMemosMap := make(map[string]model.MemoLog) for _, memo := range latestMemos { latestMemosMap[memo.URL] = memo } resp, err := http.Get(dfMemoRssURL) if err != nil { l.Errorf(err, "failed to get rss feed from %s, status code: %d", dfMemoRssURL, resp.StatusCode) return nil, err } defer resp.Body.Close() decoder := xml.NewDecoder(resp.Body) inItem := false currentElem := "" item := Item{} newMemos := make([]model.MemoLog, 0) stop := false for !stop { token, err := decoder.Token() if err != nil { break } switch se := token.(type) { case xml.StartElement: currentElem = se.Name.Local if se.Name.Local == "item" { inItem = true item = Item{} } case xml.EndElement: if se.Name.Local == "item" { inItem = false if _, ok := latestMemosMap[item.Link]; ok { continue } // Ignore folder is built as an item if item.Description == "" && item.Author == "" { continue } pubDate, _ := time.Parse(time.RFC1123Z, item.PubDate) if pubDate.Before(last7days) { stop = true break } authorUsernames := make([]string, 0) for _, s := range strings.Split(strings.TrimSpace(item.Author), ",") { if s != "" { authorUsernames = append(authorUsernames, strings.TrimSpace(s)) } } authors, err := c.store.DiscordAccount.ListByMemoUsername(c.repo.DB(), authorUsernames) if err != nil { l.Errorf(err, "failed to get authors by discord usernames: %v", authorUsernames) continue } newMemos = append(newMemos, model.MemoLog{ Title: item.Title, URL: item.Link, Description: item.Description, PublishedAt: &pubDate, Authors: authors, AuthorMemoUsernames: authorUsernames, Category: extractMemoCategory(item.Link), }) } case xml.CharData: if inItem { data := string(se) switch currentElem { case "title": item.Title = data case "link": item.Link = data case "pubDate": item.PubDate = data case "author": item.Author = data case "guid": item.Guid = data case "description": item.Description = data case "draft": item.Draft = data } } } } if len(newMemos) == 0 { return nil, nil } // Create new memos results, err := c.store.MemoLog.Create(c.repo.DB(), newMemos) if err != nil { l.Errorf(err, "failed to create new memos") return nil, err } return results, nil } type Item struct { Title string `xml:"title"` Link string `xml:"link"` PubDate string `xml:"pubDate"` Author string `xml:"author"` Guid string `xml:"guid"` Description string `xml:"description"` Draft string `xml:"draft"` } // extractMemoCategory extracts memo category from link func extractMemoCategory(url string) []string { routes := strings.Split(url, "memo.d.foundation") if len(routes) < 2 { return nil } splitPath := strings.Split(strings.TrimSpace(routes[1]), "/") // Filter out empty string category := make([]string, 0) for _, s := range splitPath { if s != "" { category = append(category, s) } } // final thing is the name of memo, ignore it if len(category) > 0 { category = category[:len(category)-1] } return category }
```

# pkg/controller/news/interface.go

```go
package news import ( "context" "github.com/dwarvesf/fortress-api/pkg/model" ) type IController interface { FetchLobstersNews(ctx context.Context, tag string) ([]model.News, error) FetchRedditNews(ctx context.Context, tag string) ([]model.News, error) }
```

# pkg/controller/news/lobsters.go

```go
package news import ( "context" "sort" "time" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) func (c *controller) FetchLobstersNews(ctx context.Context, tag string) ([]model.News, error) { logger := c.logger.Fields(logger.Fields{ "controller": "news", "method": "FetchLobstersNews", "tag": tag, }) news, err := c.service.Lobsters.FetchNews(tag) if err != nil { logger.Error(err, "failed to fetch news from lobsters") return nil, err } normalized := make([]model.News, 0, len(news)) for _, n := range news { url := n.URL if url == "" { url = n.ShortIDURL } if url == "" { continue } normalized = append(normalized, model.News{ Title: n.Title, URL: url, Popularity: int64(n.Score), CommentCount: int64(n.CommentCount), Description: n.Description, Tags: n.Tags, CreatedAt: n.CreatedAt, }) } // Sort by creation time (descending) and then by popularity (descending) sort.Slice(normalized, func(i, j int) bool { if normalized[i].CreatedAt.Equal(normalized[j].CreatedAt) { return normalized[i].Popularity > normalized[j].Popularity } return normalized[i].CreatedAt.After(normalized[j].CreatedAt) }) // Filter for posts within the last 24 hours emerging := make([]model.News, 0) for _, n := range normalized { if time.Since(n.CreatedAt) <= 24*time.Hour { emerging = append(emerging, n) } } // If more than 10 posts in 24 hours, truncate to 10 if len(emerging) > 10 { emerging = emerging[:10] } else if len(emerging) < 10 { // If less than 10 posts in 24 hours, add more posts without time check for _, n := range normalized { if len(emerging) == 10 { break } if time.Since(n.CreatedAt) > 24*time.Hour { emerging = append(emerging, n) } } } return emerging, nil }
```

# pkg/controller/news/new.go

```go
package news import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type controller struct { store *store.Store service *service.Service logger logger.Logger config *config.Config } func New(store *store.Store, service *service.Service, logger logger.Logger, cfg *config.Config) IController { return &controller{ store: store, service: service, logger: logger, config: cfg, } }
```

# pkg/controller/news/reddit.go

```go
package news import ( "context" "github.com/dwarvesf/fortress-api/pkg/model" ) func (c *controller) FetchRedditNews(ctx context.Context, tag string) ([]model.News, error) { // Fetch Golang news from Reddit redditPosts, err := c.service.Reddit.FetchGolangNews(ctx) if err != nil { return nil, err } // Truncate to last 10 posts if more than 10 if len(redditPosts) > 10 { redditPosts = redditPosts[len(redditPosts)-10:] } // Convert to model.News news := make([]model.News, len(redditPosts)) for i, post := range redditPosts { news[i] = model.News{ Title: post.Title, URL: post.URL, Popularity: int64(post.Score), CommentCount: int64(post.NumberOfComments), Description: post.Body, Tags: []string{tag}, // Using the input tag CreatedAt: post.Created.Time, } } return news, nil }
```

# pkg/handler/accounting/accounting.go

```go
package accounting import ( "fmt" "net/http" "strings" "time" "github.com/gin-gonic/gin" "github.com/jackc/numfmt" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/store/project" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } func (h handler) CreateAccountingTodo(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "Accounting", "method": "CreateAccountingTodo", }) month, year := timeutil.GetMonthAndYearOfNextMonth() l.Info(fmt.Sprintf("Creating accounting todo for %s-%v", time.Month(month), year)) accountingTodo := consts.PlaygroundID todoSetID := consts.PlaygroundTodoID if h.config.Env == "prod" { accountingTodo = consts.AccountingID todoSetID = consts.AccountingTodoID } todoList := bcModel.TodoList{Name: fmt.Sprintf("Accounting | %s %v", time.Month(month).String(), year)} todoGroupInFoundation := bcModel.TodoGroup{Name: "In"} todoGroupOut := bcModel.TodoGroup{Name: "Out"} // Get list accounting(Service table in db) template outTodoTemplates, err := h.store.OperationalService.FindOperationByMonth(h.repo.DB(), time.Month(month)) if err != nil { l.Errorf(err, "failed to find operation by month", "month", time.Month(month)) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, time.Month(month), "")) return } createTodo, err := h.service.Basecamp.Todo.CreateList(accountingTodo, todoSetID, todoList) if err != nil { l.Errorf(err, "failed to create todo list", "accountingTodo", accountingTodo, "todoSetID", todoSetID, "todoList", todoList) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, "")) return } //Create In group inGroup, err := h.service.Basecamp.Todo.CreateGroup(accountingTodo, createTodo.ID, todoGroupInFoundation) if err != nil { l.Errorf(err, "failed to create todo list", "accountingTodo", accountingTodo, "createTodo.ID", createTodo.ID, "todoGroupInFoundation", todoGroupInFoundation) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, "")) return } // Create Out group outGroup, err := h.service.Basecamp.Todo.CreateGroup(accountingTodo, createTodo.ID, todoGroupOut) if err != nil { l.Errorf(err, "failed to create group", "accountingTodo", accountingTodo, "createTodo.ID", createTodo.ID, "todoGroupOut", todoGroupOut) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, "")) return } // Create todoList for each accounting template into out Group err = h.createTodoInOutGroup(outGroup.ID, accountingTodo, outTodoTemplates, month, year) if err != nil { l.Errorf(err, "failed to create In Out todo group", "accountingTodo", accountingTodo, "outTodoTemplates", outTodoTemplates, "month", month, "year", year) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, "")) return } // Create Salary to do and add into out group err = h.createSalaryTodo(outGroup.ID, accountingTodo, month, year) if err != nil { l.Errorf(err, "failed to create salary todo", "accountingTodo", accountingTodo, "month", month, "year", year) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, "")) return } // create to do IN group err = h.createTodoInInGroup(inGroup.ID, accountingTodo) if err != nil { l.Errorf(err, "failed to create salary todo", "accountingTodo", accountingTodo, "inGroup.ID", inGroup.ID) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, accountingTodo, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } func (h handler) createTodoInOutGroup(outGroupID int, projectID int, outTodoTemplates []*model.OperationalService, month int, year int) error { l := h.logger.Fields(logger.Fields{ "handler": "Accounting", "method": "createTodoInOutGroup", }) for _, v := range outTodoTemplates { extraMsg := "" // Create CBRE management fee from `Office Rental` template if strings.Contains(v.Name, "Office Rental") { extraMsg = fmt.Sprintf("Hado Office Rental %v/%v", month, year) s := v.Name for _, v := range []string{"Tiá»n Ä‘iá»‡n", "CBRE"} { content := strings.Replace(s, "Office Rental", v, 1) todo := bcModel.Todo{ Content: fmt.Sprintf("%s %v/%v", content, month, year), Description: fmt.Sprintf("I3.18.08 thanh toan %s %v/%v", v, month, year), DueOn: fmt.Sprintf("%v-%v-%v", timeutil.LastDayOfMonth(month, year).Day(), month, year), AssigneeIDs: []int{consts.QuangBasecampID}, } _, err := h.service.Basecamp.Todo.Create(projectID, outGroupID, todo) if err != nil { l.Error(err, "Fail when try to create CBRE management fee") return err } } } f := &numfmt.Formatter{ NegativeTemplate: "(n)", MinDecimalPlaces: 0, } todo := bcModel.Todo{ Content: fmt.Sprintf("%s | %s | %s", v.Name, strings.Replace(f.Format(v.Amount), ",", ".", -1), v.Currency.Name), //nolint:govet DueOn: fmt.Sprintf("%v-%v-%v", timeutil.LastDayOfMonth(month, year).Day(), month, year), AssigneeIDs: []int{consts.QuangBasecampID}, Description: extraMsg, } _, err := h.service.Basecamp.Todo.Create(projectID, outGroupID, todo) if err != nil { l.Error(err, "Fail when try to create out todos") return err } } return nil } func (h handler) createSalaryTodo(outGroupID int, projectID int, month int, year int) error { //created TO DO salary 15th salary15 := bcModel.Todo{ Content: "salary 15th", DueOn: fmt.Sprintf("%v-%v-%v", 12, year, month), AssigneeIDs: []int{consts.QuangBasecampID, consts.HanBasecampID}, } _, err := h.service.Basecamp.Todo.Create(projectID, outGroupID, salary15) if err != nil { return err } // Create To do Salary 1st salary1 := bcModel.Todo{ Content: "salary 1st", DueOn: fmt.Sprintf("%v-%v-%v", 27, year, month), AssigneeIDs: []int{consts.QuangBasecampID, consts.HanBasecampID}, } _, err = h.service.Basecamp.Todo.Create(projectID, outGroupID, salary1) if err != nil { return err } return nil } func (h handler) createTodoInInGroup(inGroupID int, projectID int) error { l := h.logger.Fields(logger.Fields{ "handler": "Accounting", "method": "createSalaryTodo", }) activeProjects, _, err := h.store.Project.All(h.repo.DB(), project.GetListProjectInput{Statuses: []string{model.ProjectStatusActive.String()}}, model.Pagination{}) if err != nil { return err } now := time.Now() month := int(now.Month()) year := now.Year() for _, p := range activeProjects { // Default will assign to Giang Than assigneeIDs := []int{consts.GiangThanBasecampID} _, err := h.service.Basecamp.Todo.Create(projectID, inGroupID, buildInvoiceTodo(p.Name, month, year, assigneeIDs)) if err != nil { l.Error(err, fmt.Sprint("Failed to create invoice todo on project", p.Name)) } } return nil } func buildInvoiceTodo(name string, month, year int, assigneeIDs []int) bcModel.Todo { dueOn := getProjectInvoiceDueOn(name, month, year) content := getProjectInvoiceContent(name, month, year) return bcModel.Todo{ Content: content, AssigneeIDs: assigneeIDs, DueOn: dueOn, } } func getProjectInvoiceDueOn(name string, month, year int) string { var day int if strings.ToLower(name) == "voconic" { day = 23 } else { a := timeutil.LastDayOfMonth(month, year) day = a.Day() } return fmt.Sprintf("%v-%v-%v", day, month, year) } func getProjectInvoiceContent(name string, month, year int) string { return fmt.Sprintf("%s %v/%v", name, month, year) }
```

# pkg/handler/accounting/service.go

```go
package accounting import "github.com/gin-gonic/gin" type IHandler interface { CreateAccountingTodo(c *gin.Context) }
```

# pkg/handler/asset/asset.go

```go
package asset import ( "fmt" "net/http" "path/filepath" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/handler/asset/errs" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } // Upload godoc // @Summary Upload the content // @Description Upload the content // @id upload // @Tags Asset // @Accept json // @Produce json // @Security BearerAuth // @Param file formData file true "content upload" // @Param type formData string true "image/doc" // @Param targetType formData string true "employees/projects/change-logs/invoices" // @Param targetID formData string false "employeeID/projectID" // @Success 200 {object} ContentDataResponse // @Failure 500 {object} ErrorResponse // @Router /assets/upload [post] func (h *handler) Upload(c *gin.Context) { // 1.1 get userID userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } uuidUserID, err := model.UUIDFromString(userInfo.UserID) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 1.2 get upload file file, err := c.FormFile("file") if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, file, "")) return } fType := c.PostForm("type") tType := c.PostForm("targetType") tID := c.PostForm("targetID") l := h.logger.Fields(logger.Fields{ "handler": "asset", "method": "Upload", }) fileName := file.Filename fileExtension := model.ContentExtension(filepath.Ext(fileName)) fileType := model.ContentType(fType) targetType := model.ContentTargetType(tType) fileSize := file.Size if !fileType.Valid() { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, "")) return } if !targetType.Valid() { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, "")) return } if fileType == model.ContentTypeImage && !fileExtension.ImageValid() { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, "")) return } if (fileType == model.ContentTypeImage && fileSize > model.MaxFileSizeImage) || (fileType == model.ContentTypeDoc && fileSize > model.MaxFileSizePdf) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileSize, nil, "")) return } tx, done := h.repo.NewTransaction() if targetType == model.ContentTargetTypeEmployee { if tID == "" { tID = uuidUserID.String() } isExisted, err := h.store.Employee.IsExist(tx.DB(), tID) if err != nil { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } if !isExisted { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrEmployeeNotFound), nil, "")) return } } if targetType == model.ContentTargetTypeProject { isExisted, err := h.store.Project.IsExist(tx.DB(), tID) if err != nil { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } if !isExisted { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrProjectNotFound), nil, "")) return } } gcsPath := "" if targetType == model.ContentTargetTypeEmployee || targetType == model.ContentTargetTypeProject { gcsPath = fmt.Sprintf("%s/%s/%s/%s", targetType, tID, fileType, fileName) } else { gcsPath = fmt.Sprintf("%s/%s", targetType, fileName) } filePath := fmt.Sprintf("https://storage.googleapis.com/%s/%s", h.config.Google.GCSBucketName, gcsPath) var targetID model.UUID if targetType == model.ContentTargetTypeEmployee || targetType == model.ContentTargetTypeProject { targetID, err = model.UUIDFromString(tID) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } } authType := "Authorization" if authutils.IsAPIKey(c) { authType = "ApiKey" } content, err := h.store.Content.Create(tx.DB(), model.Content{ Type: fileType.String(), Extension: fileExtension.String(), Path: filePath, TargetID: targetID, UploadBy: uuidUserID, TargetType: targetType.String(), AuthType: authType, }) if err != nil { l.Error(err, "error create content") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } multipart, err := file.Open() if err != nil { l.Error(err, "error in open file") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } // 3. Upload to GCS err = h.service.GoogleStorage.UploadContentGCS(multipart, gcsPath) if err != nil { l.Error(err, "error in upload file") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToContentData(content.Path), nil, done(nil), nil, "")) }
```

# pkg/handler/asset/errs/errors.go

```go
package errs import "errors" var ( ErrEmployeeNotFound = errors.New("employee not found") ErrProjectNotFound = errors.New("project not found") ErrInvalidFileExtension = errors.New("invalid file extension") ErrInvalidFileType = errors.New("invalid file type") ErrInvalidFileSize = errors.New("invalid file size") ErrFileAlreadyExisted = errors.New("file already existed") )
```

# pkg/handler/asset/interface.go

```go
package asset import "github.com/gin-gonic/gin" type IHandler interface { Upload(c *gin.Context) }
```

# pkg/handler/audit/audit.go

```go
package audit import ( "errors" "net/http" "reflect" "time" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/handler/audit/errs" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/view" ) const ( VoconicAudit1 = "0fde875d-67b1-4c23-b524-4b541b301c62" NghenhanAudit1 = "23d6b63b-3a2b-49fc-8af7-5ffca1379a29" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } // Sync godoc // @Summary Sync audit info from Notion to database // @Description Sync audit info from Notion to database // @id syncAudit // @Tags Audit // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} MessageResponse // @Router /cronjobs/audits [post] func (h *handler) Sync(c *gin.Context) { h.SyncAuditCycle() c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "sync audit from notion successfully")) } // SyncAuditCycle sync audit cycle from notion to database func (h *handler) SyncAuditCycle() { l := h.logger.Fields(logger.Fields{ "method": "SyncAuditCycle", }) l.Infof("Sync audit cycle started") // Start Transaction tx, done := h.repo.NewTransaction() // Get all audit cycle from notion database, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.AuditCycle, nil, nil, 0) if err != nil { l.Error(done(err), "failed to get database from notion") return } // Map notion page mapPage := NotionDatabaseToMap(tx.DB(), database) // Get all audit cycle from database auditCycles, err := h.store.AuditCycle.All(tx.DB()) if err != nil { l.Error(done(err), "failed to get audit cycle from database") return } auditCycleMap := model.AuditCycleToMap(auditCycles) // Compare and update // Create audit cycle if not exist in auditCycleMap for _, page := range mapPage { // If auditCycle not exist in mapPage if ac, ok := auditCycleMap[model.MustGetUUIDFromString(page.ID)]; !ok { l.Infof("Create audit cycle ID: %s", page.ID) auditCycle := model.NewAuditCycleFromNotionPage(&page, h.config.Notion.Databases.AuditCycle) // Check project_is map with audit_notion_id in db or not exists, err := h.store.ProjectNotion.IsExistByAuditNotionID(tx.DB(), auditCycle.ProjectID.String()) if err != nil { l.Error(done(err), "failed to check project_notion") return } if !exists { l.Infof("Project %s not exist in project_notion", auditCycle.ProjectID.String()) continue } // Create audits if err := h.createAudits(tx.DB(), &page, auditCycle); err != nil { l.Error(done(err), "failed to create audit") return } // Create audit cycle _, err = h.store.AuditCycle.Create(tx.DB(), auditCycle) if err != nil { l.Error(done(err), "failed to create audit cycle") return } } else { l.Infof("Sync audit cycle ID: %s", page.ID) delete(auditCycleMap, model.MustGetUUIDFromString(page.ID)) if err := h.syncAuditCycle(tx.DB(), &page, ac); err != nil { l.Error(done(err), "failed to sync audit cycle") return } } } // Delete audit cycle if not exist in mapPage for _, auditCycle := range auditCycleMap { l.Infof("Delete audit cycle ID: %s", auditCycle.ID.String()) if err := h.deleteAuditCycle(tx.DB(), auditCycle); err != nil { l.Error(done(err), "failed to delete audit cycle") return } } // Set value action item high, action item to 0 if err := h.store.AuditCycle.ResetActionItem(tx.DB()); err != nil { l.Error(done(err), "failed to reset action item") return } if err := h.store.Audit.ResetActionItem(tx.DB()); err != nil { l.Error(done(err), "failed to reset action item") return } // Sync Action Item if err := h.SyncActionItem(tx.DB()); err != nil { l.Error(done(err), "failed to sync action item") return } if err := done(nil); err != nil { l.Error(err, "failed to commit txn") } l.Infof("Sync audit cycle finished") } // SyncActionItem sync action item from notion to database func (h *handler) SyncActionItem(db *gorm.DB) error { l := h.logger.Fields(logger.Fields{ "method": "SyncActionItem", }) l.Infof("Syncing action item started") // Get all audit cycle from database actionItems, err := h.store.ActionItem.All(db) if err != nil { l.Error(err, "failed to get audit cycle from database") return err } actionItemMap := model.ActionItemToMap(actionItems) // Sync action item if err := h.syncActionItemPage(db, h.config.Notion.Databases.AuditActionItem, false, actionItemMap); err != nil { l.Error(err, "failed to run function syncActionItemPage") return err } // Delete non-exist action item for _, actionItem := range actionItemMap { if err := h.store.ActionItem.Delete(db, actionItem.ID.String()); err != nil { l.Error(err, "failed to delete action item") return err } } // Sync audit action item if err := h.syncAuditActionItem(db); err != nil { l.Error(err, "failed to run function syncAuditActionItem") return err } if err := h.snapShot(db); err != nil { l.Error(err, "failed to run function snapShot") return err } l.Infof("Syncing action item finished") return nil } // createAudits create audit record for each audit cycle func (h *handler) createAudits(db *gorm.DB, page *notion.Page, auditCycle *model.AuditCycle) error { l := h.logger.Fields(logger.Fields{ "method": "createAudits", "pageID": page.ID, "auditCycleID": auditCycle.ID.String(), }) audit, err := h.service.Notion.GetBlockChildren(page.ID) if err != nil { l.Error(err, "failed to get audit from notion") return err } // Find the audit checklist block index auditChecklistIndex := -1 for index, block := range audit.Results { if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) { auditChecklistIndex = index } } if page.ID == NghenhanAudit1 || page.ID == VoconicAudit1 || auditChecklistIndex == -1 { return nil } properties := page.Properties.(notion.DatabasePageProperties) auditChecklist, err := h.service.Notion.GetDatabase(audit.Results[auditChecklistIndex].ID(), nil, nil, 0) if err != nil { l.Error(err, "failed to get database from notion") return err } // Create audit record for each row for _, row := range auditChecklist.Results { if err := h.createAudit(db, page, row, properties, auditChecklistIndex, audit, auditCycle); err != nil { l.Error(err, "failed to create audit") return err } } return nil } // syncActionItemPage sync a action item include create action item if not exist, dekete, udpate exist item and update action item high in audit cycle func (h *handler) syncActionItemPage(db *gorm.DB, databaseID string, withStartCursor bool, actionItemMap map[model.UUID]*model.ActionItem) error { l := h.logger.Fields(logger.Fields{ "method": "syncActionItemPage", "databaseID": databaseID, "withStartCursor": withStartCursor, }) // Get audit action database var database *notion.DatabaseQueryResponse var err error if withStartCursor { database, err = h.service.Notion.GetDatabaseWithStartCursor(h.config.Notion.Databases.AuditActionItem, databaseID) if err != nil { l.Error(err, "failed to get database from notion") return err } } else { database, err = h.service.Notion.GetDatabase(databaseID, nil, nil, 0) if err != nil { l.Error(err, "failed to get database from notion") return err } } if database.HasMore { err = h.syncActionItemPage(db, *database.NextCursor, true, actionItemMap) if err != nil { l.Error(err, "failed to run function syncActionItemPage") return err } } // Map notion page mapPage := NotionDatabaseToMap(db, database) // Compare and update // Create action item if not exist in actionItemMap for _, page := range mapPage { l.Infof("Create action item ID: %s", page.ID) // If actionItem not exist in mapPage actionItempProperties := page.Properties.(notion.DatabasePageProperties) pic := &model.Employee{} picID := model.UUID{} if actionItempProperties["PIC"].People != nil && len(actionItempProperties["PIC"].People) > 0 { pic, err = h.store.Employee.OneByNotionID(db, actionItempProperties["PIC"].People[0].ID) if err != nil { l.Error(err, "failed to get pic from notion id") } } if pic != nil { picID = pic.ID } newActionItem := model.NewActionItemFromNotionPage(page, picID, h.config.Notion.Databases.AuditActionItem) // Check whether project_id map with audit_notion_id in db or not if !newActionItem.ProjectID.IsZero() { exits, err := h.store.ProjectNotion.IsExistByAuditNotionID(db, newActionItem.ProjectID.String()) if err != nil { l.Error(err, "failed to check project_notion_id exits in db") return err } if !exits { l.Infof("Project ID: %s not exits in project_notion_id table", newActionItem.ProjectID.String()) continue } } if !newActionItem.AuditCycleID.IsZero() { auditCycle, err := h.store.AuditCycle.One(db, newActionItem.AuditCycleID.String()) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Infof("Audit cycle ID: %s not exits in db", newActionItem.AuditCycleID.String()) continue } l.Error(err, "failed to get audit cycle from database") return err } newActionItem.ProjectID = auditCycle.ProjectID } if ai, ok := actionItemMap[model.MustGetUUIDFromString(page.ID)]; !ok { // Create action item newActionItem, err = h.store.ActionItem.Create(db, newActionItem) if err != nil { l.Error(err, "failed to create action item") return err } } else { // Update action item if !model.CompareActionItem(ai, newActionItem) { // Update action item newActionItem.ID = ai.ID newActionItem, err = h.store.ActionItem.UpdateSelectedFieldsByID(db, newActionItem.ID.String(), *newActionItem, "project_id", "notion_db_id", "pic_id", "audit_cycle_id", "name", "description", "need_help", "priority", "status") if err != nil { l.Error(err, "failed to update action item") return err } } delete(actionItemMap, model.MustGetUUIDFromString(page.ID)) } // Update audit cycle if !newActionItem.AuditCycleID.IsZero() { auditCycle, err := h.store.AuditCycle.One(db, newActionItem.AuditCycleID.String()) if err != nil { l.Error(err, "failed to get audit cycle from database") return err } if newActionItem.Priority != nil && newActionItem.Status != model.ActionItemStatusDone { // Update audit cycle switch *newActionItem.Priority { case model.ActionItemPriorityLow: auditCycle.ActionItemLow++ case model.ActionItemPriorityMedium: auditCycle.ActionItemMedium++ case model.ActionItemPriorityHigh: auditCycle.ActionItemHigh++ } if _, err = h.store.AuditCycle.Update(db, auditCycle); err != nil { l.Error(err, "failed to update audit cycle") return err } } } } return nil } // syncAuditCycle sync audit cycle if it already exists func (h *handler) syncAuditCycle(db *gorm.DB, page *notion.Page, auditCycle *model.AuditCycle) error { l := h.logger.Fields(logger.Fields{ "method": "syncAuditCycle", "pageID": page.ID, }) newAuditCycle := model.NewAuditCycleFromNotionPage(page, h.config.Notion.Databases.AuditCycle) cloneAuditCycle, err := h.store.AuditCycle.One(db, newAuditCycle.ID.String()) if err != nil { l.Error(err, "failed to get audit cycle from database") return err } if err := h.syncAudit(db, page, cloneAuditCycle); err != nil { l.Error(err, "failed to sync audit") return err } if !model.CompareAuditCycle(auditCycle, newAuditCycle) || !compareAuditID(auditCycle.HealthAuditID, cloneAuditCycle.HealthAuditID) || !compareAuditID(auditCycle.ProcessAuditID, cloneAuditCycle.ProcessAuditID) || !compareAuditID(auditCycle.BackendAuditID, cloneAuditCycle.BackendAuditID) || !compareAuditID(auditCycle.FrontendAuditID, cloneAuditCycle.FrontendAuditID) || !compareAuditID(auditCycle.BlockchainAuditID, cloneAuditCycle.BlockchainAuditID) || !compareAuditID(auditCycle.SystemAuditID, cloneAuditCycle.SystemAuditID) || !compareAuditID(auditCycle.MobileAuditID, cloneAuditCycle.MobileAuditID) { // Update audit cycle newAuditCycle.HealthAuditID = cloneAuditCycle.HealthAuditID newAuditCycle.ProcessAuditID = cloneAuditCycle.ProcessAuditID newAuditCycle.BackendAuditID = cloneAuditCycle.BackendAuditID newAuditCycle.FrontendAuditID = cloneAuditCycle.FrontendAuditID newAuditCycle.BlockchainAuditID = cloneAuditCycle.BlockchainAuditID newAuditCycle.SystemAuditID = cloneAuditCycle.SystemAuditID newAuditCycle.MobileAuditID = cloneAuditCycle.MobileAuditID _, err := h.store.AuditCycle.UpdateSelectedFieldsByID(db, newAuditCycle.ID.String(), *newAuditCycle, "project_id", "notion_db_id", "health_audit_id", "process_audit_id", "backend_audit_id", "frontend_audit_id", "blockchain_audit_id", "system_audit_id", "mobile_audit_id", "cycle", "average_score", "flag", "quarter") if err != nil { l.Error(err, "failed to update audit cycle") return err } } return nil } func compareAuditID(oldID, newID *model.UUID) bool { if oldID == nil && newID == nil { return true } if oldID == nil || newID == nil { return false } return oldID.String() == newID.String() } // deleteAuditCycle delete audit cycle if it not exists in notion func (h *handler) deleteAuditCycle(db *gorm.DB, auditCycle *model.AuditCycle) error { l := h.logger.Fields(logger.Fields{ "method": "deleteAuditCycle", "auditCycleID": auditCycle.ID.String(), }) auditMap := model.AuditMap(*auditCycle) for auditID := range auditMap { if err := h.deleteAudit(db, auditID); err != nil { l.Error(err, "failed to delete audit") return err } } if err := h.store.AuditCycle.Delete(db, auditCycle.ID.String()); err != nil { l.Error(err, "failed to delete audit cycle") return err } return nil } // syncAudit sync audit if it already exists func (h *handler) syncAudit(db *gorm.DB, page *notion.Page, auditCycle *model.AuditCycle) error { l := h.logger.Fields(logger.Fields{ "method": "syncAudit", "pageID": page.ID, "auditCycleID": auditCycle.ID.String(), }) audit, err := h.service.Notion.GetBlockChildren(page.ID) if err != nil { l.Error(err, "failed to get audit from notion") return err } // Find the audit checklist block index auditChecklistIndex := -1 for index, block := range audit.Results { if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) { auditChecklistIndex = index } } if page.ID == NghenhanAudit1 || page.ID == VoconicAudit1 || auditChecklistIndex == -1 { return nil } properties := page.Properties.(notion.DatabasePageProperties) auditChecklist, err := h.service.Notion.GetDatabase(audit.Results[auditChecklistIndex].ID(), nil, nil, 0) if err != nil { l.Error(err, "failed to get database from notion") return err } auditMap := model.AuditMap(*auditCycle) // Sync audit record for each row for _, row := range auditChecklist.Results { // Check audit existence in database if _, ok := auditMap[model.MustGetUUIDFromString(row.ID)]; !ok { // if audit is not exist create audit if err := h.createAudit(db, page, row, properties, auditChecklistIndex, audit, auditCycle); err != nil { l.Error(err, "failed to create audit") return err } } else { // Delete audit from audit map delete(auditMap, model.MustGetUUIDFromString(row.ID)) // Check audit info with info in the database // Get audit in database auditDB, err := h.store.Audit.One(db, row.ID) if err != nil { l.Error(err, "failed to get audit from database") return err } // Get auditor from notion id checklistProperties := row.Properties.(notion.DatabasePageProperties) if len(checklistProperties["Auditor"].People) == 0 { l.Error(errs.ErrMissingAuditorInAudit, "missing auditor in audit") return errs.ErrMissingAuditorInAudit } auditor, err := h.store.Employee.OneByNotionID(db, checklistProperties["Auditor"].People[0].ID) if err != nil { l.Error(err, "failed to get auditor from notion id") } auditorID := model.UUID{} if auditor != nil { auditorID = auditor.ID } flag, err := h.getFlag(db, page, &row) if err != nil { l.Error(err, "failed to get flag") return errs.ErrFailedToGetFlag } if len(properties["Project"].Relation) == 0 { l.Error(errs.ErrMissingProjectInAudit, "missing project in audit") return errs.ErrMissingProjectInAudit } newAudit := model.NewAuditFromNotionPage(row, properties["Project"].Relation[0].ID, auditorID, flag, audit.Results[auditChecklistIndex].ID()) // compare new audit object if !model.CompareAudit(*auditDB, *newAudit) { // Update audit newAudit.ID = auditDB.ID if _, err := h.store.Audit.UpdateSelectedFieldsByID(db, newAudit.ID.String(), *newAudit, "project_id", "notion_db_id", "auditor_id", "name", "type", "score", "status", "flag", "action_item", "duration", "audited_at"); err != nil { l.Error(err, "failed to update audit") return err } } // Sync audit participant - DONE if err := h.syncParticipant(db, checklistProperties, newAudit.ID); err != nil { l.Error(err, "failed to sync audit participant") return err } // Sync Audit Items - DONE if err := h.syncAuditItem(db, page, &row); err != nil { l.Error(err, "failed to sync audit item") return err } } } // Delete non-existent audits for key := range auditMap { deletedAudit, err := h.store.Audit.One(db, key.String()) if err != nil { l.Error(err, "failed to get audit from database") return err } h.deleteAuditIDForAuditCycle(db, deletedAudit, auditCycle) if err := h.deleteAudit(db, key); err != nil { l.Error(err, "failed to delete audit") return err } } return nil } func (h *handler) deleteAudit(db *gorm.DB, auditID model.UUID) error { l := h.logger.Fields(logger.Fields{ "method": "deleteAudit", "auditID": auditID.String(), }) // Delete audit item if err := h.store.AuditItem.DeleteByAuditID(db, auditID.String()); err != nil { l.Error(err, "failed to delete audit item") return err } // Delete audit participant if err := h.store.AuditParticipant.DeleteByAuditID(db, auditID.String()); err != nil { l.Error(err, "failed to delete audit participant") return err } // Delete audit action item by audit id if err := h.store.AuditActionItem.DeleteByAuditID(db, auditID.String()); err != nil { l.Error(err, "failed to delete audit action item") return err } // Delete audit if err := h.store.Audit.Delete(db, auditID.String()); err != nil { l.Error(err, "failed to delete audit") return err } return nil } func (h *handler) createAudit(db *gorm.DB, page *notion.Page, row notion.Page, properties notion.DatabasePageProperties, auditChecklistIndex int, audit *notion.BlockChildrenResponse, auditCycle *model.AuditCycle) error { l := h.logger.Fields(logger.Fields{ "method": "createAudit", }) // get auditor from notion id checklistProperties := row.Properties.(notion.DatabasePageProperties) if len(checklistProperties["Auditor"].People) == 0 { l.Error(errs.ErrMissingAuditorInAudit, "auditor is missing in audit") return errs.ErrMissingAuditorInAudit } auditor, err := h.store.Employee.OneByNotionID(db, checklistProperties["Auditor"].People[0].ID) if err != nil { l.Error(err, "failed to get auditor from notion id") return err } // Create new audit object flag, err := h.getFlag(db, page, &row) if err != nil { l.Error(err, "failed to get flag") return errs.ErrFailedToGetFlag } projectID := "" if properties["Project"].Relation != nil && len(properties["Project"].Relation) > 0 { projectID = properties["Project"].Relation[0].ID } newAudit := model.NewAuditFromNotionPage(row, projectID, auditor.ID, flag, audit.Results[auditChecklistIndex].ID()) // if something wrong with the audit object, return nil if newAudit == nil { return nil } newAudit, _ = h.store.Audit.Create(db, newAudit) // Create new audit participant if len(checklistProperties["Participants"].People) > 0 { for _, p := range checklistProperties["Participants"].People { participant, err := h.store.Employee.OneByNotionID(db, p.ID) if err != nil { l.Error(err, "failed to get participant by notion id") continue } _, err = h.store.AuditParticipant.Create(db, &model.AuditParticipant{ AuditID: newAudit.ID, EmployeeID: participant.ID, }) if err != nil { l.Error(err, "failed to create audit participant") return err } } } // Update audit cycle h.updateAuditIDForAuditCycle(db, newAudit, auditCycle) // Create Audit Items if err := h.createAuditItem(db, page, &row); err != nil { l.Error(err, "failed to create audit item") return err } return nil } func (h *handler) syncParticipant(db *gorm.DB, checklistProperties notion.DatabasePageProperties, auditID model.UUID) error { l := h.logger.Fields(logger.Fields{ "method": "syncParticipant", "auditID": auditID.String(), }) // Get all audit participant auditParticipants, err := h.store.AuditParticipant.AllByAuditID(db, auditID.String()) if err != nil { l.Error(err, "failed to get all audit participant") return err } apMap := model.AuditParticipantToMap(auditParticipants) if len(checklistProperties["Participants"].People) > 0 { for _, p := range checklistProperties["Participants"].People { participant, err := h.store.Employee.OneByNotionID(db, p.ID) if err != nil { l.Error(err, "failed to get participant by notion id") continue } if _, ok := apMap[participant.ID]; !ok { _, err = h.store.AuditParticipant.Create(db, &model.AuditParticipant{ AuditID: auditID, EmployeeID: participant.ID, }) if err != nil { l.Error(err, "failed to create audit participant") return err } } else { delete(apMap, participant.ID) } } for _, p := range apMap { if err := h.store.AuditParticipant.Delete(db, p.ID.String()); err != nil { l.Error(err, "failed to delete audit participant") return err } } } return nil } func (h *handler) deleteAuditIDForAuditCycle(db *gorm.DB, audit *model.Audit, auditCycle *model.AuditCycle) { switch audit.Type { case model.AuditTypeHealth: if *auditCycle.HealthAuditID == audit.ID { auditCycle.HealthAuditID = nil } case model.AuditTypeProcess: if *auditCycle.ProcessAuditID == audit.ID { auditCycle.ProcessAuditID = nil } case model.AuditTypeBackend: if *auditCycle.BackendAuditID == audit.ID { auditCycle.BackendAuditID = nil } case model.AuditTypeFrontend: if *auditCycle.FrontendAuditID == audit.ID { auditCycle.FrontendAuditID = nil } case model.AuditTypeSystem: if *auditCycle.SystemAuditID == audit.ID { auditCycle.SystemAuditID = nil } case model.AuditTypeMobile: if *auditCycle.MobileAuditID == audit.ID { auditCycle.MobileAuditID = nil } case model.AuditTypeBlockchain: if *auditCycle.BlockchainAuditID == audit.ID { auditCycle.BlockchainAuditID = nil } } } func (h *handler) updateAuditIDForAuditCycle(db *gorm.DB, audit *model.Audit, auditCycle *model.AuditCycle) { switch audit.Type { case model.AuditTypeHealth: auditCycle.HealthAuditID = &audit.ID case model.AuditTypeProcess: auditCycle.ProcessAuditID = &audit.ID case model.AuditTypeBackend: auditCycle.BackendAuditID = &audit.ID case model.AuditTypeFrontend: auditCycle.FrontendAuditID = &audit.ID case model.AuditTypeSystem: auditCycle.SystemAuditID = &audit.ID case model.AuditTypeMobile: auditCycle.MobileAuditID = &audit.ID case model.AuditTypeBlockchain: auditCycle.BlockchainAuditID = &audit.ID } if audit.Score != 0 { auditCycle.Status = model.AuditStatusAudited } } func (h *handler) getFlag(db *gorm.DB, page *notion.Page, row *notion.Page) (model.AuditFlag, error) { l := h.logger.Fields(logger.Fields{ "method": "getFlag", "pageID": page.ID, "rowID": row.ID, }) countPoor, countAcceptable := 0, 0 checklistPage, err := h.service.Notion.GetBlockChildren(row.ID) if err != nil { l.Error(err, "failed to get audit from notion") return "", err } // Find the audit checklist block index checklistDatabaseIndex := -1 for index, block := range checklistPage.Results { if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) { checklistDatabaseIndex = index } } if checklistDatabaseIndex == -1 { return model.AuditFlagGreen, nil } checklistDatabase, err := h.service.Notion.GetDatabase(checklistPage.Results[checklistDatabaseIndex].ID(), nil, nil, 0) if err != nil { l.Error(err, "failed to get database from notion") return "", err } // Create audit item record for each row for _, checklist := range checklistDatabase.Results { // Create new audit object properties := checklist.Properties.(notion.DatabasePageProperties) if properties["Grade"].Select != nil { switch properties["Grade"].Select.Name { case "Poor": countPoor++ case "Acceptable": countAcceptable++ } } } if countPoor >= 3 { return model.AuditFlagRed, nil } else if countAcceptable >= 3 { return model.AuditFlagYellow, nil } return model.AuditFlagGreen, nil } func (h *handler) createAuditItem(db *gorm.DB, page *notion.Page, row *notion.Page) error { l := h.logger.Fields(logger.Fields{ "method": "createAuditItem", "pageID": page.ID, "rowID": row.ID, }) l.Infof("Create audit item %s", row.ID) checklistPage, err := h.service.Notion.GetBlockChildren(row.ID) if err != nil { l.Error(err, "failed to get audit from notion") return err } // Find the audit checklist block index checklistDatabaseIndex := -1 for index, block := range checklistPage.Results { if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) { checklistDatabaseIndex = index } } checklistDatabase, err := h.service.Notion.GetDatabase(checklistPage.Results[checklistDatabaseIndex].ID(), nil, nil, 0) if err != nil { l.Error(err, "failed to get database from notion") return err } // Create audit item record for each row for _, checklist := range checklistDatabase.Results { // Create new audit object newAuditItem := model.NewAuditItemFromNotionPage(checklist, row.ID, checklistPage.Results[checklistDatabaseIndex].ID()) _, err := h.store.AuditItem.Create(db, newAuditItem) if err != nil { l.Error(err, "failed to create audit item") } } return nil } func (h *handler) syncAuditItem(db *gorm.DB, page *notion.Page, row *notion.Page) error { l := h.logger.Fields(logger.Fields{ "method": "syncAuditItem", "pageID": page.ID, "rowID": row.ID, }) // Get all audit items auditItems, err := h.store.AuditItem.AllByAuditID(db, row.ID) if err != nil { l.Error(err, "failed to get audit items from database") return err } aiMap := model.AuditItemToMap(auditItems) l.Infof("Sync audit item %s", row.ID) checklistPage, err := h.service.Notion.GetBlockChildren(row.ID) if err != nil { l.Error(err, "failed to get audit from notion") return err } // Find the audit checklist block index checklistDatabaseIndex := -1 for index, block := range checklistPage.Results { if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) { checklistDatabaseIndex = index } } checklistDatabase, err := h.service.Notion.GetDatabase(checklistPage.Results[checklistDatabaseIndex].ID(), nil, nil, 0) if err != nil { l.Error(err, "failed to get database from notion") return err } // Sync audit item record for each row for _, checklist := range checklistDatabase.Results { if _, ok := aiMap[model.MustGetUUIDFromString(checklist.ID)]; !ok { // Create new audit object newAuditItem := model.NewAuditItemFromNotionPage(checklist, row.ID, checklistPage.Results[checklistDatabaseIndex].ID()) _, err = h.store.AuditItem.Create(db, newAuditItem) if err != nil { l.Error(err, "failed to create audit item") return err } } else { // Update audit object auditItem := aiMap[model.MustGetUUIDFromString(checklist.ID)] newAuditItem := model.NewAuditItemFromNotionPage(checklist, row.ID, checklistPage.Results[checklistDatabaseIndex].ID()) if !model.CompareAuditItem(&auditItem, newAuditItem) { newAuditItem.ID = auditItem.ID if _, err := h.store.AuditItem.UpdateSelectedFieldsByID(db, newAuditItem.ID.String(), *newAuditItem, "audit_id", "notion_db_id", "name", "area", "requirements", "grade", "severity", "notes", "action_item_id"); err != nil { l.Error(err, "failed to update audit item") return err } } delete(aiMap, model.MustGetUUIDFromString(checklist.ID)) } } // Delete audit items not exist for _, auditItem := range aiMap { if err := h.store.AuditItem.Delete(db, auditItem.ID.String()); err != nil { l.Error(err, "failed to delete audit item") return err } } return nil } func NotionDatabaseToMap(db *gorm.DB, database *notion.DatabaseQueryResponse) map[string]notion.Page { result := make(map[string]notion.Page) for _, r := range database.Results { result[r.ID] = r } return result } // syncAuditActionItem sync audit action item for all audit cycle, audit, audit item, audit action item func (h *handler) syncAuditActionItem(db *gorm.DB) error { l := h.logger.Fields(logger.Fields{ "method": "syncAuditActionItem", }) l.Infof("Syncing audit action item started") // Get all audit cycle from database auditCycles, err := h.store.AuditCycle.All(db) if err != nil { l.Error(err, "failed to get audit cycle from database") return err } // Sync audit action item for all audit cycles for _, auditCycle := range auditCycles { if err := h.syncAuditActionItemInAuditCycle(db, auditCycle); err != nil { l.Error(err, "failed to run syncAuditActionItemInAuditCycle function") return err } } l.Infof("Syncing audit action item finished") return err } func (h *handler) syncAuditActionItemInAuditCycle(db *gorm.DB, auditCycle *model.AuditCycle) error { l := h.logger.Fields(logger.Fields{ "method": "syncAuditActionItemInAuditCycle", "auditCycleID": auditCycle.ID.String(), }) l.Infof("Sync Audit Action Item for audit cycle: %s", auditCycle.ID.String()) // check if audit cycle has audit if auditCycle.HealthAuditID != nil { if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.HealthAuditID); err != nil { l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.HealthAuditID.String()) return err } } if auditCycle.ProcessAuditID != nil { if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.ProcessAuditID); err != nil { l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.ProcessAuditID.String()) return err } } if auditCycle.FrontendAuditID != nil { if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.FrontendAuditID); err != nil { l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.FrontendAuditID.String()) return err } } if auditCycle.BackendAuditID != nil { if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.BackendAuditID); err != nil { l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.BackendAuditID.String()) return err } } if auditCycle.MobileAuditID != nil { if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.MobileAuditID); err != nil { l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.MobileAuditID.String()) return err } } if auditCycle.BlockchainAuditID != nil { if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.BlockchainAuditID); err != nil { l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.BlockchainAuditID.String()) return err } } if auditCycle.SystemAuditID != nil { if err := h.syncAuditActionItemInAudit(db, auditCycle, *auditCycle.SystemAuditID); err != nil { l.Errorf(err, "failed to sync audit action item in audit %s", auditCycle.SystemAuditID.String()) return err } } return nil } func (h *handler) syncAuditActionItemInAudit(db *gorm.DB, auditCycle *model.AuditCycle, auditID model.UUID) error { l := h.logger.Fields(logger.Fields{ "method": "syncAuditActionItemInAudit", "auditID": auditID.String(), "auditCycleID": auditCycle.ID.String(), }) l.Infof("Sync Audit Action Item for audit: %s", auditID.String()) audit, err := h.store.Audit.One(db, auditID.String()) if err != nil { l.Error(err, "failed to get audit from database") return err } // call api to get data of the audit from notion checklistPage, err := h.service.Notion.GetBlockChildren(audit.ID.String()) if err != nil { l.Error(err, "failed to get audit from notion") return err } // Find the audit checklist block index checklistDatabaseIndex := -1 for index, block := range checklistPage.Results { if reflect.TypeOf(block) == reflect.TypeOf(&notion.ChildDatabaseBlock{}) { checklistDatabaseIndex = index } } checklistDatabase, err := h.service.Notion.GetDatabase(checklistPage.Results[checklistDatabaseIndex].ID(), nil, nil, 0) if err != nil { l.Error(err, "failed to get database from notion") return err } // Get all audit action item in the database auditActionItem, err := h.store.AuditActionItem.AllByAuditID(db, auditID.String()) if err != nil { l.Error(err, "failed to get audit action item from database") return err } aaiMap := model.AuditActionItemToMap(auditActionItem) // Loop through all audit items and update to database if it have value in Audit action items field for _, checklist := range checklistDatabase.Results { checklistProperties := checklist.Properties.(notion.DatabasePageProperties) // Get audit item auditItem, err := h.store.AuditItem.One(db, checklist.ID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Errorf(err, "audit item with id: %s not found", checklist.ID) continue } l.Error(err, "failed to get audit item from database") return err } if checklistProperties["â˜Žï¸ Audit Action Items"].Relation == nil && auditItem.ActionItemID != nil { // Update audit item if action item to nil auditItem.ActionItemID = nil if _, err = h.store.AuditItem.UpdateSelectedFieldsByID(db, auditItem.ID.String(), *auditItem, "action_item_id"); err != nil { l.Error(err, "failed to update audit item") return err } } else if len(checklistProperties["â˜Žï¸ Audit Action Items"].Relation) > 0 { // update audit_items(action_item_id)->audit(action_item)-> create record trong audit_action_items // Get action item actionItem, err := h.store.ActionItem.One(db, checklistProperties["â˜Žï¸ Audit Action Items"].Relation[0].ID) if err != nil { // if err is not found skip update if errors.Is(err, gorm.ErrRecordNotFound) { continue } l.Error(err, "failed to get action item from database") return err } // Update audit item if action item change if auditItem.ActionItemID == nil || (auditItem.ActionItemID != nil && *auditItem.ActionItemID != actionItem.ID) { auditItem.ActionItemID = &actionItem.ID if _, err = h.store.AuditItem.UpdateSelectedFieldsByID(db, auditItem.ID.String(), *auditItem, "action_item_id"); err != nil { l.Error(err, "failed to update audit item") return err } } // Update audit audit.ActionItem++ if audit, err = h.store.Audit.Update(db, audit); err != nil { l.Error(err, "failed to update audit") return err } // Update audit action item table if _, ok := aaiMap[model.AuditAction{AuditID: audit.ID, ActionItemID: actionItem.ID}]; ok { delete(aaiMap, model.AuditAction{AuditID: audit.ID, ActionItemID: actionItem.ID}) } else { // Create audit action item auditActionItem := &model.AuditActionItem{ AuditID: audit.ID, ActionItemID: actionItem.ID, } if _, err = h.store.AuditActionItem.Create(db, auditActionItem); err != nil { l.Error(err, "failed to create audit action item") return err } } } } // Delete audit action item for _, aai := range aaiMap { if err := h.store.AuditActionItem.Delete(db, aai.ID.String()); err != nil { l.Error(err, "failed to delete audit action item") return err } } return nil } func (h *handler) snapShot(db *gorm.DB) error { l := h.logger.Fields(logger.Fields{ "method": "snapShot", }) // Get all audit cycle from database auditCycles, err := h.store.AuditCycle.All(db) if err != nil { l.Error(err, "failed to get audit cycle from database") return err } // Create action item snapshot record for each audit cycle for _, auditCycle := range auditCycles { projectNotion, err := h.store.ProjectNotion.OneByAuditNotionID(db, auditCycle.ProjectID.String()) if err != nil { l.Error(err, "failed to get project notion from database") return err } if projectNotion.Project.Status != model.ProjectStatusClosed && projectNotion.Project.Status != model.ProjectStatusPaused { actionItemSnapshot := &model.ActionItemSnapshot{ ProjectID: auditCycle.ProjectID, AuditCycleID: auditCycle.ID, High: auditCycle.ActionItemHigh, Medium: auditCycle.ActionItemMedium, Low: auditCycle.ActionItemLow, } // Check record exists in database today := time.Now().Format("2006-01-02") if snapShot, err := h.store.ActionItemSnapshot.OneByAuditCycleIDAndTime(db, auditCycle.ID.String(), today); err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { if _, err := h.store.ActionItemSnapshot.Create(db, actionItemSnapshot); err != nil { l.Error(err, "failed to create action item snapshot") return err } } else { l.Error(err, "failed to get action item snapshot from database") return err } } else { // Update if record exists if !model.CompareActionItemSnapshot(snapShot, actionItemSnapshot) { if _, err := h.store.ActionItemSnapshot.UpdateSelectedFieldsByID(db, snapShot.ID.String(), *actionItemSnapshot, "high", "medium", "low"); err != nil { l.Error(err, "failed to update action item snapshot") return err } } } } } return nil }
```

# pkg/handler/audit/errs/errors.go

```go
package errs import "errors" var ( ErrFailedToGetFlag = errors.New("failed to get flag") ErrMissingAuditorInAudit = errors.New("missing auditor in audit") ErrMissingProjectInAudit = errors.New("missing project in audit") )
```

# pkg/handler/audit/interface.go

```go
package audit import "github.com/gin-gonic/gin" type IHandler interface { Sync(c *gin.Context) }
```

# pkg/handler/bankaccount/bank_account.go

```go
package bankaccount import ( "net/http" "github.com/gin-gonic/gin" _ "github.com/lib/pq" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } // List godoc // @Summary Get all bank accounts // @Description Get all bank accounts // @id listBankAccounts // @Tags Bank // @Accept json // @Produce json // @Success 200 {object} ListBankAccountResponse // @Failure 500 {object} ErrorResponse // @Router /bank-accounts [get] func (h *handler) List(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "bankaccount", "method": "List", }) res, err := h.store.BankAccount.All(h.repo.DB()) if err != nil { l.Error(err, "failed to get all bank accounts") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListBankAccount(res), nil, nil, nil, "")) }
```

# pkg/handler/bankaccount/interface.go

```go
package bankaccount import "github.com/gin-gonic/gin" type IHandler interface { List(c *gin.Context) }
```

# pkg/handler/brainerylogs/brainery_log.go

```go
package brainerylogs import ( "net/http" "regexp" "strings" "time" "github.com/gin-gonic/gin" "github.com/shopspring/decimal" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs/errs" "github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/store/employee" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { controller *controller.Controller store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ controller: controller, store: store, repo: repo, service: service, logger: logger, config: cfg, } } const ( braineryLogsChannelID = "955015316293972048" braineryLogsPlaygroundChannelID = "1119171172198797393" ) // Create godoc // @Summary Create brainery logs // @Description Create brainery logs // @id createBraineryLog // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param body body CreateBraineryLogRequest true "Body" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /brainery-logs [post] func (h *handler) Create(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "brainerylogs", "method": "Create", }, ) body := request.CreateBraineryLogRequest{} if err := c.ShouldBindJSON(&body); err != nil { l.Error(err, "failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } if err := body.Validate(); err != nil { l.Errorf(err, "failed to validate data", "body", body) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } publishedAt, _ := time.Parse(time.RFC3339Nano, body.PublishedAt) b := model.BraineryLog{ Title: body.Title, URL: body.URL, GithubID: body.GithubID, DiscordID: body.DiscordID, Tags: body.Tags, PublishedAt: &publishedAt, Reward: body.Reward, } log, err := h.controller.BraineryLog.Create(b) if err != nil { l.Errorf(err, "failed to create brainery logs", "braineryLog", b) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, log, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any]("success", nil, nil, body, "")) } // GetMetrics godoc // @Summary Get brainery metric // @Description Get brainery metric // @id getBraineryMetric // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param view query string false "Time view" // @Param date query string false "Date" Format(date) // @Success 200 {object} BraineryMetricResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /brainery-logs/metrics [get] func (h *handler) GetMetrics(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "brainerylogs", "method": "GetMetrics", }, ) queryView := c.DefaultQuery("view", "weekly") date := c.Query("date") selectedDate := time.Now() if date != "" { t, err := time.Parse("2006-01-02", date) if err != nil { l.Error(err, "failed to parse date") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidDateFormat, nil, "")) return } selectedDate = t } latestPosts, logs, ncids, err := h.controller.BraineryLog.GetMetrics(selectedDate, queryView) if err != nil { l.Error(err, "failed to get brainery metrics") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToBraineryMetric(latestPosts, logs, ncids, queryView), nil, nil, nil, "")) } func (h *handler) Sync(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "brainerylogs", "method": "Sync", }, ) githubPattern := `github\.com/([\w-]+)` githubRe := regexp.MustCompile(githubPattern) displayNameIDMap := map[string]string{ "An Tran": "656dd867-39c1-4ed8-b72e-63d0e89c3679", "Bach Phuong": "1782aaea-733c-4ced-8d30-a921abede14e", "Bien Vo": "5a8f3d89-04a0-4a0e-bdc8-73045ced6a08", "Binh Le": "06126b41-b20f-4ca2-933a-06fdb01fe362", "Dung Ho": "bf1d3fcc-6a59-413e-a692-113989849556", "Hieu Phan": "e0d8c920-f4f1-4309-aabf-1d83f792f45b", "Huy Tieu": "3c420751-bb9a-4878-896e-2f10f3a633d6", "Khanh Truong": "63d163a7-e9f5-4210-a685-151061fe9c29", "Khoi Nguyen": "224b9b85-7206-46bd-803a-5308fd4e81e1", "Lap Nguyen": "e84c1860-6991-44a1-b687-fec078b842eb", "Le Duc Chinh": "40f33d74-91ae-4eec-ba35-8d330376d6e1", "M.Vu Cuong(Jim)": "07a5a7b2-6e5f-4165-bbdf-40d06f3e7837", "Ngo Lap Nguyen": "e84c1860-6991-44a1-b687-fec078b842eb", "Ngo Trong Khoi": "8281ade3-214a-4348-a171-42b0fe304032", "Nguyen Dinh Nam": "a5ddbb54-3faa-4f92-964a-3754928d3f21", "Nguyen Huu Nguyen": "9a91ff6b-7367-403f-b23d-4c16dabd6857", "Nguyen Tran Khanh": "14bdccb9-3460-40f6-ba87-6ad1a7884670", "Nguyen Xuan Anh": "69bf5adf-7ba2-4abc-b87e-9a68668a267e", "Nhut Huynh": "a8f34385-61f8-46f0-9403-4b05e37cd8e3", "Pham Duc Thanh": "3e858c81-d661-4d4f-b913-e02dd6f4007e", "Pham Ngoc Thanh": "ec086e4a-2167-4924-adfd-84be02edebe9", "Pham The Hung": "133483cd-7a76-4a6d-9c63-964900284a44", "Phan Viet Trung": "ee219b4e-e4dc-4782-b590-03f799cd41ab", "Phat Ha": "1b63c305-b04b-47ab-ab1b-e6810d8a17cc", "Phuc Le": "d8a6af04-9e0a-4724-97c4-a78ecd5e9bc4", "Thanh Pham": "3e858c81-d661-4d4f-b913-e02dd6f4007e", "Tom Nguyen": "69bf5adf-7ba2-4abc-b87e-9a68668a267e", "Tran Hoang Nam": "d8b2785c-31f1-451b-8bb5-385cbc873402", "Tran Khac Vy": "2641297b-c632-4c22-9a42-61291d621552", "Trung Phan": "ee219b4e-e4dc-4782-b590-03f799cd41ab", "Truong Hung Khanh": "63d163a7-e9f5-4210-a685-151061fe9c29", "Vy Tran": "2641297b-c632-4c22-9a42-61291d621552", } body := request.SyncBraineryLogs{} if err := c.ShouldBindJSON(&body); err != nil { l.Errorf(err, "failed to parse request") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } if body.StartMessageID == "" { body.StartMessageID = "960194750806364171" } if body.EndMessageID == "" { body.EndMessageID = "1120663834261205052" } channelID := braineryLogsChannelID if h.config.Env != "prod" { channelID = braineryLogsChannelID } messages, err := h.service.Discord.GetMessagesAfterCursor(channelID, body.StartMessageID, body.EndMessageID) if err != nil { l.Errorf(err, "failed to get messages from discord", "startMessageID", body.StartMessageID, "endMessageID", body.EndMessageID) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } socialAccounts, err := h.store.SocialAccount.GetByType(h.repo.DB(), model.SocialAccountTypeGitHub.String()) if err != nil { l.Errorf(err, "failed to get social accounts") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } githubEmployeeIDMap, empIDGithubMap := model.SocialAccounts(socialAccounts).ToMap() employees, _, err := h.store.Employee.All(h.repo.DB(), employee.EmployeeFilter{}, model.Pagination{ Page: 0, Size: 1000, }) if err != nil { l.Errorf(err, "failed to get employees") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } employeeDiscordMap := make(map[string]string) for _, e := range employees { if e.DiscordAccount != nil && e.DiscordAccount.DiscordID != "" { employeeDiscordMap[e.ID.String()] = e.DiscordAccount.DiscordID } } var braineryLogs []model.BraineryLog for _, m := range messages { if !m.Author.Bot { continue } if len(m.Embeds) == 0 { continue } githubID := "" discordID := "" employeeID := "" var tags []string for _, f := range m.Embeds[0].Fields { if f.Name == "Topic" { if f.Value != "" { tmp := strings.ReplaceAll(f.Value, "#", "") tmp = strings.ReplaceAll(tmp, "\n", "/") tmp = strings.ReplaceAll(tmp, " ", "") tmp = strings.ReplaceAll(tmp, "...", "") tmp = strings.ToLower(tmp) tmpTags := strings.Split(tmp, "/") tags = append(tags, tmpTags...) } } if f.Name == "Tags" { if f.Value != "" { tmp := strings.ReplaceAll(f.Value, "#", "") tmp = strings.ReplaceAll(tmp, "\n", "/") tmp = strings.ReplaceAll(tmp, " ", "") tmp = strings.ReplaceAll(tmp, "...", "") tmp = strings.ToLower(tmp) tmpTags := strings.Split(tmp, "/") tags = append(tags, tmpTags...) } } if f.Name == "Author" && strings.Contains(m.Embeds[0].URL, "https://github.com/dwarvesf") { githubID = f.Value v, ok := githubEmployeeIDMap[f.Value] if ok { employeeID = v d, ok := employeeDiscordMap[v] if ok { discordID = d } } } if f.Name == "Author" && strings.Contains(m.Embeds[0].URL, "https://brain.d.foundation") { github := githubRe.FindStringSubmatch(f.Value) if len(github) > 1 { githubID = github[1] v, ok := githubEmployeeIDMap[github[1]] if ok { employeeID = v d, ok := employeeDiscordMap[v] if ok { discordID = d } } } else { v, ok := displayNameIDMap[f.Value] if ok { employeeID = v d, ok := employeeDiscordMap[v] if ok { discordID = d } gh, ok := empIDGithubMap[v] if ok { githubID = gh } } else { githubID = f.Value } } } } eid := model.UUID{} euuid, err := model.UUIDFromString(employeeID) if err == nil { eid = euuid } loc, _ := time.LoadLocation("Asia/Ho_Chi_Minh") t := m.Timestamp.In(loc) l := model.BraineryLog{ Title: m.Embeds[0].Title, URL: m.Embeds[0].URL, GithubID: githubID, DiscordID: discordID, EmployeeID: eid, Tags: tags, PublishedAt: &t, Reward: decimal.NewFromInt(10), } braineryLogs = append(braineryLogs, l) } if len(braineryLogs) == 0 { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) return } _, err = h.store.BraineryLog.Create(h.repo.DB(), braineryLogs) if err != nil { l.Errorf(err, "failed to create brainery logs") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) }
```

# pkg/handler/brainerylogs/errs/errors.go

```go
package errs import "errors" var ( ErrInvalidPublishedAt = errors.New("cannot parse publishedAt") ErrInvalidDateFormat = errors.New("invalid date format") )
```

# pkg/handler/brainerylogs/interface.go

```go
package brainerylogs import "github.com/gin-gonic/gin" type IHandler interface { Create(c *gin.Context) GetMetrics(c *gin.Context) Sync(c *gin.Context) }
```

# pkg/handler/brainerylogs/request/request.go

```go
package request import ( "time" "github.com/shopspring/decimal" "github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs/errs" ) type CreateBraineryLogRequest struct { Title string `json:"title" binding:"required"` URL string `json:"url" binding:"required"` GithubID string `json:"githubID"` DiscordID string `json:"discordID" binding:"required"` Tags []string `json:"tags" binding:"required"` PublishedAt string `json:"publishedAt" binding:"required"` Reward decimal.Decimal `json:"reward" binding:"required"` } // @name CreateBraineryLogRequest func (r CreateBraineryLogRequest) Validate() error { if _, err := time.Parse(time.RFC3339Nano, r.PublishedAt); err != nil { return errs.ErrInvalidPublishedAt } return nil } type SyncBraineryLogs struct { StartMessageID string `json:"startMessageID"` EndMessageID string `json:"endMessageID"` }
```

# pkg/handler/client/client.go

```go
package client import ( "errors" "net/http" "github.com/gin-gonic/gin" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/handler/client/errs" "github.com/dwarvesf/fortress-api/pkg/handler/client/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config controller *controller.Controller } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, controller: controller, } } // Create godoc // @Summary Create new client // @Description Create new client // @id createClient // @Tags Client // @Accept json // @Produce json // @Security BearerAuth // @Param Body body CreateClientRequest true "Body" // @Success 200 {object} CreateClientResponse // @Failure 500 {object} ErrorResponse // @Router /clients [post] func (h *handler) Create(c *gin.Context) { input := request.CreateClientRequest{} if err := c.ShouldBindJSON(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "client", "method": "Create", "request": input, }) client, err := h.controller.Client.Create(c, input) if err != nil { l.Error(err, "failed to create client") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToClient(client), nil, nil, nil, "")) } // List godoc // @Summary Get all clients // @Description Get all clients // @id getListClients // @Tags Client // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} GetListClientResponse // @Failure 500 {object} ErrorResponse // @Router /clients [get] func (h *handler) List(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "client", "method": "List", }) clients, err := h.controller.Client.List(c) if err != nil { l.Error(err, "failed to get client list") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToClients(clients), nil, nil, nil, "")) } // Detail godoc // @Summary Get client detail by id // @Description Get client detail by id // @id getClientDetail // @Tags Client // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Client ID" // @Success 200 {object} GetDetailClientResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /clients/{id} [get] func (h *handler) Detail(c *gin.Context) { clientID := c.Param("id") if clientID == "" || !model.IsUUIDFromString(clientID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidClientID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "client", "method": "Detail", }) client, err := h.controller.Client.Detail(c, clientID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrClientNotFound, nil, "")) return } l.Error(err, "failed to get client detail") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToClient(client), nil, nil, nil, "")) } // Update godoc // @Summary Update client by id // @Description Update client by id // @id updateClient // @Tags Client // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Client ID" // @Param Body body UpdateClientInput true "Body" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /clients/{id} [put] func (h *handler) Update(c *gin.Context) { clientID := c.Param("id") if clientID == "" || !model.IsUUIDFromString(clientID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidClientID, nil, "")) return } input := request.UpdateClientInput{} if err := c.ShouldBindJSON(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "client", "method": "Update", "request": input, }) errCode, err := h.controller.Client.Update(c, clientID, input) if err != nil { l.Error(err, "failed to update client") c.JSON(errCode, view.CreateResponse[any](nil, nil, err, input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // Delete godoc // @Summary Delete client by id // @Description Delete client by id // @id deleteClient // @Tags Client // @Accept json // @Produce json // @Param id path string true "Client ID" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /clients/{id} [delete] func (h *handler) Delete(c *gin.Context) { clientID := c.Param("id") if clientID == "" || !model.IsUUIDFromString(clientID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidClientID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "client", "method": "UpdateInfo", "clientID": clientID, }) errCode, err := h.controller.Client.Delete(c, clientID) if err != nil { l.Error(err, "failed to delete client") c.JSON(errCode, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // PublicList godoc // @Summary Get all clients // @Description Get all clients // @id getAllPublicClients // @Tags Public // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} PublicClientListResponse // @Failure 500 {object} ErrorResponse // @Router /public/clients [get] func (h *handler) PublicList(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "client", "method": "PublicList", }) clients, err := h.controller.Client.PublicList(c) if err != nil { l.Error(err, "failed to get client list") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToPublicClientListResponse(clients), nil, nil, nil, "")) }
```

# pkg/handler/client/errs/errors.go

```go
package errs import "errors" var ( ErrInvalidClientID = errors.New("invalid client id") ErrInvalidClientContactID = errors.New("invalid client contact id") ErrClientNotFound = errors.New("client not found") )
```

# pkg/handler/client/interface.go

```go
package client import "github.com/gin-gonic/gin" type IHandler interface { Create(c *gin.Context) List(c *gin.Context) Detail(c *gin.Context) Update(c *gin.Context) Delete(c *gin.Context) PublicList(c *gin.Context) }
```

# pkg/handler/client/request/request.go

```go
package request type CreateClientRequest struct { Name string `json:"name"` Description string `json:"description"` RegistrationNumber string `json:"registrationNumber"` Address string `json:"address"` Country string `json:"country"` Industry string `json:"industry"` Website string `json:"website"` Contacts []*CreateClientContactInput `json:"contacts"` } // @name CreateClientRequest type CreateClientContactInput struct { Name string `json:"name"` Role string `json:"role"` Emails []string `json:"emails"` IsMainContact bool `json:"isMainContact"` } // @name CreateClientContactInput type UpdateClientInput struct { Name string `json:"name"` Description string `json:"description"` RegistrationNumber string `json:"registrationNumber"` Address string `json:"address"` Country string `json:"country"` Industry string `json:"industry"` Website string `json:"website"` Contacts []*UpdateClientContactInput `json:"contacts"` } // @name UpdateClientInput type UpdateClientContactInput struct { Name string `json:"name"` Role string `json:"role"` Emails []string `json:"emails"` IsMainContact bool `json:"isMainContact"` } // @name UpdateClientContactInput
```

# pkg/handler/communitynft/communitynft.go

```go
package communitynft import ( "net/http" "strconv" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" ctrl "github.com/dwarvesf/fortress-api/pkg/controller/communitynft" "github.com/dwarvesf/fortress-api/pkg/handler/communitynft/errs" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config controller *controller.Controller } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, controller: controller, } } // GetNftMetadata godoc // @Summary Get metadata of a nft // @Description Get metadata of a nft // @id getNftMetadata // @Tags CommunityNft // @Accept json // @Produce json // @Param id path string true "NFT ID" // @Success 200 {object} GetNftMetadataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /community-nfts/{id} [get] func (h *handler) GetNftMetadata(c *gin.Context) { tokenIdStr := c.Param("id") if tokenIdStr == "" { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidTokenID, nil, "")) return } tid, err := strconv.Atoi(tokenIdStr) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidTokenID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "client", "method": "Detail", }) nftMetadata, err := h.controller.CommunityNft.GetNftMetadata(tid) if err == ctrl.ErrTokenNotFound { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrTokenNotFound, nil, "")) return } if err != nil { l.Error(err, "failed to get nft metadata") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.ToNftMetadata(nftMetadata)) }
```

# pkg/handler/communitynft/errs/errors.go

```go
package errs import "errors" var ( ErrInvalidTokenID = errors.New("invalid token id") ErrTokenNotFound = errors.New("token not found") )
```

# pkg/handler/communitynft/interface.go

```go
package communitynft import "github.com/gin-gonic/gin" type IHandler interface { GetNftMetadata(c *gin.Context) }
```

# pkg/handler/companyinfo/company_info.go

```go
package companyinfo import ( "net/http" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/gin-gonic/gin" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config controller *controller.Controller } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, controller: controller, } } // List godoc // @Summary Get all company info // @Description Get all company info // @id get list of company info // @Tags Client // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} view.GetListCompanyInfoResponse // @Failure 500 {object} ErrorResponse // @Router /company-infos [get] func (h *handler) List(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "companyInfo", "method": "List", }) companyInfos, err := h.controller.CompanyInfo.List(c) if err != nil { l.Error(err, "failed to get company info list") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToCompanyInfos(companyInfos), nil, nil, nil, "")) }
```

# pkg/handler/companyinfo/interface.go

```go
package companyinfo import "github.com/gin-gonic/gin" type IHandler interface { List(c *gin.Context) }
```

# pkg/handler/conversionrate/conversion_rate.go

```go
package conversionrate import ( "net/http" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config controller *controller.Controller } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, controller: controller, } } func (h *handler) List(c *gin.Context) { //l := h.logger.Fields(logger.Fields{ // "handler": "conversionRate", // "method": "List", //}) //clients, err := h.controller.Client.List(c) //if err != nil { // l.Error(err, "failed to get client list") // c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) // return //} c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } func (h *handler) Sync(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "conversionRate", "method": "Sync", }) err := h.controller.ConversionRate.Sync(c) if err != nil { l.Error(err, "failed to sync") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) }
```

# pkg/handler/conversionrate/interface.go

```go
package conversionrate import "github.com/gin-gonic/gin" type IHandler interface { List(c *gin.Context) Sync(c *gin.Context) }
```

# pkg/handler/dashboard/dashboard.go

```go
package dashboard import ( "errors" "net/http" "time" "github.com/gin-gonic/gin" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/handler/dashboard/errs" "github.com/dwarvesf/fortress-api/pkg/handler/dashboard/request" "github.com/dwarvesf/fortress-api/pkg/handler/dashboard/util" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config util util.IUtil } // New returns a handler func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config, u util.IUtil) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, util: u, } } // GetProjectSizes godoc // @Summary Get the total number of active member in each project // @Description Get the total number of active member in each project // @id getProjectSizeList // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} ProjectSizeResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/projects/sizes [get] func (h *handler) GetProjectSizes(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetProjectSizes", }) res, err := h.store.Dashboard.GetProjectSizes(h.repo.DB()) if err != nil { l.Error(err, "failed to get project sizes") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToProjectSizes(res), nil, nil, nil, "")) } // GetWorkSurveys godoc // @Summary Get Work Surveys data for dashboard // @Description Get Work Surveys data for dashboard // @id getWorkSurveyList // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Param projectID query string false "Project ID" // @Success 200 {object} WorkSurveyResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/projects/work-surveys [get] func (h *handler) GetWorkSurveys(c *gin.Context) { input := request.WorkSurveysInput{} if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if input.ProjectID != "" && !model.IsUUIDFromString(input.ProjectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetWorkSurveys", "input": input, }) var project *model.Project var workSurveys []*model.WorkSurvey var err error if input.ProjectID != "" { // Check project existence project, err = h.store.Project.One(h.repo.DB(), input.ProjectID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, "")) return } l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } // Get work survey by project ID workSurveys, err = h.store.Dashboard.GetWorkSurveysByProjectID(h.repo.DB(), input.ProjectID) if err != nil { l.Error(err, "failed to get work survey by project ID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } else { workSurveys, err = h.store.Dashboard.GetAllWorkSurveys(h.repo.DB()) if err != nil { l.Error(err, "failed to get work survey") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToWorkSurveyData(project, workSurveys), nil, nil, nil, "")) } // GetActionItemReports godoc // @Summary Get Action items report for dashboard // @Description Get Action items report for dashboard // @id getActionItemReportList // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Param projectID query string false "Project ID" // @Success 200 {object} ActionItemReportResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/projects/action-items [get] func (h *handler) GetActionItemReports(c *gin.Context) { input := request.ActionItemInput{} if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if input.ProjectID != "" && !model.IsUUIDFromString(input.ProjectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetActionItemReports", "input": input, }) var actionItemReports []*model.ActionItemReport var err error if input.ProjectID != "" { // Check project existence isExist, err := h.store.Project.IsExist(h.repo.DB(), input.ProjectID) if err != nil { l.Error(err, "failed to get project by project ID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if !isExist { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, "")) return } // Get audit notion id by project ID projectNotion, err := h.store.ProjectNotion.OneByProjectID(h.repo.DB(), input.ProjectID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project notion not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotionNotFound, input, "")) return } l.Error(err, "failed to get project notion by project ID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // Get action item report by project ID actionItemReports, err = h.store.Dashboard.GetActionItemReportsByProjectNotionID(h.repo.DB(), projectNotion.AuditNotionID.String()) if err != nil { l.Error(err, "failed to get action item report by project ID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } else { actionItemReports, err = h.store.Dashboard.GetAllActionItemReports(h.repo.DB()) if err != nil { l.Error(err, "failed to get action item report") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToActionItemReportData(actionItemReports), nil, nil, nil, "")) } // GetEngineeringHealth godoc // @Summary Get Engineering health information for dashboard // @Description Get Engineering health information for dashboard // @id getEngineeringHealth // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Param projectID query string false "Project ID" // @Success 200 {object} EngineeringHealthResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/projects/engineering-healths [get] func (h *handler) GetEngineeringHealth(c *gin.Context) { input := request.WorkSurveysInput{} if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if input.ProjectID != "" && !model.IsUUIDFromString(input.ProjectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetEngineeringHealth", "input": input, }) var average []*model.AverageEngineeringHealth var groups []*model.GroupEngineeringHealth var err error if input.ProjectID != "" { // Check project existence isExist, err := h.store.Project.IsExist(h.repo.DB(), input.ProjectID) if err != nil { l.Error(err, "failed to get project by project ID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if !isExist { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, "")) return } // Get audit notion id by project ID projectNotion, err := h.store.ProjectNotion.OneByProjectID(h.repo.DB(), input.ProjectID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project notion not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotionNotFound, input, "")) return } l.Error(err, "failed to get project notion by project ID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } average, err = h.store.Dashboard.AverageEngineeringHealthByProjectNotionID(h.repo.DB(), projectNotion.AuditNotionID.String()) if err != nil { l.Error(err, "failed to get average engineering health") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } groups, err = h.store.Dashboard.GroupEngineeringHealthByProjectNotionID(h.repo.DB(), projectNotion.AuditNotionID.String()) if err != nil { l.Error(err, "failed to get group engineering health") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } else { average, err = h.store.Dashboard.AverageEngineeringHealth(h.repo.DB()) if err != nil { l.Error(err, "failed to get average engineering health") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } groups, err = h.store.Dashboard.GroupEngineeringHealth(h.repo.DB()) if err != nil { l.Error(err, "failed to get group engineering health") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEngineeringHealthData(average, groups), nil, nil, nil, "")) } // GetAudits godoc // @Summary Get Audit information for dashboard // @Description Get Audit information for dashboard // @id getAuditList // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Param projectID query string false "Project ID" // @Success 200 {object} AuditResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/projects/audits [get] func (h *handler) GetAudits(c *gin.Context) { input := request.WorkSurveysInput{} if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if input.ProjectID != "" && !model.IsUUIDFromString(input.ProjectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetAudits", "input": input, }) var average []*model.AverageAudit var groups []*model.GroupAudit var err error if input.ProjectID != "" { // Check project existence isExist, err := h.store.Project.IsExist(h.repo.DB(), input.ProjectID) if err != nil { l.Error(err, "failed to get project by project ID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if !isExist { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, "")) return } // Get audit notion id by project ID projectNotion, err := h.store.ProjectNotion.OneByProjectID(h.repo.DB(), input.ProjectID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project notion not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotionNotFound, input, "")) return } l.Error(err, "failed to get project notion by project ID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } average, err = h.store.Dashboard.GetAverageAuditByProjectNotionID(h.repo.DB(), projectNotion.AuditNotionID.String()) if err != nil { l.Error(err, "failed to get average audits") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } groups, err = h.store.Dashboard.GetGroupAuditByProjectNotionID(h.repo.DB(), projectNotion.AuditNotionID.String()) if err != nil { l.Error(err, "failed to get group audits") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } else { average, err = h.store.Dashboard.GetAverageAudit(h.repo.DB()) if err != nil { l.Error(err, "failed to get average audits") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } groups, err = h.store.Dashboard.GetGroupAudit(h.repo.DB()) if err != nil { l.Error(err, "failed to get group audits") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToAuditData(average, groups), nil, nil, nil, "")) } // GetActionItemSquashReports godoc // @Summary Get Action items squash report for dashboard // @Description Get Action items squash report for dashboard // @id getActionItemSquashReportList // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Param projectID query string false "Project ID" // @Success 200 {object} ActionItemSquashReportResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/projects/action-item-squash [get] func (h *handler) GetActionItemSquashReports(c *gin.Context) { input := request.ActionItemInput{} if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if input.ProjectID != "" && !model.IsUUIDFromString(input.ProjectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetActionItemSquashReports", "input": input, }) var actionItemSquashReports []*model.ActionItemSquashReport var err error if input.ProjectID != "" { // Check project existence isExist, err := h.store.Project.IsExist(h.repo.DB(), input.ProjectID) if err != nil { l.Error(err, "failed to get project by project ID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if !isExist { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, "")) return } // Get action item report by project ID actionItemSquashReports, err = h.store.Dashboard.GetActionItemSquashReportsByProjectID(h.repo.DB(), input.ProjectID) if err != nil { l.Error(err, "failed to get action item squash report by project ID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } else { actionItemSquashReports, err = h.store.Dashboard.GetAllActionItemSquashReports(h.repo.DB()) if err != nil { l.Error(err, "failed to get action item squash report") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToActionItemSquashReportData(actionItemSquashReports), nil, nil, nil, "")) } // GetSummary godoc // @Summary Get the summary audit info for projects // @Description Get the summary audit info for projects // @id getProjectSummary // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} AuditSummariesResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/projects/summary [get] func (h *handler) GetSummary(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetSummary", }) summaries, err := h.store.Dashboard.GetAuditSummaries(h.repo.DB()) if err != nil { l.Error(err, "failed to get audit summaries") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } summaryMap := make(map[model.UUID][]*model.AuditSummary) for _, summary := range summaries { summaryMap[summary.ID] = append(summaryMap[summary.ID], summary) } now := time.Now() currentMonth := now.Month() currentYear := now.Year() firstDayOfLastQuarter := time.Date(currentYear, (currentMonth-1)/3*3+1, 1, 0, 0, 0, 0, time.UTC) previousQuarterSizes, err := h.store.Dashboard.GetProjectSizesByStartTime(h.repo.DB(), firstDayOfLastQuarter) if err != nil { l.Error(err, "failed to get project sizes") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } previousQuarterMap := make(map[model.UUID]int64) for _, projectSize := range previousQuarterSizes { previousQuarterMap[projectSize.ID] = projectSize.Size } allProjects, err := h.store.Dashboard.GetProjectSizes(h.repo.DB()) if err != nil { l.Error(err, "failed to get project sizes") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // Create map for all projects allProjectsMap := make(map[model.UUID]*model.ProjectSize) for _, project := range allProjects { allProjectsMap[project.ID] = project } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToAuditSummaries(summaryMap, previousQuarterMap, allProjectsMap), nil, nil, nil, "")) } // GetResourcesAvailability godoc // @Summary Get resources availability // @Description Get resources availability // @id getResourcesAvailability // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} ResourceAvailabilityResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/resources/availabilities [get] func (h *handler) GetResourcesAvailability(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetResourcesAvailability", }) slots, err := h.store.Dashboard.GetPendingSlots(h.repo.DB()) if err != nil { l.Error(err, "failed to get pending slots") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } employees, err := h.store.Dashboard.GetAvailableEmployees(h.repo.DB()) if err != nil { l.Error(err, "failed to get available employees") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToResourceAvailability(slots, employees), nil, nil, nil, "")) } // GetEngagementInfo godoc // @Summary Get engagement dashboard // @Description Get engagement dashboard // @id getEngagementInfo // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} GetEngagementDashboardResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/engagement/info [get] func (h *handler) GetEngagementInfo(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetEngagementInfo", }) events, err := h.store.FeedbackEvent.GetLatestEventByType(h.repo.DB(), model.EventTypeSurvey, model.EventSubtypeEngagement, 4) if err != nil { l.Error(err, "failed to get engagement events") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, errs.ErrEventNotFound, nil, "")) return } timeList := make([]time.Time, 0) for _, t := range events { timeList = append(timeList, *t.StartDate) } statistic, err := h.store.EmployeeEventQuestion.GetAverageAnswerEngagementByTime(h.repo.DB(), timeList) if err != nil { l.Error(err, "failed to get engagement statistic") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEngagementDashboard(statistic), nil, nil, nil, "")) } // GetEngagementInfoDetail godoc // @Summary Get engagement dashboard // @Description Get engagement dashboard // @id getEngagementInfoDetailList // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Param filter query string true "chapter/seniority/project" // @Param startDate query string true "startDate" // @Success 200 {object} GetEngagementDashboardDetailResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/engagement/detail [get] func (h *handler) GetEngagementInfoDetail(c *gin.Context) { query := request.GetEngagementDashboardDetailRequest{} if err := c.ShouldBindQuery(&query); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "")) return } filter := model.EngagementDashboardFilter(query.Filter) if !filter.IsValid() { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEngagementDashboardFilter, query, "")) return } startDate, err := time.Parse("2006-01-02", query.StartDate) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidStartDate, query, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetEngagementInfoDetail", }) statistic, err := h.store.EmployeeEventQuestion.GetAverageAnswerEngagementByFilter(h.repo.DB(), filter, &startDate) if err != nil { l.Error(err, "failed to get engagement statistic") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEngagementDashboardDetails(statistic), nil, nil, nil, "")) } // GetResourceUtilization godoc // @Summary Get dashboard resource utilization // @Description Get dashboard resource utilization // @id getResourceUtilizationList // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} GetDashboardResourceUtilizationResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/resources/utilization [get] func (h *handler) GetResourceUtilization(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetResourceUtilization", }) res, err := h.store.Dashboard.GetResourceUtilization(h.repo.DB(), h.util.TimeNow()) if err != nil { l.Error(err, "failed to get resource utilization by year") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToReSourceUtilizations(res), nil, nil, nil, "")) } // GetWorkUnitDistributionSummary godoc // @Summary Get summary for workunit distribution dashboard // @Description Get summary for workunit distribution dashboard // @id getWorkUnitDistributionSummary // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} SummaryWorkUnitDistributionResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/resources/work-unit-distribution-summary [get] func (h *handler) GetWorkUnitDistributionSummary(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetWorkUnitDistributionSummary", }) // Get total work unit distribution totalWorkUnitDistribution, err := h.store.Dashboard.TotalWorkUnitDistribution(h.repo.DB()) if err != nil { l.Error(err, "failed to get total work unit distribution") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToSummaryWorkUnitDistributionData(totalWorkUnitDistribution), nil, nil, nil, "")) } // GetWorkUnitDistribution godoc // @Summary Get work unit distribution data for dashboard // @Description Get work unit distribution data for dashboard // @id getWorkUnitDistributionList // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Param name query string false "employee name for filter" // @Param sort query string false "sort required" // @Param type query string false "work unit type for filter" // @Success 200 {object} WorkUnitDistributionsResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/resources/work-unit-distribution [get] func (h *handler) GetWorkUnitDistribution(c *gin.Context) { input := request.WorkUnitDistributionInput{} if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetWorkUnitDistribution", "input": input, }) // Check and validate input if input.Type != "" && !input.Type.IsValid() { l.Error(errs.ErrInvalidWorkUnitDistributionType, "invalid work unit distribution type") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidWorkUnitDistributionType, nil, "")) return } if input.Sort != "" && !input.Sort.IsValid() { l.Error(errs.ErrInvalidWorkUnitDistributionSort, "invalid work unit distribution sort") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidWorkUnitDistributionSort, nil, "")) return } employees, err := h.store.Dashboard.GetWorkUnitDistributionEmployees(h.repo.DB(), input.Name, input.Type.String()) if err != nil { l.Error(err, "failed to get work unit distribution employees") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToWorkUnitDistributionData(employees, input.Sort.String()), nil, nil, nil, "")) } // GetResourceWorkSurveySummaries godoc // @Summary Get resource work summaries for dashboard // @Description Get resource work summaries for dashboard // @id getResourceWorkSurveySummaryList // @Tags Dashboard // @Accept json // @Produce json // @Security BearerAuth // @Param keyword query string false "Keyword" // @Param page query string false "Page" // @Param size query string false "Size" // @Success 200 {object} WorkSurveySummaryResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /dashboards/resources/work-survey-summaries [get] func (h *handler) GetResourceWorkSurveySummaries(c *gin.Context) { input := request.GetResourceWorkSurveySummariesInput{} if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } input.Standardize() l := h.logger.Fields(logger.Fields{ "handler": "dashboard", "method": "GetResourceWorkSurveySummaries", "input": input, }) reviews, err := h.store.Dashboard.GetAllWorkReviews(h.repo.DB(), input.Keyword, input.Pagination) if err != nil { l.Error(err, "failed to get all work reviews") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToWorkSummaries(reviews), &view.PaginationResponse{Pagination: view.Pagination{Page: input.Pagination.Page, Size: input.Pagination.Size, Sort: input.Pagination.Sort}}, nil, nil, "")) }
```

# pkg/handler/dashboard/errs/errors.go

```go
package errs import "errors" var ( ErrInvalidProjectID = errors.New("invalid project ID") ErrProjectNotFound = errors.New("project not found") ErrEventNotFound = errors.New("event not found") ErrProjectNotionNotFound = errors.New("project notion not found") ErrInvalidEngagementDashboardFilter = errors.New("invalid engagement dashboard filter") ErrInvalidStartDate = errors.New("invalid startDate") ErrInvalidWorkUnitDistributionType = errors.New("invalid work unit distribution type") ErrInvalidWorkUnitDistributionSort = errors.New("invalid sort value") )
```

# pkg/handler/dashboard/interface.go

```go
package dashboard import "github.com/gin-gonic/gin" type IHandler interface { GetProjectSizes(c *gin.Context) GetWorkSurveys(c *gin.Context) GetActionItemReports(c *gin.Context) GetEngineeringHealth(c *gin.Context) GetAudits(c *gin.Context) GetActionItemSquashReports(c *gin.Context) GetSummary(c *gin.Context) GetResourcesAvailability(c *gin.Context) GetEngagementInfo(c *gin.Context) GetEngagementInfoDetail(c *gin.Context) GetResourceUtilization(c *gin.Context) GetWorkUnitDistribution(c *gin.Context) GetWorkUnitDistributionSummary(c *gin.Context) GetResourceWorkSurveySummaries(c *gin.Context) }
```

# pkg/handler/dashboard/request/request.go

```go
package request import "github.com/dwarvesf/fortress-api/pkg/model" type WorkSurveysInput struct { ProjectID string `json:"projectID" form:"projectID"` } type ActionItemInput struct { ProjectID string `json:"projectID" form:"projectID"` } type GetEngagementDashboardDetailRequest struct { Filter string `form:"filter" json:"filter"` StartDate string `form:"startDate" json:"startDate"` } type WorkUnitDistributionInput struct { Sort model.SortOrder `json:"sort" form:"sort"` Type model.WorkUnitType `json:"type" form:"type"` Name string `json:"name" form:"name"` } type GetResourceWorkSurveySummariesInput struct { model.Pagination Keyword string `json:"keyword" form:"keyword"` }
```

# pkg/handler/dashboard/util/interface.go

```go
package util import "time" type IUtil interface { TimeNow() time.Time }
```

# pkg/handler/dashboard/util/util.go

```go
package util import "time" type util struct{} func New() IUtil { return &util{} } func (u *util) TimeNow() time.Time { return time.Now() }
```

# pkg/handler/deliverymetric/discord_msg.go

```go
package deliverymetric import ( "net/http" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service/discord" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/gin-gonic/gin" ) func (h *handler) GetWeeklyReportDiscordMsg(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "delivery", "method": "GetWeeklyReportDiscordMsg", }) report, err := h.controller.DeliveryMetric.GetWeeklyReport() if err != nil { l.Errorf(err, "failed to get delivery metric weekly report", "body") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } leaderBoard, err := h.controller.DeliveryMetric.GetWeeklyLeaderBoard() if err != nil { l.Errorf(err, "failed to get delivery metric weekly report") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } reportView := view.ToDeliveryMetricWeeklyReport(report) leaderBoardView := view.ToDeliveryMetricLeaderBoard(leaderBoard) msg := discord.CreateDeliveryMetricWeeklyReportMessage(reportView, leaderBoardView) c.JSON(http.StatusOK, view.CreateResponse[any](msg, nil, nil, nil, "")) } func (h *handler) GetMonthlyReportDiscordMsg(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "delivery", "method": "GetMonthlyReportDiscordMsg", }) report, err := h.controller.DeliveryMetric.GetMonthlyReport() if err != nil { l.Errorf(err, "failed to get delivery metric weekly report") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } currentMonthReport := report.Reports[1] previousMonthReport := report.Reports[2] if c.Query("to-now") == "true" { currentMonthReport = report.Reports[0] previousMonthReport = report.Reports[1] } leaderBoard, err := h.controller.DeliveryMetric.GetMonthlyLeaderBoard(currentMonthReport.Month) if err != nil { l.Errorf(err, "failed to get delivery metric weekly report") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } reportView := view.ToDeliveryMetricMonthlyReport(currentMonthReport, previousMonthReport) leaderBoardView := view.ToDeliveryMetricLeaderBoard(leaderBoard) msg := discord.CreateDeliveryMetricMonthlyReportMessage(reportView, leaderBoardView) c.JSON(http.StatusOK, view.CreateResponse[any](msg, nil, nil, nil, "")) }
```

# pkg/handler/deliverymetric/get.go

```go
package deliverymetric import ( "net/http" "time" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/logger" ) func (h *handler) GetWeeklyReport(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "delivery", "method": "GetWeeklyReport", }) // Get data of current week report, err := h.controller.DeliveryMetric.GetWeeklyReport() if err != nil { l.Error(err, "failed to get weekly report") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "failed to get weekly report")) return } // Return data c.JSON(http.StatusOK, view.CreateResponse[any](report, nil, nil, nil, "")) } func (h *handler) GetMonthlyReport(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "delivery", "method": "GetMonthlyReport", }) // Get data of current month report, err := h.controller.DeliveryMetric.GetMonthlyReport() if err != nil { l.Error(err, "failed to get monthly report") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "failed to get monthly report")) return } // Return data c.JSON(http.StatusOK, view.CreateResponse[any](report, nil, nil, nil, "")) } func (h *handler) GetWeeklyLeaderBoard(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "delivery", "method": "GetWeeklyLeaderBoard", }) // Get data of current week report, err := h.controller.DeliveryMetric.GetWeeklyLeaderBoard() if err != nil { l.Error(err, "failed to get weekly leaderboard") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "failed to get weekly leaderboard")) return } // Return data c.JSON(http.StatusOK, view.CreateResponse[any](view.ToDeliveryMetricLeaderBoard(report), nil, nil, nil, "")) } func (h *handler) GetMonthlyLeaderBoard(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "delivery", "method": "GetMonthlyLeaderBoard", }) var month *time.Time if c.Query("month") != "" { m, err := time.Parse(time.RFC3339, c.Query("month")) if err != nil { l.Error(err, "failed to parse month") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "failed to parse month")) return } month = &m } // Get data of current month report, err := h.controller.DeliveryMetric.GetMonthlyLeaderBoard(month) if err != nil { l.Error(err, "failed to get monthly leaderboard") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "failed to get monthly leaderboard")) return } // Return data c.JSON(http.StatusOK, view.CreateResponse[any](view.ToDeliveryMetricLeaderBoard(report), nil, nil, nil, "")) }
```

# pkg/handler/deliverymetric/interface.go

```go
package deliverymetric import "github.com/gin-gonic/gin" type IHandler interface { GetWeeklyReport(c *gin.Context) GetMonthlyReport(c *gin.Context) GetWeeklyLeaderBoard(c *gin.Context) GetMonthlyLeaderBoard(c *gin.Context) GetWeeklyReportDiscordMsg(c *gin.Context) GetMonthlyReportDiscordMsg(c *gin.Context) Sync(c *gin.Context) }
```

# pkg/handler/deliverymetric/new.go

```go
package deliverymetric import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" ) type handler struct { controller *controller.Controller store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ controller: controller, store: store, repo: repo, service: service, logger: logger, config: cfg, } }
```

# pkg/handler/deliverymetric/sync.go

```go
package deliverymetric import ( "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/gin-gonic/gin" "net/http" ) func (h *handler) Sync(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "deliverymetric", "method": "Sync", }, ) err := h.controller.DeliveryMetric.Sync() if err != nil { l.Errorf(err, "failed to create delivery metric") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) }
```

# pkg/handler/discord/discord.go

```go
package discord import ( "context" "errors" "fmt" "math/rand" "net/http" "sort" "strconv" "strings" "time" "github.com/bwmarrin/discordgo" "github.com/gin-gonic/gin" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/handler/discord/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/service/mochiprofile" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/store/discordevent" "github.com/dwarvesf/fortress-api/pkg/store/employee" "github.com/dwarvesf/fortress-api/pkg/store/onleaverequest" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { controller *controller.Controller store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ controller: controller, store: store, repo: repo, service: service, logger: logger, config: cfg, } } const ( discordReadingChannel = "1225085624260759622" discordRandomChannel = "788084358991970337" discordPlayGroundReadingChannel = "1119171172198797393" ) func (h *handler) SyncDiscordInfo(c *gin.Context) { guildMembers, err := h.service.Discord.GetMembers() if err != nil { h.logger.Error(err, "failed to get guild members") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } for _, member := range guildMembers { if member.User.Bot { continue } communityProfile := model.DiscordAccount{ DiscordID: member.User.ID, PersonalEmail: member.User.Email, DiscordUsername: member.User.Username, Roles: member.Roles, // currently an array of Discord role_id(s) MemoUsername: member.User.Username, // default memo username is discord username } mochiPrf, err := h.service.MochiProfile.GetProfileByDiscordID(member.User.ID) if err == nil { for _, account := range mochiPrf.AssociatedAccounts { if account.Platform == mochiprofile.ProfilePlatformGithub { communityProfile.GithubUsername = fmt.Sprintf("%v", account.PlatformMetadata["username"]) } } } _, err = h.store.DiscordAccount.Upsert(h.repo.DB(), &communityProfile) if err != nil { h.logger.Error(err, "failed to upsert discord account") } } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // BirthdayDailyMessage check if today is birthday of any employee in the system // if yes, send birthday message to employee through discord func (h *handler) BirthdayDailyMessage(c *gin.Context) { // check app run mode projectID := consts.OperationID todoListID := consts.BirthdayToDoListID if h.config.Env != "prod" { projectID = consts.PlaygroundID todoListID = consts.PlaygroundBirthdayTodoID } //random message pool pool := []string{ `Dear %s, we wish you courage and persistence in reaching all your greatest goals. Have a great birthday!`, `Happy Birthday to %s. No one knows your real age, except God, Human Resources and you yourself. Enjoy the blast!`, `Happy Birthday, %s! Thank you for being such a great team player and for giving us a perfect excuse to party on a weekday! Let's go grab a drink!`, `Just so you know you'd look much younger if not for working in this field :) Happy Birthday, %s`, `Congratulation on a great day! Here's to another year closer of retiring! Happy Birthday, %s!`, `%s, thank you for being a part of making this company more lively and cheerful. Wish you all the best in this special day.`, `Dear %s, we wish you a great birthday and a memorable year. From all the Dwarves brothers.`, `I canâ€™t believe you are still single â€“ lol. I hope you have a super day and get everything you want like a companion to share it with. Happy birthday to %s!`, `Hereâ€™s to another year of version controlling, bug reports, and comments about the documentation looking like code. Happy birthday, mate %s!`, `Hope your birthday loops run smoothly and that you donâ€™t break out of the for loop too soon. Cheers, %s!`, `Happy birthday, %s. May your code works perfectly the first time you ran it.`, `I wish you could have a programming language that does not need compiling, installing, or debugging to run perfectly on the first run. Have a happy birthday, %s`, } // query active user filter := employee.EmployeeFilter{ WorkingStatuses: []string{"full-time"}, } employees, _, err := h.store.Employee.All(h.repo.DB(), filter, model.Pagination{ Page: 0, Size: 1000, }) if err != nil { h.logger.Error(err, "failed to get employees") c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "")) return } // format message if there is user's birthday var names string var birthDateNames []string todayDate := time.Now().Format("01/02") for _, e := range employees { now := time.Now() if now.Day() == e.DateOfBirth.Day() && now.Month() == e.DateOfBirth.Month() { if e.DiscordAccount != nil && e.DiscordAccount.DiscordID != "" { discordID := e.DiscordAccount.DiscordID names += fmt.Sprintf("<@%s>, ", discordID) birthDateNames = append(birthDateNames, e.FullName) } } } if len(birthDateNames) == 0 { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "no birthday today")) return } rand.New(rand.NewSource(time.Now().Unix())) msg := fmt.Sprintf(pool[rand.Intn(len(pool))], strings.TrimSuffix(names, ", ")) //send message to Discord channel var discordMsg model.DiscordMessage discordMsg, err = h.service.Discord.PostBirthdayMsg(msg) if err != nil { h.logger.Error(err, "failed to post Discord message") c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, discordMsg, "")) return } //Make Basecamp todos for _, birthDateName := range birthDateNames { birthDayTodo := bcModel.Todo{ Title: fmt.Sprintf("Prepare gift for %s, %s", birthDateName, todayDate), Content: fmt.Sprintf("Prepare gift for %s, %s", birthDateName, todayDate), } _, err := h.service.Basecamp.Todo.Create(projectID, todoListID, birthDayTodo) if err != nil { h.logger.Error(err, "failed create Basecamp todo") c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, birthDateName, "k")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // OnLeaveMessage check if today is birthday of any employee in the system // if yes, send birthday message to employee thru discord func (h *handler) OnLeaveMessage(c *gin.Context) { todayDate := time.Now().Format("2006-01-02") onLeaveData, err := h.store.OnLeaveRequest.All(h.repo.DB(), onleaverequest.GetOnLeaveInput{Date: todayDate}) if err != nil { h.logger.Error(err, "failed to get employees") c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "")) return } if len(onLeaveData) == 0 { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "there is no one on leave today")) return } var names string for _, e := range onLeaveData { names += fmt.Sprintf("<@%s>, ", e.Creator.DiscordAccount.DiscordID) } msg := fmt.Sprintf("Please be notified that %s will be absent today", strings.TrimSuffix(names, ", ")) discordMsg, err := h.service.Discord.SendMessage(model.DiscordMessage{ Content: msg, }, h.config.Discord.Webhooks.AuditLog) if err != nil { h.logger.Error(err, "failed to post Discord message") c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, discordMsg, "")) return } h.logger.Infof("Discord message sent: %s", msg) c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // ReportBraineryMetrics reports brainery metrics to a channel func (h *handler) ReportBraineryMetrics(c *gin.Context) { body := request.BraineryReportInput{} if err := c.ShouldBindJSON(&body); err != nil { h.logger.Error(err, "failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } if err := body.Validate(); err != nil { h.logger.Errorf(err, "failed to validate data", "body", body) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } now := time.Now() if body.View == "monthly" { now = now.Add(-24 * time.Hour) } latestPosts, logs, ncids, err := h.controller.BraineryLog.GetMetrics(now, body.View) if err != nil { h.logger.Error(err, "failed to get brainery metrics") c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "")) return } metrics := view.ToBraineryMetric(latestPosts, logs, ncids, body.View) //send message to Discord channel var discordMsg *discordgo.Message discordMsg, err = h.service.Discord.ReportBraineryMetrics(body.View, &metrics, body.ChannelID) if err != nil { h.logger.Error(err, "failed to report brainery metrics discord message") c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, discordMsg, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } func (h *handler) DeliveryMetricsReport(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "discord", "method": "DeliveryMetricsReport", }, ) in := request.DeliveryMetricReportInput{} if err := c.ShouldBindJSON(&in); err != nil { l.Error(err, "failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, "")) return } if err := in.Validate(); err != nil { l.Errorf(err, "failed to validate data", "body", in) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, "")) return } if in.Sync { err := h.controller.DeliveryMetric.Sync() if err != nil { l.Errorf(err, "failed sync latest data", "body", in) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, "")) return } } if in.View == "weekly" { report, err := h.controller.DeliveryMetric.GetWeeklyReport() if err != nil { l.Errorf(err, "failed to get delivery metric weekly report", "body", in) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, "")) return } leaderBoard, err := h.controller.DeliveryMetric.GetWeeklyLeaderBoard() if err != nil { l.Errorf(err, "failed to get delivery metric weekly report", "body", in) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, "")) return } reportView := view.ToDeliveryMetricWeeklyReport(report) leaderBoardView := view.ToDeliveryMetricLeaderBoard(leaderBoard) discordMsg, err := h.service.Discord.DeliveryMetricWeeklyReport(reportView, leaderBoardView, in.ChannelID) if err != nil { h.logger.Error(err, "failed to post Discord message") c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, discordMsg, "")) return } } if in.View == "monthly" { report, err := h.controller.DeliveryMetric.GetMonthlyReport() if err != nil { l.Errorf(err, "failed to get delivery metric weekly report", "body", in) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, "")) return } currentMonthReport := report.Reports[0] previousMonthReport := report.Reports[1] if in.OnlyCompletedMonth { currentMonthReport = report.Reports[1] previousMonthReport = report.Reports[2] } leaderBoard, err := h.controller.DeliveryMetric.GetMonthlyLeaderBoard(currentMonthReport.Month) if err != nil { l.Errorf(err, "failed to get delivery metric weekly report", "body", in) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, "")) return } reportView := view.ToDeliveryMetricMonthlyReport(currentMonthReport, previousMonthReport) leaderBoardView := view.ToDeliveryMetricLeaderBoard(leaderBoard) discordMsg, err := h.service.Discord.DeliveryMetricMonthlyReport(reportView, leaderBoardView, in.ChannelID) if err != nil { h.logger.Error(err, "failed to post Discord message") c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, discordMsg, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // SyncMemo syncs memologs from the source memo.d.foundation func (h *handler) SyncMemo(c *gin.Context) { targetChannelID := discordPlayGroundReadingChannel if h.config.Env == "prod" { targetChannelID = discordRandomChannel } memos, err := h.controller.MemoLog.Sync() if err != nil { h.logger.Error(err, "failed to sync memologs") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if len(memos) == 0 { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "no new memo")) return } _, err = h.service.Discord.SendNewMemoMessage(h.config.Discord.IDs.DwarvesGuild, memos, targetChannelID) if err != nil { h.logger.Error(err, "failed to send new memo message") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // SweepMemo sweeps memologs func (h *handler) SweepMemo(c *gin.Context) { err := h.controller.MemoLog.Sweep() if err != nil { h.logger.Error(err, "failed to sweep memologs") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } func (h *handler) NotifyWeeklyMemos(c *gin.Context) { // get last 7 days end := time.Now() start := end.AddDate(0, 0, -7) var weekRangeStr string startDay := start.Day() endDay := end.Day() startMonth := strings.ToUpper(start.Month().String()) endMonth := strings.ToUpper(end.Month().String()) if startMonth == endMonth { weekRangeStr = fmt.Sprintf("%v - %v %v", startDay, endDay, startMonth) } else { weekRangeStr = fmt.Sprintf("%v %v - %v %v", startDay, startMonth, endDay, endMonth) } memos, err := h.store.MemoLog.GetLimitByTimeRange(h.repo.DB(), &start, &end, 1000) if err != nil { h.logger.Error(err, "failed to retrieve weekly memos") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if len(memos) == 0 { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "no new memos in this week")) return } targetChannelID := discordPlayGroundReadingChannel if h.config.Env == "prod" { targetChannelID = discordRandomChannel } _, err = h.service.Discord.SendWeeklyMemosMessage(h.config.Discord.IDs.DwarvesGuild, memos, weekRangeStr, targetChannelID) if err != nil { h.logger.Error(err, "failed to send weekly memos report") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // CreateScheduledEvent create new DF guild discord event func (h *handler) CreateScheduledEvent(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "discord", "method": "CreateScheduledEvent", }, ) in := request.DiscordEventInput{} if err := c.ShouldBindJSON(&in); err != nil { l.Error(err, "failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, "")) return } if err := in.Validate(); err != nil { l.Errorf(err, "failed to validate data", "body", in) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, "")) return } // check if event already exists if _, err := h.store.DiscordEvent. One(h.repo.DB(), &discordevent.Query{DiscordEventID: in.ID}); !errors.Is(err, gorm.ErrRecordNotFound) { l.Errorf(err, "cannot find discord event", "body", in) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, "")) return } evtType, err := in.EventType() if err != nil { l.Errorf(err, "failed to set event type", "body", in) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, "")) return } // create event e := &model.Event{ DiscordEventID: in.ID, DiscordChannelID: in.DiscordChannelID, DiscordCreatorID: in.DiscordCreatorID, Name: in.Name, Description: in.Description, Date: in.Date, EventType: evtType, Image: in.Image, } _, err = h.store.DiscordEvent.Create(h.repo.DB(), e) if err != nil { h.logger.Error(err, "failed to create event") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // create youtube broadcast if evtType == model.DiscordScheduledEventTypeOGIF { err = h.service.Youtube.CreateBroadcast(e) if err != nil { h.logger.Error(err, "failed to create youtube broadcast") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // ListScheduledEvent returns list of scheduled events func (h *handler) ListScheduledEvent(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "discord", "method": "ListScheduledEvent", }, ) var err error // get scheduled events from discord discordScheduledEvents, err := h.service.Discord.ListEvents() if err != nil { l.Error(err, "failed to get scheduled events") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } eventIDs := make([]string, 0) for _, e := range discordScheduledEvents { eventIDs = append(eventIDs, e.ID) } // Get future events now := time.Now() events, err := h.store.DiscordEvent.All(h.repo.DB(), &discordevent.Query{ DiscordEventIDs: eventIDs, }, false) if err != nil { l.Error(err, "failed to get events") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } mapUpcomingEvents := make(map[string]bool) for _, e := range events { mapUpcomingEvents[e.DiscordEventID] = true } // Get completed events in the last 7 days, sometimes we need to update these events // If the event has date in the future, but cannot be found in discord, it means it has been done earlier after := now.AddDate(0, 0, -7) completedEvents, err := h.store.DiscordEvent.All(h.repo.DB(), &discordevent.Query{ After: &after, }, false) if err != nil { l.Error(err, "failed to get completed events") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } for i := range completedEvents { event := completedEvents[i] if _, ok := mapUpcomingEvents[event.DiscordEventID]; ok { continue } event.IsOver = true events = append(events, event) } sort.Slice(events, func(i, j int) bool { return events[i].Date.After(events[j].Date) }) c.JSON(http.StatusOK, view.CreateResponse[any](events, nil, nil, nil, "ok")) } // SetScheduledEventSpeakers sets speakers for a scheduled event func (h *handler) SetScheduledEventSpeakers(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "discord", "method": "SetScheduledEventSpeakers", }, ) in := []request.DiscordEventSpeakerInput{} if err := c.ShouldBindJSON(&in); err != nil { l.Error(err, "failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, "")) return } for _, i := range in { if err := i.Validate(); err != nil { l.Errorf(err, "failed to validate data", "body", in) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, "")) return } } // get event discordEventID := c.Param("id") event, err := h.store.DiscordEvent.One(h.repo.DB(), &discordevent.Query{DiscordEventID: discordEventID}) if err != nil { l.Errorf(err, "failed to get event", "body", in) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, in, "")) return } // delete all speakers if err = h.store.EventSpeaker.DeleteAllByEventID(h.repo.DB(), event.ID.String()); err != nil { l.Errorf(err, "failed to delete all speakers", "body", in) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, "")) return } event.EventSpeakers = make([]model.EventSpeaker, 0) // get speakers for _, i := range in { speaker, err := h.store.DiscordAccount.OneByDiscordID(h.repo.DB(), i.ID) if errors.Is(err, gorm.ErrRecordNotFound) { discordUser, err := h.service.Discord.GetMember(i.ID) if err != nil { l.Errorf(err, "failed to get discord user", "body", in) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, "")) return } speaker = &model.DiscordAccount{ DiscordID: i.ID, DiscordUsername: discordUser.User.Username, } _, err = h.store.DiscordAccount.Upsert(h.repo.DB(), speaker) if err != nil { l.Errorf(err, "failed to upsert speaker", "body", in) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, "")) return } } else if err != nil { l.Errorf(err, "failed to get speaker", "body", in) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, "")) return } event.EventSpeakers = append(event.EventSpeakers, model.EventSpeaker{ EventID: event.ID, DiscordAccountID: speaker.ID, Topic: i.Topic, }) } // set speakers err = h.store.DiscordEvent.SetSpeakers(h.repo.DB(), event) if err != nil { l.Errorf(err, "failed to set speakers", "body", in) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, in, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToDiscordEvent(*event), nil, nil, nil, "")) } // ListDiscordResearchTopics godoc // @Summary Get list of research topics on discord // @Description Get list of research topics on discord // @id ListDiscordResearchTopics // @Tags Discord // @Accept json // @Produce json // @Param page query string false "Page" // @Param size query string false "Size" // @Success 200 {object} ListResearchTopicResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /discords/research-topics [get] func (h *handler) ListDiscordResearchTopics(c *gin.Context) { var query model.Pagination if err := c.ShouldBindQuery(&query); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "bind query failed")) return } query.Standardize() limit, offset := query.ToLimitOffset() // Default by last 7 days, 0 is get all inputDays := c.Query("days") if inputDays == "" { inputDays = "7" } days, err := strconv.Atoi(inputDays) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "invalid days query")) } topics, total, err := h.controller.Discord.ListDiscordResearchTopics(context.Background(), days, limit, offset) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse(view.ToListResearchTopicResponse(topics), &view.PaginationResponse{ Pagination: view.Pagination{ Page: query.Page, Size: query.Size, }, Total: total, }, nil, nil, "")) } func (h *handler) UserOgifStats(c *gin.Context) { discordID := c.Query("discordID") if discordID == "" { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errors.New("discord_id is required"), nil, "")) return } var afterTime time.Time after := c.Query("after") if after != "" { var err error afterTime, err = time.Parse(time.RFC3339, after) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errors.New("invalid after time format"), nil, "")) return } } stats, err := h.controller.Discord.UserOgifStats(c.Request.Context(), discordID, afterTime) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, errors.New("discord_id is required"), nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse(stats, nil, nil, nil, "")) } func (h *handler) OgifLeaderboard(c *gin.Context) { var afterTime time.Time after := c.Query("after") if after != "" { var err error afterTime, err = time.Parse(time.RFC3339, after) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errors.New("invalid after time format"), nil, "")) return } } limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10")) leaderboard, err := h.controller.Discord.GetOgifLeaderboard(c.Request.Context(), afterTime, limit) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse(leaderboard, nil, nil, nil, "")) } func (h *handler) SweepOgifEvent(c *gin.Context) { err := h.controller.Event.SweepOgifEvent(c.Request.Context()) if err != nil { h.logger.Error(err, "failed to sweep events") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "events swept successfully")) }
```

# pkg/handler/discord/errs/errors.go

```go
package errs import "errors" var ( ErrEmptyReportView = errors.New("view is empty") ErrEmptyChannelID = errors.New("channelID is empty") ErrEmptyGuildID = errors.New("guildID is empty") ErrEmptyCreatorID = errors.New("creatorID is empty") ErrEmptyName = errors.New("name is empty") ErrEmptyDate = errors.New("date is nil") ErrEmptyID = errors.New("discord user id is nil") ErrEmptyTopic = errors.New("topic is nil") )
```

# pkg/handler/discord/interface.go

```go
package discord import "github.com/gin-gonic/gin" type IHandler interface { SyncDiscordInfo(c *gin.Context) BirthdayDailyMessage(c *gin.Context) OnLeaveMessage(c *gin.Context) ReportBraineryMetrics(c *gin.Context) DeliveryMetricsReport(c *gin.Context) SyncMemo(c *gin.Context) SweepMemo(c *gin.Context) NotifyWeeklyMemos(c *gin.Context) CreateScheduledEvent(c *gin.Context) ListScheduledEvent(c *gin.Context) SetScheduledEventSpeakers(c *gin.Context) ListDiscordResearchTopics(c *gin.Context) UserOgifStats(c *gin.Context) OgifLeaderboard(c *gin.Context) SweepOgifEvent(c *gin.Context) }
```

# pkg/handler/discord/request/request.go

```go
package request import ( "errors" "strings" "time" "github.com/dwarvesf/fortress-api/pkg/handler/discord/errs" "github.com/dwarvesf/fortress-api/pkg/model" ) type BraineryReportInput struct { View string `json:"view" binding:"required"` ChannelID string `json:"channelID" binding:"required"` } func (input BraineryReportInput) Validate() error { if len(input.View) == 0 { return errs.ErrEmptyReportView } if len(input.ChannelID) == 0 { return errs.ErrEmptyChannelID } return nil } type DeliveryMetricReportInput struct { View string `json:"view" binding:"required"` ChannelID string `json:"channelID" binding:"required"` OnlyCompletedMonth bool `json:"onlyCompletedMonth"` Sync bool `json:"sync"` } func (input DeliveryMetricReportInput) Validate() error { if len(input.View) == 0 { return errs.ErrEmptyReportView } if len(input.ChannelID) == 0 { return errs.ErrEmptyChannelID } return nil } type DiscordEventInput struct { ID string `json:"id"` Name string `json:"name"` Description string `json:"description"` Date time.Time `json:"date"` Image string `json:"image"` DiscordEventID string `json:"discord_event_id"` DiscordChannelID string `json:"discord_channel_id"` DiscordCreatorID string `json:"discord_creator_id"` DiscordMessageID string `json:"discord_message_id"` } func (input DiscordEventInput) Validate() error { if len(input.Name) == 0 { return errs.ErrEmptyName } if len(input.DiscordChannelID) == 0 { return errs.ErrEmptyChannelID } if len(input.DiscordCreatorID) == 0 { return errs.ErrEmptyCreatorID } return nil } func (in DiscordEventInput) EventType() (model.DiscordScheduledEventType, error) { switch { case strings.Contains(strings.ToLower(in.Description), "demo"), strings.Contains(strings.ToLower(in.Name), "demo"), strings.Contains(strings.ToLower(in.Description), "showcase"), strings.Contains(strings.ToLower(in.Name), "showcase"): return model.DiscordScheduledEventTypeDemo, nil case strings.Contains(strings.ToLower(in.Description), "ogif"), strings.Contains(strings.ToLower(in.Name), "ogif"): return model.DiscordScheduledEventTypeOGIF, nil default: return model.DiscordScheduledEventType(""), errors.New("invalid event type") } } type DiscordEventSpeakerInput struct { ID string `json:"id"` Topic string `json:"topic"` } func (input DiscordEventSpeakerInput) Validate() error { if len(input.ID) == 0 { return errs.ErrEmptyID } if len(input.Topic) == 0 { return errs.ErrEmptyTopic } return nil }
```

# pkg/handler/earn/earn.go

```go
package earn import ( "net/http" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config controller *controller.Controller } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, controller: controller, } } // ListEarn godoc // @Summary List of earns from memo // @Description List of earns from memo // @Tags Earn // @Accept json // @Produce json // @Success 200 {object} ListEarnResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /earn [get] func (h *handler) ListEarn(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "vault", "method": "ListEarn", }) earns, err := h.controller.Earn.ListEarn(c.Request.Context()) if err != nil { l.Error(err, "get list earn failed") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) } c.JSON(http.StatusOK, view.CreateResponse(view.ToEarns(earns), nil, nil, nil, "")) }
```

# pkg/handler/earn/interface.go

```go
package earn import "github.com/gin-gonic/gin" type IHandler interface { ListEarn(c *gin.Context) }
```

# pkg/handler/employee/employee.go

```go
package employee import ( "errors" "fmt" "net/http" "strconv" "time" "github.com/gin-gonic/gin" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/controller/employee" "github.com/dwarvesf/fortress-api/pkg/handler/employee/errs" "github.com/dwarvesf/fortress-api/pkg/handler/employee/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/utils" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { controller *controller.Controller store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ controller: controller, store: store, repo: repo, service: service, logger: logger, config: cfg, } } // List godoc // @Summary Get the list of employees // @Description Get the list of employees with pagination and workingStatus // @id getEmployeeList // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param Body body GetListEmployeeQuery true "Body" // @Success 200 {object} EmployeeListDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/search [post] func (h *handler) List(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } var body request.GetListEmployeeQuery if err := c.ShouldBindJSON(&body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } if err := body.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "List", "params": body, }) workingStatuses, err := h.getWorkingStatusInput(body.WorkingStatuses, userInfo) if err != nil { l.Error(err, "failed to get working status") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) } pagination := model.Pagination{ Page: body.Pagination.Page, Size: body.Pagination.Size, } pagination.Standardize() requestBody := employee.GetListEmployeeInput{ Pagination: pagination, WorkingStatuses: body.WorkingStatuses, Preload: body.Preload, Positions: body.Positions, Stacks: body.Stacks, Projects: body.Projects, Chapters: body.Chapters, Seniorities: body.Seniorities, Organizations: body.Organizations, LineManagers: body.LineManagers, Keyword: body.Keyword, } employees, total, err := h.controller.Employee.List(workingStatuses, requestBody, userInfo) if err != nil { l.Error(err, "failed to get list employees") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse(view.ToEmployeeListData(employees, userInfo), &view.PaginationResponse{Pagination: view.Pagination{Page: pagination.Page, Size: pagination.Size, Sort: pagination.Sort}, Total: total}, nil, nil, "")) } func (h *handler) getWorkingStatusInput(input []string, userInfo *model.CurrentLoggedUserInfo) ([]string, error) { // user who do not have permission if !authutils.HasPermission(userInfo.Permissions, model.PermissionEmployeesReadFilterByAllStatuses) { if len(input) == 0 { return []string{ model.WorkingStatusOnBoarding.String(), model.WorkingStatusProbation.String(), model.WorkingStatusFullTime.String(), model.WorkingStatusContractor.String(), }, nil } var result []string for _, v := range input { if v != model.WorkingStatusLeft.String() { result = append(result, v) } } return result, nil } // user who have permission if len(input) == 0 { return []string{ model.WorkingStatusOnBoarding.String(), model.WorkingStatusProbation.String(), model.WorkingStatusFullTime.String(), model.WorkingStatusContractor.String(), model.WorkingStatusLeft.String(), }, nil } return input, nil } // Details godoc // @Summary Get employee by id // @Description Get employee by id // @id getEmployeeDetails // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Employee ID" // @Success 200 {object} EmployeeDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/{id} [get] func (h *handler) Details(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } // 1. parse id from uri, validate id id := c.Param("id") // 1.1 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "Details", "id": id, }) rs, err := h.controller.Employee.Details(id, userInfo) if err != nil { l.Error(err, "failed to get detail employees") errs.ConvertControllerErr(c, err) return } // 3. return employee c.JSON(http.StatusOK, view.CreateResponse[any](view.ToOneEmployeeData(rs, userInfo), nil, nil, nil, "")) } // UpdateEmployeeStatus godoc // @Summary Update account status by employee id // @Description Update account status by employee id // @id updateEmployeeStatus // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Employee ID" // @Param employeeStatus body UpdateWorkingStatusRequest true "Employee Status" // @Success 200 {object} UpdateEmployeeStatusResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/{id}/employee-status [put] func (h *handler) UpdateEmployeeStatus(c *gin.Context) { employeeID := c.Param("id") if employeeID == "" || !model.IsUUIDFromString(employeeID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEmployeeID, nil, "")) return } var body request.UpdateWorkingStatusRequest if err := c.ShouldBindJSON(&body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "UpdateEmployeeStatus", "id": employeeID, }) if err := body.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } emp, err := h.controller.Employee.UpdateEmployeeStatus(employeeID, employee.UpdateWorkingStatusInput{ EmployeeStatus: model.WorkingStatus(body.EmployeeStatus), IsKeepFwdEmail: body.IsKeepFwdEmail, }) if err != nil { l.Error(err, "failed to update employee status") errs.ConvertControllerErr(c, err) return } userID, _ := authutils.GetUserIDFromContext(c, h.config) err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "employee_update_working_status", Data: map[string]interface{}{ "working_status": emp.WorkingStatus.String(), "employee_id": userID, "updated_employee_id": emp.ID.String(), }, }) if err != nil { l.Error(err, "failed to logs to discord") } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEmployeeData(emp), nil, nil, nil, "")) } // UpdateGeneralInfo godoc // @Summary Update general info of the employee by id // @Description Update general info of the employee by id // @id updateGeneralInfo // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Employee ID" // @Param Body body UpdateEmployeeGeneralInfoRequest true "Body" // @Success 200 {object} UpdateGeneralEmployeeResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/{id}/general-info [put] func (h *handler) UpdateGeneralInfo(c *gin.Context) { employeeID := c.Param("id") if employeeID == "" || !model.IsUUIDFromString(employeeID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEmployeeID, nil, "")) return } var body request.UpdateEmployeeGeneralInfoRequest if err := c.ShouldBindJSON(&body); err != nil { if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } } l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "UpdateGeneralInfo", "request": body, }) requestBody := employee.UpdateEmployeeGeneralInfoInput{ FullName: body.FullName, Email: body.Email, Phone: body.Phone, LineManagerID: model.UUID(body.LineManagerID), DisplayName: body.DisplayName, GithubID: body.GithubID, NotionID: body.NotionID, NotionName: body.NotionName, NotionEmail: body.NotionEmail, DiscordName: body.DiscordName, LinkedInName: body.LinkedInName, LeftDate: body.LeftDate, JoinedDate: body.JoinedDate, OrganizationIDs: view.ToModelUUIDs(body.OrganizationIDs), ReferredBy: model.UUID(body.ReferredBy), WiseRecipientID: body.WiseRecipientID, WiseAccountNumber: body.WiseAccountNumber, WiseRecipientEmail: body.WiseRecipientEmail, WiseRecipientName: body.WiseRecipientName, WiseCurrency: body.WiseCurrency, } emp, err := h.controller.Employee.UpdateGeneralInfo(employeeID, requestBody) if err != nil { l.Error(err, "failed to update general info for employee") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateGeneralInfoEmployeeData(emp), nil, nil, nil, "")) } // Create godoc // @Summary Create new employee // @Description Create new employee // @id createEmployee // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param Body body CreateEmployeeRequest true "Body" // @Success 200 {object} EmployeeDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees [post] func (h *handler) Create(c *gin.Context) { userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 1. parse eml data from body var input request.CreateEmployeeRequest if err := c.ShouldBindJSON(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } // 1.1 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "Create", "input": input, }) requestBody := employee.CreateEmployeeInput{ FullName: input.FullName, DisplayName: input.DisplayName, TeamEmail: input.TeamEmail, PersonalEmail: input.PersonalEmail, Positions: input.Positions, Salary: input.Salary, SeniorityID: input.SeniorityID, Roles: input.Roles, Status: input.Status, ReferredBy: input.ReferredBy, JoinDate: input.GetJoinedDate(), } eml, err := h.controller.Employee.Create(userID, requestBody) if err != nil { l.Error(err, "failed to create employee") errs.ConvertControllerErr(c, err) return } // 3. return employee c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEmployeeData(eml), nil, nil, nil, "")) } // UpdateSkills godoc // @Summary Update Skill for employee by id // @Description Update Skill for employee by id // @id updateSkill // @Tags Employee // @Accept json // @Produce json // @Param id path string true "Employee ID" // @Security BearerAuth // @Param Body body UpdateSkillsRequest true "Body" // @Success 200 {object} UpdateSkillsEmployeeResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/{id}/skills [put] func (h *handler) UpdateSkills(c *gin.Context) { employeeID := c.Param("id") if employeeID == "" || !model.IsUUIDFromString(employeeID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEmployeeID, nil, "")) return } var body request.UpdateSkillsRequest if err := c.ShouldBindJSON(&body); err != nil { if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } } l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "UpdateSkills", "request": body, }) requestBody := employee.UpdateSkillsInput{ Positions: body.Positions, LeadingChapters: body.LeadingChapters, Chapters: body.Chapters, Seniority: body.Seniority, Stacks: body.Stacks, } emp, err := h.controller.Employee.UpdateSkills(h.logger, employeeID, requestBody) if err != nil { l.Error(err, "failed to update skills") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateSkillEmployeeData(emp), nil, nil, nil, "")) } // UpdatePersonalInfo godoc // @Summary Update personal info of the employee by id // @Description Update personal info of the employee by id // @id updatePersonalInfo // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Employee ID" // @Param Body body UpdatePersonalInfoRequest true "Body" // @Success 200 {object} UpdatePersonalEmployeeResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/{id}/personal-info [put] func (h *handler) UpdatePersonalInfo(c *gin.Context) { employeeID := c.Param("id") if employeeID == "" || !model.IsUUIDFromString(employeeID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEmployeeID, nil, "")) return } var body request.UpdatePersonalInfoRequest if err := c.ShouldBindJSON(&body); err != nil { if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } } l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "UpdatePersonalInfo", "request": body, }) city, err := h.validateAndMappingCity(h.repo.DB(), body.Country, body.City) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } requestBody := employee.UpdatePersonalInfoInput{ DoB: body.DoB, Gender: body.Gender, PlaceOfResidence: body.PlaceOfResidence, Address: body.Address, PersonalEmail: body.PersonalEmail, Country: body.Country, City: body.City, Lat: city.Lat, Long: city.Long, } emp, err := h.controller.Employee.UpdatePersonalInfo(employeeID, requestBody) if err != nil { l.Error(err, "failed to update personal info") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdatePersonalEmployeeData(emp), nil, nil, nil, "")) } func (h *handler) validateAndMappingCity(db *gorm.DB, countryName string, cityName string) (*model.City, error) { country, err := h.store.Country.OneByName(db, countryName) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return nil, errs.ErrCountryNotFound } return nil, err } city := country.Cities.GetCity(cityName) if city == nil { return nil, errs.ErrCityDoesNotBelongToCountry } return city, nil } // UploadAvatar godoc // @Summary Upload avatar of employee by id // @Description Upload avatar of employee by id // @id uploadAvatar // @Tags Employee // @Accept json // @Produce json // @Param id path string true "Employee ID" // @Security BearerAuth // @Param file formData file true "avatar upload" // @Success 200 {object} EmployeeContentDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/{id}/upload-avatar [post] func (h *handler) UploadAvatar(c *gin.Context) { // 1.1 get userID userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } uuidUserID, err := model.UUIDFromString(userID) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 1.2 parse id from uri, validate id var params struct { ID string `uri:"id" binding:"required"` } if err := c.ShouldBindUri(&params); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, params, "")) return } // 1.3 get upload file file, err := c.FormFile("file") if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, file, "")) return } // 1.4 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "UploadAvatar", "params": params, // "body": body, }) filePath, err := h.controller.Employee.UploadAvatar(uuidUserID, file, employee.UploadAvatarInput{ ID: params.ID, }) if err != nil { l.Error(err, "failed to update avatar") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToContentData(filePath), nil, nil, nil, "")) } // UpdateRole godoc // @Summary Update role by employee id // @Description Update role by employee id // @id updateRole // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Employee ID" // @Param Body body UpdateRoleRequest true "body" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/{id}/roles [put] func (h *handler) UpdateRole(c *gin.Context) { userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } var input request.UpdateRoleInput input.EmployeeID = c.Param("id") if err := c.ShouldBindJSON(&input.Body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "UpdateRole", "input": input, }) if err := input.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } inputRequest := employee.UpdateRoleInput{ EmployeeID: input.EmployeeID, Body: employee.UpdateRoleBody{ Roles: input.Body.Roles, }, } err = h.controller.Employee.UpdateRole(userID, inputRequest) if err != nil { l.Error(err, "failed to update role") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // GetLineManagers godoc // @Summary Get the list of line managers // @Description Get the list of line managers // @id getLineManagerList // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} LineManagersResponse // @Failure 500 {object} ErrorResponse // @Router /line-managers [get] func (h *handler) GetLineManagers(c *gin.Context) { userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "GetLineManagers", "userInfo": userInfo.UserID, }) managers, err := h.controller.Employee.GetLineManagers(userInfo) if err != nil { l.Error(err, "failed to get line managers") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToBasicEmployees(managers), nil, nil, nil, "")) } // UpdateBaseSalary godoc // @Summary Update employee's base salary by employee and base salary id // @Description Update employee's base salary by employee and base salary id // @id updateBaseSalary // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Employee ID" // @Param Body body UpdateBaseSalaryRequest true "Body" // @Success 200 {object} UpdateBaseSalaryResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/{id}/base-salary [put] func (h *handler) UpdateBaseSalary(c *gin.Context) { employeeID := c.Param("id") if employeeID == "" || !model.IsUUIDFromString(employeeID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEmployeeID, nil, "")) return } var req request.UpdateBaseSalaryRequest if err := c.ShouldBindJSON(&req); err != nil { if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, "")) return } } l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "UpdateBaseSalary", "request": req, }) requestBody := employee.UpdateBaseSalaryInput{ ContractAmount: req.ContractAmount, CompanyAccountAmount: req.CompanyAccountAmount, PersonalAccountAmount: req.PersonalAccountAmount, CurrencyCode: req.CurrencyCode, EffectiveDate: req.EffectiveDate, Batch: req.Batch, } emp, err := h.controller.Employee.UpdateBaseSalary(h.logger, employeeID, requestBody) if err != nil { l.Error(err, "failed to update base salary") errs.ConvertControllerErr(c, err) return } userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } totalBaseSalary := req.PersonalAccountAmount + req.CompanyAccountAmount formattedBaseSalary := utils.FormatMoney(float64(totalBaseSalary), "VND") // update discord as audit log err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "employee_update_base_salary", Data: map[string]interface{}{ "employee_id": userID, "updated_employee_id": employeeID, "new_salary": formattedBaseSalary, }, }) if err != nil { l.Error(err, "failed to logs to discord") } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToBaseSalary(emp), nil, nil, nil, "")) } // PublicList godoc // @Summary Get public employees list // @Description Get public employees list // @id getPublicEmployeeList // @Tags Public // @Accept json // @Produce json // @Success 200 {object} EmployeeLocationListResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /public/employees [get] func (h *handler) PublicList(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "PublicList", }) employees, err := h.controller.Employee.ListWithLocation() if err != nil { l.Error(err, "failed to list employees") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEmployeesWithLocation(employees), nil, nil, nil, "")) } func (h *handler) ListByDiscordRequest(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } // 1. parse id from uri, validate id discordID := c.Query("discord_id") email := c.Query("email") key := c.Query("key") // 1.1 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "ListByDiscordRequest", }) rs, err := h.controller.Employee.ListByDiscordRequest(discordID, email, key, userInfo) if err != nil { l.Error(err, "failed to get detail employees") errs.ConvertControllerErr(c, err) return } // 3. return employee c.JSON(http.StatusOK, view.CreateResponse[any](view.ToDiscordEmployeeListData(rs, userInfo), nil, nil, nil, "")) } func (h *handler) ListWithMMAScore(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "DetailByDiscord", }) rs, err := h.controller.Employee.ListWithMMAScore() if err != nil { l.Error(err, "failed to get employees with mma scores") errs.ConvertControllerErr(c, err) return } // 3. return employee c.JSON(http.StatusOK, view.CreateResponse[any](view.ToEmployeesWithMMAScore(rs), nil, nil, nil, "")) } // SalaryAdvance godoc // @Summary Salary advance by discord id // @Description Salary advance by discord id // @id salaryAdvance // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param salaryAdvanceRequest body SalaryAdvanceRequest true "Salary Advance Request" // @Success 200 {object} SalaryAdvanceResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/advance-salary [post] func (h *handler) SalaryAdvance(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "employee", "method": "SalaryAdvance", }) body := request.SalaryAdvanceRequest{} if err := c.ShouldBindJSON(&body); err != nil { l.Error(err, "failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } amount, err := strconv.Atoi(body.Amount) if err != nil { l.Error(err, "failed to parse amount") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } response, err := h.controller.Employee.SalaryAdvance(body.DiscordID, int64(amount)) if err != nil { l.Error(err, "failed to advance salary") errs.ConvertControllerErr(c, err) return } err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "employee_advance_salary", Data: map[string]interface{}{ "employee_id": response.EmployeeID, "amount": fmt.Sprintf("%v ICY($%v)", response.AmountICY, response.AmountUSD), }, }) if err != nil { l.Error(err, "failed to create discord log") } err = h.controller.Discord.PublicAdvanceSalaryLog(model.LogDiscordInput{ Data: map[string]interface{}{ "icy_amount": response.AmountICY, "usd_amount": response.AmountUSD, }, }) if err != nil { l.Error(err, "failed to create discord public log") } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToSalaryAdvance(response.AmountICY, response.AmountUSD, response.TransactionID, response.TransactionHash), nil, nil, nil, "")) } // CheckSalaryAdvance godoc // @Summary Check salary advance by discord id // @Description Check salary advance by discord id // @id checkSalaryAdvance // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param checkSalaryAdvanceRequest body SalaryAdvanceRequest true "Check Salary Advance Request" // @Success 200 {object} CheckSalaryAdvanceResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /employees/check-advance-salary [post] func (h *handler) CheckSalaryAdvance(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "employee", "method": "CheckSalaryAdvance", }, ) body := request.SalaryAdvanceRequest{} if err := c.ShouldBindJSON(&body); err != nil { l.Error(err, "failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } amountICY, amountUSD, err := h.controller.Employee.CheckSalaryAdvance(body.DiscordID) if err != nil { l.Error(err, "failed to check advance salary") errs.ConvertControllerErr(c, err) return } // 3. return employee c.JSON(http.StatusOK, view.CreateResponse[any](view.ToCheckSalaryAdvance(amountICY, amountUSD), nil, nil, nil, "ok")) } // SalaryAdvanceReport godoc // @Summary List salary advance aggregated by employee // @Description List salary advance aggregated by employee // @id SalaryAdvanceReport // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param SalaryAdvanceReportRequest body SalaryAdvanceReportRequest true "Get List Aggregated Salary Advance Request" // @Success 200 {object} SalaryAdvanceReportResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /discords/salary-advance-report [get] func (h *handler) SalaryAdvanceReport(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "employee", "method": "ListSalaryAdvance", }, ) input := request.SalaryAdvanceReportRequest{} if err := c.ShouldBindQuery(&input); err != nil { l.Error(err, "failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } // default size is 10 if input.Pagination.Size == 0 { input.Pagination.Size = 10 } // default sort by amount_icy if input.Pagination.Sort == "" { input.Pagination.Sort = "amount_icy" } // default sort is DESC if input.SortOrder == "" { input.SortOrder = model.SortOrderDESC } if !input.SortOrder.IsValid() { l.Error(errs.ErrInvalidSortType, "invalid sort type") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidSortType, nil, "")) return } result, err := h.controller.Employee.ListAggregatedSalaryAdvance(employee.ListAggregatedSalaryAdvanceInput{ Pagination: model.Pagination{ Page: input.Pagination.Page, Size: input.Pagination.Size, Sort: input.Pagination.Sort, }, SortOrder: input.SortOrder, IsPaid: input.IsPaid, }) if err != nil { l.Error(err, "failed to list advance salary") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse(view.ToSalaryAdvanceReport(*result), &view.PaginationResponse{Pagination: input.Pagination, Total: result.Count}, nil, nil, "")) } // GetEmployeeEarnTransactions godoc // @Summary List earn transactions of employee // @Description List earn transactions of employee // @id GetEmployeeEarnTransactions // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param discord_id path string true "Employee Discord ID" // @Param page query int false "Page" // @Param size query int false "Size" // @Success 200 {object} GetEmployeeEarnTransactionsResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /discords/{discord_id}/earns/transactions [get] func (h *handler) GetEmployeeEarnTransactions(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "employee", "method": "GetEmployeeEarnTransactions", }, ) discordID := c.Param("discord_id") input := request.GetEmployeeEarnTransactionsRequest{} if err := c.ShouldBindQuery(&input); err != nil { l.Error(err, "failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } // default size is 10 if input.Pagination.Size == 0 { input.Pagination.Size = 10 } result, total, err := h.controller.Employee.GetEmployeeEarnTransactions(discordID, employee.GetEmployeeEarnTransactionsInput{ Pagination: model.Pagination{ Page: input.Pagination.Page, Size: input.Pagination.Size, Sort: input.Pagination.Sort, }, }) if err != nil { l.Error(err, "failed to get employee earn transactions") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse( view.ToEmployeeEarnsTransactions(result), &view.PaginationResponse{ Pagination: view.Pagination{ Page: input.Pagination.Page, Size: input.Pagination.Size, Sort: input.Pagination.Sort, }, Total: total, }, nil, nil, "")) } // GetEmployeeTotalEarn godoc // @Summary Get total earn of employee // @Description Get total earn of employee // @id GetEmployeeTotalEarn // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param discord_id path string true "Employee Discord ID" // @Success 200 {object} GetEmployeeTotalEarnResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /discords/{discord_id}/earns/total [get] func (h *handler) GetEmployeeTotalEarn(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "employee", "method": "GetEmployeeTotalEarn", }, ) discordID := c.Param("discord_id") earnsICY, earnsUSD, err := h.controller.Employee.GetEmployeeTotalEarn(discordID) if err != nil { l.Error(err, "failed to get employee total earn") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse(view.EmployeeTotalEarn{ TotalEarnsICY: earnsICY, TotalEarnsUSD: earnsUSD, }, nil, nil, nil, "")) } func (h *handler) GetTotalEarn(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "employee", "method": "GetTotalEarn", }, ) var err error to := time.Now() from := to.AddDate(0, 0, -30) if c.Query("from") != "" { from, err = time.Parse("2006-01-02", c.Query("from")) if err != nil { l.Error(err, "failed to parse from date") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "invalid from date")) return } } if c.Query("to") != "" { to, err = time.Parse("2006-01-02", c.Query("to")) if err != nil { l.Error(err, "failed to parse to date") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "invalid to date")) return } } earnsICY, earnsUSD, err := h.controller.Employee.GetTotalEarn(from, to) if err != nil { l.Error(err, "failed to get total earn") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse(view.EmployeeTotalEarn{ TotalEarnsICY: earnsICY, TotalEarnsUSD: earnsUSD, }, nil, nil, nil, "")) } // OfficeCheckIn // @Summary OfficeCheckIn for employee // @Description OfficeCheckIn for employee // @id OfficeCheckIn // @Tags Employee // @Accept json // @Produce json // @Security BearerAuth // @Param Body body CheckInRequest true "OfficeCheckIn Request" // @Success 200 {object} CheckInResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /discords/office-checkin [post] func (h *handler) OfficeCheckIn(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "employee", "method": "OfficeCheckIn", }, ) var req request.CheckInRequest if err := c.ShouldBindJSON(&req); err != nil { l.Error(err, "failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, "")) return } icyAmount := 3 // Get the current date without time currentDate := time.Now().Truncate(24 * time.Hour) var resp []view.CheckInResponse for _, v := range req.CheckIns { // Truncate the givenTime to remove the time part givenDate := v.Time.Truncate(24 * time.Hour) // check givenDate does not equal currentDate if currentDate.After(givenDate) || currentDate.Before(givenDate) { resp = append(resp, view.CheckInResponse{ DiscordID: v.DiscordID, Err: "invalid time", }) continue } data := view.CheckInResponse{ DiscordID: v.DiscordID, } r, err := h.controller.Employee.CheckIn(v.DiscordID, v.Time, float64(icyAmount)) if err != nil { l.Error(err, "failed to checkin") data.Err = err.Error() resp = append(resp, data) continue } data.IcyAmount = r.IcyAmount data.TransactionID = r.TransactionID data.TransactionHash = r.TransactionHash resp = append(resp, data) } c.JSON(http.StatusOK, view.CreateResponse[any](resp, nil, nil, nil, "")) }
```

# pkg/handler/employee/errs/errors.go

```go
package errs import ( "errors" "net/http" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/controller/employee" "github.com/dwarvesf/fortress-api/pkg/view" ) var ( ErrInvalidEmployeeID = errors.New("invalid employee ID") ErrInvalidEmployeeStatus = errors.New("invalid value for employee status") ErrInvalidJoinedDate = errors.New("invalid join date") ErrInvalidPositionCode = errors.New("invalid position code") ErrInvalidStackCode = errors.New("invalid stack code") ErrInvalidProjectCode = errors.New("invalid project code") ErrInvalidChapterCode = errors.New("invalid chapter code") ErrInvalidSeniorityCode = errors.New("invalid seniority code") ErrInvalidOrganizationCode = errors.New("invalid organization code") ErrInvalidEmailDomain = errors.New("invalid email domain") ErrRoleCannotBeEmpty = errors.New("role cannot be empty") ErrCountryNotFound = errors.New("country not found") ErrCityDoesNotBelongToCountry = errors.New("city does not belong to country") ErrInvalidLineManagerID = errors.New("invalid line manager ID") ErrInvalidOrganizationID = errors.New("invalid organization ID") ErrInvalidReferredBy = errors.New("invalid referred by") ErrInvalidSortType = errors.New("invalid sort type") ) func ConvertControllerErr(c *gin.Context, err error) { if err == nil { return } var status int switch { case errors.Is(err, employee.ErrEmployeeNotFound), errors.Is(err, employee.ErrLineManagerNotFound), errors.Is(err, employee.ErrRoleNotfound), errors.Is(err, employee.ErrSeniorityNotfound), errors.Is(err, employee.ErrReferrerNotFound), errors.Is(err, employee.ErrOrganizationNotFound), errors.Is(err, employee.ErrStackNotFound), errors.Is(err, employee.ErrPositionNotFound): status = http.StatusNotFound case errors.Is(err, employee.ErrInvalidJoinedDate), errors.Is(err, employee.ErrInvalidLeftDate), errors.Is(err, employee.ErrLeftDateBeforeJoinedDate), errors.Is(err, employee.ErrEmployeeExisted), errors.Is(err, employee.ErrInvalidCountryOrCity), errors.Is(err, employee.ErrInvalidFileExtension), errors.Is(err, employee.ErrInvalidFileSize), errors.Is(err, employee.ErrInvalidAccountRole), errors.Is(err, employee.ErrEmailExisted), errors.Is(err, employee.ErrTeamEmailExisted), errors.Is(err, employee.ErrSalaryAdvanceExceedAmount), errors.Is(err, employee.ErrEmployeeNotFullTime), errors.Is(err, employee.ErrPersonalEmailExisted): status = http.StatusBadRequest default: status = http.StatusInternalServerError } c.JSON(status, view.CreateResponse[any](nil, nil, err, nil, "")) }
```

# pkg/handler/employee/interface.go

```go
package employee import "github.com/gin-gonic/gin" type IHandler interface { Create(c *gin.Context) Details(c *gin.Context) ListByDiscordRequest(c *gin.Context) GetLineManagers(c *gin.Context) List(c *gin.Context) ListWithMMAScore(c *gin.Context) UpdateEmployeeStatus(c *gin.Context) UpdateGeneralInfo(c *gin.Context) UpdateSkills(c *gin.Context) UpdatePersonalInfo(c *gin.Context) UploadAvatar(c *gin.Context) UpdateRole(c *gin.Context) UpdateBaseSalary(c *gin.Context) SalaryAdvance(c *gin.Context) CheckSalaryAdvance(c *gin.Context) SalaryAdvanceReport(c *gin.Context) GetEmployeeEarnTransactions(c *gin.Context) GetEmployeeTotalEarn(c *gin.Context) GetTotalEarn(c *gin.Context) OfficeCheckIn(c *gin.Context) PublicList(c *gin.Context) }
```

# pkg/handler/employee/request/request.go

```go
package request import ( "regexp" "strings" "time" "github.com/dwarvesf/fortress-api/pkg/handler/employee/errs" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) type GetListEmployeeQuery struct { view.Pagination WorkingStatuses []string `json:"workingStatuses" form:"workingStatuses"` Preload bool `json:"preload" form:"preload,default=true"` Positions []string `json:"positions" form:"positions"` Stacks []string `json:"stacks" form:"stacks"` Projects []string `json:"projects" form:"projects"` Chapters []string `json:"chapters" form:"chapters"` Seniorities []string `json:"seniorities" form:"seniorities"` Organizations []string `json:"organizations" form:"organizations"` LineManagers []string `json:"lineManagers" form:"lineManagers"` Keyword string `json:"keyword" form:"keyword"` } // @name GetListEmployeeQuery type UpdateEmployeeGeneralInfoRequest struct { FullName string `form:"fullName" json:"fullName" binding:"required,max=99"` Email string `form:"email" json:"email" binding:"required,email"` Phone string `form:"phone" json:"phone" binding:"required,max=18,min=9"` LineManagerID view.UUID `form:"lineManagerID" json:"lineManagerID"` DisplayName string `form:"displayName" json:"displayName"` GithubID string `form:"githubID" json:"githubID"` NotionID string `form:"notionID" json:"notionID"` NotionName string `form:"notionName" json:"notionName"` NotionEmail string `form:"notionEmail" json:"notionEmail"` DiscordID string `form:"discordID" json:"discordID"` DiscordName string `form:"discordName" json:"discordName"` LinkedInName string `form:"linkedInName" json:"linkedInName"` LeftDate string `form:"leftDate" json:"leftDate"` JoinedDate string `form:"joinedDate" json:"joinedDate"` OrganizationIDs []view.UUID `form:"organizationIDs" json:"organizationIDs"` ReferredBy view.UUID `form:"referredBy" json:"referredBy"` WiseRecipientID string `form:"wiseRecipientID" json:"wiseRecipientID"` WiseRecipientEmail string `form:"wiseRecipientEmail" json:"wiseRecipientEmail"` WiseRecipientName string `form:"wiseRecipientName" json:"wiseRecipientName"` WiseAccountNumber string `form:"wiseAccountNumber" json:"wiseAccountNumber"` WiseCurrency string `form:"wiseCurrency" json:"wiseCurrency"` } // @name UpdateEmployeeGeneralInfoRequest type UpdateBaseSalaryRequest struct { ContractAmount int64 `form:"contractAmount" json:"contractAmount" binding:"gte=0"` CompanyAccountAmount int64 `form:"companyAccountAmount" json:"companyAccountAmount" binding:"gte=0"` PersonalAccountAmount int64 `form:"personalAccountAmount" json:"personalAccountAmount" binding:"gte=0"` CurrencyCode string `form:"currencyCode" json:"currencyCode" binding:"required"` EffectiveDate *time.Time `form:"effectiveDate" json:"effectiveDate"` Batch int `form:"batch" json:"batch" binding:"required,eq=1|eq=15"` } // @name UpdateBaseSalaryRequest type AddMenteeInput struct { MenteeID model.UUID `form:"menteeID" json:"menteeID" binding:"required"` } type DeleteMenteeInput struct { MentorID string MenteeID string } func (e *DeleteMenteeInput) Validate() error { if e.MentorID == "" || !model.IsUUIDFromString(e.MentorID) { return errs.ErrInvalidEmployeeID } if e.MenteeID == "" || !model.IsUUIDFromString(e.MenteeID) { return errs.ErrInvalidEmployeeID } return nil } // CreateEmployeeRequest view for create new employee type CreateEmployeeRequest struct { FullName string `json:"fullName" binding:"required,max=100"` DisplayName string `json:"displayName" binding:"required"` TeamEmail string `json:"teamEmail" binding:"required"` PersonalEmail string `json:"personalEmail" binding:"required,email"` Positions []model.UUID `form:"positions" json:"positions" binding:"required"` Salary int64 `json:"salary" binding:"required"` SeniorityID model.UUID `json:"seniorityID" binding:"required"` Roles []model.UUID `json:"roles" binding:"required"` Status string `json:"status" binding:"required"` ReferredBy model.UUID `json:"referredBy"` JoinedDate string `json:"joinedDate" binding:"required"` } // @name CreateEmployeeRequest type UpdateSkillsRequest struct { Positions []model.UUID `form:"positions" json:"positions" binding:"required"` LeadingChapters []model.UUID `form:"leadingChapters" json:"leadingChapters"` Chapters []model.UUID `form:"chapters" json:"chapters" binding:"required"` Seniority model.UUID `form:"seniority" json:"seniority" binding:"required"` Stacks []model.UUID `form:"stacks" json:"stacks" binding:"required"` } // @name UpdateSkillsRequest type UpdatePersonalInfoRequest struct { DoB *time.Time `form:"dob" json:"dob" binding:"required"` Gender string `form:"gender" json:"gender" binding:"required"` PlaceOfResidence string `form:"placeOfResidence" json:"placeOfResidence"` Address string `form:"address" json:"address" binding:"required,max=200"` PersonalEmail string `form:"personalEmail" json:"personalEmail" binding:"required,email"` Country string `form:"country" json:"country" binding:"required"` City string `form:"city" json:"city" binding:"required"` } // @name UpdatePersonalInfoRequest type UpdateWorkingStatusRequest struct { EmployeeStatus WorkingStatus `json:"employeeStatus"` IsKeepFwdEmail bool `json:"isKeepFwdEmail"` } // @name UpdateWorkingStatusRequest type WorkingStatus string // @name WorkingStatus const ( WorkingStatusOnBoarding WorkingStatus = "on-boarding" WorkingStatusLeft WorkingStatus = "left" WorkingStatusProbation WorkingStatus = "probation" WorkingStatusFullTime WorkingStatus = "full-time" WorkingStatusContractor WorkingStatus = "contractor" ) func (e WorkingStatus) IsValid() bool { switch e { case WorkingStatusOnBoarding, WorkingStatusContractor, WorkingStatusLeft, WorkingStatusProbation, WorkingStatusFullTime: return true } return false } // String returns the string type from the WorkingStatus type func (e WorkingStatus) String() string { return string(e) } func (i *UpdateWorkingStatusRequest) Validate() error { if !i.EmployeeStatus.IsValid() { return errs.ErrInvalidEmployeeStatus } return nil } func (input *GetListEmployeeQuery) Validate() error { if len(input.Positions) > 0 { for _, p := range input.Positions { if strings.TrimSpace(p) == "" { return errs.ErrInvalidPositionCode } } } if len(input.Stacks) > 0 { for _, s := range input.Stacks { if strings.TrimSpace(s) == "" { return errs.ErrInvalidStackCode } } } if len(input.Projects) > 0 { for _, p := range input.Projects { if strings.TrimSpace(p) == "" { return errs.ErrInvalidProjectCode } } } if len(input.Chapters) > 0 { for _, c := range input.Chapters { if strings.TrimSpace(c) == "" { return errs.ErrInvalidChapterCode } } } if len(input.Seniorities) > 0 { for _, s := range input.Seniorities { if strings.TrimSpace(s) == "" { return errs.ErrInvalidSeniorityCode } } } if len(input.Organizations) > 0 { for _, v := range input.Organizations { if strings.TrimSpace(v) == "" { return errs.ErrInvalidOrganizationCode } } } return nil } func (i *CreateEmployeeRequest) Validate() error { teamEmailRegex := ".+@((dwarvesv\\.com)|(d\\.foundation))" regex, _ := regexp.Compile(teamEmailRegex) if i.TeamEmail != "" && !regex.MatchString(i.TeamEmail) { return errs.ErrInvalidEmailDomain } if !model.WorkingStatus(i.Status).IsValid() { return errs.ErrInvalidEmployeeStatus } if len(i.Roles) == 0 { return errs.ErrRoleCannotBeEmpty } _, err := time.Parse("2006-01-02", i.JoinedDate) if i.JoinedDate != "" && err != nil { return errs.ErrInvalidJoinedDate } return nil } func (i *CreateEmployeeRequest) GetJoinedDate() *time.Time { date, err := time.Parse("2006-01-02", i.JoinedDate) if i.JoinedDate == "" || err != nil { return nil } return &date } type UpdateRoleRequest struct { Roles []model.UUID `form:"roles" json:"roles" binding:"required"` } // @name UpdateRoleRequest type UpdateRoleInput struct { EmployeeID string Body UpdateRoleRequest } func (i UpdateRoleInput) Validate() error { if i.EmployeeID == "" || !model.IsUUIDFromString(i.EmployeeID) { return errs.ErrInvalidEmployeeID } if len(i.Body.Roles) == 0 { return errs.ErrRoleCannotBeEmpty } return nil } type SalaryAdvanceRequest struct { DiscordID string `json:"discordID"` Amount string `json:"amount"` } // @name SalaryAdvanceRequest type SalaryAdvanceReportRequest struct { view.Pagination model.SortOrder `json:"sortOrder" form:"sortOrder"` IsPaid *bool `json:"isPaid" form:"isPaid"` } // @name SalaryAdvanceReportRequest type GetEmployeeEarnTransactionsRequest struct { view.Pagination } // @name GetEmployeeEarnTransactionsRequest type CheckInRequest struct { CheckIns []CheckIn `json:"check_ins" binding:"required,dive,required"` } // @name CheckInRequest type CheckIn struct { DiscordID string `json:"discord_id" binding:"required"` Time time.Time `json:"time" binding:"required"` }
```

# pkg/handler/engagement/engagement.go

```go
package engagement import ( "fmt" "net/http" "strconv" "time" "github.com/bwmarrin/discordgo" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/handler/engagement/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/gin-gonic/gin" ) type handler struct { controller *controller.Controller store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config // isIndexingMessages is used to make sure that there cannot be // a second IndexMessages invocation if the first one is not done isIndexingMessages bool } func New( controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config, ) IHandler { return &handler{ controller: controller, store: store, repo: repo, service: service, logger: logger, config: cfg, } } // UpsertRollup godoc // @Summary Upsert engagement rollup // @Description Upsert engagement rollup // @id upsertEngagementRollup // @Tags Engagement // @Accept json // @Produce json // @Security BearerAuth // @Param Body body UpsertRollupRequest true "Body" // @Success 200 {object} MessageResponse // @Success 400 {object} ErrorResponse // @Success 500 {object} ErrorResponse // @Router /engagements/rollup [post] func (h *handler) UpsertRollup(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "engagement", "method": "UpsertRollup", }, ) body := request.UpsertRollupRequest{} if err := c.ShouldBindJSON(&body); err != nil { l.Error(err, "error decoding body") c.JSON( http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""), ) return } l = l.AddField("body", body) if err := body.Validate(); err != nil { l.Error(err, "error validating data") c.JSON( http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""), ) return } discordUserID, err := strconv.ParseInt(body.DiscordUserID, 10, 64) if err != nil { l.Error(err, "unable to parse discordUserID to int64") c.JSON( http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""), ) return } lastMessageID, err := strconv.ParseInt(body.LastMessageID, 10, 64) if err != nil { l.Error(err, "unable to parse lastMessageID to int64") c.JSON( http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""), ) return } channelID, err := strconv.ParseInt(body.ChannelID, 10, 64) if err != nil { l.Error(err, "unable to parse channelID to int64") c.JSON( http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""), ) return } categoryID := int64(0) if body.CategoryID == "" { categoryID = -1 } else { categoryID, err = strconv.ParseInt(body.CategoryID, 10, 64) if err != nil { l.Error(err, "unable to parse categoryID to int64") c.JSON( http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, ""), ) return } } tx, done := h.repo.NewTransaction() rollup := &model.EngagementsRollup{ DiscordUserID: discordUserID, LastMessageID: lastMessageID, ChannelID: channelID, CategoryID: categoryID, MessageCount: body.MessageCount, ReactionCount: body.ReactionCount, } _, err = h.store.EngagementsRollup.Upsert(tx.DB(), rollup) if err != nil { l.Error(err, "unable to upsert engagements rollup") c.JSON( http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, ""), ) return } c.JSON( http.StatusOK, view.CreateResponse[any]("success", nil, done(nil), body, ""), ) } // GetLastMessageID godoc // @Summary Get local last message ID of a channel // @Description Get local last message ID of a channel // @id getLastMessageID // @Tags Engagement // @Accept json // @Produce json // @Security BearerAuth // @Param channel-id path string true "Discord Channel ID" // @Success 200 {object} MessageResponse // @Success 400 {object} ErrorResponse // @Success 500 {object} ErrorResponse // @Router /engagements/channel/:channel-id/last-message-id [get] func (h *handler) GetLastMessageID(c *gin.Context) { channelID := c.Param("channel-id") l := h.logger.Fields(logger.Fields{ "handler": "engagement", "method": "UpsertRollupRecord", "channelID": channelID, }) tx, done := h.repo.NewTransaction() lastMessageID, err := h.store.EngagementsRollup.GetLastMessageID(tx.DB(), channelID) if err != nil { l.Error(err, "unable to get last message ID") c.JSON( http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), channelID, ""), ) return } c.JSON( http.StatusOK, view.CreateResponse[any](lastMessageID, nil, done(nil), nil, "success"), ) } func AggregateMessages( l logger.Logger, messages []*discordgo.Message, channelIDToCategoryID map[string]string, ) []*model.EngagementsRollup { userIDMessageIDToRecord := make(map[string]*model.EngagementsRollup) for _, message := range messages { l := l.AddField("messageID", message.ID) if message.Author == nil { l.Warn("missing author") continue } userID, err := strconv.ParseInt(message.Author.ID, 10, 64) if err != nil { l := l.AddField("userID", message.Author.ID) l.Error(err, "unable to parse user ID to int64") continue } messageID, err := strconv.ParseInt(message.ID, 10, 64) if err != nil { l := l.AddField("messageID", message.ID) l.Error(err, "unable to parse message ID to int64") continue } channelID, err := strconv.ParseInt(message.ChannelID, 10, 64) if err != nil { l := l.AddField("channelID", message.ChannelID) l.Error(err, "unable to parse channel ID to int64") continue } categoryID := int64(0) categoryIDStr := channelIDToCategoryID[message.ChannelID] if categoryIDStr == "" { categoryID = -1 } else { categoryID, err = strconv.ParseInt(categoryIDStr, 10, 64) if err != nil { l := l.AddField("categoryIDStr", categoryIDStr) l.Error(err, "unable to parse category ID to int64") continue } } key := fmt.Sprintf("%d_%d", userID, channelID) record, ok := userIDMessageIDToRecord[key] if ok { record.MessageCount += 1 record.LastMessageID = messageID } else { userIDMessageIDToRecord[key] = &model.EngagementsRollup{ DiscordUserID: userID, LastMessageID: messageID, DiscordUsername: fmt.Sprintf("%s#%s", message.Author.Username, message.Author.Discriminator), ChannelID: channelID, CategoryID: categoryID, MessageCount: 1, } } } records := make([]*model.EngagementsRollup, 0, len(userIDMessageIDToRecord)) for _, record := range userIDMessageIDToRecord { records = append(records, record) } return records } // IndexMessages godoc // @Summary Index messages of provided Discord server // @Description Index messages of provided Discord server // @id indexEngagementMessages // @Tags Engagement // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} MessageResponse // @Success 400 {object} ErrorResponse // @Success 500 {object} ErrorResponse // @Router /cronjobs/index-engagement-messages [post] func (h *handler) IndexMessages(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "engagement", "method": "IndexMessages", }, ) if h.isIndexingMessages { l.Warn("handler is indexing messages") c.JSON( http.StatusAccepted, view.CreateResponse[any]("handler is indexing messages", nil, nil, nil, ""), ) return } h.isIndexingMessages = true defer func() { h.isIndexingMessages = false }() l = h.logger.Fields( logger.Fields{ "guildID": h.config.Discord.IDs.DwarvesGuild, }, ) channels, err := h.service.Discord.GetChannels() if err != nil { l.Error(err, "get channels error") c.JSON( http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""), ) return } l.Debugf("fetched channels: %v", channels) tx, done := h.repo.NewTransaction() allMessages := make([]*discordgo.Message, 0) // TODO: parallelize the code as each channel can be processed singly for _, channel := range channels { l := l.AddField("channelID", channel.ID) if channel.LastMessageID == "" { l.Debugf("channel has no message", channel.ID) continue } cursorMessageID, err := h.store.EngagementsRollup.GetLastMessageID(tx.DB(), channel.ID) if err != nil { l.Error(done(err), "get cursor message id error") c.JSON( http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""), ) return } messages, err := h.service.Discord.GetMessagesAfterCursor( channel.ID, cursorMessageID, channel.LastMessageID, ) if err != nil { l := l.AddField("cursorMessageID", cursorMessageID) l.Warnf("get messages after cursor error: %s", err.Error()) continue } l.Debugf("fetched %d message(s)", len(messages)) allMessages = append(allMessages, messages...) } channelIDToCategoryID := make(map[string]string, len(channels)) for _, channel := range channels { channelIDToCategoryID[channel.ID] = channel.ParentID } records := AggregateMessages(l, allMessages, channelIDToCategoryID) l.Debugf("aggregated %d message(s) to %d records", len(allMessages), len(records)) for _, record := range records { _, err := h.store.EngagementsRollup.Upsert(tx.DB(), record) if err != nil { l.Error(done(err), "upsert record error") c.JSON( http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, ""), ) return } // wait 500ms after each insert to avoid overwhelming the database time.Sleep(500 * time.Millisecond) } c.JSON( http.StatusOK, view.CreateResponse[any]("success", nil, done(nil), nil, ""), ) }
```

# pkg/handler/engagement/errors.go

```go
package engagement
```

# pkg/handler/engagement/interface.go

```go
package engagement import "github.com/gin-gonic/gin" type IHandler interface { UpsertRollup(c *gin.Context) GetLastMessageID(c *gin.Context) IndexMessages(c *gin.Context) }
```

# pkg/handler/engagement/request/request.go

```go
package request import "errors" var ErrInvalidCount = errors.New("message count or reaction count should be >0") type UpsertRollupRequest struct { DiscordUserID string `json:"discordUserID" binding:"required"` LastMessageID string `json:"lastMessageID" binding:"required"` ChannelID string `json:"channelID" binding:"required"` CategoryID string `json:"categoryID"` MessageCount int `json:"messageCount"` ReactionCount int `json:"reactionCount"` } // @name UpsertRollupRequest func (r UpsertRollupRequest) Validate() error { if r.MessageCount == 0 && r.ReactionCount == 0 { return ErrInvalidCount } return nil }
```

# pkg/handler/feedback/errs/errors.go

```go
package errs import ( "errors" "fmt" ) var ( ErrEventNotFound = errors.New("event not found") ErrReviewerNotFound = errors.New("reviewer not found") ErrProjectNotFound = errors.New("project not found") ErrEmployeeEventReviewerNotFound = errors.New("employee event reviewer not found") ErrInvalidEventType = errors.New("invalid event type") ErrInvalidReviewerID = errors.New("invalid reviewer id") ErrInvalidFeedbackID = errors.New("invalid feedback id") ErrTopicNotFound = errors.New("topic not found") ErrEventReviewerNotFound = errors.New("employee event reviewer not found") ErrEventAlreadyExisted = errors.New("event already existed") ErrInvalidAnswers = errors.New("invalid answers data") ErrInvalidAnswerForLikertScale = errors.New("invalid answer for likert-scale question") ErrInvalidEventID = errors.New("invalid event id") ErrInvalidReviewerStatus = errors.New("invalid reviewer status") ErrReviewAlreadySent = errors.New("review already sent") ErrUnansweredquestions = errors.New("must answer all questions") ErrCouldNotEditDoneFeedback = errors.New("could not edit the feedback marked as done") ErrInvalidTopicID = errors.New("invalid topic id") ErrInvalidEventSubType = errors.New("invalid event subtype") ErrInvalidQuarter = errors.New("invalid quarter") ErrEmployeeNotFound = errors.New("employee not found") ErrEmployeeNotReady = errors.New("employee not ready") ErrAlreadySent = errors.New("surveys already sent to all participants") ErrUnfinishedReviewer = errors.New("all reviewers have to finish before marked done") ) func ErrEventQuestionNotFound(id string) error { return fmt.Errorf("employee event question not found: %v", id) }
```

# pkg/handler/feedback/feedback.go

```go
package feedback import ( "errors" "net/http" "github.com/gin-gonic/gin" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/handler/feedback/errs" "github.com/dwarvesf/fortress-api/pkg/handler/feedback/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/store/employeeeventquestion" "github.com/dwarvesf/fortress-api/pkg/store/employeeeventtopic" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } // List godoc // @Summary Get list feedbacks // @Description Get list feedbacks // @id getFeedbackList // @Tags Feedback // @Accept json // @Produce json // @Security BearerAuth // @Param status query string false "Status" // @Param page query string false "Page" // @Param size query string false "Size" // @Param sort query string false "Sort" // @Success 200 {object} ListFeedbackResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /feedbacks [get] func (h *handler) List(c *gin.Context) { userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } input := request.GetListFeedbackInput{} if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } pagination := model.Pagination{ Page: input.Page, Size: input.Size, Sort: input.Sort, } pagination.Standardize() l := h.logger.Fields(logger.Fields{ "handler": "feedback", "method": "List", "userID": userID, "input": input, }) rs, total, err := h.store.EmployeeEventTopic.GetByEmployeeID(h.repo.DB(), userID, employeeeventtopic.GetByEmployeeIDInput{Status: input.Status}, pagination) if err != nil { l.Error(err, "failed to get employee event topic by employeeID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListFeedback(rs), &view.PaginationResponse{Pagination: view.Pagination{Page: pagination.Page, Size: pagination.Size, Sort: pagination.Sort}, Total: total}, nil, nil, "")) } // Detail godoc // @Summary Get feedback detail for logged-in users // @Description Get feedback detail for logged-in users // @id getFeedbackDetail // @Tags Feedback // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Feedback Event ID" // @Param topicID path string true "Employee Event Topic ID" // @Success 200 {object} FeedbackDetailResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /feedbacks/{id}/topics/{topicID} [get] func (h *handler) Detail(c *gin.Context) { userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } input := request.DetailInput{ EventID: c.Param("id"), TopicID: c.Param("topicID"), } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "feedback", "method": "Detail", "input": input, }) // Check topic and feedback existence topic, err := h.store.EmployeeEventTopic.One(h.repo.DB(), input.TopicID, input.EventID, false) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrTopicNotFound, "topic not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrTopicNotFound, input, "")) return } if err != nil { l.Error(err, "failed when getting topic") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } eventReviewer, err := h.store.EmployeeEventReviewer.OneByReviewerID(h.repo.DB(), userID, input.TopicID) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrEmployeeEventReviewerNotFound, "employee event reviewer not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEmployeeEventReviewerNotFound, nil, "")) return } if err != nil { l.Error(err, "failed to get employee event reviewer") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } questions, err := h.store.EmployeeEventQuestion.GetByEventReviewerID(h.repo.DB(), eventReviewer.ID.String()) if err != nil { l.Error(err, "failed to get employee event question by reviewer") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } reviewer, err := h.store.Employee.One(h.repo.DB(), userID, false) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrReviewerNotFound, "reviewer not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrReviewerNotFound, nil, "")) return } if err != nil { l.Error(err, "failed to get reviewer") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if !eventReviewer.IsRead { eventReviewer.IsRead = true if _, err := h.store.EmployeeEventReviewer.UpdateSelectedFieldsByID(h.repo.DB(), eventReviewer.ID.String(), *eventReviewer, "is_read"); err != nil { l.Error(err, "failed to update employee event reviewer") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } var project *model.Project if !topic.ProjectID.IsZero() { project, err = h.store.Project.One(h.repo.DB(), topic.ProjectID.String(), false) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrProjectNotFound, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } if err != nil { l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } detailInfo := view.FeedbackDetailInfo{ Status: eventReviewer.ReviewerStatus, EmployeeID: topic.EmployeeID.String(), Reviewer: reviewer, TopicID: input.TopicID, EventID: input.EventID, Title: topic.Title, Relationship: eventReviewer.Relationship, Project: project, } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListFeedbackDetails(questions, detailInfo), nil, nil, nil, "")) } // Submit godoc // @Summary Submit the draft or done answers // @Description Submit the draft or done answers // @id submitFeedback // @Tags Feedback // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Feedback Event ID" // @Param topicID path string true "Employee Event Topic ID" // @Param Body body SubmitFeedbackRequest true "Body" // @Success 200 {object} SubmitFeedbackResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /feedbacks/{id}/topics/{topicID}/submit [post] func (h *handler) Submit(c *gin.Context) { userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } input := request.SubmitInput{ EventID: c.Param("id"), TopicID: c.Param("topicID"), } if err := c.ShouldBindJSON(&input.Body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "feedback", "method": "Submit", "userID": userID, "input": input, }) // Begin transaction tx, done := h.repo.NewTransaction() // Check topic existence and validate eventID topic, err := h.store.EmployeeEventTopic.One(tx.DB(), input.TopicID, input.EventID, false) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrTopicNotFound, "topic not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrTopicNotFound), input, "")) return } if err != nil { l.Error(err, "failed when getting topic") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } eventReviewer, err := h.store.EmployeeEventReviewer.OneByReviewerID(tx.DB(), userID, input.TopicID) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrEventReviewerNotFound, "employee event reviewer not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrEventReviewerNotFound), input, "")) return } if err != nil { l.Error(err, "failed to get employee event reviewer record") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } if eventReviewer.ReviewerStatus == model.EventReviewerStatusDone { l.Error(errs.ErrCouldNotEditDoneFeedback, "could not edit the feedback marked as done") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrCouldNotEditDoneFeedback), nil, "")) return } // check questionID existence eventQuestions, err := h.store.EmployeeEventQuestion.GetByEventReviewerID(tx.DB(), eventReviewer.ID.String()) if err != nil { l.Error(err, "failed to validate questionID") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(err), input, "")) return } questionMap := model.ToQuestionMapType(eventQuestions) for i, e := range input.Body.Answers { _, ok := questionMap[e.EventQuestionID] if !ok { l.Error(errs.ErrEventQuestionNotFound(e.EventQuestionID.String()), "employee event question not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrEventQuestionNotFound(e.EventQuestionID.String())), input, "")) return } if questionMap[e.EventQuestionID] == model.QuestionTypeScale.String() { if (input.Body.Status == model.EventReviewerStatusDone && e.Answer == "" && !model.AgreementLevel(e.Answer).IsValid()) || (input.Body.Status == model.EventReviewerStatusDraft && e.Answer != "" && !model.AgreementLevel(e.Answer).IsValid()) { l.Error(errs.ErrInvalidAnswerForLikertScale, "invalid answer for likert-scale question") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, done(errs.ErrInvalidAnswerForLikertScale), input, "")) return } input.Body.Answers[i].Answer = model.AgreementLevelMap[model.AgreementLevel(e.Answer)] } } // Update answers in employee_event_questions table for _, e := range input.Body.Answers { data := employeeeventquestion.BasicEventQuestion{ EventQuestionID: e.EventQuestionID.String(), Answer: e.Answer, Note: e.Note, } if err := h.store.EmployeeEventQuestion.UpdateAnswers(tx.DB(), data); err != nil { l.Error(err, "failed to update employee event question") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } } // Update status in employee_event_reviewers table eventReviewer.ReviewerStatus = input.Body.Status if input.Body.Status == model.EventReviewerStatusDone { eventReviewer.AuthorStatus = model.EventAuthorStatusDone } _, err = h.store.EmployeeEventReviewer.UpdateSelectedFieldsByID(tx.DB(), eventReviewer.ID.String(), *eventReviewer, "reviewer_status", "author_status") if err != nil { l.Error(err, "failed to update employee event question") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } eventQuestions, err = h.store.EmployeeEventQuestion.GetByEventReviewerID(tx.DB(), eventReviewer.ID.String()) if err != nil { l.Error(err, "failed to get all empoyee event questions by event reviewer") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } if input.Body.Status == model.EventReviewerStatusDone { for _, e := range eventQuestions { if e.Answer == "" { l.Error(errs.ErrUnansweredquestions, "there are some unanswered questions") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, done(errs.ErrUnansweredquestions), input, "")) return } } } reviewer, err := h.store.Employee.One(h.repo.DB(), userID, false) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrReviewerNotFound, "reviewer not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrReviewerNotFound, nil, "")) return } if err != nil { l.Error(err, "failed to get reviewer") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } detailInfo := view.FeedbackDetailInfo{ Status: eventReviewer.ReviewerStatus, EmployeeID: topic.EmployeeID.String(), Reviewer: reviewer, TopicID: input.TopicID, EventID: input.EventID, Title: topic.Title, } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListSubmitFeedback(eventQuestions, detailInfo), nil, nil, done(nil), "")) } // CountUnreadFeedback godoc // @Summary Get number of unread inbox for user // @Description Get number of unread inbox for user // @id countUnreadFeedback // @Tags Feedback // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} UnreadFeedbackCountResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /feedbacks/unreads [get] func (h *handler) CountUnreadFeedback(c *gin.Context) { userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "feedback", "method": "CountUnreadFeedback", "userID": userID, }) // Get unread inbox count, err := h.store.EmployeeEventTopic.CountUnreadFeedbackByEmployeeID(h.repo.DB(), userID) if err != nil { l.Error(err, "failed to get unread inbox") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUnreadFeedbackCountData(userID, count), nil, nil, nil, "")) }
```

# pkg/handler/feedback/interface.go

```go
package feedback import "github.com/gin-gonic/gin" type IHandler interface { List(c *gin.Context) Detail(c *gin.Context) Submit(c *gin.Context) CountUnreadFeedback(c *gin.Context) }
```

# pkg/handler/feedback/request/request.go

```go
package request import ( "github.com/dwarvesf/fortress-api/pkg/handler/feedback/errs" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) type GetListFeedbackInput struct { view.Pagination Status string `json:"status" form:"status"` } func (i *GetListFeedbackInput) Validate() error { if i.Status != "" && !model.EventReviewerStatus(i.Status).IsValid() { return errs.ErrInvalidReviewerStatus } return nil } type DetailInput struct { EventID string TopicID string } func (i *DetailInput) Validate() error { if i.EventID == "" || !model.IsUUIDFromString(i.EventID) { return errs.ErrInvalidFeedbackID } if i.TopicID == "" || !model.IsUUIDFromString(i.TopicID) { return errs.ErrInvalidTopicID } return nil } type BasicEventQuestionRequest struct { EventQuestionID model.UUID `json:"eventQuestionID" form:"eventQuestionID" binding:"required"` Answer string `json:"answer" form:"answer"` Note string `json:"note" form:"note"` } // @name BasicEventQuestionRequest type SubmitFeedbackRequest struct { Answers []BasicEventQuestionRequest `json:"answers" form:"answers" binding:"required"` Status model.EventReviewerStatus `json:"status" form:"status" binding:"required"` } // @name SubmitFeedbackRequest func (i *SubmitFeedbackRequest) Validate() error { if !i.Status.IsValid() { return errs.ErrInvalidReviewerStatus } return nil } type SubmitInput struct { Body SubmitFeedbackRequest EventID string TopicID string } func (i *SubmitInput) Validate() error { if i.EventID == "" || !model.IsUUIDFromString(i.EventID) { return errs.ErrInvalidEventID } if i.TopicID == "" || !model.IsUUIDFromString(i.TopicID) { return errs.ErrInvalidTopicID } return i.Body.Validate() }
```

# pkg/handler/handler.go

```go
package handler import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/handler/accounting" "github.com/dwarvesf/fortress-api/pkg/handler/asset" "github.com/dwarvesf/fortress-api/pkg/handler/audit" "github.com/dwarvesf/fortress-api/pkg/handler/auth" "github.com/dwarvesf/fortress-api/pkg/handler/bankaccount" "github.com/dwarvesf/fortress-api/pkg/handler/brainerylogs" "github.com/dwarvesf/fortress-api/pkg/handler/client" "github.com/dwarvesf/fortress-api/pkg/handler/communitynft" "github.com/dwarvesf/fortress-api/pkg/handler/companyinfo" "github.com/dwarvesf/fortress-api/pkg/handler/conversionrate" "github.com/dwarvesf/fortress-api/pkg/handler/dashboard" "github.com/dwarvesf/fortress-api/pkg/handler/dashboard/util" "github.com/dwarvesf/fortress-api/pkg/handler/deliverymetric" "github.com/dwarvesf/fortress-api/pkg/handler/discord" "github.com/dwarvesf/fortress-api/pkg/handler/earn" "github.com/dwarvesf/fortress-api/pkg/handler/employee" "github.com/dwarvesf/fortress-api/pkg/handler/engagement" "github.com/dwarvesf/fortress-api/pkg/handler/feedback" "github.com/dwarvesf/fortress-api/pkg/handler/healthz" "github.com/dwarvesf/fortress-api/pkg/handler/icy" "github.com/dwarvesf/fortress-api/pkg/handler/invoice" "github.com/dwarvesf/fortress-api/pkg/handler/memologs" "github.com/dwarvesf/fortress-api/pkg/handler/metadata" "github.com/dwarvesf/fortress-api/pkg/handler/news" "github.com/dwarvesf/fortress-api/pkg/handler/notion" "github.com/dwarvesf/fortress-api/pkg/handler/payroll" "github.com/dwarvesf/fortress-api/pkg/handler/profile" "github.com/dwarvesf/fortress-api/pkg/handler/project" "github.com/dwarvesf/fortress-api/pkg/handler/survey" "github.com/dwarvesf/fortress-api/pkg/handler/valuation" "github.com/dwarvesf/fortress-api/pkg/handler/vault" "github.com/dwarvesf/fortress-api/pkg/handler/webhook" yt "github.com/dwarvesf/fortress-api/pkg/handler/youtube" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/worker" ) type Handler struct { Accounting accounting.IHandler Asset asset.IHandler Audit audit.IHandler Auth auth.IHandler BankAccount bankaccount.IHandler BraineryLog brainerylogs.IHandler Client client.IHandler CompanyInfo companyinfo.IHandler ConversionRate conversionrate.IHandler Dashboard dashboard.IHandler DeliveryMetric deliverymetric.IHandler Discord discord.IHandler Employee employee.IHandler Engagement engagement.IHandler Feedback feedback.IHandler Healthcheck healthz.IHandler Invoice invoice.IHandler MemoLog memologs.IHandler Metadata metadata.IHandler Notion notion.IHandler Payroll payroll.IHandler Profile profile.IHandler Project project.IHandler Survey survey.IHandler Valuation valuation.IHandler Webhook webhook.IHandler Vault vault.IHandler Icy icy.IHandler CommunityNft communitynft.IHandler Earn earn.IHandler News news.IHandler Youtube yt.IHandler } func New(store *store.Store, repo store.DBRepo, service *service.Service, ctrl *controller.Controller, worker *worker.Worker, logger logger.Logger, cfg *config.Config) *Handler { return &Handler{ Accounting: accounting.New(store, repo, service, logger, cfg), Asset: asset.New(store, repo, service, logger, cfg), Audit: audit.New(store, repo, service, logger, cfg), Auth: auth.New(ctrl, logger, cfg), BankAccount: bankaccount.New(store, repo, service, logger, cfg), BraineryLog: brainerylogs.New(ctrl, store, repo, service, logger, cfg), Client: client.New(ctrl, store, repo, service, logger, cfg), CompanyInfo: companyinfo.New(ctrl, store, repo, service, logger, cfg), ConversionRate: conversionrate.New(ctrl, store, repo, service, logger, cfg), Dashboard: dashboard.New(store, repo, service, logger, cfg, util.New()), DeliveryMetric: deliverymetric.New(ctrl, store, repo, service, logger, cfg), Discord: discord.New(ctrl, store, repo, service, logger, cfg), Employee: employee.New(ctrl, store, repo, service, logger, cfg), Engagement: engagement.New(ctrl, store, repo, service, logger, cfg), Feedback: feedback.New(store, repo, service, logger, cfg), Healthcheck: healthz.New(), Invoice: invoice.New(ctrl, store, repo, service, worker, logger, cfg), MemoLog: memologs.New(ctrl, store, repo, service, logger, cfg), Metadata: metadata.New(store, repo, service, logger, cfg), Notion: notion.New(store, repo, service, logger, cfg), Payroll: payroll.New(ctrl, store, repo, service, worker, logger, cfg), Profile: profile.New(ctrl, store, repo, service, logger, cfg), Project: project.New(ctrl, store, repo, service, logger, cfg), Survey: survey.New(store, repo, service, logger, cfg), Valuation: valuation.New(store, repo, service, logger, cfg), Webhook: webhook.New(ctrl, store, repo, service, logger, cfg, worker), Vault: vault.New(store, repo, service, logger, cfg), Icy: icy.New(ctrl, logger), CommunityNft: communitynft.New(ctrl, store, repo, service, logger, cfg), Earn: earn.New(ctrl, store, repo, service, logger, cfg), News: news.New(store, repo, ctrl, logger, cfg), Youtube: yt.New(ctrl, store, repo, service, logger, cfg), } }
```

# pkg/handler/icy/icy.go

```go
package icy import ( "net/http" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { controller *controller.Controller logger logger.Logger } func New( controller *controller.Controller, logger logger.Logger, ) IHandler { return &handler{ controller: controller, logger: logger, } } func (h *handler) Accounting(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "icy", "method": "Accounting", }) accounting, err := h.controller.Icy.Accounting() if err != nil { l.Error(err, "failed to get icy accounting") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "failed to get icy accounting")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToIcyAccounting(accounting), nil, nil, nil, "")) }
```

# pkg/handler/icy/interface.go

```go
package icy import "github.com/gin-gonic/gin" type IHandler interface { Accounting(c *gin.Context) }
```

# pkg/handler/invoice/errs/errors.go

```go
package errs import ( "errors" "net/http" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/controller/invoice" "github.com/dwarvesf/fortress-api/pkg/view" ) var ( ErrInvalidDueAt = errors.New("invalid due at") ErrInvalidPaidAt = errors.New("invalid paid at") ErrInvalidInvoiceStatus = errors.New("invalid invoice status") ErrInvalidInvoiceID = errors.New("invalid invoice id") ErrInvalidProjectID = errors.New("invalid project id") ErrInvalidDeveloperEmail = errors.New("invalid developer email in dev mode") ErrSenderNotFound = errors.New("sender not found") ErrBankAccountNotFound = errors.New("bank account not found") ErrProjectNotFound = errors.New("project not found") ) func ConvertControllerErr(c *gin.Context, err error) { if err == nil { return } var status int switch err { case invoice.ErrInvoiceNotFound: status = http.StatusNotFound case invoice.ErrProjectNotFound: status = http.StatusNotFound case invoice.ErrSenderNotFound: status = http.StatusNotFound case invoice.ErrBankAccountNotFound: status = http.StatusNotFound case invoice.ErrInvoiceStatusAlready: status = http.StatusInternalServerError default: status = http.StatusInternalServerError } c.JSON(status, view.CreateResponse[any](nil, nil, err, nil, "")) }
```

# pkg/handler/invoice/interface.go

```go
package invoice import "github.com/gin-gonic/gin" type IHandler interface { GetTemplate(c *gin.Context) List(c *gin.Context) Send(c *gin.Context) UpdateStatus(c *gin.Context) }
```

# pkg/handler/invoice/invoice.go

```go
package invoice import ( "net/http" "time" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" invoiceCtrl "github.com/dwarvesf/fortress-api/pkg/controller/invoice" "github.com/dwarvesf/fortress-api/pkg/handler/invoice/errs" "github.com/dwarvesf/fortress-api/pkg/handler/invoice/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/dwarvesf/fortress-api/pkg/worker" ) type handler struct { controller *controller.Controller store *store.Store service *service.Service worker *worker.Worker logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(ctrl *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, worker *worker.Worker, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ controller: ctrl, store: store, repo: repo, service: service, worker: worker, logger: logger, config: cfg, } } // List godoc // @Summary Get latest invoice by project id // @Description Get latest invoice by project id // @id getInvoiceList // @Tags Invoice // @Accept json // @Produce json // @Security BearerAuth // @Param projectID query string false "projectID" // @Param status query string false "status" // @Param page query int false "page" // @Param size query int false "size" // @Param sort query string false "sort" // @Success 200 {object} InvoiceListResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /invoices [get] func (h *handler) List(c *gin.Context) { var query request.GetListInvoiceInput if err := c.ShouldBindQuery(&query); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "invoice", "method": "GetLatestInvoice", "query": query, }) pagination := query.StandardizeInput() if err := query.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "")) return } invoices, total, err := h.controller.Invoice.List(invoiceCtrl.GetListInvoiceInput{ Pagination: pagination, ProjectIDs: query.ProjectID, Statuses: query.Status, }) if err != nil { l.Error(err, "failed to get latest invoice") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, "")) return } rs, err := view.ToInvoiceListResponse(invoices) if err != nil { l.Error(err, "failed to parse invoice list response") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](rs, &view.PaginationResponse{Total: total, Pagination: view.Pagination{Page: pagination.Page, Size: pagination.Size, Sort: pagination.Sort}}, nil, nil, "")) } // GetTemplate godoc // @Summary Get the latest invoice by project id // @Description Get the latest invoice by project id // @id getInvoiceTemplate // @Tags Invoice // @Accept json // @Produce json // @Security BearerAuth // @Param projectID query string true "projectID" // @Success 200 {object} InvoiceTemplateResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /invoices/template [get] func (h *handler) GetTemplate(c *gin.Context) { now := time.Now() var input request.GetInvoiceInput if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if input.ProjectID == "" || !model.IsUUIDFromString(input.ProjectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "invoice", "method": "GetTemplate", "input": input, }) nextInvoiceNumber, lastInvoice, p, err := h.controller.Invoice.GetTemplate(invoiceCtrl.GetInvoiceInput{ Now: &now, ProjectID: input.ProjectID, }) if err != nil { l.Error(err, "failed to get invoice template") errs.ConvertControllerErr(c, err) return } rs, err := view.ToInvoiceTemplateResponse(p, lastInvoice, nextInvoiceNumber) if err != nil { l.Error(err, "failed to parse invoice template response") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](rs, nil, nil, nil, "")) } // Send godoc // @Summary Create new invoice and send to client // @Description Create new invoice and send to client // @id sendInvoice // @Tags Invoice // @Accept json // @Produce json // @Security BearerAuth // @Param Body body SendInvoiceRequest true "body" // @Success 200 {object} MessageResponse // @Failure 404 {object} ErrorResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /invoices/send [post] func (h *handler) Send(c *gin.Context) { userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } var req request.SendInvoiceRequest l := h.logger.Fields(logger.Fields{ "handler": "invoice", "method": "Send", }) if err := req.ValidateAndMappingRequest(c, h.config); err != nil { l.Errorf(err, "failed to validating and mapping the quest", "input", req) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, "")) return } iv, err := req.ToInvoiceModel(userID) if err != nil { l.Error(err, "failed to parse request to invoice model") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, "")) return } _, err = h.controller.Invoice.Send(iv) if err != nil { l.Error(err, "failed to send invoice") errs.ConvertControllerErr(c, err) return } // send message to discord channel err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "invoice_send", Data: map[string]interface{}{ "invoice_number": iv.Number, "employee_id": userID, }, }) if err != nil { l.Error(err, "failed to log to discord") } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // UpdateStatus godoc // @Summary Update status for invoice // @Description Update status for invoice // @Tags Invoice // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} MessageResponse // @Failure 404 {object} ErrorResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /invoices/{id}/status [put] func (h *handler) UpdateStatus(c *gin.Context) { invoiceID := c.Param("id") if invoiceID == "" || !model.IsUUIDFromString(invoiceID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidInvoiceID, nil, "")) return } var req request.UpdateStatusRequest if err := c.ShouldBindJSON(&req); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "invoice", "method": "UpdateStatus", "req": req, }) if err := req.Validate(); err != nil { l.Error(err, "invalid request") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, "")) return } // check invoice existence _, err := h.controller.Invoice.UpdateStatus(invoiceCtrl.UpdateStatusInput{ InvoiceID: invoiceID, Status: req.Status, SendThankYouEmail: req.SendThankYouEmail, }) if err != nil { l.Error(err, "failed to update invoice status") errs.ConvertControllerErr(c, err) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) }
```

# pkg/handler/invoice/request/request.go

```go
package request import ( "encoding/json" "math" "strings" "time" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/handler/invoice/errs" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/utils" "github.com/dwarvesf/fortress-api/pkg/utils/mailutils" "github.com/dwarvesf/fortress-api/pkg/view" ) type UpdateStatusRequest struct { Status model.InvoiceStatus `json:"status"` SendThankYouEmail bool `json:"sendThankYouEmail"` } func (r *UpdateStatusRequest) Validate() error { if r.Status != "" && !r.Status.IsValid() { return errs.ErrInvalidInvoiceStatus } return nil } type GetInvoiceInput struct { ProjectID string `json:"projectID" form:"projectID"` } type GetListInvoiceInput struct { view.Pagination ProjectID []string `json:"projectID" form:"projectID"` Status []string `json:"status" form:"status"` } func (r *GetListInvoiceInput) StandardizeInput() model.Pagination { statuses := utils.RemoveEmptyString(r.Status) projectsIDs := utils.RemoveEmptyString(r.ProjectID) pagination := model.Pagination{ Page: r.Page, Size: r.Size, Sort: r.Sort, } pagination.Standardize() r.Status = statuses r.ProjectID = projectsIDs return pagination } func (r *GetListInvoiceInput) Validate() error { for _, status := range r.Status { if !model.InvoiceStatus(status).IsValid() { return errs.ErrInvalidInvoiceStatus } } for _, ids := range r.ProjectID { if _, err := model.UUIDFromString(ids); err != nil { return errs.ErrInvalidProjectID } } return nil } type SendInvoiceRequest struct { IsDraft bool `json:"isDraft"` ProjectID view.UUID `json:"projectID" binding:"required"` BankID view.UUID `json:"bankID" binding:"required"` Description string `json:"description"` Note string `json:"note"` CC []string `json:"cc"` LineItems []InvoiceItem `json:"lineItems"` Email string `json:"email" binding:"required,email"` Total float64 `json:"total" binding:"gte=0"` Discount float64 `json:"discount" binding:"gte=0"` Tax float64 `json:"tax" binding:"gte=0"` SubTotal float64 `json:"subtotal" binding:"gte=0"` InvoiceDate string `json:"invoiceDate" binding:"required"` DueDate string `json:"dueDate" binding:"required"` Month int `json:"invoiceMonth" binding:"gte=0,lte=11"` Year int `json:"invoiceYear" binding:"gte=0"` Number string } // @name SendInvoiceRequest type InvoiceItem struct { Quantity float64 `json:"quantity"` UnitCost float64 `json:"unitCost"` Discount float64 `json:"discount"` Cost float64 `json:"cost"` Description string `json:"description"` IsExternal bool `json:"isExternal"` } // @name InvoiceItem func toInvoiceItemsModel(lineItems []InvoiceItem) []model.InvoiceItem { var items []model.InvoiceItem for _, item := range lineItems { items = append(items, model.InvoiceItem{ Quantity: math.Round(item.Quantity*100) / 100, UnitCost: math.Round(item.UnitCost*100) / 100, Discount: math.Round(item.Discount*100) / 100, Cost: math.Round(item.Cost*100) / 100, Description: item.Description, IsExternal: item.IsExternal, }) } return items } func (i *SendInvoiceRequest) ValidateAndMappingRequest(c *gin.Context, cfg *config.Config) error { if err := c.ShouldBindJSON(&i); err != nil { return err } var ccList []string for _, cc := range i.CC { if strings.TrimSpace(cc) == "" { continue } ccList = append(ccList, cc) } i.CC = ccList if cfg.Env == "prod" { return nil } if !mailutils.IsDwarvesMail(i.Email) { return errs.ErrInvalidDeveloperEmail } for _, v := range i.CC { if !mailutils.IsDwarvesMail(v) { return errs.ErrInvalidDeveloperEmail } } return nil } func (i *SendInvoiceRequest) ToInvoiceModel(sentByID string) (*model.Invoice, error) { lineItems, err := json.Marshal(toInvoiceItemsModel(i.LineItems)) if err != nil { return nil, err } dueAt, err := time.Parse("2006-01-02", i.DueDate) if err != nil { return nil, err } invoiceAt, err := time.Parse("2006-01-02", i.InvoiceDate) if err != nil { return nil, err } defaultStatus := model.InvoiceStatusSent if i.IsDraft { defaultStatus = model.InvoiceStatusDraft } cc, err := json.Marshal(i.CC) if err != nil { return nil, err } var senderID *model.UUID if sentByID != "" { s, err := model.UUIDFromString(sentByID) if err != nil { return nil, err } senderID = &s } return &model.Invoice{ ProjectID: model.UUID(i.ProjectID), BankID: model.UUID(i.BankID), Description: i.Description, Note: i.Note, LineItems: lineItems, Email: i.Email, CC: cc, Total: math.Round(i.Total*100) / 100, Discount: math.Round(i.Discount*100) / 100, Tax: i.Tax, SubTotal: math.Round(i.SubTotal*100) / 100, Month: i.Month + 1, Year: i.Year, Status: defaultStatus, SentBy: senderID, DueAt: &dueAt, InvoicedAt: &invoiceAt, }, nil }
```

# pkg/handler/memologs/errs/errors.go

```go
package errs import "errors" var ( ErrInvalidPublishedAt = errors.New("cannot parse publishedAt") ErrInvalidDateFormat = errors.New("invalid date format") )
```

# pkg/handler/memologs/interface.go

```go
package memologs import "github.com/gin-gonic/gin" type IHandler interface { Create(c *gin.Context) List(c *gin.Context) Sync(c *gin.Context) ListOpenPullRequest(c *gin.Context) ListByDiscordID(c *gin.Context) GetTopAuthors(c *gin.Context) }
```

# pkg/handler/memologs/memo_log.go

```go
package memologs import ( "context" "errors" "net/http" "strconv" "time" "github.com/bwmarrin/discordgo" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/handler/memologs/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/service/mochiprofile" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/store/memolog" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/gin-gonic/gin" ) type handler struct { controller *controller.Controller store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ controller: controller, store: store, repo: repo, service: service, logger: logger, config: cfg, } } // Create create memo logs func (h *handler) Create(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "memologs", "method": "Create", }, ) body := request.CreateMemoLogsRequest{} if err := c.ShouldBindJSON(&body); err != nil { l.Error(err, "[memologs.Create] failed to decode body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } memologs := make([]model.MemoLog, 0) for _, b := range body { publishedAt, _ := time.Parse(time.RFC3339Nano, b.PublishedAt) existedAuthors, err := h.store.DiscordAccount.ListByMemoUsername(h.repo.DB(), b.Authors) if err != nil { l.Errorf(err, "[memologs.Create] failed to get authors", "authors", b.Authors) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, b, "")) return } authors := make([]model.DiscordAccount, 0) // If author does not exist, we will create new author, use memo username as discord username to query discord member mapExistedAuthors := make(map[string]model.DiscordAccount) for _, author := range existedAuthors { mapExistedAuthors[author.MemoUsername] = author } for _, authorMemoUsername := range b.Authors { if a, ok := mapExistedAuthors[authorMemoUsername]; ok { authors = append(authors, a) continue } // Build new author aka new community member var newAuthor model.DiscordAccount // Search discord user by memo username discordMembers, err := h.service.Discord.SearchMember(authorMemoUsername) if err != nil { l.Errorf(err, "[memologs.Create] failed to get discord user", "discord username", authorMemoUsername) } var discordMember discordgo.Member if len(discordMembers) == 1 && discordMembers[0] != nil { discordMember = *discordMembers[0] } newAuthor.MemoUsername = authorMemoUsername newAuthor.DiscordUsername = discordMember.User.Username newAuthor.DiscordID = discordMember.User.ID newAuthor.PersonalEmail = discordMember.User.Email newAuthor.Roles = discordMember.Roles // Get profile by discord ID profile, err := h.service.MochiProfile.GetProfileByDiscordID(discordMember.User.ID) if err != nil { l.Errorf(err, "[memologs.Create] failed to get profile", "discord id", discordMember.User.ID) } if profile != nil { for _, assocAccount := range profile.AssociatedAccounts { if assocAccount.Platform == mochiprofile.ProfilePlatformGithub { githubIDInt, err := strconv.ParseInt(assocAccount.PlatformIdentifier, 10, 64) if err != nil { l.Errorf(err, "[memologs.Create] failed to parse github ID %d", assocAccount.PlatformIdentifier) continue } newAuthor.GithubUsername, err = h.service.Github.RetrieveUsernameByID(context.Background(), githubIDInt) if err != nil { l.Errorf(err, "[memologs.Create] failed to get github username with ID %d", githubIDInt) continue } break } } } authors = append(authors, newAuthor) } b := model.MemoLog{ Title: b.Title, URL: b.URL, Authors: authors, Tags: b.Tags, PublishedAt: &publishedAt, Description: b.Description, Reward: b.Reward, } memologs = append(memologs, b) } logs, err := h.store.MemoLog.Create(h.repo.DB(), memologs) if err != nil { l.Errorf(err, "[memologs.Create] failed to create new memo logs", "memologs", memologs) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, memologs, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToMemoLog(logs), nil, nil, body, "")) } // List list memo logs func (h *handler) List(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "memologs", "method": "List", }, ) var fromPtr, toPtr *time.Time fromStr := c.Query("from") if fromStr != "" { from, err := time.Parse(time.RFC3339, fromStr) if err != nil { l.Error(err, "failed to parse from time") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } fromPtr = &from } toStr := c.Query("to") if toStr != "" { to, err := time.Parse(time.RFC3339, toStr) if err != nil { l.Error(err, "failed to parse to time") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } toPtr = &to } memoLogs, err := h.store.MemoLog.List(h.repo.DB(), memolog.ListFilter{ From: fromPtr, To: toPtr, }) if err != nil { l.Error(err, "failed to get memologs") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToMemoLog(memoLogs), nil, nil, nil, "")) } // Sync sync memo logs func (h *handler) Sync(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "memologs", "method": "Sync", }, ) results, err := h.controller.MemoLog.Sync() if err != nil { l.Error(err, "failed to sync memologs") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToMemoLog(results), nil, nil, nil, "ok")) } // ListOpenPullRequest list open pull request func (h *handler) ListOpenPullRequest(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "memologs", "method": "ListOpenPullRequest", }, ) memoprs, err := h.controller.MemoLog.ListOpenPullRequest() if err != nil { l.Error(err, "failed to list open pull request") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](memoprs, nil, nil, nil, "ok")) } // ListByDiscordID list memo logs by discord id func (h *handler) ListByDiscordID(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "memologs", "method": "ListByDiscordID", }, ) discordID := c.Query("discordID") if discordID == "" { l.Error(errors.New("discordID is required"), "discordID is required") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "discordID is required")) return } memoLogs, err := h.store.MemoLog.List(h.repo.DB(), memolog.ListFilter{ DiscordID: discordID, }) if err != nil { l.Error(err, "failed to get memologs") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } discordMemoRank, err := h.store.MemoLog.GetRankByDiscordID(h.repo.DB(), discordID) if err != nil { l.Error(err, "failed to get rank by discord id") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToMemoLogByDiscordID(memoLogs, discordMemoRank), nil, nil, nil, "")) } func (h *handler) GetTopAuthors(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "memologs", "method": "GetTopAuthors", }, ) topAuthors, err := h.store.MemoLog.GetTopAuthors(h.repo.DB(), 10) if err != nil { l.Error(err, "failed to get top authors") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToMemoTopAuthors(topAuthors), nil, nil, nil, "")) }
```

# pkg/handler/memologs/request/request.go

```go
package request import ( "github.com/shopspring/decimal" ) type CreateMemoLogsRequest []MemoLogItem // @name CreateMemoLogsRequest type MemoLogItem struct { Title string `json:"title" binding:"required"` URL string `json:"url" binding:"required"` Authors []string `json:"authors"` Tags []string `json:"tags"` Description string `json:"description"` PublishedAt string `json:"publishedAt"` Reward decimal.Decimal `json:"reward"` }
```

# pkg/handler/metadata/errors.go

```go
package metadata import "errors" var ( ErrInvalidCategory = errors.New("invalid category") ErrInvalidSubcategory = errors.New("invalid subcategory") )
```

# pkg/handler/metadata/errs/errs.go

```go
package errs import "errors" var ( ErrInvalidStackID = errors.New("invalid stack ID") ErrStackNotFound = errors.New("stack not found") ErrInvalidPositionID = errors.New("invalid Position ID") ErrPositionNotFound = errors.New("position not found") ErrEmployeeNotFound = errors.New("employee not found") )
```

# pkg/handler/metadata/interface.go

```go
package metadata import "github.com/gin-gonic/gin" type IHandler interface { Banks(c *gin.Context) Chapters(c *gin.Context) CreatePosition(c *gin.Context) CreateStack(c *gin.Context) DeletePosition(c *gin.Context) DeleteStack(c *gin.Context) GetCities(c *gin.Context) GetCountries(c *gin.Context) GetCurrencies(c *gin.Context) GetQuestions(c *gin.Context) GetRoles(c *gin.Context) Organizations(c *gin.Context) Positions(c *gin.Context) ProjectStatuses(c *gin.Context) Seniorities(c *gin.Context) Stacks(c *gin.Context) UpdatePosition(c *gin.Context) UpdateStack(c *gin.Context) WorkingStatuses(c *gin.Context) }
```

# pkg/handler/metadata/metadata.go

```go
package metadata import ( "errors" "net/http" "github.com/gin-gonic/gin" _ "github.com/lib/pq" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/handler/metadata/errs" "github.com/dwarvesf/fortress-api/pkg/handler/metadata/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" bankRepo "github.com/dwarvesf/fortress-api/pkg/store/bank" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } // WorkingStatuses godoc // @Summary Get list values for working status // @Description Get list values for working status // @id getWorkingStatusList // @Tags Metadata // @Accept json // @Produce json // @Success 200 {object} MetaDataResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/working-status [get] func (h *handler) WorkingStatuses(c *gin.Context) { // return list values for working status // hardcode for now since we dont need db storage for this res := []view.MetaData{ { Code: model.WorkingStatusLeft.String(), Name: "Left", }, { Code: model.WorkingStatusOnBoarding.String(), Name: "On Boarding", }, { Code: model.WorkingStatusProbation.String(), Name: "Probation", }, { Code: model.WorkingStatusFullTime.String(), Name: "Full-time", }, { Code: model.WorkingStatusContractor.String(), Name: "Contractor", }, } c.JSON(http.StatusOK, view.CreateResponse[any](res, nil, nil, nil, "")) } // Seniorities godoc // @Summary Get list values for sentitorities // @Description Get list values for sentitorities // @id getSenioritiesList // @Tags Metadata // @Accept json // @Produce json // @Success 200 {object} SeniorityResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/seniorities [get] func (h *handler) Seniorities(c *gin.Context) { // 1 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "Seniorities", }) // 2 query seniorities from db seniorities, err := h.store.Seniority.All(h.repo.DB()) if err != nil { l.Error(err, "error query seniorities from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 3 return array of seniorities c.JSON(http.StatusOK, view.CreateResponse[any](seniorities, nil, nil, nil, "")) } // Chapters godoc // @Summary Get list values for chapters // @Description Get list values for chapters // @id getChaptersList // @Tags Metadata // @Accept json // @Produce json // @Success 200 {object} ChapterResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/chapters [get] func (h *handler) Chapters(c *gin.Context) { // 1 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "Chapters", }) // 2 query chapters from db chapters, err := h.store.Chapter.All(h.repo.DB()) if err != nil { l.Error(err, "error query chapters from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 3 return array of chapters c.JSON(http.StatusOK, view.CreateResponse[any](chapters, nil, nil, nil, "")) } // Organizations godoc // @Summary Get list values for organizations // @Description Get list values for organizations // @id getOrganizationsList // @Tags Metadata // @Accept json // @Produce json // @Success 200 {object} OrganizationsResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/organizations [get] func (h *handler) Organizations(c *gin.Context) { // 1 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "Organizations", }) // 2 query organizations from db organizations, err := h.store.Organization.All(h.repo.DB()) if err != nil { l.Error(err, "error query organization from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 3 return array of organizations c.JSON(http.StatusOK, view.CreateResponse[any](organizations, nil, nil, nil, "")) } // GetRoles godoc // @Summary Get list roles // @Description Get list roles // @id getRolesList // @Tags Metadata // @Accept json // @Produce json // @Success 200 {object} RolesResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/roles [get] func (h *handler) GetRoles(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "GetRoles", }) // 2 query roles from db roles, err := h.store.Role.All(h.repo.DB()) if err != nil { l.Error(err, "failed to get all roles") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 3 return array of roles c.JSON(http.StatusOK, view.CreateResponse[any](view.ToRoles(roles), nil, nil, nil, "")) } // ProjectStatuses godoc // @Summary Get list values for project statuses // @Description Get list values for project statuses // @id getProjectStatusesList // @Tags Metadata // @Accept json // @Produce json // @Success 200 {object} MetaDataResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/project-statuses [get] func (h *handler) ProjectStatuses(c *gin.Context) { // return list values for project statuses // hardcode for now since we don't need db storage for this res := []view.MetaData{ { Code: "on-boarding", Name: "On Boarding", }, { Code: "paused", Name: "Paused", }, { Code: "active", Name: "Active", }, { Code: "closed", Name: "Closed", }, } c.JSON(http.StatusOK, view.CreateResponse[any](res, nil, nil, nil, "")) } // Positions godoc // @Summary Get list values for positions // @Description Get list values for positions // @id getPositionsList // @Tags Metadata // @Accept json // @Produce json // @Success 200 {object} PositionResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/positions [get] func (h *handler) Positions(c *gin.Context) { // 1 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "Positions", }) // 2 query positions from db positions, err := h.store.Position.All(h.repo.DB()) if err != nil { l.Error(err, "error query positions from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 3 return array of positions c.JSON(http.StatusOK, view.CreateResponse[any](positions, nil, nil, nil, "")) } // GetCountries godoc // @Summary Get all countries // @Description Get all countries // @id getCountriesList // @Tags Metadata // @Accept json // @Produce json // @Success 200 {object} CountriesResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/countries [get] func (h *handler) GetCountries(c *gin.Context) { countries, err := h.store.Country.All(h.repo.DB()) if err != nil { h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "GetCountries", }).Error(err, "failed to get all countries") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } rs, err := view.ToCountryView(countries) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse(rs, nil, nil, nil, "")) } // GetCities godoc // @Summary Get list cities by country // @Description Get list cities by country // @id getCitiesList // @Tags Metadata // @Accept json // @Produce json // @Success 200 {object} CitiesResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/countries/{country_id}/cities [get] func (h *handler) GetCities(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "GetCities", }) countryID := c.Param("country_id") if countryID == "" { l.Info("country_id is empty") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errors.New("country_id is empty"), nil, "")) return } country, err := h.store.Country.One(h.repo.DB(), countryID) if err != nil { l.AddField("countryID", countryID).Error(err, "failed to get cities") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse(country.Cities, nil, nil, nil, "")) } // Stacks godoc // @Summary Get list values for stacks // @Description Get list values for stacks // @id getStacksList // @Tags Metadata // @Accept json // @Produce json // @Param keyword query string false "Keyword" // @Param page query string false "Page" // @Param size query string false "Size" // @Success 200 {object} StackResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/stacks [get] func (h *handler) Stacks(c *gin.Context) { var input request.GetStacksInput if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "Stacks", "input": input, }) total, stacks, err := h.store.Stack.All(h.repo.DB(), input.Keyword, &input.Pagination) if err != nil { l.Error(err, "failed to get all stack") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](stacks, &view.PaginationResponse{Pagination: view.Pagination{Page: input.Pagination.Page, Size: input.Pagination.Size, Sort: input.Pagination.Sort}, Total: total}, nil, nil, "")) } // UpdateStack godoc // @Summary Update stack information by ID // @Description Update stack information by ID // @id updateStack // @Tags Metadata // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Stack ID" // @Param Body body UpdateStackBody true "Body" // @Success 200 {object} MessageResponse // @Failure 404 {object} ErrorResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/stacks/{id} [put] func (h *handler) UpdateStack(c *gin.Context) { var input request.UpdateStackInput input.ID = c.Param("id") if err := c.ShouldBindJSON(&input.Body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "UpdateStack", "input": input, }) if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } stack, err := h.store.Stack.One(h.repo.DB(), input.ID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "Stack not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrStackNotFound, input, "")) return } l.Error(err, "failed to get stacks") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, input, "")) return } stack.Name = input.Body.Name stack.Avatar = input.Body.Avatar stack.Code = input.Body.Code _, err = h.store.Stack.Update(h.repo.DB(), stack) if err != nil { l.Error(err, "error query Stacks from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 2 return array of account statuses c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // CreateStack godoc // @Summary Create new stack // @Description Create new stack // @id createStack // @Tags Metadata // @Accept json // @Produce json // @Security BearerAuth // @Param Body body CreateStackInput true "Body" // @Success 200 {object} MessageResponse // @Failure 404 {object} ErrorResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/stacks [post] func (h *handler) CreateStack(c *gin.Context) { var input request.CreateStackInput if err := c.ShouldBindJSON(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "CreateStack", "input": input, }) stack := &model.Stack{ Name: input.Name, Code: input.Code, Avatar: input.Avatar, } _, err := h.store.Stack.Create(h.repo.DB(), stack) if err != nil { l.Error(err, "error query Stacks from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 2 return array of account statuses c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // DeleteStack godoc // @Summary Delete stack by ID // @Description Delete stack by ID // @id deleteStack // @Tags Metadata // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Stack ID" // @Success 200 {object} MessageResponse // @Failure 404 {object} ErrorResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/stacks/{id} [delete] func (h *handler) DeleteStack(c *gin.Context) { stackID := c.Param("id") if stackID == "" || !model.IsUUIDFromString(stackID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidStackID, stackID, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "DeleteStack", "stackID": stackID, }) if err := h.store.Stack.Delete(h.repo.DB(), stackID); err != nil { l.Error(err, "error query Stacks from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // 2 return array of account statuses c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // UpdatePosition godoc // @Summary Update position information by ID // @Description Update position information by ID // @id updatePosition // @Tags Metadata // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Position ID" // @Param Body body UpdatePositionBody true "Body" // @Success 200 {object} MessageResponse // @Failure 404 {object} ErrorResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/positions/{id} [put] func (h *handler) UpdatePosition(c *gin.Context) { var input request.UpdatePositionInput input.ID = c.Param("id") if err := c.ShouldBindJSON(&input.Body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "UpdatePosition", "input": input, }) if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } position, err := h.store.Position.One(h.repo.DB(), model.MustGetUUIDFromString(input.ID)) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "position not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrPositionNotFound, input, "")) return } l.Error(err, "failed to get position") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, input, "")) return } position.Name = input.Body.Name position.Code = input.Body.Code _, err = h.store.Position.Update(h.repo.DB(), position) if err != nil { l.Error(err, "error query Positions from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // CreatePosition godoc // @Summary Create new position // @Description Create new position // @id createPosition // @Tags Metadata // @Accept json // @Produce json // @Security BearerAuth // @Param Body body CreatePositionInput true "Body" // @Success 200 {object} MessageResponse // @Failure 404 {object} ErrorResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/positions [post] func (h *handler) CreatePosition(c *gin.Context) { var input request.CreatePositionInput if err := c.ShouldBindJSON(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "CreatePosition", "input": input, }) position := &model.Position{ Name: input.Name, Code: input.Code, } _, err := h.store.Position.Create(h.repo.DB(), position) if err != nil { l.Error(err, "error query Positions from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // DeletePosition godoc // @Summary Delete position by ID // @Description Delete position by ID // @id deletePosition // @Tags Metadata // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Position ID" // @Success 200 {object} MessageResponse // @Failure 404 {object} ErrorResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/positions/{id} [delete] func (h *handler) DeletePosition(c *gin.Context) { positionID := c.Param("id") if positionID == "" || !model.IsUUIDFromString(positionID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidPositionID, positionID, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "DeletePosition", "positionID": positionID, }) if err := h.store.Position.Delete(h.repo.DB(), positionID); err != nil { l.Error(err, "error query Position from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // GetQuestions godoc // @Summary Get list question by category and subcategory // @Description Get list question by category and subcategory // @id getQuestionsList // @Tags Metadata // @Accept json // @Produce json // @Param category query EventType true "Category" // @Param subcategory query EventSubtype true "Subcategory" // @Success 200 {object} GetQuestionResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/questions [get] func (h *handler) GetQuestions(c *gin.Context) { var input GetQuestionsInput if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "GetQuestions", "input": input, }) rs, err := h.store.Question.AllByCategory(h.repo.DB(), model.EventType(input.Category), model.EventSubtype(input.Subcategory)) if err != nil { l.Error(err, "failed to get question from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListQuestion(rs), nil, nil, nil, "")) } // GetCurrencies godoc // @Summary Get list currencies // @Description Get list currencies // @id getCurrenciesList // @Tags Metadata // @Accept json // @Produce json // @Success 200 {object} GetCurrenciesResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /metadata/currencies [get] func (h *handler) GetCurrencies(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "metadata", "method": "GetCurrencies", }) rs, err := h.store.Currency.GetList(h.repo.DB()) if err != nil { l.Error(err, "failed to get question from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToCurrencies(rs), nil, nil, nil, "")) } // Banks godoc // @Summary Get all banks // @Description Get all bank by given filter params // @id getBanksList // @Tags Metadata // @Accept json // @Produce json // @Param id query string false "Bank ID" // @Param bin query string false "Bin" // @Param swiftCode query string false "Swift SwiftCode" // @Success 200 {object} ListBankResponse // @Failure 500 {object} ErrorResponse // @Router /banks [get] func (h *handler) Banks(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "bank", "method": "List", }) query := request.GetBankRequest{} if err := c.ShouldBindQuery(&query); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "")) return } res, err := h.store.Bank.All(h.repo.DB(), bankRepo.GetBanksInput{ ID: query.ID, Bin: query.Bin, SwiftCode: query.SwiftCode, }) if err != nil { l.Error(err, "failed to get all banks") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListBank(res), nil, nil, nil, "")) }
```

# pkg/handler/metadata/request.go

```go
package metadata // GetQuestionsInput input params for get questions api type GetQuestionsInput struct { Category EventType `form:"category" json:"category" binding:"required"` Subcategory EventSubtype `form:"subcategory" json:"subcategory" binding:"required"` } type EventType string // @name EventType type EventStatus string // @name EventStatus const ( EventTypeFeedback EventType = "feedback" EventTypeSurvey EventType = "survey" ) // IsValid validation for EventType func (e EventType) IsValid() bool { switch e { case EventTypeFeedback, EventTypeSurvey: return true } return false } func (e EventType) String() string { return string(e) } type EventSubtype string // @name EventSubtype const ( EventSubtypePeerReview EventSubtype = "peer-review" EventSubtypeEngagement EventSubtype = "engagement" EventSubtypeWork EventSubtype = "work" EventSubtypeAppreciation EventSubtype = "appreciation" EventSubtypeComment EventSubtype = "comment" ) func (e EventSubtype) IsValid() bool { switch e { case EventSubtypePeerReview, EventSubtypeEngagement, EventSubtypeWork, EventSubtypeAppreciation, EventSubtypeComment: return true } return false } // Validate check valid for values in input params func (i GetQuestionsInput) Validate() error { if i.Category == "" || !i.Category.IsValid() { return ErrInvalidCategory } if i.Subcategory == "" || !i.Subcategory.IsValid() { return ErrInvalidSubcategory } return nil }
```

# pkg/handler/metadata/request/request.go

```go
package request import ( "github.com/dwarvesf/fortress-api/pkg/handler/metadata/errs" "github.com/dwarvesf/fortress-api/pkg/model" ) type UpdateStackBody struct { Name string `json:"name"` Code string `json:"code"` Avatar string `json:"avatar"` } // @name UpdateStackBody type UpdateStackInput struct { ID string Body UpdateStackBody } // @name UpdateStackInput func (i UpdateStackInput) Validate() error { if i.ID == "" || !model.IsUUIDFromString(i.ID) { return errs.ErrInvalidStackID } return nil } type CreateStackInput struct { Name string `json:"name" binding:"required"` Code string `json:"code" binding:"required"` Avatar string `json:"avatar"` } // @name CreateStackInput type UpdatePositionBody struct { Name string `json:"name"` Code string `json:"code"` } // @name UpdatePositionBody type UpdatePositionInput struct { ID string Body UpdatePositionBody } // @name UpdatePositionInput func (i UpdatePositionInput) Validate() error { if i.ID == "" || !model.IsUUIDFromString(i.ID) { return errs.ErrInvalidPositionID } return nil } type CreatePositionInput struct { Name string `json:"name" binding:"required"` Code string `json:"code" binding:"required"` } // @name CreatePositionInput type GetStacksInput struct { model.Pagination Keyword string `json:"keyword" form:"keyword"` } type GetBankRequest struct { ID string `json:"id" form:"id" ` Bin string `json:"bin" form:"bin"` SwiftCode string `json:"swiftCode" form:"swiftCode"` }
```

# pkg/handler/news/fetch.go

```go
package news import ( "net/http" "strings" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/gin-gonic/gin" ) func (h *handler) Fetch(c *gin.Context) { l := h.logger.Fields( logger.Fields{ "handler": "discord", "method": "Fetch", }, ) platform := strings.TrimSpace(c.Query("platform")) if platform == "" { l.Info("platform is empty") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "platform is empty")) return } topic := strings.TrimSpace(c.Query("topic")) if topic == "" { l.Info("topic is empty") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "topic is empty")) return } var posts []model.News var err error switch platform { case model.LobstersPlatform: posts, err = h.controller.News.FetchLobstersNews(c.Request.Context(), topic) if err != nil { l.Error(err, "failed to fetch lobsters news") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } case model.RedditPlatform: posts, err = h.controller.News.FetchRedditNews(c.Request.Context(), topic) if err != nil { l.Error(err, "failed to fetch reddit news") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse(view.ToFetchNewsResponse(posts), nil, nil, nil, "")) }
```

# pkg/handler/news/interface.go

```go
package news import ( "github.com/gin-gonic/gin" ) type IHandler interface { Fetch(c *gin.Context) }
```

# pkg/handler/news/news.go

```go
package news import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/store" ) type handler struct { store *store.Store controller *controller.Controller logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(store *store.Store, repo store.DBRepo, controller *controller.Controller, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, controller: controller, logger: logger, config: cfg, } }
```

# pkg/handler/notion/audience.go

```go
// Package notion please edit this file only with approval from hnh package notion import ( "net/http" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) // ListAudiences godoc // @Summary Get list audiences from DF Audience // @Description Get list audiences from DF Audience // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/audiences [get] func (h *handler) ListAudiences(c *gin.Context) { filter := &notion.DatabaseQueryFilter{} filterNewSubscriber := true if c.Query("new_subscriber") == "false" { filterNewSubscriber = false } filter.And = append(filter.And, notion.DatabaseQueryFilter{ Property: "New Subscriber", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ Checkbox: &notion.CheckboxDatabaseQueryFilter{ Equals: &filterNewSubscriber, }, }, }) resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Audience, filter, []notion.DatabaseQuerySort{ { Direction: notion.SortDirDesc, Timestamp: notion.SortTimeStampCreatedTime, }, }, 0) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get list audiences from notion")) return } var audiences []model.NotionAudience for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) fullName := "" if len(props["Full Name"].Title) > 0 { fullName = props["Full Name"].Title[0].Text.Content } var sources []string for _, c := range props["Source"].MultiSelect { sources = append(sources, c.Name) } email := "" if props["Email"].Email != nil { email = *props["Email"].Email } audiences = append(audiences, model.NotionAudience{ ID: r.ID, FullName: fullName, Email: email, CreatedAt: r.CreatedTime, Sources: sources, }) } c.JSON(http.StatusOK, view.CreateResponse[any](audiences, nil, nil, nil, "get list audiences successfully")) }
```

# pkg/handler/notion/changelog.go

```go
package notion import ( "context" "fmt" "net/http" "net/url" "path/filepath" "runtime/debug" "sort" "strings" "time" "github.com/Boostport/mjml-go" nt "github.com/dstotijn/go-notion" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/notion" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/gin-gonic/gin" "github.com/sendgrid/sendgrid-go/helpers/mail" ) const ( projectColumn = "Project" clientsColumn = "Client" groupEmailColumn = "Group Email" changelogRecipientsColumn = "Changelog Recipients" leadColumn = "Lead" changelogColumn = "Changelog" portalColumn = "Project Portal" emailSubject = "EmailSubject" ) type singleChangelogError struct { ProjectName string Err error } func (e singleChangelogError) Error() string { return fmt.Sprintf("%s: %s", e.ProjectName, e.Err.Error()) } func parseProjectChangelogNotionMessageFromCtx(c *gin.Context) (ProjectChangelog, error) { msg := ProjectChangelog{} err := c.ShouldBindJSON(&msg) if err != nil { return msg, err } return msg, nil } // GetAvailableProjectsChangelog godoc // @Summary get available projects changelog // @Description get available projects changelog // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/changelogs/projects/available [get] func (h *handler) GetAvailableProjectsChangelog(c *gin.Context) { projects, err := h.service.Notion.ListProject() if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](projects, nil, nil, nil, "")) } // SendProjectChangelog godoc // @Summary send project changelog // @Description send project changelog // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/changelogs/project [post] func (h *handler) SendProjectChangelog(c *gin.Context) { msg, err := parseProjectChangelogNotionMessageFromCtx(c) if err != nil { h.logger.Error(err, "failed to parse project changelog message") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if err = h.sendProjectChangelog(msg); err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } func (h *handler) sendProjectChangelog(changelog ProjectChangelog) error { key := "project changelog" if changelog.IsPreview { key = "project changelog preview" } categories := []string{key, changelog.ProjectPageID} values, err := h.service.Notion.GetProjectInDB(changelog.ProjectPageID) if err != nil { h.logger.Errorf(err, "failed to get project in db", "project", changelog.ProjectPageID) return err } return h.sendSingleProjectChangelog(changelog.ProjectPageID, *values, &mail.Email{ Name: changelog.From.Name, Address: changelog.From.Email}, categories, changelog.IsPreview, ) } func (h *handler) sendSingleProjectChangelog( id string, values nt.DatabasePageProperties, from *mail.Email, categories []string, isPreview bool, ) error { m, _, err := h.generateEmailChangelog(id, values, from, categories, isPreview) if err != nil { return err } if err := h.service.Sendgrid.SendEmail(m); err != nil { return err } h.logger.Info(fmt.Sprintf("Send %s successfully", m.Subject)) return nil } func (h *handler) generateEmailChangelog( id string, values nt.DatabasePageProperties, from *mail.Email, categories []string, isPreview bool, ) (*model.Email, *model.ProjectChangelogPage, error) { m := model.Email{From: from, Categories: categories} var changelogBlocks []nt.Block projectName := "" archiveURL := "" p := model.ProjectChangelogPage{RowID: id} defer func() { if r := recover(); r != nil { fmt.Println("stacktrace from panic: \n" + string(debug.Stack())) h.logger.Error(fmt.Errorf("%v", r), "Recovered "+projectName) } }() // process for i, v := range values { switch i { case projectColumn: if len(v.Title) < 1 || v.Title[0].Text == nil { continue } projectName = v.Title[0].Text.Content p.Name = projectName case portalColumn: if v.URL == nil { continue } archiveURL = *v.URL if archiveURL != "" { if !strings.HasPrefix(archiveURL, "http") || !strings.HasPrefix(archiveURL, "https") { archiveURL = "https://" + archiveURL } } case changelogRecipientsColumn: if len(v.Relation) < 1 { continue } for _, c := range v.Relation { clientPage, err := h.service.Notion.FindClientPageForChangelog(c.ID) if err != nil { h.logger.Errorf(err, "failed to find client page for changelog", "clientPage", c.ID) return nil, nil, singleChangelogError{ProjectName: projectName, Err: err} } props := clientPage.Properties.(nt.DatabasePageProperties) var name string if len(props["First Name"].RichText) > 0 { name = props["First Name"].RichText[0].Text.Content } address := props["Email"].Email if name == "" || *address == "" { continue } m.To = append(m.To, &mail.Email{Name: name, Address: *address}) } case groupEmailColumn: if len(v.RichText) < 1 || v.RichText[0].Text == nil { continue } groupEmails := v.RichText[0].Text.Content gms := strings.Split(groupEmails, ",") for _, groupEmail := range gms { bccMail := strings.TrimSpace(groupEmail) m.Bcc = append(m.Bcc, &mail.Email{Name: bccMail, Address: bccMail}) } case leadColumn: if len(v.Relation) < 1 { continue } for _, c := range v.Relation { recipientsPage, err := h.service.Notion.FindClientPageForChangelog(c.ID) if err != nil { h.logger.Errorf(err, "failed to find page for changelogs", "clientPage", c.ID) return nil, nil, singleChangelogError{ProjectName: projectName, Err: err} } props := recipientsPage.Properties.(nt.DatabasePageProperties) var name string if len(props["Full Name"].Title) > 0 { name = props["Full Name"].Title[0].Text.Content } address := props["Team Email"].Email if name == "" || *address == "" { continue } m.Bcc = append(m.Bcc, &mail.Email{Name: name, Address: *address}) } case changelogColumn: if v.URL == nil { continue } changelogsID := "" changelogsURL := *v.URL fields := strings.Split(changelogsURL, "/") changelogsID = strings.Split(fields[len(fields)-1], "?")[0] // timeFilter is one month ago from now timeFilter := time.Now().AddDate(0, -1, 0) resp, err := h.service.Notion.GetDatabase(changelogsID, &nt.DatabaseQueryFilter{ And: []nt.DatabaseQueryFilter{ { Property: "Created", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{ Date: &nt.DatePropertyFilter{ OnOrAfter: &timeFilter, }, }, }, }, }, nil, 0) if err != nil { h.logger.Error(err, "download page") return nil, nil, singleChangelogError{ProjectName: projectName, Err: err} } var pages = resp.Results // get latest changelog sort.Slice(pages, func(i, j int) bool { propsI := pages[i].Properties.(nt.DatabasePageProperties) propsJ := pages[j].Properties.(nt.DatabasePageProperties) return propsI["Created"].Date.Start.After(propsJ["Created"].Date.Start.Time) }) var latestChangelogPage = pages[0] pageContent, err := h.service.Notion.GetBlockChildren(latestChangelogPage.ID) if err != nil { h.logger.Errorf(err, "failed to download page", "pageID", latestChangelogPage.ID) return nil, nil, singleChangelogError{ProjectName: projectName, Err: err} } changelogBlocks = pageContent.Results } } // pageTitle := changelogPage.Root().Title if isPreview { // m.Bcc = []*mail.Email{mail.NewEmail("Minh Luu", "leo@dwarvesv.com")} m.Categories = []string{} m.To = []*mail.Email{mail.NewEmail("Minh Luu", "leo@d.foundation")} } m.Subject = values[emailSubject].Title[0].Text.Content // Get children blocks of changelogBlocks if err := h.getChildrenBlocks(changelogBlocks); err != nil { h.logger.Error(err, "failed to get block children") return nil, nil, singleChangelogError{ProjectName: projectName, Err: err} } // upload temp image from notion s3 to gcs for i, block := range changelogBlocks { switch v := block.(type) { case *nt.ImageBlock: var isExternalFile = v.External != nil var imgURL string if isExternalFile { imgURL = v.External.URL } else { imgURL = v.File.URL } // parse the url u, err := url.Parse(imgURL) if err != nil { return nil, nil, singleChangelogError{ProjectName: projectName, Err: err} } // get the file extension extension := filepath.Ext(u.Path) fPath := fmt.Sprintf("https://storage.googleapis.com/%s/projects/change-logs-images/%s", h.config.Google.GCSBucketName, v.ID()) gcsPath := fmt.Sprintf("projects/change-logs-images/%s", v.ID()+extension) response, err := http.Get(imgURL) if err != nil { return nil, nil, singleChangelogError{ProjectName: projectName, Err: err} } defer response.Body.Close() if err := h.service.GoogleStorage.UploadContentGCS(response.Body, gcsPath); err != nil { return nil, nil, singleChangelogError{ProjectName: projectName, Err: err} } if isExternalFile { changelogBlocks[i].(*nt.ImageBlock).External.URL = fPath + extension } else { changelogBlocks[i].(*nt.ImageBlock).File.URL = fPath + extension } } } content, err := h.service.Notion.ToChangelogMJML(changelogBlocks, m) if err != nil { h.logger.Error(err, "To Changelog MJML") return nil, nil, singleChangelogError{ProjectName: projectName, Err: err} } mjmlContent := fmt.Sprintf(notion.MJMLChangelogTemplate, content, archiveURL, archiveURL) m.HTMLContent, err = mjml.ToHTML(context.Background(), mjmlContent) if err != nil { h.logger.Error(err, "To HTML") return nil, nil, singleChangelogError{ProjectName: projectName, Err: err} } return &m, &p, nil } func (h *handler) getChildrenBlocks(blocks []nt.Block) error { for _, block := range blocks { if block.HasChildren() { switch v := block.(type) { case *nt.BulletedListItemBlock: children, err := h.service.Notion.GetBlockChildren(block.ID()) if err != nil { return err } v.Children = children.Results if err := h.getChildrenBlocks(v.Children); err != nil { return err } default: continue } } } return nil }
```

# pkg/handler/notion/digest.go

```go
// Package notion please edit this file only with approval from hnh package notion import ( "net/http" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) // ListDigests godoc // @Summary Get list digests from DF Internal Digest // @Description Get list digests from DF Internal Digest // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/digests [get] func (h *handler) ListDigests(c *gin.Context) { resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Digest, nil, []notion.DatabaseQuerySort{ { Property: "Created at", Direction: notion.SortDirDesc, }, }, 5) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get digests from notion")) return } var digests []model.NotionDigest for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) name := props["Name"].Title[0].Text.Content if r.Icon != nil && r.Icon.Emoji != nil { name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content } digests = append(digests, model.NotionDigest{ ID: r.ID, Name: name, CreatedAt: props["Created at"].Date.Start.Time, }) } c.JSON(http.StatusOK, view.CreateResponse[any](digests, nil, nil, nil, "get list digests successfully")) }
```

# pkg/handler/notion/earn.go

```go
// Package notion please edit this file only with approval from hnh package notion import ( "net/http" "time" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) // ListEarns godoc // @Summary Get list items from DF earn // @Description Get list items from DF earn // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/earns [get] func (h *handler) ListEarns(c *gin.Context) { filter := &notion.DatabaseQueryFilter{} rewardFilter := 0 filter.And = append(filter.And, notion.DatabaseQueryFilter{ Property: "Reward ðŸ§Š", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ Number: &notion.NumberDatabaseQueryFilter{ GreaterThan: &rewardFilter, }, }, }, notion.DatabaseQueryFilter{ Property: "Status", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ Status: &notion.StatusDatabaseQueryFilter{ Equals: "Open", }, }, }, notion.DatabaseQueryFilter{ Property: "PICs", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ People: &notion.PeopleDatabaseQueryFilter{ IsEmpty: true, }, }, }, ) resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Earn, filter, []notion.DatabaseQuerySort{ { Property: "Reward ðŸ§Š", Direction: notion.SortDirAsc, }, }, 0) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get items earn from notion")) return } var earns = make([]model.NotionEarn, 0, len(resp.Results)) for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) if props["Status"].Status == nil { continue } if props["Reward ðŸ§Š"].Number == nil || *props["Reward ðŸ§Š"].Number == 0 { continue } var tags []string for _, tag := range props["Tags"].MultiSelect { tags = append(tags, tag.Name) } var functions []string for _, f := range props["Function"].MultiSelect { functions = append(functions, f.Name) } var employees []model.Employee for _, e := range props["PICs"].People { if e.Person == nil { continue } employees = append(employees, model.Employee{ FullName: e.Name, PersonalEmail: e.Person.Email, Avatar: e.AvatarURL, }) } var dueData *time.Time if props["Due Date"].Date != nil { dueData = &props["Due Date"].Date.Start.Time } name := props["Name"].Title[0].Text.Content if r.Icon != nil && r.Icon.Emoji != nil { name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content } parentID := "" if len(props["Parent item"].Relation) > 0 { parentID = props["Parent item"].Relation[0].ID } earns = append(earns, model.NotionEarn{ ID: r.ID, Name: name, Reward: int(*props["Reward ðŸ§Š"].Number), Tags: tags, PICs: employees, Status: props["Status"].Status.Name, Function: functions, DueDate: dueData, ParentID: parentID, }) } c.JSON(http.StatusOK, view.CreateResponse[any](earns, nil, nil, nil, "get list earn items successfully")) }
```

# pkg/handler/notion/event.go

```go
// Package notion please edit this file only with approval from hnh package notion import ( "net/http" "strconv" "time" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) // ListEvents godoc // @Summary Get list events from DF Dwarves Community Events // @Description Get list events from DF Dwarves Community Events // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/events [get] func (h *handler) ListEvents(c *gin.Context) { filter := &notion.DatabaseQueryFilter{} nextDays := 7 if c.Query("d") != "" { d, ok := c.GetQuery("d") if !ok { d = "7" } var err error nextDays, err = strconv.Atoi(d) if err != nil { nextDays = 7 } } from := time.Now() to := from.Add(24 * time.Hour * time.Duration(nextDays)) filter.And = append(filter.And, notion.DatabaseQueryFilter{ Property: "Date", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ Date: &notion.DatePropertyFilter{ OnOrAfter: &from, }, }, }) filter.And = append(filter.And, notion.DatabaseQueryFilter{ Property: "Date", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ Date: &notion.DatePropertyFilter{ OnOrBefore: &to, }, }, }) resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Event, filter, []notion.DatabaseQuerySort{ { Property: "Date", Direction: notion.SortDirAsc, }, }, 0) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get events from notion")) return } var events []model.NotionEvent for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) name := props["Name"].Title[0].Text.Content if r.Icon != nil && r.Icon.Emoji != nil { name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content } activityType := "" if props["Activity Type"].Select != nil { activityType = props["Activity Type"].Select.Name } var date model.DateTime if props["Date"].Date != nil { date.Time = props["Date"].Date.Start.Time date.HasTime = props["Date"].Date.Start.HasTime() } events = append(events, model.NotionEvent{ ID: r.ID, Name: name, ActivityType: activityType, Date: date, CreatedAt: r.CreatedTime, }) } c.JSON(http.StatusOK, view.CreateResponse[any](events, nil, nil, nil, "get list events successfully")) }
```

# pkg/handler/notion/hiring.go

```go
// Package notion Package hiring please edit this file only with approval from hnh package notion import ( "net/http" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/thoas/go-funk" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) // ListHiringPositions godoc // @Summary Get list hiring from DF Dwarves Hiring // @Description Get list hiring from DF Dwarves Hiring // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/hiring-positions [get] func (h *handler) ListHiringPositions(c *gin.Context) { filter := &notion.DatabaseQueryFilter{} status := "Active" if c.Query("status") != "" { if !funk.Contains([]string{"Active", "Inactive"}, c.Query("status")) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "status must be Active or Inactive")) return } status = c.Query("status") } filter.And = append(filter.And, notion.DatabaseQueryFilter{ Property: "Status", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ Select: &notion.SelectDatabaseQueryFilter{ Equals: status, }, }, }) resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Hiring, nil, []notion.DatabaseQuerySort{ { Direction: notion.SortDirDesc, Timestamp: notion.SortTimeStampCreatedTime, }, }, 0) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get hiring positions from notion")) return } var positions []model.NotionHiringPosition for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) if props["Status"].Select == nil || props["Status"].Select.Name != status { continue } name := props["Name"].Title[0].Text.Content if r.Icon != nil && r.Icon.Emoji != nil { name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content } var projects []string if props["Project"].MultiSelect != nil { for _, p := range props["Project"].MultiSelect { projects = append(projects, p.Name) } } positions = append(positions, model.NotionHiringPosition{ ID: r.ID, Name: name, Status: props["Status"].Select.Name, Projects: projects, CreatedAt: r.CreatedTime, }) } c.JSON(http.StatusOK, view.CreateResponse[any](positions, nil, nil, nil, "get list hiring positions successfully")) }
```

# pkg/handler/notion/interface.go

```go
package notion import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/gin-gonic/gin" ) type IHandler interface { CreateTechRadar(c *gin.Context) GetAvailableProjectsChangelog(c *gin.Context) ListEarns(c *gin.Context) ListMemos(c *gin.Context) ListTechRadars(c *gin.Context) ListAudiences(c *gin.Context) ListEvents(c *gin.Context) ListDigests(c *gin.Context) ListUpdates(c *gin.Context) ListIssues(c *gin.Context) ListStaffingDemands(c *gin.Context) ListHiringPositions(c *gin.Context) ListProjectMilestones(c *gin.Context) SendNewsLetter(c *gin.Context) SendProjectChangelog(c *gin.Context) } type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, } }
```

# pkg/handler/notion/issue.go

```go
// Package notion please edit this file only with approval from hnh package notion import ( "net/http" "time" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) // ListIssues godoc // @Summary Get list issues from DF Issues & Resolution Log // @Description Get list issues from DF Issues & Resolution Log // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/issues [get] func (h *handler) ListIssues(c *gin.Context) { resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Issue, nil, []notion.DatabaseQuerySort{ { Property: "Incident Date", Direction: notion.SortDirDesc, }, }, 0) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get issues from notion")) return } var issues []model.NotionIssue for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) if props["Status"].Status == nil || props["Status"].Status.Name == "Done" { continue } source := "" if len(props["Source"].MultiSelect) > 0 { source = props["Source"].MultiSelect[0].Name } serverity := "" if props["Severity"].Select != nil { serverity = props["Severity"].Select.Name } scope := "" if len(props["Scope"].MultiSelect) > 0 { scope = props["Scope"].MultiSelect[0].Name } var projects []string if len(props["Project"].Relation) > 0 { for _, p := range props["Project"].Relation { projects = append(projects, p.ID) } } pic := "" if len(props["PIC"].People) > 0 { pic = props["PIC"].People[0].Name } priority := "" if props["Priority"].Select != nil { priority = props["Priority"].Select.Name } profile := "" if len(props["Profile"].Relation) > 0 { profile = props["Profile"].Relation[0].ID } resolution := "" if len(props["Resolution"].RichText) > 0 { resolution = props["Resolution"].RichText[0].Text.Content } var incidentDate time.Time if props["Incident Date"].Date != nil { incidentDate = props["Incident Date"].Date.Start.Time } var solvedDate time.Time if props["Solved Date"].Date != nil { solvedDate = props["Solved Date"].Date.Start.Time } rootCause := "" if len(props["Rootcause"].RichText) > 0 { rootCause = props["Rootcause"].RichText[0].Text.Content } name := props["Name"].Title[0].Text.Content if r.Icon != nil && r.Icon.Emoji != nil { name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content } issues = append(issues, model.NotionIssue{ ID: r.ID, Name: name, Status: props["Status"].Status.Name, Source: source, RootCause: rootCause, IncidentDate: &incidentDate, SolvedDate: &solvedDate, Severity: serverity, Scope: scope, Projects: projects, PIC: pic, Priority: priority, Profile: profile, Resolution: resolution, }) } c.JSON(http.StatusOK, view.CreateResponse[any](issues, nil, nil, nil, "get list issues successfully")) }
```

# pkg/handler/notion/memo.go

```go
// Package notion please edit this file only with approval from hnh package notion import ( "net/http" "github.com/dstotijn/go-notion" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/gin-gonic/gin" ) // ListMemos godoc // @Summary Get list memos from DF Memos // @Description Get list memos from DF Memos // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/memos [get] func (h *handler) ListMemos(c *gin.Context) { resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Memo, nil, []notion.DatabaseQuerySort{ { Property: "Created", Direction: notion.SortDirDesc, }, }, 0) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get memos from notion")) return } var memos []model.NotionMemo for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) name := props["Name"].Title[0].Text.Content if r.Icon != nil && r.Icon.Emoji != nil { name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content } author := "" if len(props["Author"].People) > 0 { author = props["Author"].People[0].Name } var tags []string if len(props["Tags"].MultiSelect) > 0 { for _, t := range props["Tags"].MultiSelect { tags = append(tags, t.Name) } } memos = append(memos, model.NotionMemo{ ID: r.ID, Name: name, CreatedAt: props["Created"].Date.Start.Time, Tags: tags, Author: author, }) } c.JSON(http.StatusOK, view.CreateResponse[any](memos, nil, nil, nil, "get list memos successfully")) }
```

# pkg/handler/notion/newsletter.go

```go
package notion import ( "context" "fmt" "net/http" "net/url" "path/filepath" "github.com/Boostport/mjml-go" nt "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/notion" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/sendgrid/sendgrid-go/helpers/mail" ) type From struct { Email string `json:"email,omitempty"` Name string `json:"name,omitempty"` } type ProjectChangelog struct { ProjectPageID string `json:"project_page_id,omitempty"` IsPreview bool `json:"is_preview"` From From `json:"from,omitempty"` } // SendNewsLetter godoc // @Summary send project changelog // @Description send project changelog // @Tags Notion // @Accept json // @Produce json // @Param id path string true "id" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/df-updates/{id}/send [post] func (h *handler) SendNewsLetter(c *gin.Context) { contentID := c.Param("id") isPreview := false if c.Query("preview") == "true" { isPreview = true } categories := []string{"newsletter", contentID} var emails []*model.Email m, err := h.generateEmailNewsletter( contentID, &mail.Email{ Name: "Dwarves Team", Address: "team@d.foundation", }, categories, ) if err != nil { h.logger.Error(err, "generateEmailNewsletter() failed") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if isPreview { emails = []*model.Email{ { HTMLContent: m.HTMLContent, Subject: m.Subject, From: m.From, To: []*mail.Email{ mail.NewEmail("Minh Luu", "leo@d.foundation"), mail.NewEmail("Huy Nguyen", "huy@d.foundation"), mail.NewEmail("Nikki", "nikki@d.foundation"), mail.NewEmail("Inno", "mytx@d.foundation"), mail.NewEmail("Vi", "tranthiaivi.cs@gmail.com"), }, Categories: categories, }, } } else { // get subscribers subscribers, _, err := h.getSubscribers(h.config.Notion.Databases.Audience, "Dwarves Updates") if err != nil { h.logger.Error(err, "getSubscribers() failed") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // get audience list for _, s := range subscribers { if err != nil { h.logger.Error(err, "ToNewsletterHtml() failed with "+s.Address) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } emails = append(emails, &model.Email{ HTMLContent: m.HTMLContent, Subject: m.Subject, From: m.From, To: []*mail.Email{s}, Categories: categories, }) } if h.config.Env != "prod" { if len(emails) > 1 { emails = emails[:1] } } } for _, email := range emails { err = h.service.Sendgrid.SendEmail(email) if err != nil { h.logger.Error(err, "send email failed: "+email.To[0].Address+" "+email.Subject) continue } } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } func (h *handler) getSubscribers(pageID, audience string) ([]*mail.Email, []string, error) { records, err := h.service.Notion.QueryAudienceDatabase(pageID, audience) if err != nil { h.logger.Error(err, "query audience database") return nil, nil, err } var mails []*mail.Email var subs []string for i := range records { props := records[i].Properties.(nt.DatabasePageProperties) var name string if len(props["First Name"].RichText) > 0 { name = props["First Name"].RichText[0].PlainText } address := props["Email"].Email if address == nil { continue } if name == "" { continue } id := records[i].ID subs = append(subs, id) mails = append(mails, &mail.Email{ Name: name, Address: *address, }) } return mails, subs, nil } func (h *handler) generateEmailNewsletter(id string, from *mail.Email, categories []string) (*model.Email, error) { m := model.Email{From: from, Categories: categories} var changelogBlocks []nt.Block title := "Dwarves Updates" page, err := h.service.Notion.GetBlock(id) if err != nil { h.logger.Error(err, "get block") return nil, err } switch v := page.(type) { case *nt.ChildPageBlock: title = v.Title } m.Subject = title pageContent, err := h.service.Notion.GetBlockChildren(id) if err != nil { h.logger.Errorf(err, "failed to download page", "pageID", id) return nil, err } changelogBlocks = pageContent.Results // Get children blocks of changelogBlocks for _, block := range changelogBlocks { if block.HasChildren() { children, err := h.service.Notion.GetBlockChildren(block.ID()) if err != nil { h.logger.Errorf(err, "failed to get block children", "blockID", block.ID()) return nil, err } switch v := block.(type) { case *nt.BulletedListItemBlock: v.Children = children.Results default: continue } } } // upload temp image from notion s3 to gcs for i, block := range changelogBlocks { switch v := block.(type) { case *nt.ImageBlock: // parse the url u, err := url.Parse(v.File.URL) if err != nil { return nil, err } // get the file extension extension := filepath.Ext(u.Path) fPath := fmt.Sprintf("https://storage.googleapis.com/%s/projects/newsletter-images/%s", h.config.Google.GCSBucketName, v.ID()) gcsPath := fmt.Sprintf("projects/newsletter-images/%s", v.ID()+extension) response, err := http.Get(v.File.URL) if err != nil { return nil, err } defer response.Body.Close() if err := h.service.GoogleStorage.UploadContentGCS(response.Body, gcsPath); err != nil { return nil, err } changelogBlocks[i].(*nt.ImageBlock).File.URL = fPath + extension } } content, err := h.service.Notion.ToChangelogMJML(changelogBlocks, m) if err != nil { h.logger.Error(err, "To Changelog MJML") return nil, err } m.HTMLContent, err = mjml.ToHTML(context.Background(), fmt.Sprintf(notion.MJMLDFUpdateTemplate, content)) if err != nil { h.logger.Error(err, "To HTML") return nil, err } return &m, nil }
```

# pkg/handler/notion/project_milestone.go

```go
package notion import ( "net/http" "regexp" "sort" "strings" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) // ListProjectMilestones godoc // @Summary Get list project milestones // @Description Get list project milestones // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/projects/milestones [get] func (h *handler) ListProjectMilestones(c *gin.Context) { filter := &notion.DatabaseQueryFilter{} filter.And = append(filter.And, []notion.DatabaseQueryFilter{{ Property: "Type", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ Select: &notion.SelectDatabaseQueryFilter{ Equals: "Project", }, }, }, { Property: "Status", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ Select: &notion.SelectDatabaseQueryFilter{ DoesNotEqual: "Done", }, }, }, }...) resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Delivery, filter, nil, 0) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "failed to get milestones from notion")) return } var projects []struct { Name string `json:"name"` Milestones []model.NotionProjectMilestone `json:"milestones"` } var milestones []model.NotionProjectMilestone for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) if props["Project"].Select == nil || (props["Project"].Select != nil && props["Project"].Select.Name == "") { continue } if c.Query("project_name") != "" { matched, err := regexp.MatchString(".*"+strings.ToLower(c.Query("project_name"))+".*", strings.ToLower(props["Project"].Select.Name)) if err != nil || !matched { continue } } m := model.NotionProjectMilestone{ ID: r.ID, Name: props["Scope"].Title[0].PlainText, Project: props["Project"].Select.Name, } if props["Date"].Date != nil { m.StartDate = props["Date"].Date.Start.Time if props["Date"].Date.End != nil { m.EndDate = props["Date"].Date.End.Time } } milestones = append(milestones, m) } // group milestones by project name for _, m := range milestones { found := false for i := range projects { if projects[i].Name == m.Project { projects[i].Milestones = append(projects[i].Milestones, m) found = true break } } if !found { p := struct { Name string `json:"name"` Milestones []model.NotionProjectMilestone `json:"milestones"` }{ Name: m.Project, Milestones: []model.NotionProjectMilestone{m}, } projects = append(projects, p) } } for i := range projects { sort.Slice(projects[i].Milestones[:], func(j, k int) bool { return projects[i].Milestones[j].StartDate.Before(projects[i].Milestones[k].StartDate) }) } sort.Slice(projects[:], func(i, j int) bool { return projects[i].Name < projects[j].Name }) c.JSON(http.StatusOK, view.CreateResponse[any](projects, nil, nil, nil, "get list milestones successfully")) }
```

# pkg/handler/notion/staffing_demand.go

```go
// Package notion please edit this file only with approval from hnh package notion import ( "net/http" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) // ListStaffingDemands godoc // @Summary Get list staffing demands from DF Staffing Demand // @Description Get list staffing demands from DF Staffing Demand // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/staffing-demands [get] func (h *handler) ListStaffingDemands(c *gin.Context) { resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.StaffingDemand, nil, nil, 0) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "failed to get staffing demands from notion")) return } var staffingDemands []model.NotionStaffingDemand for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) name := props["Project Name"].Title[0].Text.Content if r.Icon != nil && r.Icon.Emoji != nil { name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content } request := "" if len(props["Request"].RichText) > 0 { request = props["Request"].RichText[0].Text.Content } staffingDemands = append(staffingDemands, model.NotionStaffingDemand{ ID: r.ID, Name: name, Request: request, }) } c.JSON(http.StatusOK, view.CreateResponse[any](staffingDemands, nil, nil, nil, "get list staffing demands successfully")) }
```

# pkg/handler/notion/tech_radar.go

```go
// Package notion please edit this file only with approval from hnh package notion import ( "html" "net/http" "regexp" "strings" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/thoas/go-funk" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) // ListTechRadars godoc // @Summary Get list items from DF TechRadar // @Description Get list items from DF TechRadar // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/tech-radars [get] func (h *handler) ListTechRadars(c *gin.Context) { filter := &notion.DatabaseQueryFilter{} rings := []string{"Adopt", "Trial", "Assess", "Hold"} filterRings := rings if c.Query("name") != "" && len(c.Query("name")) < 2 { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "name must be at least 2 characters")) return } if len(c.Request.URL.Query()["ring"]) != 0 { filterRings = c.Request.URL.Query()["ring"] } for _, r := range filterRings { if !funk.Contains(rings, r) { continue } filter.Or = append(filter.Or, notion.DatabaseQueryFilter{ Property: "Status", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ Select: &notion.SelectDatabaseQueryFilter{ Equals: r, }, }, }) } resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.TechRadar, filter, nil, 0) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get items tech radar from notion")) return } var techs []model.NotionTechRadar for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) if props["Name"].Title == nil || len(props["Name"].Title) == 0 { continue } name := props["Name"].Title[0].Text.Content if c.Query("name") != "" { input := c.Query("name") escaped := html.EscapeString(input) matched, err := regexp.MatchString(".*"+strings.ToLower(escaped)+".*", html.EscapeString(strings.ToLower(name))) if err != nil || !matched { continue } } if r.Icon != nil && r.Icon.Emoji != nil { name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content } assign := "" if len(props["Assign"].People) > 0 { assign = props["Assign"].People[0].Name } quadrant := "" if props["Quadrant"].Select != nil { quadrant = props["Quadrant"].Select.Name } ring := "" if props["Status"].Select != nil { ring = props["Status"].Select.Name } var categories []string for _, c := range props["Categories"].MultiSelect { categories = append(categories, c.Name) } var tags []string for _, t := range props["Tag"].MultiSelect { tags = append(tags, t.Name) } techs = append(techs, model.NotionTechRadar{ ID: r.ID, Name: name, Assign: assign, Quadrant: quadrant, Categories: categories, Ring: ring, Tags: tags, }) } c.JSON(http.StatusOK, view.CreateResponse[any](techs, nil, nil, nil, "get list earn items successfully")) } // CreateTechRadar create a new tech radar item // @Summary Create a new tech radar item // @Description Create a new tech radar item // @Tags TechRadar // @Accept json // @Produce json // @Param body body model.NotionTechRadar true "body for create tech radar item" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse func (h *handler) CreateTechRadar(c *gin.Context) { var input model.NotionTechRadar if err := c.ShouldBindJSON(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "invalid input")) return } if input.Name == "" { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "name and ring are required")) return } // check item is existed var filter = &notion.DatabaseQueryFilter{} filter.And = append(filter.And, notion.DatabaseQueryFilter{ Property: "Name", DatabaseQueryPropertyFilter: notion.DatabaseQueryPropertyFilter{ Title: &notion.TextPropertyFilter{ Equals: input.Name, }, }, }) resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.TechRadar, filter, nil, 0) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get items tech radar from notion")) return } if len(resp.Results) > 0 { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, nil, nil, "item is exist")) return } properties := map[string]interface{}{ "Name": input.Name, "Status": "Assess", } if input.Assign != "" { properties["Assign"] = input.Assign } // create tech radar item pageID, err := h.service.Notion.CreateDatabaseRecord(h.config.Notion.Databases.TechRadar, properties) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't create tech radar item")) return } c.JSON(http.StatusOK, view.CreateResponse[any](pageID, nil, nil, nil, "create tech radar item successfully")) }
```

# pkg/handler/notion/update.go

```go
// Package notion please edit this file only with approval from hnh package notion import ( "net/http" "github.com/dstotijn/go-notion" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) // ListUpdates godoc // @Summary Get list updates from DF Updates // @Description Get list updates from DF Updates // @Tags Notion // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Router /notion/update [get] func (h *handler) ListUpdates(c *gin.Context) { resp, err := h.service.Notion.GetDatabase(h.config.Notion.Databases.Updates, nil, []notion.DatabaseQuerySort{ { Property: "Created at", Direction: notion.SortDirDesc, }, }, 5) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "can't get updates from notion")) return } var updates []model.NotionUpdate for _, r := range resp.Results { props := r.Properties.(notion.DatabasePageProperties) name := props["Name"].Title[0].Text.Content if r.Icon != nil && r.Icon.Emoji != nil { name = *r.Icon.Emoji + " " + props["Name"].Title[0].Text.Content } audience := "" if len(props["Audience"].MultiSelect) > 0 { audience = props["Audience"].MultiSelect[0].Name } updates = append(updates, model.NotionUpdate{ ID: r.ID, Name: name, CreatedAt: props["Created at"].Date.Start.Time, Audience: audience, }) } c.JSON(http.StatusOK, view.CreateResponse[any](updates, nil, nil, nil, "get list updates successfully")) }
```

# pkg/handler/payroll/bhxh.go

```go
package payroll import ( "net/http" "time" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/store/employee" "github.com/dwarvesf/fortress-api/pkg/view" ) func (h *handler) GetPayrollsBHXH(c *gin.Context) { res, err := h.getPayrollBHXHHandler() if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse(res, nil, nil, nil, "")) } func (h *handler) getPayrollBHXHHandler() (interface{}, error) { var res []payrollBHXHResponse isLeft := false for _, b := range []model.Batch{model.FirstBatch, model.SecondBatch} { date := time.Date(time.Now().Year(), time.Now().Month(), int(b), 0, 0, 0, 0, time.Now().Location()) us, _, err := h.store.Employee.All(h.repo.DB(), employee.EmployeeFilter{IsLeft: &isLeft, BatchDate: &date, Preload: true}, model.Pagination{Page: 0, Size: 500}) if err != nil { return nil, err } for i := range us { if us[i].BaseSalary.CompanyAccountAmount == 0 || us[i].BaseSalary.Batch != int(b) { continue } res = append(res, payrollBHXHResponse{ DisplayName: us[i].FullName, BHXH: us[i].BaseSalary.CompanyAccountAmount, Batch: int(b), AccountNumber: us[i].LocalBankNumber, Bank: us[i].LocalBranchName, }) } } return res, nil }
```

# pkg/handler/payroll/commit.go

```go
package payroll import ( "encoding/json" "errors" "fmt" "net/http" "strconv" "strings" "sync" "time" "github.com/gin-gonic/gin" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/handler/payroll/errs" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/service/currency" "github.com/dwarvesf/fortress-api/pkg/store/payroll" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" "github.com/dwarvesf/fortress-api/pkg/view" ) func (h *handler) CommitPayroll(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "payroll", "method": "CommitPayroll", }) l.Info("Start commit payroll") year, err := strconv.ParseInt(c.Query("year"), 0, 64) if err != nil || year <= 0 { year = int64(time.Now().Year()) } if c.Query("month") == "" { if year != int64(time.Now().Year()) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrBadRequest, nil, "")) return } year = int64(time.Now().Year()) } month, err := strconv.ParseInt(c.Query("month"), 0, 64) if err != nil { l.Errorf(err, "failed to parse month", "month", month) month = int64(time.Now().Month()) } batch, err := strconv.ParseInt(c.Query("date"), 0, 64) if err != nil { l.Errorf(err, "failed to parse date", "date", batch) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrBadRequest, nil, "")) return } email := c.Query("email") err = h.commitPayrollHandler(int(month), int(year), int(batch), email) if err != nil { l.Errorf(err, "failed to process commit payroll for batch date", "date", batch) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "payroll_commit", Data: map[string]interface{}{ "batch_number": strconv.Itoa(int(batch)), "month": time.Month(month).String(), "year": year, }, }) if err != nil { l.Error(err, "failed to logs to discord") } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "")) } func (h *handler) commitPayrollHandler(month, year, batch int, email string) error { month, year = timeutil.LastMonthYear(month, year) if month > int(time.Now().Month()) { if month != 12 && time.Now().Month() != 1 { return errors.New("cannot commit payroll too far away") } } for _, b := range []model.Batch{model.FirstBatch, model.SecondBatch} { if batch != int(b) { continue } q := payroll.GetListPayrollInput{ Month: month, Year: year, Day: int(b), } if email != "" { u, err := h.store.Employee.OneByEmail(h.repo.DB(), email) if err != nil { return err } q.UserID = u.ID.String() } batchDate := time.Date(year, time.Month(month), int(b), 0, 0, 0, 0, time.UTC) var payrolls []model.Payroll cPayroll, err := h.store.CachedPayroll.Get(h.repo.DB(), month, year, batch) if err != nil { if !errors.Is(err, gorm.ErrRecordNotFound) { return errs.ErrPayrollNotSnapshotted } return err } err = json.Unmarshal(cPayroll.Payrolls, &payrolls) if err != nil { return err } // this is for testing // filteredPayrolls := []model.Payroll{} // for _, p := range payrolls { // if p.Employee.TeamEmail == "huy@d.foundation" { // filteredPayrolls = append(filteredPayrolls, p) // } // } // payrolls = filteredPayrolls for i := range payrolls { payrolls[i].IsPaid = true err = h.markBonusAsDone(&payrolls[i]) if err != nil { return err } // hacky way to mark done commission if _, err := h.getCommissionExplains(&payrolls[i], true); err != nil { return err } // update is_pay_back to true if the employee has payback if payrolls[i].SalaryAdvanceAmount != 0 { salaryAdvances, err := h.store.SalaryAdvance.ListNotPayBackByEmployeeID(h.repo.DB(), payrolls[i].Employee.ID.String()) if err != nil { return err } for _, salaryAdvance := range salaryAdvances { now := time.Now() salaryAdvance.IsPaidBack = true salaryAdvance.PaidAt = &now err = h.store.SalaryAdvance.Save(h.repo.DB(), &salaryAdvance) if err != nil { return err } } } } // Batch insert payrolls err = h.store.Payroll.InsertList(h.repo.DB(), payrolls) if err != nil { return err } // Using WaitGroup go routines to SendPayrollPaidEmail var wg sync.WaitGroup wg.Add(len(payrolls)) c := make(chan *model.Payroll, len(payrolls)+1) for _, pr := range payrolls { go func(p model.Payroll) { defer wg.Done() if h.config.Env == "prod" || p.Employee.TeamEmail == "quang@d.foundation" || p.Employee.TeamEmail == "huy@d.foundation" { c <- &p } }(pr) } wg.Wait() c <- nil go h.activateGmailQueue(c) err = h.storePayrollTransaction(payrolls, batchDate) if err != nil { return err } } return nil } func (h *handler) storePayrollTransaction(p []model.Payroll, batchDate time.Time) error { var transactions []*model.AccountingTransaction for i := range p { m := model.AccountingMetadata{ Source: "payroll", ID: p[i].ID.String(), } bonusBytes, err := json.Marshal(&m) if err != nil { return err } var organization = "Dwarves Foundation" now := time.Now() // baseSalaryConversionAmount = total - bonus and reimbursement (commission + projectBonus) - contract, cannot use origin baseSalary becauuse it is not converted to VND baseSalaryConversionAmount := p[i].Total - model.NewVietnamDong(p[i].ContractAmount) - p[i].CommissionAmount - p[i].ProjectBonusAmount payrollTransaction := model.AccountingTransaction{ Amount: float64(p[i].BaseSalaryAmount), ConversionAmount: baseSalaryConversionAmount, Name: fmt.Sprintf("Payroll TW - %v %v", p[i].Employee.FullName, batchDate.Format("02 January 2006")), Category: p[i].Employee.BaseSalary.Category, Currency: p[i].Employee.BaseSalary.Currency.Name, Date: &now, CurrencyID: &p[i].Employee.BaseSalary.Currency.ID, Organization: organization, Metadata: bonusBytes, ConversionRate: float64(baseSalaryConversionAmount) / float64(p[i].BaseSalaryAmount), Type: p[i].Employee.BaseSalary.Type, } transactions = append(transactions, &payrollTransaction) // separate BHXH and transferwise if p[i].ContractAmount != 0 { bhxhTransaction := model.AccountingTransaction{ Amount: float64(p[i].ContractAmount), ConversionAmount: model.NewVietnamDong(p[i].ContractAmount), Name: fmt.Sprintf("Payroll BHXH - %v %v", p[i].Employee.FullName, batchDate.Format("02 January 2006")), Category: p[i].Employee.BaseSalary.Category, Currency: p[i].Employee.BaseSalary.Currency.Name, Date: &now, CurrencyID: &p[i].Employee.BaseSalary.Currency.ID, Organization: organization, Metadata: bonusBytes, ConversionRate: 1, Type: p[i].Employee.BaseSalary.Type, } transactions = append(transactions, &bhxhTransaction) } // bonusConversionAmount = total bonus (commission + projectBonus) - reimbursement (total - conversionAmount) bonusConversionAmount := p[i].CommissionAmount + p[i].ProjectBonusAmount - (p[i].Total - p[i].ConversionAmount) if bonusConversionAmount != 0 { cur, err := h.store.Currency.GetByName(h.repo.DB(), currency.VNDCurrency) if err != nil { return err } category := p[i].Employee.BaseSalary.Category t := model.AccountingSE if p[i].Employee.BaseSalary.Category == model.AccountingRec { category = model.AccountingCommHiring t = p[i].Employee.BaseSalary.Type } var commissionName string for j := range p[i].CommissionExplains { commissionName += p[i].CommissionExplains[j].Name + " " } if strings.Contains(commissionName, "Account") { category = model.AccountingCommAccount } if strings.Contains(commissionName, "Sales") { category = model.AccountingCommSales } if strings.Contains(commissionName, "Lead") { category = model.AccountingCommLead } bonusTransaction := model.AccountingTransaction{ Amount: float64(bonusConversionAmount), ConversionAmount: bonusConversionAmount, Name: fmt.Sprintf("Bonus - %v %v", p[i].Employee.FullName, batchDate.Format("02 January 2006")), Category: category, Currency: cur.Name, Date: &now, CurrencyID: &cur.ID, Organization: organization, Metadata: bonusBytes, ConversionRate: 1, Type: t, } transactions = append(transactions, &bonusTransaction) } } return h.storeMultipleTransaction(transactions) } func (h *handler) storeMultipleTransaction(transactions []*model.AccountingTransaction) error { if err := h.store.Accounting.CreateMultipleTransaction(h.repo.DB(), transactions); err != nil { return err } return nil } func (h *handler) markBonusAsDone(p *model.Payroll) error { var projectBonusExplains []model.ProjectBonusExplain err := json.Unmarshal( p.ProjectBonusExplain, &projectBonusExplains, ) if err != nil { return err } for i := range projectBonusExplains { // handle the bonus from basecamp todo (expense reimbursement and accounting) if projectBonusExplains[i].BasecampBucketID != 0 && projectBonusExplains[i].BasecampTodoID != 0 { woodlandID := consts.PlaygroundID accountingID := consts.PlaygroundID if h.config.Env == "prod" { woodlandID = consts.WoodlandID accountingID = consts.AccountingID } // expense reimbursement -> from woodland -> mark done // accounting -> comment confirm message switch projectBonusExplains[i].BasecampBucketID { case woodlandID: err := h.service.Basecamp.Todo.Complete(projectBonusExplains[i].BasecampBucketID, projectBonusExplains[i].BasecampTodoID) if err != nil { return err } case accountingID: mention, err := h.service.Basecamp.BasecampMention(p.Employee.BasecampID) if err != nil { return err } msg := fmt.Sprintf("Amount has been deposited in your payroll %v", mention) cm := h.service.Basecamp.BuildCommentMessage(projectBonusExplains[i].BasecampBucketID, projectBonusExplains[i].BasecampTodoID, msg, "") h.worker.Enqueue(bcModel.BasecampCommentMsg, cm) } } } return nil } func (h *handler) activateGmailQueue(p chan *model.Payroll) { h.logger.Info("gmail queue activated") ticker := time.NewTicker(time.Second) defer ticker.Stop() emailCh := make(chan *model.Payroll) go func() { for c := range emailCh { h.logger.Info(fmt.Sprintf("sending email %v", c.Employee.TeamEmail)) err := h.service.GoogleMail.SendPayrollPaidMail(c) if err != nil { h.logger.Error(err, "error when sending email") } } }() for { select { case <-ticker.C: // Do something every second case c := <-p: if c == nil { return } emailCh <- c } } }
```

# pkg/handler/payroll/details.go

```go
package payroll import ( "encoding/json" "errors" "fmt" "net/http" "strconv" "strings" "time" "github.com/gin-gonic/gin" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/handler/payroll/errs" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/currency" "github.com/dwarvesf/fortress-api/pkg/store/employee" "github.com/dwarvesf/fortress-api/pkg/store/employeecommission" "github.com/dwarvesf/fortress-api/pkg/store/payroll" "github.com/dwarvesf/fortress-api/pkg/utils" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" "github.com/dwarvesf/fortress-api/pkg/view" ) func (h *handler) GetPayrollsByMonth(c *gin.Context) { q := c.Request.URL.Query() email := q.Get("email") if q.Get("next") == "true" { res, err := h.getPayrollDetailHandler(0, 0, 0, email) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse(res, nil, nil, nil, "")) return } batch, err := strconv.ParseInt(q.Get("date"), 0, 64) if err != nil { batch = 0 } year, err := strconv.ParseInt(q.Get("year"), 0, 64) if err != nil || year <= 0 { year = int64(time.Now().Year()) } if q.Get("month") == "" { if year != int64(time.Now().Year()) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidYear, nil, "")) return } year = int64(time.Now().Year()) } month, err := strconv.ParseInt(q.Get("month"), 0, 64) if err != nil { month = int64(time.Now().Month()) } res, err := h.getPayrollDetailHandler(int(month), int(year), int(batch), email) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse(res, nil, nil, nil, "")) } func (h *handler) getPayrollDetailHandler(month, year, batch int, email string) (interface{}, error) { tx, done := h.repo.NewTransaction() if month == 0 && year == 0 && batch == 0 { date, err := h.store.Payroll.GetLatestCommitTime(tx.DB()) if err != nil { h.logger.Error(err, "can't get payroll latest commit time") date = time.Now() } month = int(date.Month()) year = date.Year() batch = int(model.FirstBatch) if date.Day() == int(model.FirstBatch) { batch = int(model.SecondBatch) month, year = timeutil.LastMonthYear(month, year) } } else { month, year = timeutil.LastMonthYear(month, year) } var res []payrollResponse var subTotal int64 var bonusTotal model.VietnamDong isPaid := true for _, b := range []model.Batch{model.FirstBatch, model.SecondBatch} { if batch != 0 && batch != int(b) { continue } q := payroll.GetListPayrollInput{ Month: month, Year: year, Day: int(b), } if email != "" { u, err := h.store.Employee.OneByEmail(tx.DB(), email) if err != nil { h.logger.Error(err, "can't get employee by email") return nil, err } q.UserID = u.ID.String() } batchDate := time.Date(year, time.Month(month), int(b), 0, 0, 0, 0, time.UTC) payrolls, err := h.store.Payroll.GetList(tx.DB(), q) if err != nil { h.logger.Error(err, "can't get payroll list") return nil, done(err) } if len(payrolls) == 0 { isPaid = false // TODO : get all user payroll isLeft := false us, _, err := h.store.Employee.All(tx.DB(), employee.EmployeeFilter{IsLeft: &isLeft, BatchDate: &batchDate, Preload: true}, model.Pagination{Page: 0, Size: 500}) if err != nil { h.logger.Error(err, "can't get list active employee") return nil, err } var tempPayrolls []model.Payroll newPayrolls, err := h.calculatePayrolls(us, batchDate) if err != nil { h.logger.Error(err, "can't calculate payroll") return nil, err } for i := range newPayrolls { tempPayrolls = append(tempPayrolls, *newPayrolls[i]) } payrolls = tempPayrolls } standardizedPayrolls := make([]model.Payroll, 0) for i := range payrolls { var notes []string // get tw quotes (default -> GBP) c := payrolls[i].Employee.WiseCurrency if c == "" { c = "GBP" } // !isForecast if batchDate.Month() <= time.Now().Month() || (batchDate.Month() == 12 && time.Now().Month() == 1) { toDate := batchDate.AddDate(0, 1, 0) commissionQuery := employeecommission.Query{ EmployeeID: payrolls[i].Employee.ID.String(), IsPaid: isPaid, FromDate: &batchDate, ToDate: &toDate, } userCommissions, err := h.store.EmployeeCommission.Get(h.repo.DB(), commissionQuery) if err != nil { return nil, err } duplicate := map[string]int{} for j := range userCommissions { if userCommissions[j].Amount != 0 { name := userCommissions[j].Invoice.Number if userCommissions[j].Note != "" { name = fmt.Sprintf("%v - %v", name, userCommissions[j].Note) } duplicate[name] += int(userCommissions[j].Amount) } } for j := range duplicate { notes = append(notes, fmt.Sprintf("%v (%v)", j, utils.FormatCurrencyAmount(duplicate[j]))) } var bonusExplain []model.CommissionExplain if len(payrolls[i].ProjectBonusExplain) > 0 { if err := json.Unmarshal(payrolls[i].ProjectBonusExplain, &bonusExplain); err != nil { return nil, errs.ErrCannotReadProjectBonusExplain } } for j := range bonusExplain { notes = append(notes, fmt.Sprintf("%v (%v)", bonusExplain[j].Name, utils.FormatCurrencyAmount(int(bonusExplain[j].Amount)))) } } standardizedPayroll, bonus, sub, err := h.preparePayroll(c, payrolls[i], false) if err != nil { return nil, err } subTotal += sub for j := range standardizedPayroll.CommissionExplains { isContained := false for n := range notes { if strings.Contains(notes[n], standardizedPayroll.CommissionExplains[j].Name) { isContained = true } } if isContained { continue } notes = append(notes, fmt.Sprintf("%v (%v)", standardizedPayroll.CommissionExplains[j].Name, utils.FormatCurrencyAmount(int(standardizedPayroll.CommissionExplains[j].Amount)))) } for j := range standardizedPayroll.ProjectBonusExplains { isContained := false for n := range notes { if strings.Contains(notes[n], standardizedPayroll.ProjectBonusExplains[j].Name) { isContained = true } } if isContained { continue } notes = append(notes, fmt.Sprintf("%v (%v)", standardizedPayroll.ProjectBonusExplains[j].Name, utils.FormatCurrencyAmount(int(standardizedPayroll.ProjectBonusExplains[j].Amount)))) } r := payrollResponse{ DisplayName: standardizedPayroll.Employee.FullName, BaseSalary: standardizedPayroll.BaseSalaryAmount, SalaryAdvanceAmount: standardizedPayroll.SalaryAdvanceAmount, Bonus: bonus, TotalWithContract: standardizedPayroll.Total, TotalWithoutContract: standardizedPayroll.TotalAllowance, Notes: notes, Date: standardizedPayroll.Employee.BaseSalary.Batch, Month: month, Year: year, BankAccountNumber: standardizedPayroll.Employee.LocalBankNumber, Bank: standardizedPayroll.Employee.LocalBranchName, HasContract: standardizedPayroll.ContractAmount != 0, PayrollID: "", TWRecipientID: standardizedPayroll.Employee.WiseRecipientID, TWRecipientName: standardizedPayroll.Employee.WiseRecipientName, TWAccountNumber: standardizedPayroll.Employee.WiseAccountNumber, TWEmail: standardizedPayroll.Employee.WiseRecipientEmail, TWGBP: standardizedPayroll.TWAmount, TWAmount: standardizedPayroll.TWAmount, TWFee: standardizedPayroll.TWFee, TWCurrency: c, IsCommit: !standardizedPayroll.ID.IsZero(), IsPaid: standardizedPayroll.IsPaid, Currency: standardizedPayroll.Employee.BaseSalary.Currency.Name, } if r.IsCommit { r.PayrollID = standardizedPayroll.ID.String() } res = append(res, r) standardizedPayrolls = append(standardizedPayrolls, *standardizedPayroll) } if email == "" { err = h.cachePayroll(month, year, batch, standardizedPayrolls) if err != nil { return nil, err } } } // return res, done(nil) sub := model.NewVietnamDong(subTotal) return map[string]interface{}{ "sub_total": sub.Format(), "bonus_total": bonusTotal, "payrolls": res, }, nil } func (h *handler) preparePayroll(c string, p model.Payroll, markPaid bool) (*model.Payroll, float64, int64, error) { var bonus float64 var subTotal int64 if p.Employee.BaseSalary.Currency.Name != currency.VNDCurrency { c, _, err := h.service.Wise.Convert(float64(p.CommissionAmount), currency.VNDCurrency, p.Employee.BaseSalary.Currency.Name) if err != nil { return nil, 0, 0, err } b, _, err := h.service.Wise.Convert(float64(p.ProjectBonusAmount), currency.VNDCurrency, p.Employee.BaseSalary.Currency.Name) if err != nil { return nil, 0, 0, err } bonus = b + c p.TotalAllowance = float64(p.BaseSalaryAmount) + bonus - p.SalaryAdvanceAmount base, _, err := h.service.Wise.Convert(float64(p.BaseSalaryAmount), p.Employee.BaseSalary.Currency.Name, currency.VNDCurrency) if err != nil { return nil, 0, 0, err } subTotal += int64(base) } else { bonus = float64(p.CommissionAmount + p.ProjectBonusAmount) p.TotalAllowance = float64(p.BaseSalaryAmount) + bonus - p.SalaryAdvanceAmount subTotal += p.BaseSalaryAmount } projectBonusExplains, err := getProjectBonusExplains(&p) if err != nil { return nil, 0, 0, err } p.ProjectBonusExplains = projectBonusExplains commissionExplains, err := h.getCommissionExplains(&p, markPaid) if err != nil { return nil, 0, 0, err } p.CommissionExplains = commissionExplains for i, v := range p.ProjectBonusExplains { formattedAmount, err := h.getFormattedAmount(&p, v.Amount) if err != nil { return nil, 0, 0, err } p.ProjectBonusExplains[i].FormattedAmount = formattedAmount } for i, v := range p.CommissionExplains { formattedAmount, err := h.getFormattedAmount(&p, v.Amount) if err != nil { return nil, 0, 0, err } p.CommissionExplains[i].FormattedAmount = formattedAmount } quote, err := h.service.Wise.GetPayrollQuotes(c, p.Employee.BaseSalary.Currency.Name, p.TotalAllowance) if err != nil { h.logger.Error(err, "cannot use wise to get quote") return nil, 0, 0, err } p.TWAmount = quote.SourceAmount p.TWRate = quote.Rate p.TWFee = quote.Fee return &p, bonus, subTotal, nil } func (h *handler) getFormattedAmount(p *model.Payroll, amount model.VietnamDong) (string, error) { if p.Employee.BaseSalary.Currency.Name != currency.VNDCurrency { temp, _, err := h.service.Wise.Convert(float64(amount), currency.VNDCurrency, p.Employee.BaseSalary.Currency.Name) if err != nil { return "", err } return fmt.Sprintf("%.02f", temp), nil } return amount.String(), nil } func getProjectBonusExplains(p *model.Payroll) ([]model.ProjectBonusExplain, error) { projectBonusExplains := make([]model.ProjectBonusExplain, 0) err := json.Unmarshal( p.ProjectBonusExplain, &projectBonusExplains, ) if err != nil { return nil, err } tempBonus := map[string]*model.ProjectBonusExplain{} for i := range projectBonusExplains { if tempBonus[projectBonusExplains[i].Name] == nil { tempBonus[projectBonusExplains[i].Name] = &projectBonusExplains[i] } else { tempBonus[projectBonusExplains[i].Name].Amount += projectBonusExplains[i].Amount } } var tempBonusExplains []model.ProjectBonusExplain for i := range tempBonus { tempBonusExplains = append(tempBonusExplains, *tempBonus[i]) } return tempBonusExplains, nil } func (h *handler) getCommissionExplains(p *model.Payroll, markPaid bool) ([]model.CommissionExplain, error) { commissionExplains := make([]model.CommissionExplain, 0) err := json.Unmarshal( p.CommissionExplain, &commissionExplains, ) if err != nil { return nil, err } if markPaid { for i := range commissionExplains { err := h.store.EmployeeCommission.MarkPaid(h.repo.DB(), commissionExplains[i].ID) if err != nil { return nil, err } } } tempCommission := map[string]*model.CommissionExplain{} for i := range commissionExplains { if commissionExplains[i].Amount == 0 { continue } if tempCommission[commissionExplains[i].Name] == nil { tempCommission[commissionExplains[i].Name] = &commissionExplains[i] } else { tempCommission[commissionExplains[i].Name].Amount += commissionExplains[i].Amount } } var tempCommissionExplains []model.CommissionExplain for i := range tempCommission { tempCommissionExplains = append(tempCommissionExplains, *tempCommission[i]) } return tempCommissionExplains, nil } func (h *handler) cachePayroll(month, year, batch int, payrolls []model.Payroll) error { payrollsBytes, err := json.Marshal(&payrolls) if err != nil { return err } cPayroll, err := h.store.CachedPayroll.Get(h.repo.DB(), month, year, batch) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { return err } cPayroll.Month = month cPayroll.Year = year cPayroll.Batch = batch cPayroll.Payrolls = payrollsBytes return h.store.CachedPayroll.Set(h.repo.DB(), cPayroll) }
```

# pkg/handler/payroll/errs/errors.go

```go
package errs import "errors" var ( ErrBadRequest = errors.New("bad request") ErrInvalidYear = errors.New("invalid year, must be current year") ErrCannotReadProjectBonusExplain = errors.New("cannot read project bonus explain") ErrPayrollNotSnapshotted = errors.New("payroll not snapshotted") )
```

# pkg/handler/payroll/mark_paid.go

```go
package payroll import ( "net/http" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/store/payroll" "github.com/dwarvesf/fortress-api/pkg/view" ) func (h *handler) MarkPayrollAsPaid(c *gin.Context) { var ids []string if err := c.Bind(&ids); err != nil { return } err := h.markPayrollAsPaid(ids) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "marking the payroll as paid was successful")) } // markPayrollAsPaid from selected payroll row in database // update the is_paid and is_sent_mail in payroll table // send email into the users that marked as paid func (h *handler) markPayrollAsPaid(ids []string) error { for _, id := range ids { q := payroll.GetListPayrollInput{ ID: id, } ps, err := h.store.Payroll.GetList(h.repo.DB(), q) if err != nil { return err } if len(ps) == 0 { continue } if err := h.service.GoogleMail.SendPayrollPaidMail(&ps[0]); err != nil { return err } fields := map[string]interface{}{ "is_paid": true, } if err := h.store.Payroll.UpdateSpecificFields(h.repo.DB(), id, fields); err != nil { return err } } return nil }
```

# pkg/handler/payroll/new.go

```go
// Package payroll please edit this file only with approval from hnh package payroll import ( "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/worker" ) type IHandler interface { GetPayrollsByMonth(c *gin.Context) GetPayrollsBHXH(c *gin.Context) CommitPayroll(c *gin.Context) MarkPayrollAsPaid(c *gin.Context) } type handler struct { controller *controller.Controller store *store.Store service *service.Service logger logger.Logger worker *worker.Worker repo store.DBRepo config *config.Config } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, worker *worker.Worker, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ controller: controller, store: store, repo: repo, service: service, worker: worker, logger: logger, config: cfg, } }
```

# pkg/handler/payroll/payroll_calculator.go

```go
package payroll import ( "encoding/json" "fmt" "strings" "sync" "time" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/service/currency" commissionStore "github.com/dwarvesf/fortress-api/pkg/store/employeecommission" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" ) // calculatePayrolls return list of payrolls for all given users in batchDate func (h *handler) calculatePayrolls(users []*model.Employee, batchDate time.Time) (res []*model.Payroll, err error) { batch := batchDate.Day() // HACK: sneak quang into this if batch == 1 { quang, err := h.store.Employee.OneByEmail(h.repo.DB(), "quang@d.foundation") if err != nil { h.logger.Error(err, "Can't insert quang into 1st payroll batch") return nil, err } users = append(users, quang) } if batch == 15 { inno, err := h.store.Employee.OneByEmail(h.repo.DB(), "mytx@d.foundation") if err != nil { h.logger.Error(err, "Can't insert inno into 15th payroll batch") return nil, err } users = append(users, inno) } dueDate := batchDate.AddDate(0, 1, 0) var expenses []bcModel.Todo woodlandID := consts.PlaygroundID expenseID := consts.PlaygroundExpenseTodoID opsID := consts.PlaygroundID opsExpenseID := consts.PlaygroundExpenseTodoID approver := consts.NamNguyenBasecampID if h.config.Env == "prod" { woodlandID = consts.WoodlandID expenseID = consts.ExpenseTodoID opsID = consts.OperationID opsExpenseID = consts.OpsExpenseTodoID approver = consts.HanBasecampID } opsTodoLists, err := h.service.Basecamp.Todo.GetAllInList(opsExpenseID, opsID) if err != nil { h.logger.Error(err, "can't get ops expense todo") return nil, err } for _, exps := range opsTodoLists { isApproved := false cmts, err := h.service.Basecamp.Comment.Gets(opsID, exps.ID) if err != nil { h.logger.Error(err, "can't get basecamp approved message") return nil, err } for _, cmt := range cmts { if cmt.Creator.ID == approver && strings.Contains(strings.ToLower(cmt.Content), "approve") { isApproved = true break } } if isApproved { expenses = append(expenses, exps) } } // get team expenses todolists, err := h.service.Basecamp.Todo.GetGroups(expenseID, woodlandID) if err != nil { h.logger.Error(err, "can't get groups expense") return nil, err } for i := range todolists { e, err := h.service.Basecamp.Todo.GetAllInList(todolists[i].ID, woodlandID) if err != nil { h.logger.Error(err, "can't get expense todo") return nil, err } for j := range e { isApproved := false cmts, err := h.service.Basecamp.Comment.Gets(woodlandID, e[j].ID) if err != nil { h.logger.Error(err, "can't get basecamp approved message") return nil, err } for k := range cmts { if cmts[k].Creator.ID == approver && strings.Contains(strings.ToLower(cmts[k].Content), "approve") { isApproved = true break } } if isApproved { expenses = append(expenses, e[j]) } } } accountingExpenses, err := h.getAccountingExpense(batch) if err != nil { h.logger.Error(err, "can't get accounting todo") return nil, err } expenses = append(expenses, accountingExpenses...) for i, u := range users { if users[i].BaseSalary.Currency == nil { continue } var total model.VietnamDong var baseSalary, contract int64 if users[i].BaseSalary.Batch != batchDate.Day() { if users[i].TeamEmail != "quang@d.foundation" && users[i].TeamEmail != "mytx@d.foundation" { continue } else { users[i].BaseSalary.PersonalAccountAmount = 0 users[i].BaseSalary.CompanyAccountAmount = 0 users[i].BaseSalary.ContractAmount = 0 } } // TODO... // try to calculate if user start/end after/before the payroll // fallback to default baseSalary, contract, _ = tryPartialCalculation(batchDate, dueDate, *u.JoinedDate, u.LeftDate, users[i].BaseSalary.PersonalAccountAmount, users[i].BaseSalary.CompanyAccountAmount) var bonus, commission, reimbursementAmount model.VietnamDong var bonusExplains, commissionExplains []model.CommissionExplain bonus, commission, reimbursementAmount, bonusExplains, commissionExplains = h.getBonus(*users[i], batchDate, expenses) commBytes, err := json.Marshal(&commissionExplains) if err != nil { return nil, err } bonusBytes, err := json.Marshal(&bonusExplains) if err != nil { return nil, err } if users[i].BaseSalary.Currency.Name != currency.VNDCurrency { c, _, err := h.service.Wise.Convert(float64(commission), currency.VNDCurrency, users[i].BaseSalary.Currency.Name) if err != nil { return nil, err } b, _, err := h.service.Wise.Convert(float64(bonus), currency.VNDCurrency, users[i].BaseSalary.Currency.Name) if err != nil { return nil, err } temp, _, err := h.service.Wise.Convert(float64(baseSalary+contract)+b+c, users[i].BaseSalary.Currency.Name, currency.VNDCurrency) if err != nil { return nil, err } total = model.NewVietnamDong(int64(temp)) } else { temp := model.NewVietnamDong(baseSalary) baseSalary = int64(temp.Format()) total = model.NewVietnamDong(baseSalary+contract) + bonus + commission } if total == 0 { continue } // get advance salary advanceAmountUSD := 0.0 advanceSalaries, err := h.store.SalaryAdvance.ListNotPayBackByEmployeeID(h.repo.DB(), u.ID.String()) if err != nil { return nil, err } for _, as := range advanceSalaries { advanceAmountUSD += as.AmountUSD } advanceAmountVND, _, err := h.service.Wise.Convert(advanceAmountUSD, currency.USDCurrency, currency.VNDCurrency) if err != nil { return nil, err } // calculate total minus advance salary total = model.NewVietnamDong(int64(float64(total) - advanceAmountVND)) p := model.Payroll{ EmployeeID: users[i].ID, Total: total.Format(), BaseSalaryAmount: baseSalary, ConversionAmount: total.Format() - reimbursementAmount, SalaryAdvanceAmount: advanceAmountVND, DueDate: &dueDate, Month: int64(batchDate.Month()), Year: int64(batchDate.Year()), CommissionExplain: commBytes, CommissionAmount: commission, ProjectBonusAmount: bonus, ProjectBonusExplain: bonusBytes, Employee: *users[i], ContractAmount: contract, } res = append(res, &p) } return res, nil } func (h *handler) getBonus(u model.Employee, batchDate time.Time, expenses []bcModel.Todo) (bonus, commission, reimbursementAmount model.VietnamDong, bonusExplain, commissionExplain []model.CommissionExplain) { h.logger.Info("get bonus") var explanation string bonusRecords, err := h.store.Bonus.GetByUserID(h.repo.DB(), u.ID) if err != nil { return } if explanation != "" { bonusExplain = append(bonusExplain, model.CommissionExplain{ Amount: 0, Month: int(batchDate.Month()), Year: batchDate.Year(), Name: explanation, }) } for i := range bonusRecords { bonus += bonusRecords[i].Amount bonusExplain = append(bonusExplain, model.CommissionExplain{ Amount: bonusRecords[i].Amount, Month: int(batchDate.Month()), Year: batchDate.Year(), Name: bonusRecords[i].Name, }) } for i := range expenses { hasReimbursement := false for j := range expenses[i].Assignees { if expenses[i].Assignees[j].ID == u.BasecampID { hasReimbursement = true break } } if hasReimbursement { name, amount, err := h.getReimbursement(expenses[i].Title) if err != nil { return } if amount == 0 { continue } bonus += amount reimbursementAmount += amount bonusExplain = append(bonusExplain, model.CommissionExplain{ Amount: amount, Month: int(batchDate.Month()), Year: batchDate.Year(), Name: name, BasecampTodoID: expenses[i].ID, BasecampBucketID: expenses[i].Bucket.ID, }) } } commissionQuery := commissionStore.Query{ EmployeeID: u.ID.String(), IsPaid: false, } userCommissions, err := h.store.EmployeeCommission.Get(h.repo.DB(), commissionQuery) if err != nil { return } for i := range userCommissions { commissionYear, commissionMonth, _ := userCommissions[i].CreatedAt.Date() commission += userCommissions[i].Amount if userCommissions[i].Invoice == nil { continue } name := userCommissions[i].Invoice.Number if userCommissions[i].Note != "" { name = fmt.Sprintf("%v - %v", name, userCommissions[i].Note) } commissionExplain = append(commissionExplain, model.CommissionExplain{ ID: userCommissions[i].ID, Amount: userCommissions[i].Amount, Month: int(commissionMonth), Year: commissionYear, Name: name, }) } return } func tryPartialCalculation( batchDate, dueDate, startDate time.Time, leftDate *time.Time, baseSalary, contract int64, ) (resBase, resContract int64, explanation string) { partialStart := batchDate partialEnd := dueDate isPartial := false if checkUserFirstBatch(startDate, batchDate) { partialStart = startDate isPartial = true } if leftDate != nil && leftDate.Before(dueDate) { partialEnd = *leftDate isPartial = true } if isPartial { var temp int64 temp, explanation, _ = calculatePartialPayroll(partialStart, partialEnd, dueDate, batchDate, baseSalary+contract) baseSalary = temp - contract if baseSalary < 0 { contract += baseSalary baseSalary = 0 } } return baseSalary, contract, explanation } func checkUserFirstBatch(startDate, batchDate time.Time) bool { if (startDate.Month() == batchDate.Month() && startDate.Year() == batchDate.Year()) || (startDate.Month() == 12 && batchDate.Month() == 1 && startDate.Year() == batchDate.Year()-1) { return true } return false } func calculatePartialPayroll(startDate time.Time, endDate time.Time, dueDate time.Time, lastDueDate time.Time, totalSalary int64) (int64, string, error) { dayWorkOfMonth := int64(dueDate.Sub(lastDueDate).Hours() / 24) weekendsOfMonth := int64(timeutil.CountWeekendDays(lastDueDate, dueDate)) // minus the weekends dayWorkOfMonth -= weekendsOfMonth // get day work in fist batch dayWorkOfFirstBatch := int64(endDate.Sub(startDate).Hours() / 24) // sum up with end date if left if !timeutil.IsSameDay(endDate, dueDate) { dayWorkOfFirstBatch++ } // minus the weekends weekendsOfFirstBatch := int64(timeutil.CountWeekendDays(startDate, endDate)) dayWorkOfFirstBatch -= weekendsOfFirstBatch if dayWorkOfFirstBatch == dayWorkOfMonth { return totalSalary, "", nil } // calculate salary per date // get the actual salary of first batch total := dayWorkOfFirstBatch * totalSalary / dayWorkOfMonth return total, fmt.Sprintf("Work from %s to %s", startDate.Format("2 Jan"), endDate.Format("2 Jan")), nil } func (h *handler) getReimbursement(expense string) (string, model.VietnamDong, error) { var amount model.VietnamDong splits := strings.Split(expense, "|") if len(splits) < 3 { return "", 0, nil } c := strings.TrimSpace(splits[2]) bcAmount := h.service.Basecamp.ExtractBasecampExpenseAmount(strings.TrimSpace(splits[1])) if c != currency.VNDCurrency { tempAmount, _, err := h.service.Wise.Convert(float64(bcAmount), c, currency.VNDCurrency) if err != nil { return "", 0, err } amount = model.NewVietnamDong(int64(tempAmount)) } else { amount = model.NewVietnamDong(int64(h.service.Basecamp.ExtractBasecampExpenseAmount(strings.TrimSpace(splits[1])))) } return strings.TrimSpace(splits[0]), amount.Format(), nil } func (h *handler) getAccountingExpense(batch int) (res []bcModel.Todo, err error) { accountingID := consts.AccountingID accountingTodoID := consts.AccountingTodoID if h.config.Env != "prod" { accountingID = consts.PlaygroundID accountingTodoID = consts.PlaygroundTodoID } // get accounting todo list lists, err := h.service.Basecamp.Todo.GetLists(accountingID, accountingTodoID) if err != nil { h.logger.Error(err, "can't get list of todo") return nil, err } var wg sync.WaitGroup var mu sync.Mutex // get all group in each list for i := range lists { wg.Add(1) go func(i int) { defer wg.Done() groups, err := h.service.Basecamp.Todo.GetGroups(lists[i].ID, accountingID) if err != nil { h.logger.Error(err, "can't get groups in todo list") return } // filter out group only for j := range groups { if strings.ToLower(groups[j].Title) == "out" { // get all todo in out grou todos, err := h.service.Basecamp.Todo.GetAllInList(groups[j].ID, accountingID) if err != nil { h.logger.Error(err, "can't get todo in out group") return } // find expense in list of todos for k := range todos { if len(todos[k].Assignees) == 1 && todos[k].Assignees[0].ID != consts.HanBasecampID { mu.Lock() res = append(res, todos[k]) mu.Unlock() } } } } }(i) } wg.Wait() return res, nil }
```

# pkg/handler/payroll/types.go

```go
package payroll import "github.com/dwarvesf/fortress-api/pkg/model" type payrollResponse struct { DisplayName string `json:"display_name"` BaseSalary int64 `json:"base_salary"` SalaryAdvanceAmount float64 `json:"salary_advance_amount"` Bonus float64 `json:"bonus"` TotalWithoutContract float64 `json:"total_without_contract"` TotalWithContract model.VietnamDong `json:"total_with_contract"` Notes []string `json:"notes"` Date int `json:"date"` Month int `json:"month"` Year int `json:"year"` BankAccountNumber string `json:"bank_account_number"` TWRecipientID string `json:"tw_recipient_id"` // will be removed TWRecipientName string `json:"tw_recipient_name"` TWAccountNumber string `json:"tw_account_number"` Bank string `json:"bank"` HasContract bool `json:"has_contract"` PayrollID string `json:"payroll_id"` IsCommit bool `json:"is_commit"` IsPaid bool `json:"is_paid"` TWGBP float64 `json:"tw_gbp"` // will be removed TWAmount float64 `json:"tw_amount"` TWFee float64 `json:"tw_fee"` TWEmail string `json:"tw_email"` TWCurrency string `json:"tw_currency"` Currency string `json:"currency"` } type payrollBHXHResponse struct { DisplayName string `json:"display_name"` BHXH int64 `json:"bhxh"` Batch int `json:"batch"` AccountNumber string `json:"account_number"` Bank string `json:"bank"` }
```

# pkg/handler/profile/errs/errors.go

```go
package errs import "errors" var ( ErrEmployeeNotFound = errors.New("employee not found") ErrCountryNotFound = errors.New("country not found") ErrInvalidCountryOrCity = errors.New("invalid country or city") ErrInvalidFileExtension = errors.New("invalid file extension") ErrInvalidDocumentType = errors.New("invalid document type") ErrInvalidFileType = errors.New("invalid file type") ErrInvalidFileSize = errors.New("invalid file size") ErrFileAlreadyExisted = errors.New("file already existed") ErrEmailExisted = errors.New("email already exists") ErrOnboardingFormAlreadyDone = errors.New("onboarding form already done") ErrMissingDocuments = errors.New("missing id/passport documents") ErrInvalidDate = errors.New("invalid date") ErrInvalidDiscordMemberInfo = errors.New("invalid discord member info") ErrDiscordAccountAlreadyUsedByAnotherEmployee = errors.New("discord account already used by another employee") ErrCouldNotFoundDiscordMemberInGuild = errors.New("could not found discord member in the guild") ErrCityDoesNotBelongToCountry = errors.New("city does not belong to country") )
```

# pkg/handler/profile/interface.go

```go
package profile import "github.com/gin-gonic/gin" type IHandler interface { GetProfile(c *gin.Context) UpdateInfo(c *gin.Context) SubmitOnboardingForm(c *gin.Context) GetInvitation(c *gin.Context) Upload(c *gin.Context) UploadAvatar(c *gin.Context) }
```

# pkg/handler/profile/profile.go

```go
package profile import ( "errors" "fmt" "net/http" "path/filepath" "github.com/bwmarrin/discordgo" "github.com/gin-gonic/gin" "gorm.io/gorm" "gorm.io/gorm/utils" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/handler/profile/errs" "github.com/dwarvesf/fortress-api/pkg/handler/profile/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { controller *controller.Controller store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ controller: controller, store: store, repo: repo, service: service, logger: logger, config: cfg, } } // GetProfile godoc // @Summary Get profile information of employee // @Description Get profile information of employee // @id getPofile // @Tags Profile // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} ProfileDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /profile [get] func (h *handler) GetProfile(c *gin.Context) { userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "profile", "method": "GetProfile", }) rs, err := h.store.Employee.One(h.repo.DB(), userID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("employee not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, nil, "")) return } l.Error(err, "error query employee from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToProfileData(rs), nil, nil, nil, "")) } // UpdateInfo godoc // @Summary Update profile info by id // @Description Update profile info by id // @id updateProfileInfo // @Tags Profile // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Employee ID" // @Param Body body UpdateInfoInput true "Body" // @Success 200 {object} UpdateProfileInfoResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /profile [put] func (h *handler) UpdateInfo(c *gin.Context) { employeeID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } input := request.UpdateInfoInput{} if err := c.ShouldBindJSON(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "profile", "method": "UpdateInfo", "request": input, }) emp, err := h.store.Employee.One(h.repo.DB(), employeeID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("emp not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, nil, "")) return } l.Error(err, "failed to get emp") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // validate personal email _, err = h.store.Employee.OneByEmail(h.repo.DB(), input.PersonalEmail) if emp.PersonalEmail != input.PersonalEmail && input.PersonalEmail != "" && !errors.Is(err, gorm.ErrRecordNotFound) { if err == nil { l.Error(err, "personal email exists") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrEmailExisted, input, "")) return } l.Error(err, "failed to get emp by email") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } city, err := h.validateAndMappingCity(h.repo.DB(), input.Country, input.City) if err != nil { l.Info("country or city is invalid") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidCountryOrCity, input, "")) return } input.Lat = city.Lat input.Long = city.Long input.ToEmployeeModel(emp) tx, done := h.repo.NewTransaction() // Update social accounts saInput := model.SocialAccountInput{ GithubID: input.GithubID, NotionID: input.NotionID, NotionName: input.NotionName, NotionEmail: input.NotionEmail, LinkedInName: input.LinkedInName, } if err := h.updateSocialAccounts(tx.DB(), saInput, emp.ID); err != nil { l.Error(err, "failed to update emp") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // Get discord info discordID := "" discordMember, err := h.service.Discord.GetMemberByUsername(input.DiscordName) if err != nil { l.Error(err, "failed to get discord info") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } if discordMember == nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrCouldNotFoundDiscordMemberInGuild), input, "")) return } discordID = discordMember.User.ID tmpE, err := h.store.Employee.GetByDiscordID(tx.DB(), discordID, false) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { l.Errorf(err, "failed to get emp by discordID", "discordID", discordID) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } if !errors.Is(err, gorm.ErrRecordNotFound) { if tmpE.ID != emp.ID { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrDiscordAccountAlreadyUsedByAnotherEmployee), input, "")) return } } discordAccountInput := &model.DiscordAccount{ DiscordID: discordID, DiscordUsername: input.DiscordName, } discordAccount, err := h.store.DiscordAccount.Upsert(tx.DB(), discordAccountInput) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } emp.DiscordAccountID = discordAccount.ID // Update emp _, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, *emp, "personal_email", "phone_number", "place_of_residence", "address", "country", "city", "lat", "long", "wise_recipient_id", "wise_account_number", "wise_recipient_email", "wise_recipient_name", "wise_currency", "discord_account_id", ) if err != nil { l.Error(err, "failed to update emp") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateProfileInfoData(emp), nil, done(nil), nil, "")) } func (h *handler) updateSocialAccounts(db *gorm.DB, input model.SocialAccountInput, employeeID model.UUID) error { l := h.logger.Fields(logger.Fields{ "handler": "profile", "method": "updateSocialAccounts", "request": input, }) accounts, err := h.store.SocialAccount.GetByEmployeeID(db, employeeID.String()) if err != nil { l.Error(err, "failed to get social accounts by employeeID") return err } accountsInput := map[model.SocialAccountType]model.SocialAccount{ model.SocialAccountTypeGitHub: { Type: model.SocialAccountTypeGitHub, EmployeeID: employeeID, AccountID: input.GithubID, Name: input.GithubID, }, model.SocialAccountTypeNotion: { Type: model.SocialAccountTypeNotion, EmployeeID: employeeID, AccountID: input.NotionID, Name: input.NotionName, Email: input.NotionEmail, }, model.SocialAccountTypeLinkedIn: { EmployeeID: employeeID, Type: model.SocialAccountTypeLinkedIn, AccountID: input.LinkedInName, Name: input.LinkedInName, }, } for _, account := range accounts { delete(accountsInput, account.Type) switch account.Type { case model.SocialAccountTypeGitHub: account.AccountID = input.GithubID account.Name = input.GithubID case model.SocialAccountTypeNotion: account.Name = input.NotionName account.Email = input.NotionEmail case model.SocialAccountTypeLinkedIn: account.AccountID = input.LinkedInName account.Name = input.LinkedInName default: continue } if _, err := h.store.SocialAccount.UpdateSelectedFieldsByID(db, account.ID.String(), *account, "account_id", "name", "email"); err != nil { l.Errorf(err, "failed to update social account %s", account.ID) return err } } for _, account := range accountsInput { if _, err := h.store.SocialAccount.Create(db, &account); err != nil { l.AddField("account", account).Error(err, "failed to create social account") return err } } return nil } func (h *handler) validateAndMappingCity(db *gorm.DB, countryName string, cityName string) (*model.City, error) { country, err := h.store.Country.OneByName(db, countryName) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return nil, errs.ErrCountryNotFound } return nil, err } city := country.Cities.GetCity(cityName) if city == nil { return nil, errs.ErrCityDoesNotBelongToCountry } return city, nil } // UploadAvatar godoc // @Summary Upload avatar by id // @Description Upload avatar by id // @id uploadProfileAvatar // @Tags Profile // @Accept json // @Produce json // @Security BearerAuth // @Param file formData file true "content upload" // @Success 200 {object} EmployeeContentDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /profile/upload-avatar [post] func (h *handler) UploadAvatar(c *gin.Context) { employeeID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } file, err := c.FormFile("file") if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, file, "")) return } // 1.3 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "profile", "method": "UploadAvatar", "id": employeeID, }) fileName := file.Filename fileExtension := model.ContentExtension(filepath.Ext(fileName)) fileSize := file.Size filePath := fmt.Sprintf("https://storage.googleapis.com/%s/employees/%s/images/%s", h.config.Google.GCSBucketName, employeeID, fileName) gcsPath := fmt.Sprintf("employees/%s/images/%s", employeeID, fileName) fileType := "image" // 2.1 validate if !fileExtension.ImageValid() { l.Info("invalid file extension") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, "")) return } if fileSize > model.MaxFileSizeImage { l.Info("invalid file size") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileSize, nil, "")) return } tx, done := h.repo.NewTransaction() // 2.2 check file name exist _, err = h.store.Content.OneByPath(tx.DB(), filePath) if err != nil && err != gorm.ErrRecordNotFound { l.Error(err, "error query content from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } if err == nil { l.Info("file already existed") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrFileAlreadyExisted), nil, "")) return } // 2.3 check employee existed existedEmployee, err := h.store.Employee.One(tx.DB(), employeeID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("employee not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } l.Error(err, "error query employee from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } _, err = h.store.Content.Create(tx.DB(), model.Content{ Type: fileType, Extension: fileExtension.String(), Path: filePath, TargetID: existedEmployee.ID, UploadBy: existedEmployee.ID, }) if err != nil { l.Error(err, "error query employee from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } // 3.1 update avatar link _, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, model.Employee{ Avatar: filePath, }, "avatar") if err != nil { l.Error(err, "error update avatar from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } multipart, err := file.Open() if err != nil { l.Error(err, "error in open file") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } // 3.2 Upload to GCS err = h.service.GoogleStorage.UploadContentGCS(multipart, gcsPath) if err != nil { l.Error(err, "error in upload file") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToContentData(filePath), nil, done(nil), nil, "")) } // Upload godoc // @Summary Upload image by id // @Description Upload image by id // @id uploadImage // @Tags Profile // @Accept json // @Produce json // @Security BearerAuth // @Param file formData file true "content upload" // @Success 200 {object} EmployeeContentDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /profile/upload [post] func (h *handler) Upload(c *gin.Context) { employeeID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } file, err := c.FormFile("file") if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, file, "")) return } fDoctype := c.PostForm("documentType") // 1.3 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "profile", "method": "UploadAvatar", "id": employeeID, }) docType := model.DocumentType(fDoctype) fileName := file.Filename fileExtension := model.ContentExtension(filepath.Ext(fileName)) fileSize := file.Size filePath := fmt.Sprintf("https://storage.googleapis.com/%s/employees/%s/images/%s", h.config.Google.GCSBucketName, employeeID, fileName) gcsPath := fmt.Sprintf("employees/%s/images/%s", employeeID, fileName) fileType := "image" // 2.1 validate if !docType.Valid() { l.Info("invalid document type") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidDocumentType, nil, "")) return } if !fileExtension.ImageValid() { l.Info("invalid file extension") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, "")) return } if fileSize > model.MaxFileSizeImage { l.Info("invalid file size") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileSize, nil, "")) return } tx, done := h.repo.NewTransaction() // 2.2 check file name exist _, err = h.store.Content.OneByPath(tx.DB(), filePath) if err != nil && err != gorm.ErrRecordNotFound { l.Error(err, "error query content from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } if err == nil { l.Info("file already existed") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrFileAlreadyExisted), nil, "")) return } // 2.3 check employee existed existedEmployee, err := h.store.Employee.One(tx.DB(), employeeID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("employee not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } l.Error(err, "error query employee from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } _, err = h.store.Content.Create(tx.DB(), model.Content{ Type: fileType, Extension: fileExtension.String(), Path: filePath, TargetID: existedEmployee.ID, UploadBy: existedEmployee.ID, }) if err != nil { l.Error(err, "error query employee from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } switch docType { case model.DocumentTypeAvatar: _, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, model.Employee{ Avatar: filePath, }, "avatar") if err != nil { l.Error(err, "error update avatar from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } case model.DocumentTypeIDPhotoFront: _, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, model.Employee{ IdentityCardPhotoFront: filePath, }, "avatar") if err != nil { l.Error(err, "error update id card front from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } case model.DocumentTypeIDPhotoBack: _, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, model.Employee{ IdentityCardPhotoBack: filePath, }, "avatar") if err != nil { l.Error(err, "error update id card back from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } } // 3.1 update avatar link multipart, err := file.Open() if err != nil { l.Error(err, "error in open file") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } // 3.2 Upload to GCS err = h.service.GoogleStorage.UploadContentGCS(multipart, gcsPath) if err != nil { l.Error(err, "error in upload file") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToContentData(filePath), nil, done(nil), nil, "")) } // GetInvitation godoc // @Summary Get invitation state based on token // @Description Submit Get invitation state based on token // @id getInvitation // @Tags Onboarding // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} EmployeeInvitationResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /invite [get] func (h *handler) GetInvitation(c *gin.Context) { employeeID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "profile", "method": "GetInvitation", }) employeeInvitation, err := h.store.EmployeeInvitation.OneByEmployeeID(h.repo.DB(), employeeID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("employee invitation not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, nil, "")) return } l.Error(err, "failed to get employee invitation") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToBasicEmployeeInvitationData(employeeInvitation), nil, nil, nil, "")) } // SubmitOnboardingForm godoc // @Summary Submit onboarding form // @Description Submit Onboarding form // @id submitOnboardingForm // @Tags Onboarding // @Accept json // @Produce json // @Security BearerAuth // @Param Body body SubmitOnboardingFormRequest true "Body" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /invite/submit [put] func (h *handler) SubmitOnboardingForm(c *gin.Context) { employeeID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } input := request.SubmitOnboardingFormRequest{} if err := c.ShouldBindJSON(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "profile", "method": "SubmitOnboardingForm", "request": input, }) if err := input.Validate(); err != nil { l.Error(err, "failed to validate input") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } employeeInvitation, err := h.store.EmployeeInvitation.OneByEmployeeID(h.repo.DB(), employeeID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("employee invitation not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, nil, "")) return } l.Error(err, "failed to get employee invitation") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if employeeInvitation.IsCompleted { l.Errorf(errs.ErrOnboardingFormAlreadyDone, "employee invitation is expired") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrOnboardingFormAlreadyDone, nil, "")) return } city, err := h.validateAndMappingCity(h.repo.DB(), input.Country, input.City) if err != nil { l.Info("country or city is invalid") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidCountryOrCity, input, "")) return } input.Lat = city.Lat input.Long = city.Long employee, err := h.store.Employee.One(h.repo.DB(), employeeID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("employee not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, nil, "")) return } l.Error(err, "failed to get employee") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } updatedFields := []string{ "address", "city", "lat", "long", "country", "gender", "horoscope", "date_of_birth", "local_bank_branch", "local_bank_currency", "local_bank_number", "local_bank_recipient_name", "local_branch_name", "mbti", "phone_number", "place_of_residence", "working_status", "discord_account_id", } if input.Avatar != "" { updatedFields = append(updatedFields, "avatar") } if input.IdentityCardPhotoFront != "" { updatedFields = append(updatedFields, "identity_card_photo_front") } if input.IdentityCardPhotoBack != "" { updatedFields = append(updatedFields, "identity_card_photo_back") } if input.PassportPhotoFront != "" { updatedFields = append(updatedFields, "passport_photo_front") } if input.PassportPhotoBack != "" { updatedFields = append(updatedFields, "passport_photo_back") } employeeData := input.ToEmployeeModel() tx, done := h.repo.NewTransaction() // Get discord info discordMember, err := h.service.Discord.GetMemberByUsername(input.DiscordName) if err != nil { l.Errorf(err, "failed to get discord info", "discordName", input.DiscordName) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } discordID := "" if discordMember == nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrCouldNotFoundDiscordMemberInGuild), input, "")) return } discordID = discordMember.User.ID tmpE, err := h.store.Employee.GetByDiscordID(tx.DB(), discordID, false) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } if !errors.Is(err, gorm.ErrRecordNotFound) { if tmpE.ID != employee.ID { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrDiscordAccountAlreadyUsedByAnotherEmployee), input, "")) return } } discordAccountInput := &model.DiscordAccount{ DiscordID: discordID, DiscordUsername: input.DiscordName, } discordAccount, err := h.store.DiscordAccount.Upsert(tx.DB(), discordAccountInput) if err != nil { l.Error(err, "failed to get discord info") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) } employeeData.DiscordAccountID = discordAccount.ID // Update employee _, err = h.store.Employee.UpdateSelectedFieldsByID(tx.DB(), employeeID, *employeeData, updatedFields..., ) if err != nil { l.Error(err, "failed to update employee") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // Update social accounts saInput := model.SocialAccountInput{ GithubID: input.GithubID, NotionName: input.NotionName, LinkedInName: input.LinkedInName, } if err := h.updateSocialAccounts(tx.DB(), saInput, employee.ID); err != nil { l.Error(err, "failed to update employee") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // Commit transaction update employee info _ = done(nil) employeeInvitation.IsInfoUpdated = true employeeInvitation.IsCompleted = true if !employeeInvitation.IsTeamEmailCreated { err = h.createTeamEmail(employee.TeamEmail, employee.PersonalEmail) if err != nil { l.Error(err, "failed to create create team email") } else { employeeInvitation.IsTeamEmailCreated = true } } if !employeeInvitation.IsBasecampAccountCreated { err = h.createBasecampAccount(employee) if err != nil { l.Error(err, "failed to create basecamp account") } else { employeeInvitation.IsBasecampAccountCreated = true } } if !employeeInvitation.IsDiscordRoleAssigned { err = h.assignDiscordRole(discordMember) if err != nil { l.Error(err, "failed to assign discord role") } else { employeeInvitation.IsDiscordRoleAssigned = true } } err = h.store.EmployeeInvitation.Save(h.repo.DB(), employeeInvitation) if err != nil { l.Error(err, "failed to update employee invitation") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "employee_submit_onboarding_form", Data: map[string]interface{}{ "employee_id": employee.ID.String(), }, }) if err != nil { l.Error(err, "failed to logs to discord") } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } func (h *handler) createTeamEmail(teamEmail string, personalEmail string) error { if h.config.Env != "prod" { return nil } return h.service.ImprovMX.CreateAccount(teamEmail, personalEmail) } func (h *handler) createBasecampAccount(employee *model.Employee) error { if h.config.Env != "prod" { employee.BasecampID = 123456 employee.BasecampAttachableSGID = "sample_sg_id" _, err := h.store.Employee.UpdateSelectedFieldsByID(h.repo.DB(), employee.ID.String(), *employee, "basecamp_id", "basecamp_attachable_sgid", ) if err != nil { return err } return nil } email := employee.PersonalEmail if employee.TeamEmail != "" { email = employee.TeamEmail } bcID, sgID, err := h.service.Basecamp.People.Create(employee.DisplayName, email, model.OrganizationNameDwarves) if err != nil { return err } employee.BasecampID = int(bcID) employee.BasecampAttachableSGID = sgID _, err = h.store.Employee.UpdateSelectedFieldsByID(h.repo.DB(), employee.ID.String(), *employee, "basecamp_id", "basecamp_attachable_sgid", ) if err != nil { return err } return nil } func (h *handler) assignDiscordRole(discordMember *discordgo.Member) error { if discordMember == nil { return errs.ErrInvalidDiscordMemberInfo } // Get list discord role dRoles, err := h.service.Discord.GetRoles() if err != nil { return err } peepsRoleID := "" for _, r := range dRoles { if r.Name == model.DiscordRolePeeps.String() { peepsRoleID = r.ID break } } if peepsRoleID != "" { // Check if user already has peeps role if utils.Contains(discordMember.Roles, peepsRoleID) { return nil } err := h.service.Discord.AddRole(discordMember.User.ID, peepsRoleID) if err != nil { return err } } return nil }
```

# pkg/handler/profile/request/request.go

```go
package request import ( "strings" "time" "github.com/dwarvesf/fortress-api/pkg/handler/profile/errs" "github.com/dwarvesf/fortress-api/pkg/model" ) // UpdateInfoInput input model for update profile type UpdateInfoInput struct { PersonalEmail string `form:"personalEmail" json:"personalEmail" binding:"required,email"` PhoneNumber string `form:"phoneNumber" json:"phoneNumber" binding:"required,max=18,min=8"` PlaceOfResidence string `form:"placeOfResidence" json:"placeOfResidence" binding:"required"` Address string `form:"address" json:"address"` Country string `form:"country" json:"country" binding:"required"` City string `form:"city" json:"city" binding:"required"` Lat string `form:"lat" json:"lat"` Long string `form:"long" json:"long"` GithubID string `form:"githubID" json:"githubID"` NotionID string `form:"notionID" json:"notionID"` NotionName string `form:"notionName" json:"notionName"` NotionEmail string `form:"notionEmail" json:"notionEmail"` DiscordName string `form:"discordName" json:"discordName"` LinkedInName string `form:"linkedInName" json:"linkedInName"` WiseRecipientID string `form:"wiseRecipientID" json:"wiseRecipientID"` WiseRecipientEmail string `form:"wiseRecipientEmail" json:"wiseRecipientEmail" binding:"email"` WiseRecipientName string `form:"wiseRecipientName" json:"wiseRecipientName"` WiseAccountNumber string `form:"wiseAccountNumber" json:"wiseAccountNumber"` WiseCurrency string `form:"wiseCurrency" json:"wiseCurrency"` } // @name UpdateInfoInput func (i UpdateInfoInput) ToEmployeeModel(employee *model.Employee) { employee.PersonalEmail = i.PersonalEmail employee.PhoneNumber = i.PhoneNumber employee.PlaceOfResidence = i.PlaceOfResidence employee.Address = i.Address employee.City = i.City employee.Country = i.Country employee.Lat = i.Lat employee.Long = i.Long if strings.TrimSpace(i.WiseRecipientID) != "" { employee.WiseRecipientID = i.WiseRecipientID } if strings.TrimSpace(i.WiseRecipientEmail) != "" { employee.WiseRecipientEmail = i.WiseRecipientEmail } if strings.TrimSpace(i.WiseRecipientName) != "" { employee.WiseRecipientName = i.WiseRecipientName } if strings.TrimSpace(i.WiseAccountNumber) != "" { employee.WiseAccountNumber = i.WiseAccountNumber } if strings.TrimSpace(i.WiseCurrency) != "" { employee.WiseCurrency = i.WiseCurrency } } type SubmitOnboardingFormRequest struct { Avatar string `json:"avatar"` Address string `json:"address" binding:"required"` City string `json:"city" binding:"required"` Country string `json:"country" binding:"required"` Lat string `json:"lat"` Long string `json:"long"` DateOfBirth *time.Time `json:"dateOfBirth" binding:"required"` Gender string `json:"gender" binding:"required"` Horoscope string `json:"horoscope" binding:"required"` MBTI string `json:"mbti" binding:"required"` PhoneNumber string `json:"phoneNumber" binding:"required,max=18,min=8"` PlaceOfResidence string `json:"placeOfResidence" binding:"required"` PassportPhotoFront string `json:"passportPhotoFront"` PassportPhotoBack string `json:"passportPhotoBack"` IdentityCardPhotoFront string `json:"identityCardPhotoFront"` IdentityCardPhotoBack string `json:"identityCardPhotoBack"` LocalBankBranch string `json:"localBankBranch" binding:"required"` LocalBankCurrency string `json:"localBankCurrency" binding:"required"` LocalBankNumber string `json:"localBankNumber" binding:"required"` LocalBankRecipientName string `json:"localBankRecipientName" binding:"required"` LocalBranchName string `json:"localBranchName" binding:"required"` DiscordName string `json:"discordName" binding:"required"` GithubID string `json:"githubID"` LinkedInName string `json:"linkedInName"` NotionName string `json:"notionName"` } // @name SubmitOnboardingFormRequest func (i *SubmitOnboardingFormRequest) Validate() error { if i.DateOfBirth.After(time.Now()) { return errs.ErrInvalidDate } if i.PassportPhotoBack == "" || i.PassportPhotoFront == "" { if i.IdentityCardPhotoFront == "" || i.IdentityCardPhotoBack == "" { return errs.ErrMissingDocuments } } if i.IdentityCardPhotoFront == "" || i.IdentityCardPhotoBack == "" { if i.PassportPhotoBack == "" || i.PassportPhotoFront == "" { return errs.ErrMissingDocuments } } return nil } func (i *SubmitOnboardingFormRequest) ToEmployeeModel() *model.Employee { return &model.Employee{ Avatar: i.Avatar, Address: i.Address, Lat: i.Lat, Long: i.Long, City: i.City, Country: i.Country, DateOfBirth: i.DateOfBirth, Gender: i.Gender, Horoscope: i.Horoscope, PassportPhotoFront: strings.TrimSpace(i.PassportPhotoFront), PassportPhotoBack: strings.TrimSpace(i.PassportPhotoBack), IdentityCardPhotoFront: strings.TrimSpace(i.IdentityCardPhotoFront), IdentityCardPhotoBack: strings.TrimSpace(i.IdentityCardPhotoBack), LocalBranchName: i.LocalBranchName, LocalBankBranch: i.LocalBankBranch, LocalBankCurrency: i.LocalBankCurrency, LocalBankNumber: i.LocalBankNumber, LocalBankRecipientName: i.LocalBankRecipientName, MBTI: i.MBTI, PhoneNumber: i.PhoneNumber, PlaceOfResidence: i.PlaceOfResidence, WorkingStatus: model.WorkingStatusProbation, } }
```

# pkg/handler/project/errs/errors.go

```go
package errs import ( "errors" "fmt" ) var ( ErrInvalidProjectID = errors.New("invalid project ID") ErrInvalidProjectType = errors.New("invalid project type") ErrInvalidProjectStatus = errors.New("invalid project status") ErrInvalidProjectMemberStatus = errors.New("invalid project member status") ErrInvalidDeploymentType = errors.New("invalid deployment type") ErrInvalidStartDate = errors.New("invalid start date") ErrInvalidEndDate = errors.New("invalid end date") ErrInvalidMemberID = errors.New("invalid member ID") ErrInvalidSlotID = errors.New("invalid slot ID") ErrInvalidWorkUnitID = errors.New("invalid work unit ID") ErrInvalidWorkUnitType = errors.New("invalid work unit type") ErrInvalidWorkUnitStatus = errors.New("invalid work unit status") ErrInvalidWorkUnitStacks = errors.New("invalid work unit stacks") ErrInvalidInActiveMember = errors.New("member is not active in work unit") ErrMemberIsNotProjectLead = errors.New("project is not managed by signed-in user") ErrInvalidProjectFunction = errors.New("invalid project function value") ErrInvalidProjectImportantLevel = errors.New("invalid project important level value") ErrProjectNotFound = errors.New("project not found") ErrProjectNotionNotFound = errors.New("project notion not found") ErrCountryNotFound = errors.New("country not found") ErrBankAccountNotFound = errors.New("bank account not found") ErrEmployeeNotFound = errors.New("employee not found") ErrSeniorityNotFound = errors.New("seniority not found") ErrProjectSlotNotFound = errors.New("project slot not found") ErrProjectMemberNotFound = errors.New("project member not found") ErrAccountManagerNotFound = errors.New("account manager not found") ErrDeliveryManagerNotFound = errors.New("delivery manager not found") ErrWorkUnitNotFound = errors.New("work unit not found") ErrClientNotFound = errors.New("client not found") ErrOrganizationNotFound = errors.New("organization not found") ErrProjectNotExisted = errors.New("project not existed") ErrCompanyInfoNotFound = errors.New("company info not found") ErrMemberIsInactive = errors.New("member is inactive") ErrEmployeeWorkedOnTheProject = errors.New("employee worked on the project") ErrPositionsIsEmpty = errors.New("positions is empty") ErrMemberIsNotActiveInProject = errors.New("member is not active in project") ErrFailToCheckInputExistence = errors.New("failed to check input existence") ErrFailToDeleteWorkUnitStack = errors.New("failed to delete work unit stack in database") ErrFailedToCreateWorkUnitStack = errors.New("failed to create work unit stack") ErrFailedToGetWorkUnitMember = errors.New("failed to get work unit member") ErrFailedToUpdateWorkUnitMember = errors.New("failed to update work unit member in database") ErrFailedToSoftDeleteWorkUnitMember = errors.New("failed to soft delete work unit member") ErrFailedToGetProjectMember = errors.New("failed to get project member in database") ErrFailedToCreateWorkUnitMember = errors.New("failed to create work unit member") ErrSlotAlreadyContainsAnotherMember = errors.New("slot already contains another member") ErrDuplicateProjectCode = errors.New("project code is duplicated") ErrAccountManagerRequired = errors.New("account manager is required") ErrInvalidFileExtension = errors.New("invalid file extension") ErrInvalidFileSize = errors.New("invalid file size") ErrInvalidEmailDomainForClient = errors.New("invalid email domain for client") ErrInvalidEmailDomainForProject = errors.New("invalid email domain for project") ) // ErrPositionNotFoundWithID returns unauthorized custom error func ErrPositionNotFoundWithID(id string) error { return fmt.Errorf("position not found: %v", id) } func ErrStackNotFoundWithID(id string) error { return fmt.Errorf("stack not found: %v", id) }
```

# pkg/handler/project/interface.go

```go
package project import "github.com/gin-gonic/gin" const ( saleReferralCommissionRate int64 = 10 ) type IHandler interface { ArchiveWorkUnit(c *gin.Context) AssignMember(c *gin.Context) Create(c *gin.Context) CreateWorkUnit(c *gin.Context) DeleteMember(c *gin.Context) DeleteSlot(c *gin.Context) Details(c *gin.Context) GetMembers(c *gin.Context) GetWorkUnits(c *gin.Context) List(c *gin.Context) SyncProjectMemberStatus(c *gin.Context) UnarchiveWorkUnit(c *gin.Context) UnassignMember(c *gin.Context) UpdateContactInfo(c *gin.Context) UpdateGeneralInfo(c *gin.Context) UpdateMember(c *gin.Context) UpdateProjectStatus(c *gin.Context) UpdateSendingSurveyState(c *gin.Context) UpdateWorkUnit(c *gin.Context) UploadAvatar(c *gin.Context) IcyWeeklyDistribution(c *gin.Context) CommissionModels(c *gin.Context) }
```

# pkg/handler/project/project.go

```go
package project import ( "errors" "fmt" "net/http" "path/filepath" "slices" "strings" "time" "github.com/gin-gonic/gin" "github.com/shopspring/decimal" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/handler/project/errs" "github.com/dwarvesf/fortress-api/pkg/handler/project/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/store/project" "github.com/dwarvesf/fortress-api/pkg/utils" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store controller *controller.Controller service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, controller: controller, repo: repo, service: service, logger: logger, config: cfg, } } func (h *handler) IcyWeeklyDistribution(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "IcyWeeklyDistribution", }) weeklyIcyDistribution, err := h.store.IcyDistribution.GetWeekly(h.repo.DB()) if err != nil { l.Error(err, "failed to weekly icy distribution") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, "", "can't get weekly icy distribution")) return } c.JSON(http.StatusOK, view.CreateResponse[any](weeklyIcyDistribution, nil, nil, "", "")) } // List godoc // @Summary Get list of project // @Description Get list of project // @id getProjectList // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param status query []string false "Project status" // @Param name query string false "Project name" // @Param type query string false "Project type" // @Param page query string false "Page" // @Param size query string false "Size" // @Success 200 {object} ProjectListDataResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects [get] func (h *handler) List(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } query := request.GetListProjectInput{} if err := c.ShouldBindQuery(&query); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "")) return } query.StandardizeInput() pagination := model.Pagination{ Page: query.Page, Size: query.Size, Sort: query.Sort, Standardized: true, } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "List", "query": query, }) if err := query.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } projectTypes := make([]string, 0) for _, t := range query.Type { if strings.TrimSpace(t) != "" { projectTypes = append(projectTypes, t) } } projects, total, err := h.store.Project.All(h.repo.DB(), project.GetListProjectInput{ Statuses: query.Status, Name: query.Name, Types: projectTypes, }, pagination) if err != nil { l.Error(err, "error query project from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse(view.ToProjectsData(projects, userInfo), &view.PaginationResponse{Pagination: view.Pagination{Page: pagination.Page, Size: pagination.Size, Sort: pagination.Sort}, Total: total}, nil, nil, "")) } // UpdateProjectStatus godoc // @Summary Update status for project by id // @Description Update status for project by id // @id updateProjectStatus // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param status body UpdateProjectStatusBody true "Project Status" // @Success 200 {object} UpdateProjectStatusResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/status [put] func (h *handler) UpdateProjectStatus(c *gin.Context) { projectID := c.Param("id") if projectID == "" || !model.IsUUIDFromString(projectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } var body request.UpdateProjectStatusBody if err := c.ShouldBindJSON(&body); err != nil { if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "UpdateProjectStatus", "body": body, }) if !body.ProjectStatus.IsValid() { l.Error(errs.ErrInvalidProjectStatus, "invalid value for ProjectStatus") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectStatus, body, "")) return } p, err := h.store.Project.One(h.repo.DB(), projectID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, projectID, "")) return } l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, projectID, "")) return } tx, done := h.repo.NewTransaction() p.Status = model.ProjectStatus(body.ProjectStatus) p.EndDate = nil if p.Status == model.ProjectStatusClosed { p.EndDate = new(time.Time) *p.EndDate = time.Now() } _, err = h.store.Project.UpdateSelectedFieldsByID(tx.DB(), projectID, *p, "status", "end_date") if err != nil { l.Error(err, "failed to update project status") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } // TODO: we can open it when needing automation flow to inactivated project member //if body.ProjectStatus == model.ProjectStatusClosed { // if err := h.closeProject(tx.DB(), projectID); err != nil { // l.Error(err, "failed to close project") // c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) // return // } //} c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateProjectStatusResponse(p), nil, done(nil), nil, "")) } // func (h *handler) closeProject(db *gorm.DB, projectID string) error { // err := h.store.ProjectMember.UpdateEndDateByProjectID(db, projectID) // if err != nil { // h.logger.Error(err, "failed to update end_date by project_id") // return err // } // err = h.store.ProjectMember.UpdateSelectedFieldByProjectID(db, projectID, // model.ProjectMember{Status: model.ProjectMemberStatusInactive}, // "status") // if err != nil { // h.logger.Error(err, "failed to update status of project_member by project_id") // return err // } // err = h.store.ProjectSlot.UpdateSelectedFieldByProjectID(db, projectID, // model.ProjectSlot{Status: model.ProjectMemberStatusInactive}, // "status", // ) // if err != nil { // h.logger.Error(err, "failed to update status of project_slot by project_id") // return err // } // return nil // } // Create godoc // @Summary Create new project // @Description Create new project // @id createProject // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param Body body CreateProjectRequest true "body" // @Success 200 {object} CreateProjectRestponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects [post] func (h *handler) Create(c *gin.Context) { userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } body := request.CreateProjectRequest{} if err := c.ShouldBindJSON(&body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "Create", "body": body, }) if err := body.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } country, err := h.store.Country.One(h.repo.DB(), body.CountryID.String()) if err != nil { l.Error(err, "failed to get country") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } var bankAccount *model.BankAccount if !body.BankAccountID.IsZero() { bankAccount, err = h.store.BankAccount.One(h.repo.DB(), body.BankAccountID.String()) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "bank account not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrBankAccountNotFound, body, "")) return } l.Error(err, "failed to get bank account") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } } var organization *model.Organization if !body.OrganizationID.IsZero() { organization, err = h.store.Organization.One(h.repo.DB(), body.OrganizationID.String()) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "organization not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrOrganizationNotFound, body, "")) return } l.Error(err, "failed to get organization") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } } if body.Code == "" { body.Code = utils.ProcessString(body.Name) } exists, err := h.store.Project.IsExistByCode(h.repo.DB(), body.Code) if err != nil { l.Error(err, "failed to check existence by code") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } if exists { l.Error(errs.ErrDuplicateProjectCode, "failed to create project") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrDuplicateProjectCode, body, "")) return } var client *model.Client if !body.ClientID.IsZero() { client, err = h.store.Client.One(h.repo.DB(), body.ClientID.String()) if err != nil { l.Error(err, "client not found") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrClientNotFound, body, "")) return } } // Create employee organization org, err := h.store.Organization.OneByCode(h.repo.DB(), model.OrganizationCodeDwarves) if err != nil { l.Error(err, "error invalid organization") if errors.Is(err, gorm.ErrRecordNotFound) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrOrganizationNotFound, body, "")) return } c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } p := &model.Project{ Name: body.Name, CountryID: model.UUID(body.CountryID), Type: model.ProjectType(body.Type), Status: model.ProjectStatus(body.Status), StartDate: body.GetStartDate(), ProjectEmail: body.ProjectEmail, ClientEmail: strings.Join(body.ClientEmail, ","), Country: country, Code: body.Code, Function: model.ProjectFunction(body.Function), ClientID: model.UUID(body.ClientID), ImportantLevel: model.ProjectImportantLevelMedium, } if body.OrganizationID.IsZero() { p.OrganizationID = org.ID } else { p.OrganizationID = model.UUID(body.OrganizationID) } if !body.BankAccountID.IsZero() { p.BankAccountID = model.UUID(body.BankAccountID) p.BankAccount = bankAccount } if !body.OrganizationID.IsZero() { p.OrganizationID = model.UUID(body.OrganizationID) p.Organization = organization } tx, done := h.repo.NewTransaction() if err := h.store.Project.Create(tx.DB(), p); err != nil { l.Error(err, "failed to create project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } p.Client = client // Create audit notion id if !body.AuditNotionID.IsZero() { if _, err := h.store.ProjectNotion.Create(tx.DB(), &model.ProjectNotion{ProjectID: p.ID, AuditNotionID: model.UUID(body.AuditNotionID)}); err != nil { l.Error(err, "failed to create project notion") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } } // create project account manager ams, err := h.createProjectHeads(tx.DB(), p.ID, model.HeadPositionAccountManager, body.AccountManagers) if err != nil { l.Error(err, "failed to create account managers") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } p.Heads = append(p.Heads, ams...) // create project delivery manager dms, err := h.createProjectHeads(tx.DB(), p.ID, model.HeadPositionDeliveryManager, body.DeliveryManagers) if err != nil { l.Error(err, "failed to create delivery managers") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } p.Heads = append(p.Heads, dms...) // create project sale persons sps, err := h.createProjectHeads(tx.DB(), p.ID, model.HeadPositionSalePerson, body.DeliveryManagers) if err != nil { l.Error(err, "failed to create sale persons") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } p.Heads = append(p.Heads, sps...) // assign members to project for _, member := range body.Members { slot, code, err := h.createSlotsAndAssignMembers(tx.DB(), p, member, userInfo) if err != nil { l.Error(err, "failed to assign member to project") c.JSON(code, view.CreateResponse[any](nil, nil, done(err), member, "")) return } p.Slots = append(p.Slots, *slot) } c.JSON(http.StatusOK, view.CreateResponse(view.ToCreateProjectDataResponse(userInfo, p), nil, done(nil), nil, "")) } func (h *handler) createProjectHeads(db *gorm.DB, projectID model.UUID, position model.HeadPosition, req []request.ProjectHeadRequest) ([]*model.ProjectHead, error) { var heads []*model.ProjectHead for _, head := range req { emp, err := h.store.Employee.One(db, head.EmployeeID.String(), false) if err != nil { h.logger.Error(err, "failed to get employee by id") return nil, err } head := &model.ProjectHead{ ProjectID: projectID, EmployeeID: model.UUID(head.EmployeeID), CommissionRate: head.CommissionRate, Position: position, } if err := h.store.ProjectHead.Create(db, head); err != nil { h.logger.Error(err, "failed to create project head") return nil, err } head.Employee = *emp heads = append(heads, head) } return heads, nil } // GetMembers godoc // @Summary Get list members of project // @Description Get list members of project // @id getProjectMemberList // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string false "Project ID" // @Param status query string false "Status" // @Param preload query bool false "Preload data with default value is true" // @Param page query string false "Page" // @Param size query string false "Size" // @Param sort query string false "Sort" // @Param distinct query bool false "Distinct" // @Success 200 {object} ProjectMemberListResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/members [get] func (h *handler) GetMembers(c *gin.Context) { userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } query := request.GetListStaffInput{} if err := c.ShouldBindQuery(&query); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "")) return } pagination := model.Pagination{ Page: query.Page, Size: query.Size, Sort: query.Sort, } pagination.Standardize() projectID := c.Param("id") if projectID == "" || !model.IsUUIDFromString(projectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "GetMembers", "projectID": projectID, "query": query, }) if err := query.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "")) return } project, err := h.store.Project.One(h.repo.DB(), projectID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, query, "")) return } l.Error(err, "cannot find project by id") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, "")) return } var pendingSlots []*model.ProjectSlot var assignedMembers []*model.ProjectMember // Get pending slots if query.Status == "" || query.Status == model.ProjectMemberStatusPending.String() { pendingSlots, err = h.store.ProjectSlot.GetPendingSlots(h.repo.DB(), projectID, query.Preload) if err != nil { l.Error(err, "failed to get pending slots") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, "")) return } } // Get assigned members if query.Status != model.ProjectMemberStatusPending.String() { assignedMembers, err = h.store.ProjectMember.GetAssignedMembers(h.repo.DB(), projectID, query.Status, query.Preload) if err != nil { l.Error(err, "failed to get assigned members") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, "")) return } } // Merge pending slots and assigned members into a slice total, members := h.mergeSlotAndMembers(h.repo.DB(), pendingSlots, assignedMembers, pagination) heads, err := h.store.ProjectHead.GetActiveLeadsByProjectID(h.repo.DB(), projectID) if err != nil { l.Error(err, "failed to get project heads") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, "")) return } c.JSON(http.StatusOK, view.CreateResponse(view.ToProjectMemberListData(userInfo, members, heads, project, query.Distinct), &view.PaginationResponse{Pagination: view.Pagination{Page: pagination.Page, Size: pagination.Size, Sort: pagination.Sort}, Total: total}, nil, nil, "")) } func (h *handler) mergeSlotAndMembers(db *gorm.DB, slots []*model.ProjectSlot, members []*model.ProjectMember, pagination model.Pagination) (int64, []*model.ProjectMember) { results := make([]*model.ProjectMember, 0, len(slots)+len(members)) for _, slot := range slots { member := &model.ProjectMember{ ProjectID: slot.ProjectID, ProjectSlotID: slot.ID, SeniorityID: slot.SeniorityID, DeploymentType: slot.DeploymentType, Status: slot.Status, Rate: slot.Rate, Discount: slot.Discount, Seniority: &slot.Seniority, Note: slot.Note, } for _, psPosition := range slot.ProjectSlotPositions { member.Positions = append(member.Positions, psPosition.Position) } results = append(results, member) } results = append(results, members...) total := int64(len(results)) // Get response by offset and limit limit, offset := pagination.ToLimitOffset() if offset > len(results) { results = []*model.ProjectMember{} } else if limit+offset > len(slots) { results = results[offset:] } else { results = results[offset : offset+limit] } return total, results } // DeleteMember godoc // @Summary Delete member in a project // @Description Delete member in a project // @id deleteProjectMember // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param memberID path string true "Project Member ID" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /project/{id}/members/{memberID} [delete] func (h *handler) DeleteMember(c *gin.Context) { input := request.DeleteMemberInput{ ProjectID: c.Param("id"), MemberID: c.Param("memberID"), } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "DeleteMember", "body": input, }) member, err := h.store.ProjectMember.OneByID(h.repo.DB(), input.MemberID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project member not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectMemberNotFound, input, "")) return } l.Error(err, "failed to get project member") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } // if projectMember.Status == model.ProjectMemberStatusInactive { // l.Error(errs.ErrCouldNotDeleteInactiveMember, "can not change information of inactive member") // c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrCouldNotDeleteInactiveMember, input.MemberID, "")) // return // } tx, done := h.repo.NewTransaction() err = h.store.ProjectMemberPosition.DeleteByProjectMemberID(tx.DB(), member.ID.String()) if err != nil { l.Error(err, "failed to delete project member position") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } err = h.store.ProjectMember.Delete(tx.DB(), member.ID.String()) if err != nil { l.Error(err, "failed to delete project member") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } err = h.store.ProjectHead.DeleteByPositionInProject(tx.DB(), member.ProjectID.String(), member.EmployeeID.String(), model.HeadPositionTechnicalLead.String()) if err != nil { l.Error(err, "failed to delete project head") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // Update project slot status to inactive _, err = h.store.ProjectSlot.UpdateSelectedFieldsByID(tx.DB(), member.ProjectSlotID.String(), model.ProjectSlot{ Status: model.ProjectMemberStatusInactive, }, "status") if err != nil { l.Error(err, "failed to update project slot") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } // DeleteSlot godoc // @Summary Delete slot in a project // @Description Delete slot in a project // @id deleteProjectSlot // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param slotID path string true "Slot ID" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /project/{id}/slot/{slotID} [delete] func (h *handler) DeleteSlot(c *gin.Context) { input := request.DeleteSlotInput{ ProjectID: c.Param("id"), SlotID: c.Param("slotID"), } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "DeleteSlot", "body": input, }) slot, err := h.store.ProjectSlot.One(h.repo.DB(), input.SlotID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project slot not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectSlotNotFound, input, "")) return } l.Error(err, "failed to get project slot") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } slot.Status = model.ProjectMemberStatusInactive _, err = h.store.ProjectSlot.UpdateSelectedFieldsByID(h.repo.DB(), input.SlotID, *slot, "status") if err != nil { l.Error(err, "failed to update project slot") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // UnassignMember godoc // @Summary Unassign member in a project // @Description Unassign member in a project // @id unassignProjectMember // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param memberID path string true "Employee ID" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /project/{id}/members/{memberID} [put] func (h *handler) UnassignMember(c *gin.Context) { input := request.UnassignMemberInput{ ProjectID: c.Param("id"), MemberID: c.Param("memberID"), } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "UnassignMember", "body": input, }) // get member info projectMember, err := h.store.ProjectMember.GetActiveMemberInProject(h.repo.DB(), input.ProjectID, input.MemberID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project member not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectMemberNotFound, input.MemberID, "")) return } l.Error(err, "failed to get project member") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input.MemberID, "")) return } // if projectMember.Status == model.ProjectMemberStatusInactive { // l.Error(errs.ErrCouldNotDeleteInactiveMember, "can not change information of inactive member") // c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrCouldNotDeleteInactiveMember, input.MemberID, "")) // return // } // Begin transaction tx, done := h.repo.NewTransaction() // remove member out of project timeNow := time.Now() if projectMember.EndDate == nil { projectMember.EndDate = &timeNow } projectMember.Status = model.ProjectMemberStatusInactive _, err = h.store.ProjectMember.UpdateSelectedFieldsByID(tx.DB(), projectMember.ID.String(), *projectMember, "end_date", "status") if err != nil { l.Error(err, "failed to update project member") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // update technical lead if employees is technical lead _, err = h.store.ProjectHead.UpdateDateOfEmployee(tx.DB(), input.MemberID, input.ProjectID, model.HeadPositionTechnicalLead.String(), projectMember.StartDate, projectMember.EndDate) if err != nil { l.Error(err, "failed to update endDate for technical lead") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // update slot status -> pending slot := model.ProjectSlot{ Status: model.ProjectMemberStatusPending, } _, err = h.store.ProjectSlot.UpdateSelectedFieldsByID(tx.DB(), projectMember.ProjectSlotID.String(), slot, "status") if err != nil { l.Error(err, "failed to update project slot") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } // UpdateMember godoc // @Summary Update member in an existing project // @Description Update member in an existing project // @id updateProjectMember // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param Body body UpdateMemberRequest true "Body" // @Success 200 {object} CreateMemberDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/members [put] func (h *handler) UpdateMember(c *gin.Context) { userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } var body request.UpdateMemberRequest if err := c.ShouldBindJSON(&body); err != nil { if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } } projectID := c.Param("id") if projectID == "" || !model.IsUUIDFromString(projectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "UpdateMember", "body": body, }) if err := body.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } // check project existence p, err := h.store.Project.One(h.repo.DB(), projectID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, body, "")) return } l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } // check seniority existence exists, err := h.store.Seniority.IsExist(h.repo.DB(), body.SeniorityID.String()) if err != nil { l.Error(err, "failed to check seniority existence") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } if !exists { l.Error(errs.ErrSeniorityNotFound, "cannot find seniority by id") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrSeniorityNotFound, body, "")) return } // check position existence positions, err := h.store.Position.All(h.repo.DB()) if err != nil { l.Error(err, "failed to get all positions") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } positionMap := model.ToPositionMap(positions) for _, pID := range body.Positions { if _, ok := positionMap[model.UUID(pID)]; !ok { l.Error(errs.ErrPositionNotFoundWithID(pID.String()), "position not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrPositionNotFoundWithID(pID.String()), body, "")) return } } // check project slot status slot, err := h.store.ProjectSlot.One(h.repo.DB(), body.ProjectSlotID.String()) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrProjectSlotNotFound, "cannot find project slot by id") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectSlotNotFound, body, "")) return } l.Error(err, "failed to get project slot by id") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, body, "")) return } tx, done := h.repo.NewTransaction() if !body.EmployeeID.IsZero() { member, err := h.updateProjectMember(tx.DB(), p, slot.ID.String(), projectID, body, userInfo) if err != nil { l.Error(err, "failed to update project member") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } slot.ProjectMember = *member } // update project slot slot.SeniorityID = model.UUID(body.SeniorityID) slot.DeploymentType = model.DeploymentType(body.DeploymentType) slot.Status = model.ProjectMemberStatus(body.Status) slot.Note = body.Note if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) { slot.Rate = body.Rate slot.Discount = body.Discount } _, err = h.store.ProjectSlot.UpdateSelectedFieldsByID(tx.DB(), body.ProjectSlotID.String(), *slot, "seniority_id", "deployment_type", "status", "rate", "discount", "note", ) if err != nil { l.Error(err, "failed to update project slot") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } // update project slot positions if err := h.store.ProjectSlotPosition.DeleteByProjectSlotID(tx.DB(), slot.ID.String()); err != nil { l.Error(err, "failed to delete project member positions") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } slotPos := make([]model.ProjectSlotPosition, 0, len(body.Positions)) for _, v := range body.Positions { slotPos = append(slotPos, model.ProjectSlotPosition{ ProjectSlotID: slot.ID, PositionID: model.UUID(v), }) } if err := h.store.ProjectSlotPosition.Create(tx.DB(), slotPos...); err != nil { l.Error(err, "failed to create project slot positions") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } slot.ProjectSlotPositions = slotPos for i, v := range slot.ProjectSlotPositions { slot.ProjectSlotPositions[i].Position = positionMap[v.PositionID] } for i, v := range slot.ProjectMember.ProjectMemberPositions { slot.ProjectMember.ProjectMemberPositions[i].Position = positionMap[v.PositionID] } c.JSON(http.StatusOK, view.CreateResponse(view.ToCreateMemberData(userInfo, slot), nil, done(nil), nil, "")) } // updateProjectMember flow: // // --- start --- // // if input.EmployeeID != nil { // if input.ProjectMemberID != nil { // update ProjectMember by ProjectMemberID // } else { // update ProjectMember by ProjectID and EmployeeID // } // if !input.IsLead || input.EndDate != nil { // endDate := input.EndDate // if input.EndDate == nil { // endDate = time.Now() // update endDate of projectHead // } // } else { // create new ProjectHead // } // } // // --- end --- func (h *handler) updateProjectMember(db *gorm.DB, p *model.Project, slotID string, projectID string, input request.UpdateMemberRequest, userInfo *model.CurrentLoggedUserInfo) (*model.ProjectMember, error) { var member *model.ProjectMember var err error // check upsell person existence var upsellPerson *model.Employee if !input.UpsellPersonID.IsZero() { upsellPerson, err = h.store.Employee.One(h.repo.DB(), input.UpsellPersonID.String(), false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { h.logger.Error(errs.ErrEmployeeNotFound, "upsell person not found") return nil, err } h.logger.Error(err, "failed to get upsell person by id") return nil, err } } if !input.ProjectMemberID.IsZero() { // Update assigned slot member, err = h.store.ProjectMember.OneByID(db, input.ProjectMemberID.String()) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { h.logger.Error(errs.ErrProjectMemberNotFound, "project member not found") return nil, err } h.logger.Error(err, "failed to get project member by id") return nil, err } member.SeniorityID = model.UUID(input.SeniorityID) member.DeploymentType = model.DeploymentType(input.DeploymentType) member.StartDate = input.GetStartDate() member.Note = input.Note member.UpsellPersonID = model.UUID(input.UpsellPersonID) updateEndDate := false inputEndDate := input.GetEndDate() if member.EndDate != nil && inputEndDate == nil { member.EndDate = nil updateEndDate = true } if member.EndDate == nil && inputEndDate != nil { member.EndDate = inputEndDate updateEndDate = true } if member.EndDate != nil && inputEndDate != nil { if !member.EndDate.Equal(*inputEndDate) { member.EndDate = inputEndDate updateEndDate = true } } updateStatus := false if member.Status != model.ProjectMemberStatus(input.Status) { member.Status = model.ProjectMemberStatus(input.Status) updateStatus = true } if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) { member.UpsellCommissionRate = input.UpsellCommissionRate } updateRate := false if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) { if !member.Rate.Equal(input.Rate) { member.Rate = input.Rate updateRate = true } member.Discount = input.Discount } _, err = h.store.ProjectMember.UpdateSelectedFieldsByID(db, input.ProjectMemberID.String(), *member, "start_date", "end_date", "status", "rate", "discount", "deployment_type", "seniority_id", "note", "upsell_person_id", "upsell_commission_rate", ) if err != nil { h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to update project member") return nil, err } if updateStatus { err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "project_member_update_status", Data: map[string]interface{}{ "employee_id": userInfo.UserID, "updated_employee_id": member.EmployeeID.String(), "project_name": p.Name, "status": member.Status.String(), }, }) if err != nil { h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to log project member status update") } } if updateRate { charRate, _ := member.Rate.Float64() rate := utils.FormatMoney(charRate, p.BankAccount.Currency.Name) err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "project_member_update_charge_rate", Data: map[string]interface{}{ "employee_id": userInfo.UserID, "updated_employee_id": member.EmployeeID.String(), "project_name": p.Name, "rate": fmt.Sprintf("%s %s", rate, p.BankAccount.Currency.Name), }, }) if err != nil { h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to log project member charge rate update") } } if updateEndDate { endDateLog := "N/A" if member.EndDate != nil { endDateLog = member.EndDate.Format("2006-01-02") } err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "project_member_update_end_date", Data: map[string]interface{}{ "employee_id": userInfo.UserID, "updated_employee_id": member.EmployeeID.String(), "project_name": p.Name, "end_date": endDateLog, }, }) if err != nil { h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to log project member end date update") } } } else { // Update pending slot // Is slot contains any member? member, err = h.store.ProjectMember.OneBySlotID(db, slotID) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { h.logger.Fields(logger.Fields{"slotID": slotID}).Error(err, "failed to get project member by slotID") return nil, err } if member != nil && !member.EmployeeID.IsZero() && member.EmployeeID != model.UUID(input.EmployeeID) { h.logger. Fields(logger.Fields{"member": member}). Error(errs.ErrSlotAlreadyContainsAnotherMember, "slot already contains another member") return nil, errs.ErrSlotAlreadyContainsAnotherMember } // Is member active in project? _, err = h.store.ProjectMember.GetActiveMemberInProject(db, projectID, input.EmployeeID.String()) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { h.logger.Fields(logger.Fields{ "projectID": projectID, "employeeID": input.EmployeeID, }).Error(err, "failed to get active member in project") return nil, err } // If member is not active in project, create new project member if errors.Is(err, gorm.ErrRecordNotFound) { member = &model.ProjectMember{ ProjectID: model.MustGetUUIDFromString(projectID), EmployeeID: model.UUID(input.EmployeeID), SeniorityID: model.UUID(input.SeniorityID), ProjectSlotID: model.MustGetUUIDFromString(slotID), DeploymentType: model.DeploymentType(input.DeploymentType), Status: model.ProjectMemberStatus(input.Status), StartDate: input.GetStartDate(), EndDate: input.GetEndDate(), Note: input.Note, UpsellPersonID: model.UUID(input.UpsellPersonID), } if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) { member.UpsellCommissionRate = input.UpsellCommissionRate } if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) { member.Rate = input.Rate member.Discount = input.Discount } if err := h.store.ProjectMember.Create(db, member); err != nil { h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to create project member") return nil, err } err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "project_member_add", Data: map[string]interface{}{ "employee_id": userInfo.UserID, "updated_employee_id": member.EmployeeID.String(), "project_name": p.Name, "deployment_type": member.DeploymentType.String(), }, }) if err != nil { h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to log project member add") } } } // update project member positions if err := h.store.ProjectMemberPosition.DeleteByProjectMemberID(db, member.ID.String()); err != nil { h.logger.Fields(logger.Fields{"memberID": member.ID}).Error(err, "failed to delete project member positions") return nil, err } memberPos := make([]model.ProjectMemberPosition, 0, len(input.Positions)) for _, v := range input.Positions { memberPos = append(memberPos, model.ProjectMemberPosition{ ProjectMemberID: member.ID, PositionID: model.UUID(v), }) } if err := h.store.ProjectMemberPosition.Create(db, memberPos...); err != nil { h.logger.Fields(logger.Fields{"positions": memberPos}).Error(err, "failed to create project member positions") return nil, err } member.UpsellPerson = upsellPerson member.ProjectMemberPositions = memberPos member.IsLead = input.IsLead endDate := input.GetEndDate() if !input.IsLead { // End of lead time if endDate == nil { endDate = new(time.Time) *endDate = time.Now() } _, err := h.store.ProjectHead.UpdateDateOfEmployee(db, input.EmployeeID.String(), projectID, model.HeadPositionTechnicalLead.String(), input.GetStartDate(), endDate) if err != nil { h.logger.Fields(logger.Fields{ "projectID": projectID, "employeeID": input.EmployeeID, }).Error(err, "failed to update end_date of project head") return nil, err } } else { // Start of lead time or update lead time _, err := h.updateProjectLead(db, projectID, model.UUID(input.EmployeeID), input.GetStartDate(), input.GetEndDate(), input.LeadCommissionRate, userInfo) if err != nil { h.logger.Fields(logger.Fields{ "projectID": projectID, "employeeID": input.EmployeeID, }).Error(err, "failed to update technicalLeads") return nil, err } } return member, nil } // AssignMember godoc // @Summary Assign member into an existing project // @Description Assign member in an existing project // @id assignProjectMember // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param Body body AssignMemberRequest true "Body" // @Success 200 {object} CreateMemberDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/members [post] func (h *handler) AssignMember(c *gin.Context) { userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } var body request.AssignMemberRequest if err := c.ShouldBindJSON(&body); err != nil { if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } } projectID := c.Param("id") if projectID == "" || !model.IsUUIDFromString(projectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "AssignMember", "body": body, "id": projectID, }) if err := body.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } // TODO: uncomment // The code has been commented because inactive user can be assigned to project, // we do not need to check if member active in project or not // // get active project member info // if !body.EmployeeID.IsZero() { // _, err := h.store.ProjectMember.GetActiveMemberInProject(h.repo.DB(), projectID, body.EmployeeID.String()) // if err != gorm.ErrRecordNotFound { // if err == nil { // l.Error(err, "project member exists") // c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrProjectMemberExists, projectID, "")) // return // } // l.Error(err, "failed to query project member") // c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, projectID, "")) // return // } // } // check project existence p, err := h.store.Project.One(h.repo.DB(), projectID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } l.Error(err, "error query project from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // remove commission rate if user does not have permission body.RestrictPermission(userInfo) tx, done := h.repo.NewTransaction() slot, code, err := h.createSlotsAndAssignMembers(tx.DB(), p, body, userInfo) if err != nil { l.Error(err, "failed to assign member to project") c.JSON(code, view.CreateResponse[any](nil, nil, done(err), body, "")) } c.JSON(http.StatusOK, view.CreateResponse(view.ToCreateMemberData(userInfo, slot), nil, done(nil), nil, "")) } func (h *handler) createSlotsAndAssignMembers(db *gorm.DB, p *model.Project, req request.AssignMemberRequest, userInfo *model.CurrentLoggedUserInfo) (*model.ProjectSlot, int, error) { l := h.logger // check seniority existence seniority, err := h.store.Seniority.One(db, model.UUID(req.SeniorityID)) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrSeniorityNotFound, "cannot find seniority by id") return nil, http.StatusNotFound, errs.ErrSeniorityNotFound } l.Error(err, "failed to check seniority existence") return nil, http.StatusInternalServerError, err } // check position existence positions, err := h.store.Position.All(db) if err != nil { l.Error(err, "failed to get all position") return nil, http.StatusInternalServerError, err } positionMap := model.ToPositionMap(positions) for _, pID := range req.Positions { if _, ok := positionMap[model.UUID(pID)]; !ok { l.Error(errs.ErrPositionNotFoundWithID(pID.String()), "position not found") return nil, http.StatusNotFound, errs.ErrPositionNotFoundWithID(pID.String()) } } // create project slot slot := &model.ProjectSlot{ ProjectID: p.ID, DeploymentType: model.DeploymentType(req.DeploymentType), Status: req.GetStatus(), SeniorityID: model.UUID(req.SeniorityID), Note: req.Note, } if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) { slot.Rate = req.Rate slot.Discount = req.Discount } if err := h.store.ProjectSlot.Create(db, slot); err != nil { l.Error(err, "failed to create project slot") return nil, http.StatusInternalServerError, err } slot.Seniority = *seniority // create project slot position slotPos := make([]model.ProjectSlotPosition, 0, len(req.Positions)) for _, v := range req.Positions { slotPos = append(slotPos, model.ProjectSlotPosition{ ProjectSlotID: slot.ID, PositionID: model.UUID(v), }) } if err := h.store.ProjectSlotPosition.Create(db, slotPos...); err != nil { l.Error(err, "failed to create project member positions") return nil, http.StatusInternalServerError, err } for i := range slotPos { slotPos[i].Position = positionMap[slotPos[i].PositionID] } slot.ProjectSlotPositions = slotPos // assign member to slot if !req.EmployeeID.IsZero() { // check employee existence exists, err := h.store.Employee.IsExist(db, req.EmployeeID.String()) if err != nil { l.Error(err, "failed to check employee existence") return nil, http.StatusInternalServerError, err } if !exists { l.Error(errs.ErrEmployeeNotFound, "cannot find employee by id") return nil, http.StatusNotFound, errs.ErrEmployeeNotFound } // check upsell person existence var upsellPerson *model.Employee if !req.UpsellPersonID.IsZero() { upsellPerson, err = h.store.Employee.One(db, req.UpsellPersonID.String(), false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "failed to get upsell person") return nil, http.StatusInternalServerError, err } l.Error(errs.ErrEmployeeNotFound, "upsell person not found") return nil, http.StatusNotFound, errs.ErrEmployeeNotFound } } // create project member member := &model.ProjectMember{ ProjectID: p.ID, EmployeeID: model.UUID(req.EmployeeID), SeniorityID: model.UUID(req.SeniorityID), ProjectSlotID: slot.ID, DeploymentType: model.DeploymentType(req.DeploymentType), Status: req.GetStatus(), StartDate: req.GetStartDate(), EndDate: req.GetEndDate(), Note: req.Note, UpsellPersonID: model.UUID(req.UpsellPersonID), } if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) { member.UpsellCommissionRate = req.UpsellCommissionRate } if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) { member.Rate = req.Rate member.Discount = req.Discount } if err = h.store.ProjectMember.Create(db, member); err != nil { l.Error(err, "failed to create project member") return nil, http.StatusInternalServerError, err } member.UpsellPerson = upsellPerson slot.ProjectMember = *member // create project member positions for _, v := range req.Positions { if err := h.store.ProjectMemberPosition.Create(db, model.ProjectMemberPosition{ ProjectMemberID: member.ID, PositionID: model.UUID(v), }); err != nil { l.Error(err, "failed to create project member positions") return nil, http.StatusInternalServerError, err } } // create project head slot.ProjectMember.IsLead = req.IsLead if req.IsLead { head := &model.ProjectHead{ ProjectID: p.ID, EmployeeID: model.UUID(req.EmployeeID), Position: model.HeadPositionTechnicalLead, StartDate: *req.GetStartDate(), } if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) { head.CommissionRate = req.LeadCommissionRate } if err := h.store.ProjectHead.Create(db, head); err != nil { l.Error(err, "failed to create project head") return nil, http.StatusInternalServerError, err } slot.ProjectMember.Head = head } err = h.controller.Discord.Log(model.LogDiscordInput{ Type: "project_member_add", Data: map[string]interface{}{ "employee_id": userInfo.UserID, "updated_employee_id": member.EmployeeID.String(), "project_name": p.Name, "deployment_type": member.DeploymentType.String(), }, }) if err != nil { h.logger.Fields(logger.Fields{"member": member}).Error(err, "failed to log project member add") } } return slot, http.StatusOK, nil } // Details godoc // @Summary Get details of a project // @Description Get details of a project // @id getProjectDetails // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Success 200 {object} ProjectDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id} [get] func (h *handler) Details(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } projectID := c.Param("id") if projectID == "" { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "Details", "id": projectID, }) projectData, err := h.store.Project.One(h.repo.DB(), projectID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } l.Error(err, "error query project from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadFullAccess) && !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadReadActive) { _, ok := userInfo.Projects[projectData.ID] if !ok || !model.IsUserActiveInProject(userInfo.UserID, projectData.ProjectMembers) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } } if projectData.Status == model.ProjectStatusClosed && !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsReadFullAccess) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } projectCommissionModel := make([]model.CommissionModel, 0) if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateRead) { projectCommissionModel, err = h.aggregateCommissionModel(projectData) if err != nil { l.Error(err, "failed to aggregate commission model") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse(view.ToProjectData(projectData, userInfo, projectCommissionModel), nil, nil, nil, "")) } func (h *handler) aggregateCommissionModel(projectData *model.Project) ([]model.CommissionModel, error) { employeeIDs := make([]model.UUID, 0) var commissionModel = make([]model.CommissionModel, 0) for _, h := range projectData.Heads { commissionType := "" description := "" switch h.Position { case model.HeadPositionTechnicalLead: commissionType = "technical-lead" description = "Technical Lead" case model.HeadPositionAccountManager: commissionType = "account-manager" description = "Account Manager" case model.HeadPositionDeliveryManager: commissionType = "delivery-manager" description = "Delivery Manager" case model.HeadPositionSalePerson: commissionType = "sale-person" description = "Sale Person" if !slices.Contains(employeeIDs, h.Employee.ReferredBy) { employeeIDs = append(employeeIDs, h.Employee.ReferredBy) } } if h.CommissionRate.IsZero() { continue } commissionModel = append(commissionModel, model.CommissionModel{ Beneficiary: model.BasicEmployeeInfo{ ID: h.Employee.ID.String(), FullName: h.Employee.FullName, DisplayName: h.Employee.DisplayName, Avatar: h.Employee.Avatar, Username: h.Employee.Username, ReferredBy: h.Employee.ReferredBy.String(), }, CommissionType: commissionType, CommissionRate: h.CommissionRate, Description: description, }) } for _, pm := range projectData.ProjectMembers { if pm.UpsellPerson != nil { if pm.UpsellCommissionRate.IsZero() { continue } commissionModel = append(commissionModel, model.CommissionModel{ Beneficiary: model.BasicEmployeeInfo{ ID: pm.UpsellPerson.ID.String(), FullName: pm.UpsellPerson.FullName, DisplayName: pm.UpsellPerson.DisplayName, Avatar: pm.UpsellPerson.Avatar, Username: pm.UpsellPerson.Username, ReferredBy: pm.UpsellPerson.ReferredBy.String(), }, CommissionType: "upsell", CommissionRate: pm.UpsellCommissionRate, Description: fmt.Sprintf("Upsell for %s", pm.Employee.FullName), }) if !slices.Contains(employeeIDs, pm.UpsellPerson.ReferredBy) { employeeIDs = append(employeeIDs, pm.UpsellPerson.ReferredBy) } } } refEmployees, err := h.store.Employee.GetByIDs(h.repo.DB(), employeeIDs) if err != nil { return nil, err } refEmployeeMap := make(map[string]model.Employee) for _, ref := range refEmployees { refEmployeeMap[ref.ID.String()] = *ref } finalCommissionModel := make([]model.CommissionModel, 0) for _, cm := range commissionModel { if cm.CommissionType == "upsell" || cm.CommissionType == "sale-person" { if ref, ok := refEmployeeMap[cm.Beneficiary.ReferredBy]; ok { description := fmt.Sprintf("Sale Referral from %s", cm.Beneficiary.FullName) if cm.CommissionType == "upsell" { description = fmt.Sprintf("Sale Referral (Upsell) from %s", cm.Beneficiary.FullName) } cm.Sub = &model.CommissionModel{ Beneficiary: model.BasicEmployeeInfo{ ID: ref.ID.String(), FullName: ref.FullName, DisplayName: ref.DisplayName, Avatar: ref.Avatar, Username: ref.Username, ReferredBy: ref.ReferredBy.String(), }, CommissionType: "sale-referral", CommissionRate: decimal.NewFromInt(saleReferralCommissionRate), Description: description, } } } finalCommissionModel = append(finalCommissionModel, cm) } return finalCommissionModel, nil } // UpdateGeneralInfo godoc // @Summary Update general info of the project by id // @Description Update general info of the project by id // @id updateProjectGeneralInfo // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param Body body UpdateProjectGeneralInfoRequest true "Body" // @Success 200 {object} UpdateProjectGeneralInfoResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/general-info [put] func (h *handler) UpdateGeneralInfo(c *gin.Context) { projectID := c.Param("id") if projectID == "" || !model.IsUUIDFromString(projectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } var body request.UpdateProjectGeneralInfoRequest if err := c.ShouldBindJSON(&body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } if err := body.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "UpdateGeneralInfo", "id": projectID, "request": body, }) // Check project existence p, err := h.store.Project.One(h.repo.DB(), projectID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, projectID, "")) return } l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, projectID, "")) return } // Check country existence exist, err := h.store.Country.IsExist(h.repo.DB(), body.CountryID.String()) if err != nil { l.Error(err, "error check existence of country") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, err, body, "")) return } if !exist { l.Error(err, "country not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrCountryNotFound, body, "")) return } // Check bank account existence if !body.BankAccountID.IsZero() { exist, err := h.store.BankAccount.IsExist(h.repo.DB(), body.BankAccountID.String()) if err != nil { l.Error(err, "error check existence of bank account") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } if !exist { l.Error(err, "bank account not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrBankAccountNotFound, body, "")) return } } // Check organization existence if !body.OrganizationID.IsZero() { exist, err := h.store.Organization.IsExist(h.repo.DB(), body.OrganizationID.String()) if err != nil { l.Error(err, "error check existence of organization") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } if !exist { l.Error(err, "organization not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrOrganizationNotFound, body, "")) return } } if !body.CompanyInfoID.IsZero() { exist, err := h.store.CompanyInfo.IsExist(h.repo.DB(), body.CompanyInfoID.String()) if err != nil { l.Error(err, "error check existence of company info") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } if !exist { l.Error(err, "company info not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrCompanyInfoNotFound, body, "")) return } } // Check valid stack id _, stacks, err := h.store.Stack.All(h.repo.DB(), "", nil) if err != nil { l.Error(err, "error when finding stacks") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, body, "")) return } stackMap := model.ToStackMap(stacks) for _, sID := range body.Stacks { _, ok := stackMap[model.UUID(sID)] if !ok { l.Error(errs.ErrStackNotFoundWithID(sID.String()), "stack not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrStackNotFoundWithID(sID.String()), body, "")) return } } _, err = time.Parse("2006-01-02", body.StartDate) if body.StartDate != "" && err != nil { l.Error(errs.ErrInvalidStartDate, "invalid start date") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidStartDate, body, "")) return } if !body.ClientID.IsZero() { client, err := h.store.Client.One(h.repo.DB(), body.ClientID.String()) if err != nil { l.Error(err, "client not found") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrClientNotFound, body, "")) return } p.Client = client p.ClientID = client.ID } // Begin transaction tx, done := h.repo.NewTransaction() // Delete all exist employee stack if err := h.store.ProjectStack.DeleteByProjectID(tx.DB(), projectID); err != nil { l.Error(err, "failed to delete project stacks in database") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } // Create new employee stack for _, stackID := range body.Stacks { _, err := h.store.ProjectStack.Create(tx.DB(), &model.ProjectStack{ ProjectID: model.MustGetUUIDFromString(projectID), StackID: model.UUID(stackID), }) if err != nil { l.Error(err, "failed to create project stack") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } } p.Name = body.Name p.StartDate = body.GetStartDate() p.CountryID = model.UUID(body.CountryID) p.Function = model.ProjectFunction(body.Function) p.OrganizationID = model.UUID(body.OrganizationID) p.AccountRating = body.AccountRating p.DeliveryRating = body.DeliveryRating p.LeadRating = body.LeadRating p.ImportantLevel = model.ProjectImportantLevel(body.ImportantLevel) if !body.BankAccountID.IsZero() { p.BankAccountID = model.UUID(body.BankAccountID) } if !body.CompanyInfoID.IsZero() { p.CompanyInfoID = model.UUID(body.CompanyInfoID) } projectNotion, err := h.store.ProjectNotion.OneByProjectID(tx.DB(), p.ID.String()) if err != nil { if !errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "failed to get project notion") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), projectID, "")) return } else if !body.AuditNotionID.IsZero() { // create new project notion _, err := h.store.ProjectNotion.Create(tx.DB(), &model.ProjectNotion{ ProjectID: p.ID, AuditNotionID: model.UUID(body.AuditNotionID), }) if err != nil { l.Error(err, "failed to create project notion") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } } } else { projectNotion.AuditNotionID = model.UUID(body.AuditNotionID) // update audit notion id if _, err := h.store.ProjectNotion.UpdateSelectedFieldsByID(tx.DB(), projectNotion.ID.String(), *projectNotion); err != nil { l.Error(err, "failed to create project notion") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } } // TODO: allow updating client_id _, err = h.store.Project.UpdateSelectedFieldsByID(tx.DB(), projectID, *p, "name", "start_date", "country_id", "function", "bank_account_id", "client_id", "organization_id", "account_rating", "delivery_rating", "lead_rating", "important_level", "company_info_id", ) if err != nil { l.Error(err, "failed to update project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateProjectGeneralInfo(p), nil, done(nil), nil, "")) } // UpdateContactInfo godoc // @Summary Update contact info of the project by id // @Description Update contact info of the project by id // @id updateProjectContactInfo // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param Body body UpdateContactInfoRequest true "Body" // @Success 200 {object} UpdateProjectContactInfoResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/contact-info [put] func (h *handler) UpdateContactInfo(c *gin.Context) { userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } projectID := c.Param("id") if projectID == "" || !model.IsUUIDFromString(projectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } var body request.UpdateContactInfoRequest if err := c.ShouldBindJSON(&body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, body, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "UpdateContactInfo", "id": projectID, "request": body, }) // Validate client email address if err := body.Validate(); err != nil { l.Error(err, "invalid input request body") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, projectID, "")) return } // Check project existence p, err := h.store.Project.One(h.repo.DB(), projectID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, projectID, "")) return } l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, projectID, "")) return } // Begin transaction tx, done := h.repo.NewTransaction() err = h.updateProjectHeads(tx.DB(), projectID, model.HeadPositionAccountManager, body.AccountManagers, userInfo) if err != nil { l.Error(err, "failed to update account managers") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } err = h.updateProjectHeads(tx.DB(), projectID, model.HeadPositionDeliveryManager, body.DeliveryManagers, userInfo) if err != nil { l.Error(err, "failed to update delivery managers") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } err = h.updateProjectHeads(tx.DB(), projectID, model.HeadPositionSalePerson, body.SalePersons, userInfo) if err != nil { l.Error(err, "failed to update sale persons") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } // Update email info p.ClientEmail = strings.Join(body.ClientEmail, ",") p.ProjectEmail = body.ProjectEmail _, err = h.store.Project.UpdateSelectedFieldsByID(tx.DB(), projectID, *p, "client_email", "project_email") if err != nil { l.Error(err, "failed to update project information to db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } heads, err := h.store.ProjectHead.GetActiveLeadsByProjectID(tx.DB(), projectID) if err != nil { l.Error(err, "failed to get project heads") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), body, "")) return } p.Heads = heads c.JSON(http.StatusOK, view.CreateResponse[any](view.ToUpdateProjectContactInfo(p, userInfo), nil, done(nil), nil, "")) } func (h *handler) updateProjectHeads(db *gorm.DB, projectID string, position model.HeadPosition, headsInput []request.ProjectHeadRequest, userInfo *model.CurrentLoggedUserInfo) error { // create input map headInputMap := map[model.UUID]decimal.Decimal{} for _, head := range headsInput { if head.EmployeeID.IsZero() { continue } exists, err := h.store.Employee.IsExist(db, head.EmployeeID.String()) if err != nil { h.logger.Error(err, "failed to check employee existence") return err } if !exists { h.logger.Error(errs.ErrEmployeeNotFound, "employee not found") return errs.ErrEmployeeNotFound } headInputMap[model.UUID(head.EmployeeID)] = head.CommissionRate } heads, err := h.store.ProjectHead.GetByProjectIDAndPosition(db, projectID, position) if err != nil { h.logger.Fields(logger.Fields{ "projectID": projectID, "position": position, }).Error(err, "failed to get heads") return err } // update/delete exist heads for _, head := range heads { if _, ok := headInputMap[head.EmployeeID]; ok { if authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) { head.CommissionRate = headInputMap[head.EmployeeID] _, err := h.store.ProjectHead.UpdateSelectedFieldsByID(db, head.ID.String(), *head, "commission_rate") if err != nil { h.logger.Fields(logger.Fields{ "projectID": projectID, "headID": head.ID.String(), }).Error(err, "failed to update head") return err } } delete(headInputMap, head.EmployeeID) } else { if err := h.store.ProjectHead.DeleteByID(db, head.ID.String()); err != nil { h.logger.Fields(logger.Fields{ "projectID": projectID, "headID": head.ID.String(), }).Error(err, "failed to delete head") return err } } } // create new head for employeeID, commissionRate := range headInputMap { if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) { commissionRate = decimal.Zero } head := &model.ProjectHead{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, ProjectID: model.MustGetUUIDFromString(projectID), EmployeeID: employeeID, CommissionRate: commissionRate, Position: position, } if err := h.store.ProjectHead.Create(db, head); err != nil { h.logger.AddField("head", head).Error(err, "failed to create head") return err } } return nil } func (h *handler) updateProjectLead(db *gorm.DB, projectID string, employeeID model.UUID, startDate *time.Time, endDate *time.Time, commissionRate decimal.Decimal, userInfo *model.CurrentLoggedUserInfo) (*model.ProjectHead, error) { head, err := h.store.ProjectHead.One(db, projectID, employeeID.String(), model.HeadPositionTechnicalLead) if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) { h.logger.Fields(logger.Fields{ "projectID": projectID, "employeeID": employeeID, }).Error(err, "failed to get technical lead") return nil, err } if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) { commissionRate = decimal.Zero } else if head != nil { head.CommissionRate = commissionRate } if err == nil { // Update old record head.StartDate = *startDate head.EndDate = endDate _, err := h.store.ProjectHead.UpdateSelectedFieldsByID(db, head.ID.String(), *head, "start_date", "end_date", "commission_rate", ) if err != nil { h.logger.Fields(logger.Fields{"head": *head}).Error(err, "failed to update project head") return nil, err } } else { // Create new record head = &model.ProjectHead{ ProjectID: model.MustGetUUIDFromString(projectID), EmployeeID: employeeID, CommissionRate: commissionRate, StartDate: *startDate, EndDate: endDate, Position: model.HeadPositionTechnicalLead, } if err := h.store.ProjectHead.Create(db, head); err != nil { h.logger.Fields(logger.Fields{"head": head}).Error(err, "failed to create project head") return nil, err } } return head, nil } // GetWorkUnits godoc // @Summary Get list work units of a project // @Description Get list work units of a project // @id getProjectWorkUnitList // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param status query WorkUnitStatus false "status" // @Success 200 {object} ListWorkUnitResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/work-units [get] func (h *handler) GetWorkUnits(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } input := request.GetListWorkUnitInput{ ProjectID: c.Param("id"), } if err := c.ShouldBindQuery(&input.Query); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input.Query, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "GetWorkUnits", "projectID": input.ProjectID, "query": input.Query, }) if err := input.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } p, err := h.store.Project.One(h.repo.DB(), input.ProjectID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, input, "")) return } l.Info("failed to check if project exists") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectWorkUnitsReadFullAccess) { _, ok := userInfo.Projects[p.ID] if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } } workUnits, err := h.store.WorkUnit.GetByProjectID(h.repo.DB(), input.ProjectID, model.WorkUnitStatus(input.Query.Status)) if err != nil { l.Error(err, "failed to get work units") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input.ProjectID, "")) return } c.JSON(http.StatusOK, view.CreateResponse(view.ToWorkUnitList(workUnits, input.ProjectID, p.Code), nil, nil, nil, "")) } // CreateWorkUnit godoc // @Summary Create work unit of a project // @Description Get work unit of a project // @id createProjectWorkUnit // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param body body CreateWorkUnitRequest true "Body" // @Success 200 {object} WorkUnitResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/work-units [post] func (h *handler) CreateWorkUnit(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } input := request.CreateWorkUnitInput{ ProjectID: c.Param("id"), } if err := c.ShouldBindJSON(&input.Body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "CreateWorkUnit", "input": input, }) if err := input.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } p, err := h.store.Project.One(h.repo.DB(), input.ProjectID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrProjectNotFound, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } // Has permission when have work unit create full-access and active in project if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectWorkUnitsCreateFullAccess) { _, ok := userInfo.Projects[p.ID] if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } leadMap := map[string]bool{} for _, v := range p.Heads { if v.IsLead() { leadMap[v.EmployeeID.String()] = true } } _, ok = leadMap[userInfo.UserID] if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrMemberIsNotProjectLead, nil, "")) return } } tx, done := h.repo.NewTransaction() workUnit := &model.WorkUnit{ Name: input.Body.Name, Type: model.WorkUnitType(input.Body.Type), Status: model.WorkUnitStatus(input.Body.Status), SourceURL: input.Body.URL, ProjectID: model.MustGetUUIDFromString(input.ProjectID), } if err := h.store.WorkUnit.Create(tx.DB(), workUnit); err != nil { l.Error(err, "failed to create new work unit") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } stacks, err := h.store.Stack.GetByIDs(tx.DB(), view.ToModelUUIDs(input.Body.Stacks)) if err != nil { l.Error(err, "failed to get stacks") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // create work unit stack for _, stack := range stacks { wuStack := model.WorkUnitStack{ StackID: stack.ID, WorkUnitID: workUnit.ID, } if err := h.store.WorkUnitStack.Create(tx.DB(), &wuStack); err != nil { l.Error(err, "failed to create new work unit stack") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } wuStack.Stack = *stack workUnit.WorkUnitStacks = append(workUnit.WorkUnitStacks, &wuStack) } employees, err := h.store.Employee.GetByIDs(tx.DB(), view.ToModelUUIDs(input.Body.Members)) if err != nil { l.Error(err, "failed to get employees") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // create work unit member for _, employee := range employees { pMember, err := h.store.ProjectMember.GetActiveMemberInProject(tx.DB(), input.ProjectID, employee.ID.String()) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrMemberIsNotActiveInProject, "member is not active in project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrMemberIsNotActiveInProject), input, "")) return } wuMember := model.WorkUnitMember{ Status: model.ProjectMemberStatusActive.String(), WorkUnitID: workUnit.ID, EmployeeID: employee.ID, ProjectID: model.MustGetUUIDFromString(input.ProjectID), StartDate: *pMember.StartDate, } if err := h.store.WorkUnitMember.Create(tx.DB(), &wuMember); err != nil { l.Error(err, "failed to create new work unit member") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } wuMember.Employee = *employee workUnit.WorkUnitMembers = append(workUnit.WorkUnitMembers, &wuMember) } c.JSON(http.StatusOK, view.CreateResponse(view.ToWorkUnit(workUnit, p.Code), nil, done(nil), nil, "")) } // UpdateWorkUnit godoc // @Summary Update work unit info // @Description Update work unit info // @id updateProjectWorkUnit // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param workUnitID path string true "Work Unit ID" // @Param Body body UpdateWorkUnitRequest true "Body" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/work-units/{workUnitID} [put] func (h *handler) UpdateWorkUnit(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } input := request.UpdateWorkUnitInput{ ProjectID: c.Param("id"), WorkUnitID: c.Param("workUnitID"), } if err := c.ShouldBindJSON(&input.Body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input.Body, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "UpdateWorkUnit", "input": input, }) if err := input.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } p, err := h.store.Project.One(h.repo.DB(), input.ProjectID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrProjectNotFound, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectWorkUnitsEditFullAccess) { _, ok := userInfo.Projects[p.ID] if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } leadMap := map[string]bool{} for _, v := range p.Heads { if v.IsLead() { leadMap[v.EmployeeID.String()] = true } } _, ok = leadMap[userInfo.UserID] if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrMemberIsNotProjectLead, nil, "")) return } } // Check Exitsences of elements in input status, err := h.checkExitsInUpdateWorkUnitInput(h.repo.DB(), input) if err != nil { l.Error(err, "err when checking the existence of elements in the input") c.JSON(status, view.CreateResponse[any](nil, nil, err, input.Body, "")) return } tx, done := h.repo.NewTransaction() workUnit := &model.WorkUnit{ Name: input.Body.Name, Type: model.WorkUnitType(input.Body.Type), SourceURL: input.Body.URL, ProjectID: model.MustGetUUIDFromString(input.ProjectID), } _, err = h.store.WorkUnit.UpdateSelectedFieldsByID(tx.DB(), input.WorkUnitID, *workUnit, "name", "type", "source_url", "project_id") if err != nil { l.Error(err, "failed to update work unit") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // Update work unit stack if err := h.updateWorkUnitStack(tx.DB(), input.WorkUnitID, view.ToModelUUIDs(input.Body.Stacks)); err != nil { l.Error(err, "failed to update work unit stack") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // Get all active members of work unit members, err := h.store.WorkUnitMember.All(tx.DB(), input.WorkUnitID) if err != nil { l.Error(err, "failed to get all work unit members in database") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } var curMemberIDs []model.UUID for _, v := range members { curMemberIDs = append(curMemberIDs, v.EmployeeID) } // Get map for employee in work unit member inputMemberIDs := map[model.UUID]string{} for _, member := range input.Body.Members { inputMemberIDs[model.UUID(member)] = member.String() } // Get delete member id list var deleteMemberIDs []string for _, v := range curMemberIDs { _, ok := inputMemberIDs[v] if !ok { deleteMemberIDs = append(deleteMemberIDs, v.String()) } else { delete(inputMemberIDs, v) } } // Get create member id list var createMemberIDs []model.UUID for id := range inputMemberIDs { createMemberIDs = append(createMemberIDs, id) } // Delete work unit members if status, err = h.deleteWorkUnit(tx.DB(), input.WorkUnitID, deleteMemberIDs); err != nil { l.Error(err, "failed to remove work unit member in database") c.JSON(status, view.CreateResponse[any](nil, nil, done(err), input, "")) return } // Create new work unit member if status, err := h.createWorkUnit(tx.DB(), input.ProjectID, input.WorkUnitID, createMemberIDs); err != nil { l.Error(err, "failed to create new work unit member") c.JSON(status, view.CreateResponse[any](nil, nil, done(err), input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } func (h *handler) checkExitsInUpdateWorkUnitInput(db *gorm.DB, input request.UpdateWorkUnitInput) (int, error) { // Check project existence exists, err := h.store.Project.IsExist(db, input.ProjectID) if err != nil { return http.StatusInternalServerError, errs.ErrFailToCheckInputExistence } if !exists { return http.StatusNotFound, errs.ErrProjectNotFound } // Check work unit existence exists, err = h.store.WorkUnit.IsExists(h.repo.DB(), input.WorkUnitID) if err != nil { return http.StatusInternalServerError, errs.ErrFailToCheckInputExistence } if !exists { return http.StatusNotFound, errs.ErrProjectNotFound } // Check stack existence _, stacks, err := h.store.Stack.All(h.repo.DB(), "", nil) if err != nil { return http.StatusInternalServerError, errs.ErrFailToCheckInputExistence } stackMap := model.ToStackMap(stacks) for _, sID := range input.Body.Stacks { _, ok := stackMap[model.UUID(sID)] if !ok { return http.StatusNotFound, errs.ErrStackNotFoundWithID(sID.String()) } } return 0, nil } func (h *handler) updateWorkUnitStack(db *gorm.DB, workUnitID string, stackIDs []model.UUID) error { // Delete all exist work unit stack if err := h.store.WorkUnitStack.DeleteByWorkUnitID(db, workUnitID); err != nil { return errs.ErrFailToDeleteWorkUnitStack } // Create new work unit stack for _, stackID := range stackIDs { err := h.store.WorkUnitStack.Create(db, &model.WorkUnitStack{ WorkUnitID: model.MustGetUUIDFromString(workUnitID), StackID: stackID, }) if err != nil { return errs.ErrFailedToCreateWorkUnitStack } } return nil } func (h *handler) deleteWorkUnit(db *gorm.DB, workUnitID string, deleteMemberIDList []string) (int, error) { now := time.Now() for _, deleteMemberID := range deleteMemberIDList { workUnitMember, err := h.store.WorkUnitMember.One(db, workUnitID, deleteMemberID, model.WorkUnitMemberStatusActive.String()) if errors.Is(err, gorm.ErrRecordNotFound) { return http.StatusNotFound, errs.ErrInvalidInActiveMember } if err != nil { return http.StatusInternalServerError, errs.ErrFailedToGetWorkUnitMember } deleteMember := &model.WorkUnitMember{ Status: model.WorkUnitMemberStatusInactive.String(), EndDate: &now, } if _, err = h.store.WorkUnitMember.UpdateSelectedFieldsByID(db, workUnitMember.ID.String(), *deleteMember, "status", "end_date"); err != nil { return http.StatusInternalServerError, errs.ErrFailedToUpdateWorkUnitMember } if err = h.store.WorkUnitMember.SoftDeleteByWorkUnitID(db, workUnitMember.ID.String(), deleteMemberID); err != nil { return http.StatusInternalServerError, errs.ErrFailedToSoftDeleteWorkUnitMember } } return 0, nil } func (h *handler) createWorkUnit(db *gorm.DB, projectID string, workUnitID string, createMemberIDList []model.UUID) (int, error) { for _, createMemberID := range createMemberIDList { _, err := h.store.ProjectMember.GetActiveMemberInProject(db, projectID, createMemberID.String()) if errors.Is(err, gorm.ErrRecordNotFound) { return http.StatusBadRequest, errs.ErrMemberIsInactive } if err != nil { return http.StatusInternalServerError, errs.ErrFailedToGetProjectMember } now := time.Now() wuMember := model.WorkUnitMember{ Status: model.ProjectMemberStatusActive.String(), WorkUnitID: model.MustGetUUIDFromString(workUnitID), EmployeeID: createMemberID, ProjectID: model.MustGetUUIDFromString(projectID), StartDate: now, } if err := h.store.WorkUnitMember.Create(db, &wuMember); err != nil { return http.StatusInternalServerError, errs.ErrFailedToCreateWorkUnitMember } } return 0, nil } // ArchiveWorkUnit godoc // @Summary Archive an active work unit of a project // @Description Archive an active work unit of a project // @id archiveProjectWorkUnit // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param workUnitID path string true "Work Unit ID" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/work-units/{workUnitID}/archive [put] func (h *handler) ArchiveWorkUnit(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } input := request.ArchiveWorkUnitInput{ ProjectID: c.Param("id"), WorkUnitID: c.Param("workUnitID"), } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "ArchiveWorkUnit", "input": input, }) if err := input.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } p, err := h.store.Project.One(h.repo.DB(), input.ProjectID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrProjectNotFound, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectWorkUnitsEditFullAccess) { _, ok := userInfo.Projects[p.ID] if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } leadMap := map[string]bool{} for _, v := range p.Heads { if v.IsLead() { leadMap[v.EmployeeID.String()] = true } } _, ok = leadMap[userInfo.UserID] if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrMemberIsNotProjectLead, nil, "")) return } } workUnit, err := h.store.WorkUnit.One(h.repo.DB(), input.WorkUnitID) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "work unit not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrWorkUnitNotFound, nil, "")) return } if err != nil { l.Error(err, "failed to get one work unit") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } tx, done := h.repo.NewTransaction() workUnit.Status = model.WorkUnitStatusArchived // update work unit status -> 'archived' _, err = h.store.WorkUnit.UpdateSelectedFieldsByID(tx.DB(), input.WorkUnitID, *workUnit, "status") if err != nil { l.Error(err, "failed to update work unit") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } wuMembers, err := h.store.WorkUnitMember.GetByWorkUnitID(tx.DB(), input.WorkUnitID) if err != nil { l.Error(err, "failed to get work unit members") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } // update work unit member: end_date = now() and status = 'inactive' timeNow := time.Now() for _, member := range wuMembers { member.EndDate = &timeNow member.Status = model.ProjectMemberStatusInactive.String() _, err := h.store.WorkUnitMember.UpdateSelectedFieldsByID(tx.DB(), member.ID.String(), *member, "end_date", "status") if err != nil { l.Error(err, "failed to get work unit members") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } // UnarchiveWorkUnit godoc // @Summary Unarchive an archive work unit of a project // @Description Unarchive an archive work unit of a project // @id unarchiveProjectWorkUnit // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param workUnitID path string true "Work Unit ID" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/work-units/{workUnitID}/unarchive [put] func (h *handler) UnarchiveWorkUnit(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } input := request.ArchiveWorkUnitInput{ ProjectID: c.Param("id"), WorkUnitID: c.Param("workUnitID"), } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "UnarchiveWorkUnit", "input": input, }) if err := input.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } p, err := h.store.Project.One(h.repo.DB(), input.ProjectID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrProjectNotFound, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectWorkUnitsEditFullAccess) { _, ok := userInfo.Projects[p.ID] if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } leadMap := map[string]bool{} for _, v := range p.Heads { if v.IsLead() { leadMap[v.EmployeeID.String()] = true } } _, ok = leadMap[userInfo.UserID] if !ok || !model.IsUserActiveInProject(userInfo.UserID, p.ProjectMembers) { c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrMemberIsNotProjectLead, nil, "")) return } } workUnit, err := h.store.WorkUnit.One(h.repo.DB(), input.WorkUnitID) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "work unit not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrWorkUnitNotFound, nil, "")) return } if err != nil { l.Error(err, "failed to get one work unit") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } tx, done := h.repo.NewTransaction() workUnit.Status = model.WorkUnitStatusActive // update work unit status -> 'active' _, err = h.store.WorkUnit.UpdateSelectedFieldsByID(tx.DB(), input.WorkUnitID, *workUnit, "status") if err != nil { l.Error(err, "failed to update work unit") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } wuMembers, err := h.store.WorkUnitMember.GetByWorkUnitID(tx.DB(), input.WorkUnitID) if err != nil { l.Error(err, "failed to get work unit members") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } // check member status in project and update work unit member for _, member := range wuMembers { // _, err := h.store.ProjectMember.GetActiveMemberInProject(tx.DB(), input.ProjectID, member.EmployeeID.String(), false) // if errors.Is(err, gorm.ErrRecordNotFound) { // l.Error(err, "member is not active in project") // c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrMemberIsInactive), nil, "")) // return // } // if err != nil { // l.Error(err, "failed to get one project member") // c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) // return // } member.EndDate = nil member.Status = model.ProjectMemberStatusActive.String() _, err = h.store.WorkUnitMember.UpdateSelectedFieldsByID(tx.DB(), member.ID.String(), *member, "end_date", "status") if err != nil { l.Error(err, "failed to get work unit members") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } // UpdateSendingSurveyState godoc // @Summary Update allows sending survey for project by id // @Description Update allows sending survey for project by id // @id updateProjectSendingSurveyState // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Param allowsSendingSurvey query bool false "Allows sending survey" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/sending-survey-state [put] func (h *handler) UpdateSendingSurveyState(c *gin.Context) { projectID := c.Param("id") if projectID == "" || !model.IsUUIDFromString(projectID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } query := request.UpdateSendingSurveyInput{} if err := c.ShouldBindQuery(&query); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, query, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "UpdateSendingSurveyState", "query": query, }) p, err := h.store.Project.One(h.repo.DB(), projectID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, projectID, "")) return } l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, projectID, "")) return } p.AllowsSendingSurvey = query.AllowsSendingSurvey _, err = h.store.Project.UpdateSelectedFieldsByID(h.repo.DB(), projectID, *p, "allows_sending_survey") if err != nil { l.Error(err, "failed to update project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, query, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // UploadAvatar godoc // @Summary Upload avatar of project by id // @Description Upload avatar of project by id // @id uploadProjectAvatar // @Tags Project // @Accept json // @Produce json // @Param id path string true "Project ID" // @Security BearerAuth // @Param file formData file true "avatar upload" // @Success 200 {object} ProjectContentDataResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/upload-avatar [post] func (h *handler) UploadAvatar(c *gin.Context) { // 1.1 parse id from uri, validate id var params struct { ID string `uri:"id" binding:"required"` } if err := c.ShouldBindUri(&params); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, params, "")) return } // 1.2 get upload file file, err := c.FormFile("file") if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, file, "")) return } // 1.3 prepare the logger l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "UploadAvatar", "params": params, // "body": body, }) fileName := file.Filename fileExtension := model.ContentExtension(filepath.Ext(fileName)) fileSize := file.Size filePath := fmt.Sprintf("https://storage.googleapis.com/%s/projects/%s/images/%s", h.config.Google.GCSBucketName, params.ID, fileName) gcsPath := fmt.Sprintf("projects/%s/images/%s", params.ID, fileName) // 2.1 validate if !fileExtension.ImageValid() { l.Info("invalid file extension") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileExtension, nil, "")) return } if fileExtension == model.ContentExtensionJpg || fileExtension == model.ContentExtensionPng { if fileSize > model.MaxFileSizeImage { l.Info("invalid file size") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrInvalidFileSize, nil, "")) return } } tx, done := h.repo.NewTransaction() // 2.2 check project existed existed, err := h.store.Project.IsExist(tx.DB(), params.ID) if err != nil { l.Error(err, "error query project from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } if !existed { l.Info("project not existed") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrProjectNotExisted), nil, "")) return } // 2.3 upload to GCS multipart, err := file.Open() if err != nil { l.Error(err, "error in open file") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } err = h.service.GoogleStorage.UploadContentGCS(multipart, gcsPath) if err != nil { l.Error(err, "error in upload file") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } // 3. update avatar field _, err = h.store.Project.UpdateSelectedFieldsByID(tx.DB(), params.ID, model.Project{ Avatar: filePath, }, "avatar") if err != nil { l.Error(err, "error in update avatar") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToProjectContentData(filePath), nil, done(nil), nil, "")) } // SyncProjectMemberStatus godoc // @Summary Sync project member status // @Description Sync project member status // @id syncProjectMemberStatus // @Tags Project // @Accept json // @Produce json // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /cron-jobs/sync-project-member-status [post] func (h *handler) SyncProjectMemberStatus(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "SyncProjectMemberStatus", }) err := h.store.ProjectMember.UpdateEndDateOverdueMemberToInActive(h.repo.DB()) if err != nil { l.Error(err, "failed to update end date overdue member status to inactive") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } err = h.store.ProjectMember.UpdateMemberInClosedProjectToInActive(h.repo.DB()) if err != nil { l.Error(err, "failed to update member in closed/paused project status to inactive") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } err = h.store.ProjectMember.UpdateLeftMemberToInActive(h.repo.DB()) if err != nil { l.Error(err, "failed to update left member project status to inactive") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) } // CommissionModels godoc // @Summary Get commission models of a project // @Description Get commission models of a project // @id getProjectCommissionModels // @Tags Project // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Project ID" // @Success 200 {object} ProjectCommissionModelsResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /projects/{id}/commission-models [get] func (h *handler) CommissionModels(c *gin.Context) { // 0. Get current logged in user data userInfo, err := authutils.GetLoggedInUserInfo(c, h.store, h.repo.DB(), h.config) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, userInfo.UserID, "")) return } projectID := c.Param("id") if projectID == "" { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidProjectID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "project", "method": "CommissionModels", "id": projectID, }) projectData, err := h.store.Project.One(h.repo.DB(), projectID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } l.Error(err, "error query project from db") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } projectCommissionModel, err := h.aggregateCommissionModel(projectData) if err != nil { l.Error(err, "failed to aggregate commission model") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse(view.ToCommissionModelData(projectCommissionModel), nil, nil, nil, "")) }
```

# pkg/handler/project/request/request.go

```go
package request import ( "regexp" "time" "github.com/dwarvesf/fortress-api/pkg/utils" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/dwarvesf/fortress-api/pkg/handler/project/errs" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/shopspring/decimal" ) const emailRegex = ".+@.+\\..+" type GetListProjectInput struct { view.Pagination Name string `form:"name" json:"name"` Status []string `form:"status" json:"status"` Type []string `form:"type" json:"type"` } // @name GetListProjectInput type UpdateProjectGeneralInfoRequest struct { Name string `form:"name" json:"name" binding:"required"` StartDate string `form:"startDate" json:"startDate"` CountryID view.UUID `form:"countryID" json:"countryID" binding:"required"` Function string `form:"function" json:"function" binding:"required"` AuditNotionID view.UUID `form:"auditNotionID" json:"auditNotionID"` Stacks []view.UUID `form:"stacks" json:"stacks"` BankAccountID view.UUID `form:"bankAccountID" json:"bankAccountID"` ClientID view.UUID `form:"clientID" json:"clientID"` CompanyInfoID view.UUID `form:"companyInfoID" json:"companyInfoID"` OrganizationID view.UUID `form:"organizationID" json:"organizationID"` AccountRating int `form:"accountRating" json:"accountRating" binding:"required,min=1,max=5"` DeliveryRating int `form:"deliveryRating" json:"deliveryRating" binding:"required,min=1,max=5"` LeadRating int `form:"leadRating" json:"leadRating" binding:"required,min=1,max=5"` ImportantLevel string `form:"importantLevel" json:"importantLevel" binding:"required"` } // @name UpdateProjectGeneralInfoRequest func (i UpdateProjectGeneralInfoRequest) GetStartDate() *time.Time { startDate, err := time.Parse("2006-01-02", i.StartDate) if i.StartDate == "" || err != nil { return nil } return &startDate } func (i UpdateProjectGeneralInfoRequest) Validate() error { if !model.ProjectFunction(i.Function).IsValid() { return errs.ErrInvalidProjectFunction } if !model.ProjectImportantLevel(i.ImportantLevel).IsValid() { return errs.ErrInvalidProjectImportantLevel } return nil } type UpdateProjectStatusBody struct { ProjectStatus ProjectStatus `json:"status"` } // @name UpdateProjectStatusBody type ProjectStatus string // @name ProjectStatus const ( ProjectStatusOnBoarding ProjectStatus = "on-boarding" ProjectStatusActive ProjectStatus = "active" ProjectStatusPaused ProjectStatus = "paused" ProjectStatusClosed ProjectStatus = "closed" ) func (e ProjectStatus) IsValid() bool { switch e { case ProjectStatusOnBoarding, ProjectStatusActive, ProjectStatusPaused, ProjectStatusClosed: return true } return false } func (e ProjectStatus) String() string { return string(e) } func (i *GetListProjectInput) StandardizeInput() { statuses := utils.RemoveEmptyString(i.Status) pagination := model.Pagination{ Page: i.Page, Size: i.Size, Sort: i.Sort, } pagination.Standardize() i.Page = pagination.Page i.Size = pagination.Size i.Sort = pagination.Sort i.Status = statuses } func (i *GetListProjectInput) Validate() error { if len(i.Type) > 0 { for _, projectType := range i.Type { if utils.RemoveAllSpace(projectType) != "" && !model.ProjectType(projectType).IsValid() { return errs.ErrInvalidProjectType } } } if len(i.Status) > 0 { for _, status := range i.Status { if utils.RemoveAllSpace(status) != "" && !model.ProjectStatus(status).IsValid() { return errs.ErrInvalidProjectStatus } } } return nil } type CreateProjectRequest struct { Name string `form:"name" json:"name" binding:"required"` Status string `form:"status" json:"status" binding:"required"` Type string `form:"type" json:"type"` AccountManagers []ProjectHeadRequest `form:"accountManagers" json:"accountManagers"` DeliveryManagers []ProjectHeadRequest `form:"deliveryManagers" json:"deliveryManagers"` SalePersons []ProjectHeadRequest `form:"salePersons" json:"salePersons"` CountryID view.UUID `form:"countryID" json:"countryID" binding:"required"` StartDate string `form:"startDate" json:"startDate"` Members []AssignMemberRequest `form:"members" json:"members"` ClientEmail []string `form:"clientEmail" json:"clientEmail"` ProjectEmail string `form:"projectEmail" json:"projectEmail"` Code string `form:"code" json:"code"` Function string `form:"function" json:"function" binding:"required"` AuditNotionID view.UUID `form:"auditNotionID" json:"auditNotionID"` BankAccountID view.UUID `form:"bankAccountID" json:"bankAccountID"` ClientID view.UUID `form:"clientID" json:"clientID"` OrganizationID view.UUID `form:"organizationID" json:"organizationID"` } // @name CreateProjectRequest func (i *CreateProjectRequest) Validate() error { if i.Type == "" { i.Type = model.ProjectTypeDwarves.String() } if !model.ProjectType(i.Type).IsValid() { return errs.ErrInvalidProjectType } if !model.ProjectStatus(i.Status).IsValid() { return errs.ErrInvalidProjectStatus } _, err := time.Parse("2006-01-02", i.StartDate) if i.StartDate != "" && err != nil { return errs.ErrInvalidStartDate } for _, member := range i.Members { if err := member.Validate(); err != nil { return err } } regex, _ := regexp.Compile(emailRegex) for _, v := range i.ClientEmail { if !regex.MatchString(v) { return errs.ErrInvalidEmailDomainForClient } } if i.ProjectEmail != "" && !regex.MatchString(i.ProjectEmail) { return errs.ErrInvalidEmailDomainForProject } if !model.ProjectFunction(i.Function).IsValid() { return errs.ErrInvalidProjectFunction } if len(i.AccountManagers) == 0 { return errs.ErrAccountManagerRequired } return nil } func (i *CreateProjectRequest) GetStartDate() *time.Time { startDate, err := time.Parse("2006-01-02", i.StartDate) if i.StartDate == "" || err != nil { return nil } return &startDate } type GetListStaffInput struct { view.Pagination Status string `form:"status" json:"status"` Preload bool `json:"preload" form:"preload,default=true"` Distinct bool `json:"distinct" form:"distinct,default=false"` } func (i *GetListStaffInput) Validate() error { if i.Status != "" && !model.ProjectMemberStatus(i.Status).IsValid() { return errs.ErrInvalidProjectMemberStatus } return nil } type UpdateMemberRequest struct { ProjectSlotID view.UUID `from:"projectSlotID" json:"projectSlotID" binding:"required"` ProjectMemberID view.UUID `from:"projectMemberID" json:"projectMemberID"` EmployeeID view.UUID `form:"employeeID" json:"employeeID"` SeniorityID view.UUID `form:"seniorityID" json:"seniorityID" binding:"required"` UpsellPersonID view.UUID `form:"upsellPersonID" json:"upsellPersonID"` UpsellCommissionRate decimal.Decimal `form:"upsellCommissionRate" json:"upsellCommissionRate"` LeadCommissionRate decimal.Decimal `form:"leadCommissionRate" json:"leadCommissionRate"` Positions []view.UUID `form:"positions" json:"positions" binding:"required"` DeploymentType string `form:"deploymentType" json:"deploymentType" binding:"required"` Status string `form:"status" json:"status" binding:"required"` StartDate string `form:"startDate" json:"startDate"` EndDate string `form:"endDate" json:"endDate"` Rate decimal.Decimal `form:"rate" json:"rate" binding:"required"` Discount decimal.Decimal `form:"discount" json:"discount"` IsLead bool `form:"isLead" json:"isLead"` Note string `form:"note" json:"note"` } // @name UpdateMemberRequest func (i *UpdateMemberRequest) Validate() error { if i.DeploymentType != "" && !model.DeploymentType(i.DeploymentType).IsValid() { return errs.ErrInvalidDeploymentType } if i.Status != "" && !model.ProjectMemberStatus(i.Status).IsValid() { return errs.ErrInvalidProjectMemberStatus } _, err := time.Parse("2006-01-02", i.StartDate) if i.StartDate != "" && err != nil { return errs.ErrInvalidStartDate } _, err = time.Parse("2006-01-02", i.EndDate) if i.EndDate != "" && err != nil { return errs.ErrInvalidEndDate } if i.GetStartDate() != nil && i.GetEndDate() != nil && !i.GetStartDate().Before(*i.GetEndDate()) { return errs.ErrInvalidEndDate } if i.GetEndDate() != nil && i.GetEndDate().Before(time.Now()) { i.Status = model.ProjectMemberStatusInactive.String() } return nil } func (i *UpdateMemberRequest) GetStartDate() *time.Time { date, err := time.Parse("2006-01-02", i.StartDate) if i.StartDate == "" || err != nil { return nil } return &date } func (i *UpdateMemberRequest) GetEndDate() *time.Time { date, err := time.Parse("2006-01-02", i.EndDate) if i.EndDate == "" || err != nil { return nil } return &date } type AssignMemberRequest struct { EmployeeID view.UUID `form:"employeeID" json:"employeeID"` SeniorityID view.UUID `form:"seniorityID" json:"seniorityID" binding:"required"` Positions []view.UUID `form:"positions" json:"positions" binding:"required"` DeploymentType string `form:"deploymentType" json:"deploymentType" binding:"required"` Status string `form:"status" json:"status" binding:"required"` StartDate string `form:"startDate" json:"startDate"` EndDate string `form:"endDate" json:"endDate"` Rate decimal.Decimal `form:"rate" json:"rate" binding:"required"` Discount decimal.Decimal `form:"discount" json:"discount"` LeadCommissionRate decimal.Decimal `form:"leadCommissionRate" json:"leadCommissionRate"` IsLead bool `form:"isLead" json:"isLead"` UpsellPersonID view.UUID `form:"upsellPersonID" json:"upsellPersonID"` UpsellCommissionRate decimal.Decimal `form:"upsellCommissionRate" json:"upsellCommissionRate"` Note string `form:"note" json:"note"` } // @name AssignMemberRequest func (i *AssignMemberRequest) Validate() error { if i.DeploymentType == "" || !model.DeploymentType(i.DeploymentType).IsValid() { return errs.ErrInvalidDeploymentType } if i.Status == "" || !model.ProjectMemberStatus(i.Status).IsValid() || i.Status == model.ProjectMemberStatusInactive.String() { return errs.ErrInvalidProjectMemberStatus } if len(i.Positions) == 0 { return errs.ErrPositionsIsEmpty } _, err := time.Parse("2006-01-02", i.StartDate) if i.StartDate != "" && err != nil { return errs.ErrInvalidStartDate } _, err = time.Parse("2006-01-02", i.EndDate) if i.EndDate != "" && err != nil { return errs.ErrInvalidEndDate } if i.Status == model.ProjectMemberStatusPending.String() && !i.EmployeeID.IsZero() { i.Status = model.ProjectStatusActive.String() } return nil } func (i *AssignMemberRequest) GetStartDate() *time.Time { date, err := time.Parse("2006-01-02", i.StartDate) if i.StartDate == "" || err != nil { return nil } return &date } func (i *AssignMemberRequest) GetEndDate() *time.Time { date, err := time.Parse("2006-01-02", i.EndDate) if i.EndDate == "" || err != nil { return nil } return &date } func (i *AssignMemberRequest) GetStatus() model.ProjectMemberStatus { if i.EmployeeID.IsZero() { return model.ProjectMemberStatusPending } if !i.EmployeeID.IsZero() && i.Status == model.ProjectMemberStatusPending.String() { return model.ProjectMemberStatusActive } return model.ProjectMemberStatus(i.Status) } func (i *AssignMemberRequest) RestrictPermission(userInfo *model.CurrentLoggedUserInfo) { if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectsCommissionRateEdit) { i.LeadCommissionRate = decimal.Zero } if !authutils.HasPermission(userInfo.Permissions, model.PermissionProjectMembersRateEdit) { i.Rate = decimal.Zero i.Discount = decimal.Zero } } type DeleteMemberInput struct { ProjectID string MemberID string } func (input DeleteMemberInput) Validate() error { if input.ProjectID == "" { return errs.ErrInvalidProjectID } if input.MemberID == "" { return errs.ErrInvalidMemberID } return nil } type DeleteSlotInput struct { ProjectID string SlotID string } func (input DeleteSlotInput) Validate() error { if input.ProjectID == "" { return errs.ErrInvalidProjectID } if input.SlotID == "" { return errs.ErrInvalidSlotID } return nil } type ProjectHeadRequest struct { EmployeeID view.UUID `json:"employeeID" form:"employeeID"` CommissionRate decimal.Decimal `json:"commissionRate" form:"commissionRate"` } // @name ProjectHeadRequest type UpdateContactInfoRequest struct { ClientEmail []string `form:"clientEmail" json:"clientEmail"` ProjectEmail string `form:"projectEmail" json:"projectEmail"` AccountManagers []ProjectHeadRequest `form:"accountManagers" json:"accountManagers"` DeliveryManagers []ProjectHeadRequest `form:"deliveryManagers" json:"deliveryManagers"` SalePersons []ProjectHeadRequest `form:"salePersons" json:"salePersons"` } // @name UpdateContactInfoRequest func (i UpdateContactInfoRequest) Validate() error { regex, _ := regexp.Compile(emailRegex) for _, v := range i.ClientEmail { if !regex.MatchString(v) { return errs.ErrInvalidEmailDomainForClient } } if i.ProjectEmail != "" && !regex.MatchString(i.ProjectEmail) { return errs.ErrInvalidEmailDomainForProject } if len(i.AccountManagers) == 0 { return errs.ErrAccountManagerRequired } return nil } type UnassignMemberInput struct { ProjectID string MemberID string } func (input UnassignMemberInput) Validate() error { if input.ProjectID == "" || !model.IsUUIDFromString(input.ProjectID) { return errs.ErrInvalidProjectID } if input.MemberID == "" || !model.IsUUIDFromString(input.MemberID) { return errs.ErrInvalidMemberID } return nil } type CreateWorkUnitInput struct { ProjectID string Body CreateWorkUnitRequest } type CreateWorkUnitRequest struct { Name string `json:"name" form:"name" binding:"required"` Type string `json:"type" form:"type" binding:"required"` Status string `json:"status" form:"status" binding:"required"` Members []view.UUID `json:"members" form:"members"` Stacks []view.UUID `json:"stacks" form:"stacks" binding:"required"` URL string `json:"url" form:"url"` } // @name CreateWorkUnitRequest func (i *CreateWorkUnitInput) Validate() error { if i.ProjectID == "" || !model.IsUUIDFromString(i.ProjectID) { return errs.ErrInvalidProjectID } return i.Body.Validate() } func (i *CreateWorkUnitRequest) Validate() error { if i.Type == "" || !model.WorkUnitType(i.Type).IsValid() { return errs.ErrInvalidWorkUnitType } if i.Status == "" || !model.WorkUnitStatus(i.Status).IsValid() { return errs.ErrInvalidWorkUnitStatus } if len(i.Stacks) == 0 { return errs.ErrInvalidWorkUnitStacks } return nil } type UpdateWorkUnitInput struct { ProjectID string WorkUnitID string Body UpdateWorkUnitRequest } type UpdateWorkUnitRequest struct { Name string `form:"name" json:"name" binding:"required,max=100"` Type view.WorkUnitType `form:"type" json:"type" binding:"required"` Members []view.UUID `form:"members" json:"members"` Stacks []view.UUID `form:"stacks" json:"stacks" binding:"required"` URL string `form:"url" json:"url"` } // @name UpdateWorkUnitRequest func (i *UpdateWorkUnitInput) Validate() error { if i.ProjectID == "" || !model.IsUUIDFromString(i.ProjectID) { return errs.ErrInvalidProjectID } if i.WorkUnitID == "" || !model.IsUUIDFromString(i.WorkUnitID) { return errs.ErrInvalidWorkUnitID } return i.Body.Validate() } func (i *UpdateWorkUnitRequest) Validate() error { if !i.Type.IsValid() { return errs.ErrInvalidWorkUnitType } if len(i.Stacks) == 0 { return errs.ErrInvalidWorkUnitStacks } return nil } type ArchiveWorkUnitInput struct { ProjectID string WorkUnitID string } func (i *ArchiveWorkUnitInput) Validate() error { if i.ProjectID == "" || !model.IsUUIDFromString(i.ProjectID) { return errs.ErrInvalidProjectID } if i.WorkUnitID == "" || !model.IsUUIDFromString(i.WorkUnitID) { return errs.ErrInvalidWorkUnitID } return nil } type GetListWorkUnitInput struct { ProjectID string Query GetListWorkUnitQuery } // @name GetListWorkUnitInput type GetListWorkUnitQuery struct { Status WorkUnitStatus `form:"status" json:"status"` } // @name GetListWorkUnitQuery type WorkUnitStatus string // @name WorkUnitStatus const ( WorkUnitStatusActive WorkUnitStatus = "active" WorkUnitStatusArchived WorkUnitStatus = "archived" ) func (e WorkUnitStatus) IsValid() bool { switch e { case WorkUnitStatusActive, WorkUnitStatusArchived: return true } return false } func (e WorkUnitStatus) String() string { return string(e) } func (i GetListWorkUnitInput) Validate() error { if i.ProjectID == "" || !model.IsUUIDFromString(i.ProjectID) { return errs.ErrInvalidProjectID } return i.Query.Validate() } func (i GetListWorkUnitQuery) Validate() error { if i.Status != "" && !i.Status.IsValid() { return errs.ErrInvalidWorkUnitStatus } return nil } type UpdateSendingSurveyInput struct { AllowsSendingSurvey bool `form:"allowsSendingSurvey" json:"allowsSendingSurvey"` }
```

# pkg/handler/survey/errs/errors.go

```go
package errs import ( "errors" "fmt" ) var ( // record not found errors ErrEventNotFound = errors.New("event not found") ErrProjectNotFound = errors.New("project not found") ErrTopicNotFound = errors.New("topic not found") ErrEmployeeNotFound = errors.New("employee not found") ErrEventReviewerNotFound = errors.New("employee event reviewer not found") // invalid errors ErrInvalidEventID = errors.New("invalid event id") ErrInvalidEventType = errors.New("invalid event type") ErrInvalidReviewerID = errors.New("invalid reviewer id") ErrInvalidFeedbackID = errors.New("invalid feedback id") ErrInvalidTopicID = errors.New("invalid topic id") ErrInvalidEventSubType = errors.New("invalid event subtype") ErrInvalidQuarter = errors.New("invalid quarter") ErrInvalidYear = errors.New("invalid year") ErrInvalidDate = errors.New("invalid date") ErrInvalidDateRange = errors.New("invalid date range") // other errors ErrEventAlreadyExisted = errors.New("event already existed") ErrReviewAlreadySent = errors.New("review already sent") ErrEmployeeNotReady = errors.New("employee not ready") ErrCanNotUpdateParticipants = errors.New("can not update participants") ErrEventHasBeenDone = errors.New("event has been done") ErrNoValidProjectForEvent = errors.New("no valid project for event") ) func ErrEventQuestionNotFound(id string) error { return fmt.Errorf("employee event question not found: %v", id) }
```

# pkg/handler/survey/interface.go

```go
package survey import "github.com/gin-gonic/gin" type IHandler interface { ListSurvey(c *gin.Context) GetSurveyDetail(c *gin.Context) GetSurveyReviewDetail(c *gin.Context) SendSurvey(c *gin.Context) CreateSurvey(c *gin.Context) DeleteSurvey(c *gin.Context) DeleteSurveyTopic(c *gin.Context) GetSurveyTopicDetail(c *gin.Context) UpdateTopicReviewers(c *gin.Context) MarkDone(c *gin.Context) DeleteTopicReviewers(c *gin.Context) }
```

# pkg/handler/survey/request/request.go

```go
package request import ( "time" "github.com/dwarvesf/fortress-api/pkg/handler/survey/errs" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) type GetListSurveyInput struct { view.Pagination Subtype string `json:"subtype" form:"subtype" binding:"required"` } // @name GetListSurveyInput func (i *GetListSurveyInput) Validate() error { if i.Subtype == "" || !model.EventSubtype(i.Subtype).IsSurveyValid() { return errs.ErrInvalidEventType } return nil } type GetSurveyDetailQuery struct { view.Pagination Keyword string `json:"keyword" form:"keyword"` Status string `json:"status" form:"status"` Projects []string `json:"projects" form:"projects"` } // @name GetSurveyDetailQuery type GetSurveyDetailInput struct { EventID string Query GetSurveyDetailQuery } func (i *GetSurveyDetailInput) Validate() error { if i.EventID == "" || !model.IsUUIDFromString(i.EventID) { return errs.ErrInvalidEventID } var projects []string for _, p := range i.Query.Projects { if p != "" { projects = append(projects, p) } } i.Query.Projects = projects return nil } type SendSurveyInput struct { Type string `json:"type" form:"type" binding:"required"` TopicIDs []view.UUID `json:"topicIDs" form:"topicIDs"` } // @name SendSurveyInput // CreateSurveyFeedbackInput view for create survey feedback type CreateSurveyFeedbackInput struct { Quarter string `json:"quarter"` Year int `json:"year"` Type string `json:"type" binding:"required"` FromDate string `json:"fromDate"` ToDate string `json:"toDate"` } // @name CreateSurveyFeedbackInput // Validate input for create survey feedback func (i *CreateSurveyFeedbackInput) Validate() error { if !model.EventSubtype(i.Type).IsValidSurvey() { return errs.ErrInvalidEventSubType } if i.Type == model.EventSubtypeWork.String() { fromDate, err := time.Parse("2006-01-02", i.FromDate) if err != nil { return errs.ErrInvalidDate } toDate, err := time.Parse("2006-01-02", i.ToDate) if err != nil { return errs.ErrInvalidDate } if fromDate.After(toDate) { return errs.ErrInvalidDateRange } } return nil } type PeerReviewDetailInput struct { EventID string TopicID string } func (i *PeerReviewDetailInput) Validate() error { if i.EventID == "" || !model.IsUUIDFromString(i.EventID) { return errs.ErrInvalidFeedbackID } if i.TopicID == "" || !model.IsUUIDFromString(i.TopicID) { return errs.ErrInvalidTopicID } return nil } // UpdateTopicReviewersBody view for update topic reviewers type UpdateTopicReviewersBody struct { ReviewerIDs []view.UUID `json:"reviewerIDs"` } // @name UpdateTopicReviewersBody // UpdateTopicReviewersInput input of update topic reviewers request type UpdateTopicReviewersInput struct { EventID string TopicID string Body UpdateTopicReviewersBody } func (i *UpdateTopicReviewersInput) Validate() error { if i.EventID == "" || !model.IsUUIDFromString(i.EventID) { return errs.ErrInvalidEventID } if i.TopicID == "" || !model.IsUUIDFromString(i.TopicID) { return errs.ErrInvalidTopicID } return nil } // DeleteTopicReviewersBody view for update topic reviewers type DeleteTopicReviewersBody struct { ReviewerIDs []view.UUID `json:"reviewerIDs"` } // @name DeleteTopicReviewersBody // DeleteTopicReviewersInput input of update topic reviewers request type DeleteTopicReviewersInput struct { EventID string TopicID string Body DeleteTopicReviewersBody } func (i *DeleteTopicReviewersInput) Validate() error { if i.EventID == "" || !model.IsUUIDFromString(i.EventID) { return errs.ErrInvalidEventID } if i.TopicID == "" || !model.IsUUIDFromString(i.TopicID) { return errs.ErrInvalidTopicID } return nil }
```

# pkg/handler/survey/survey.go

```go
package survey import ( "errors" "fmt" "net/http" "strings" "time" "github.com/gin-gonic/gin" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/handler/survey/errs" "github.com/dwarvesf/fortress-api/pkg/handler/survey/request" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/store/employeeeventtopic" "github.com/dwarvesf/fortress-api/pkg/store/project" "github.com/dwarvesf/fortress-api/pkg/utils/authutils" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } // ListSurvey godoc // @Summary Get list event // @Description Get list event // @id ListSurvey // @Tags Survey // @Accept json // @Produce json // @Security BearerAuth // @Param subtype query string true "Event Subtype" // @Param page query string false "Page" // @Param size query string false "Size" // @Param sort query string false "Sort" // @Param subtype query string true "Event Subtype" // @Success 200 {object} ListSurveyResponse // @Failure 400 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys [get] func (h *handler) ListSurvey(c *gin.Context) { input := request.GetListSurveyInput{} if err := c.ShouldBindQuery(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } pagination := model.Pagination{ Page: input.Page, Size: input.Size, Sort: input.Sort, } pagination.Standardize() l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "ListSurvey", "input": pagination, }) events, total, err := h.store.FeedbackEvent.GetBySubtype(h.repo.DB(), input.Subtype, pagination) if err != nil { l.Error(err, "failed to get feedback events by subtype") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // count likert-scale question by event and projects if input.Subtype == model.EventSubtypeWork.String() { for i := range events { counts, err := h.getQuestionDomainCountsByEvent(h.repo.DB(), events[i].ID.String()) if err != nil { l.AddField("eventID", events[i].ID).Error(err, "failed to get QuestionDomainCounts by event") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } events[i].QuestionDomainCounts = counts } } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToListSurvey(events), &view.PaginationResponse{Pagination: view.Pagination{Size: pagination.Size, Page: pagination.Page, Sort: pagination.Sort}, Total: total}, nil, nil, "")) } func (h *handler) getQuestionDomainCountsByEvent(db *gorm.DB, eventID string) ([]model.QuestionDomainCount, error) { l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "GetQuestionDomainCountByEvent", "eventID": eventID, }) // count likert-scale questions wlCount, err := h.store.EmployeeEventQuestion. CountLikertScaleByEventIDAndDomain(h.repo.DB(), eventID, model.QuestionDomainWorkload.String()) if err != nil { l.Error(err, "failed to count workload questions by eventID and domain") return nil, err } dlCount, err := h.store.EmployeeEventQuestion. CountLikertScaleByEventIDAndDomain(h.repo.DB(), eventID, model.QuestionDomainDeadline.String()) if err != nil { l.Error(err, "failed to count deadline questions by eventID and domain") return nil, err } lnCount, err := h.store.EmployeeEventQuestion. CountLikertScaleByEventIDAndDomain(h.repo.DB(), eventID, model.QuestionDomainLearning.String()) if err != nil { l.Error(err, "failed to count learning questions by eventID and domain") return nil, err } counts := []model.QuestionDomainCount{ { Domain: model.QuestionDomainWorkload, LikertScaleCount: *wlCount, }, { Domain: model.QuestionDomainDeadline, LikertScaleCount: *dlCount, }, { Domain: model.QuestionDomainLearning, LikertScaleCount: *lnCount, }, } return counts, nil } // GetSurveyDetail godoc // @Summary Get survey detail // @Description Get survey detail // @id GetSurveyDetail // @Tags Survey // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Feedback Event ID" // @Param page query string false "Page" // @Param size query string false "Size" // @Param keyword query string false "Keyword" // @Param status query string false "Status" // @Param projects query []string false "Projects" // @Success 200 {object} ListSurveyDetailResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys/{id} [get] func (h *handler) GetSurveyDetail(c *gin.Context) { input := request.GetSurveyDetailInput{ EventID: c.Param("id"), } if err := c.ShouldBindQuery(&input.Query); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } pagination := model.Pagination{ Page: input.Query.Page, Size: input.Query.Size, Sort: input.Query.Sort, } pagination.Standardize() l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "GetSurveyDetail", "input": input, }) // check feedback event existence event, err := h.store.FeedbackEvent.One(h.repo.DB(), input.EventID, true) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(err, "event not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEventNotFound, input, "")) return } if err != nil { l.Error(err, "failed to get feedback event") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } topics, total, err := h.store.EmployeeEventTopic.All(h.repo.DB(), employeeeventtopic.GetByEventIDInput{ EventID: input.EventID, Keyword: input.Query.Keyword, Status: input.Query.Status, Projects: input.Query.Projects, Preload: true, Paging: true, }, &pagination) if err != nil { l.Error(err, "failed to get employee event topic by eventID") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } event.Topics = topics c.JSON(http.StatusOK, view.CreateResponse[any](view.ToSurveyDetail(event), &view.PaginationResponse{Pagination: view.Pagination{Size: pagination.Size, Page: pagination.Page, Sort: pagination.Sort}, Total: total}, nil, nil, "")) } // CreateSurvey godoc // @Summary Create new survey // @Description Create new survey // @id CreateSurvey // @Tags Survey // @Accept json // @Produce json // @Param Body body request.CreateSurveyFeedbackInput true "Body" // @Security BearerAuth // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys [post] func (h *handler) CreateSurvey(c *gin.Context) { // 1. parse request userID, err := authutils.GetUserIDFromContext(c, h.config) if err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } var req request.CreateSurveyFeedbackInput if err := c.ShouldBindJSON(&req); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "CreateSurvey", "input": req, }) if err := req.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, "")) return } tx, done := h.repo.NewTransaction() switch model.EventSubtype(req.Type) { case model.EventSubtypePeerReview: status, err := h.createPeerReview(tx.DB(), req, userID) if err != nil { l.Error(err, "failed to create new survey peer review") c.JSON(status, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } case model.EventSubtypeEngagement: status, err := h.createEngagement(tx.DB(), req, userID) if err != nil { l.Error(err, "failed to create new survey engagement") c.JSON(status, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } case model.EventSubtypeWork: status, err := h.createWorkEvent(tx.DB(), req, userID) if err != nil { l.Error(err, "failed to create new survey work") c.JSON(status, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } func (h *handler) createPeerReview(db *gorm.DB, req request.CreateSurveyFeedbackInput, userID string) (int, error) { //1. convert data var startTime, endTime time.Time var title string if req.Year < time.Now().Year()-1 { return http.StatusBadRequest, errs.ErrInvalidYear } switch strings.ToLower(strings.ReplaceAll(req.Quarter, " ", "")) { case "q1,q2": startTime = time.Date(req.Year, 1, 1, 0, 0, 0, 0, time.UTC) endTime = time.Date(req.Year, 6, 30, 23, 59, 59, 59, time.UTC) title = fmt.Sprintf("Q1/Q2, %d", req.Year) case "q3,q4": startTime = time.Date(req.Year, 7, 1, 0, 0, 0, 0, time.UTC) endTime = time.Date(req.Year, 12, 31, 23, 59, 59, 59, time.UTC) title = fmt.Sprintf("Q3/Q4, %d", req.Year) default: return http.StatusBadRequest, errs.ErrInvalidQuarter } //1.2 check event existed _, err := h.store.FeedbackEvent.OneByTypeInTimeRange(db, model.EventTypeSurvey, model.EventSubtypePeerReview, &startTime, &endTime) if err == nil { return http.StatusBadRequest, errs.ErrEventAlreadyExisted } else { if !errors.Is(err, gorm.ErrRecordNotFound) { return http.StatusInternalServerError, err } } //1.3 check employee existed createdBy, err := h.store.Employee.One(db, userID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return http.StatusNotFound, errs.ErrEmployeeNotFound } return http.StatusInternalServerError, err } //2. Create FeedbackEvent event, err := h.store.FeedbackEvent.Create(db, &model.FeedbackEvent{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, Title: title, Type: model.EventTypeSurvey, Subtype: model.EventSubtype(req.Type), Status: model.EventStatusDraft, CreatedBy: createdBy.ID, StartDate: &startTime, EndDate: &endTime, }) if err != nil { return http.StatusInternalServerError, err } //3. create EmployeeEventTopic employees, err := h.store.Employee.GetByWorkingStatus(db, model.WorkingStatusFullTime) if err != nil { return http.StatusInternalServerError, err } eets := make([]model.EmployeeEventTopic, 0) for _, e := range employees { isDwarves := false for _, o := range e.Organizations { if o.Code == model.OrganizationCodeDwarves { isDwarves = true break } } if isDwarves { topicTitle := fmt.Sprintf("Peer Performance Review: %s - %s", e.DisplayName, title) eets = append(eets, model.EmployeeEventTopic{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, Title: topicTitle, EventID: event.ID, EmployeeID: e.ID, Employee: e, }) } } i := 0 for i < len(eets) { to := i + 100 if to > len(eets) { to = len(eets) } _, err = h.store.EmployeeEventTopic.BatchCreate(db, eets[i:to]) if err != nil { return http.StatusInternalServerError, err } i = to } //4. create EmployeeEventReviewer employeeEventMapper := make(map[model.UUID]model.UUID) for _, e := range eets { employeeEventMapper[e.EmployeeID] = e.ID } reviewers := make([]model.EmployeeEventReviewer, 0) //TODO: will reused this function later // peers, err := h.store.WorkUnitMember.GetPeerReviewerInTimeRange(db, &startTime, &endTime) // if err != nil { // return http.StatusInternalServerError, err // } peers, err := h.store.WorkUnitMember.GetActivePeerReviewer(db) if err != nil { return http.StatusInternalServerError, err } reviewerMap := make(map[model.UUID]model.UUID) for _, p := range peers { canReview := false for _, e := range eets { if e.EmployeeID == p.EmployeeID { canReview = true break } } if canReview && !p.ReviewerID.IsZero() { reviewerMap[p.ReviewerID] = p.EmployeeID reviewers = append(reviewers, model.EmployeeEventReviewer{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, EventID: event.ID, EmployeeEventTopicID: employeeEventMapper[p.EmployeeID], ReviewerID: p.ReviewerID, Relationship: model.RelationshipPeer, AuthorStatus: model.EventAuthorStatusDraft, ReviewerStatus: model.EventReviewerStatusNone, IsShared: false, IsRead: false, }) } } for _, e := range eets { if !e.Employee.LineManagerID.IsZero() { _, ok := reviewerMap[e.Employee.LineManagerID] if ok { continue } reviewers = append(reviewers, model.EmployeeEventReviewer{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, EventID: event.ID, EmployeeEventTopicID: e.ID, ReviewerID: e.Employee.LineManagerID, Relationship: model.RelationshipLineManager, AuthorStatus: model.EventAuthorStatusDraft, ReviewerStatus: model.EventReviewerStatusNone, IsShared: false, IsRead: false, }) } } i = 0 for i < len(reviewers) { to := i + 100 if to > len(reviewers) { to = len(reviewers) } _, err = h.store.EmployeeEventReviewer.BatchCreate(db, reviewers[i:to]) if err != nil { return http.StatusInternalServerError, err } i = to } //4. create EmployeeEventQuestion questions, err := h.store.Question.AllByCategory(db, model.EventTypeSurvey, model.EventSubtypePeerReview) if err != nil { return http.StatusInternalServerError, err } eventQuestions := make([]model.EmployeeEventQuestion, 0) for _, r := range reviewers { for _, q := range questions { eventQuestions = append(eventQuestions, model.EmployeeEventQuestion{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, EmployeeEventReviewerID: r.ID, QuestionID: q.ID, EventID: r.EventID, Content: q.Content, Type: q.Type.String(), Order: q.Order, Domain: q.Domain, }) } } i = 0 for i < len(eventQuestions) { to := i + 100 if to > len(eventQuestions) { to = len(eventQuestions) } _, err = h.store.EmployeeEventQuestion.BatchCreate(db, eventQuestions[i:to]) if err != nil { return http.StatusInternalServerError, err } i = to } return http.StatusOK, nil } func (h *handler) createEngagement(db *gorm.DB, req request.CreateSurveyFeedbackInput, userID string) (int, error) { //1. convert data var startTime, endTime time.Time var title string if req.Year < time.Now().Year()-1 { return http.StatusBadRequest, errs.ErrInvalidYear } switch strings.ToLower(strings.ReplaceAll(req.Quarter, " ", "")) { case "q1": startTime = time.Date(req.Year, 1, 1, 0, 0, 0, 0, time.UTC) endTime = time.Date(req.Year, 3, 31, 23, 59, 59, 59, time.UTC) title = fmt.Sprintf("Q1, %d", req.Year) case "q2": startTime = time.Date(req.Year, 4, 1, 0, 0, 0, 0, time.UTC) endTime = time.Date(req.Year, 6, 30, 23, 59, 59, 59, time.UTC) title = fmt.Sprintf("Q2, %d", req.Year) case "q3": startTime = time.Date(req.Year, 7, 1, 0, 0, 0, 0, time.UTC) endTime = time.Date(req.Year, 9, 30, 23, 59, 59, 59, time.UTC) title = fmt.Sprintf("Q3, %d", req.Year) case "q4": startTime = time.Date(req.Year, 10, 1, 0, 0, 0, 0, time.UTC) endTime = time.Date(req.Year, 12, 31, 23, 59, 59, 59, time.UTC) title = fmt.Sprintf("Q4, %d", req.Year) default: return http.StatusBadRequest, errs.ErrInvalidQuarter } //1.2 check event existed _, err := h.store.FeedbackEvent.OneByTypeInTimeRange(db, model.EventTypeSurvey, model.EventSubtypeEngagement, &startTime, &endTime) if err == nil { return http.StatusBadRequest, errs.ErrEventAlreadyExisted } else { if !errors.Is(err, gorm.ErrRecordNotFound) { return http.StatusInternalServerError, err } } //1.3 check employee existed createdBy, err := h.store.Employee.One(db, userID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return http.StatusNotFound, errs.ErrEmployeeNotFound } return http.StatusInternalServerError, err } //2. Create FeedbackEvent event, err := h.store.FeedbackEvent.Create(db, &model.FeedbackEvent{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, Title: title, Type: model.EventTypeSurvey, Subtype: model.EventSubtype(req.Type), Status: model.EventStatusDraft, CreatedBy: createdBy.ID, StartDate: &startTime, EndDate: &endTime, }) if err != nil { return http.StatusInternalServerError, err } //3. create EmployeeEventTopic employees, err := h.store.Employee.GetByWorkingStatus(db, model.WorkingStatusFullTime) if err != nil { return http.StatusInternalServerError, err } eets := make([]model.EmployeeEventTopic, 0) for _, e := range employees { isDwarves := false for _, o := range e.Organizations { if o.Code == model.OrganizationCodeDwarves { isDwarves = true break } } if isDwarves { topicTitle := fmt.Sprintf("Engagement Survey: %s - %s", e.DisplayName, title) eets = append(eets, model.EmployeeEventTopic{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, Title: topicTitle, EventID: event.ID, EmployeeID: e.ID, }) } } i := 0 for i < len(eets) { to := i + 100 if to > len(eets) { to = len(eets) } _, err = h.store.EmployeeEventTopic.BatchCreate(db, eets[i:to]) if err != nil { return http.StatusInternalServerError, err } i = to } //4. create EmployeeEventReviewer employeeEventMapper := make(map[model.UUID]model.UUID) for _, e := range eets { employeeEventMapper[e.EmployeeID] = e.ID } reviewers := make([]model.EmployeeEventReviewer, 0) for _, e := range eets { reviewers = append(reviewers, model.EmployeeEventReviewer{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, EventID: event.ID, EmployeeEventTopicID: e.ID, ReviewerID: e.EmployeeID, Relationship: model.RelationshipSelf, AuthorStatus: model.EventAuthorStatusDraft, ReviewerStatus: model.EventReviewerStatusNone, IsShared: false, IsRead: false, }) } i = 0 for i < len(reviewers) { to := i + 100 if to > len(reviewers) { to = len(reviewers) } _, err = h.store.EmployeeEventReviewer.BatchCreate(db, reviewers[i:to]) if err != nil { return http.StatusInternalServerError, err } i = to } //5. create EmployeeEventQuestion questions, err := h.store.Question.AllByCategory(db, model.EventTypeSurvey, model.EventSubtypeEngagement) if err != nil { return http.StatusInternalServerError, err } eventQuestions := make([]model.EmployeeEventQuestion, 0) for _, r := range reviewers { for _, q := range questions { eventQuestions = append(eventQuestions, model.EmployeeEventQuestion{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, EmployeeEventReviewerID: r.ID, QuestionID: q.ID, EventID: r.EventID, Content: q.Content, Type: q.Type.String(), Order: q.Order, Domain: q.Domain, }) } } i = 0 for i < len(eventQuestions) { to := i + 100 if to > len(eventQuestions) { to = len(eventQuestions) } _, err = h.store.EmployeeEventQuestion.BatchCreate(db, eventQuestions[i:to]) if err != nil { return http.StatusInternalServerError, err } i = to } return 200, nil } func (h *handler) createWorkEvent(db *gorm.DB, req request.CreateSurveyFeedbackInput, userID string) (int, error) { //1.1 convert data fromDate, err := time.Parse("2006-01-02", req.FromDate) if err != nil { return http.StatusBadRequest, errs.ErrInvalidDate } toDate, err := time.Parse("2006-01-02", req.ToDate) if err != nil { return http.StatusBadRequest, errs.ErrInvalidDate } if fromDate.Add(time.Hour * 24 * 14).Before(toDate) { return http.StatusBadRequest, errs.ErrInvalidDateRange } title := fromDate.Format("Jan 02, 2006") + " - " + toDate.Format("Jan 02, 2006") //1.2 check event existed _, err = h.store.FeedbackEvent.OneByTypeInTimeRange(db, model.EventTypeSurvey, model.EventSubtypeWork, &fromDate, &toDate) if err == nil { return http.StatusBadRequest, errs.ErrEventAlreadyExisted } else { if !errors.Is(err, gorm.ErrRecordNotFound) { return http.StatusInternalServerError, err } } //1.3 check employee existed createdBy, err := h.store.Employee.One(db, userID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return http.StatusNotFound, errs.ErrEmployeeNotFound } return http.StatusInternalServerError, err } //2. Create FeedbackEvent event, err := h.store.FeedbackEvent.Create(db, &model.FeedbackEvent{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, Title: title, Type: model.EventTypeSurvey, Subtype: model.EventSubtype(req.Type), Status: model.EventStatusDraft, CreatedBy: createdBy.ID, StartDate: &fromDate, EndDate: &toDate, }) if err != nil { return http.StatusInternalServerError, err } projects, _, err := h.store.Project.All(db, project.GetListProjectInput{ Statuses: []string{model.ProjectStatusActive.String()}, AllowsSendingSurvey: true, }, model.Pagination{}) if err != nil { return http.StatusInternalServerError, err } if len(projects) < 1 { return http.StatusNotFound, errs.ErrNoValidProjectForEvent } projectIDs := make([]string, 0) for _, p := range projects { projectIDs = append(projectIDs, p.ID.String()) } //3. create EmployeeEventTopic employees, err := h.store.ProjectMember.GetActiveByProjectIDs(db, projectIDs) if err != nil { return http.StatusInternalServerError, err } eets := make([]model.EmployeeEventTopic, 0) for _, e := range employees { p, err := h.store.Project.One(db, e.ProjectID.String(), false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { return http.StatusNotFound, errs.ErrProjectNotFound } return http.StatusInternalServerError, err } eets = append(eets, model.EmployeeEventTopic{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, Title: fmt.Sprintf("%s Survey: %s - %s", p.Name, title, e.Employee.DisplayName), EventID: event.ID, EmployeeID: e.EmployeeID, ProjectID: e.ProjectID, }) } i := 0 for i < len(eets) { to := i + 100 if to > len(eets) { to = len(eets) } _, err = h.store.EmployeeEventTopic.BatchCreate(db, eets[i:to]) if err != nil { return http.StatusInternalServerError, err } i = to } //4. create EmployeeEventReviewer employeeEventMapper := make(map[model.UUID]model.UUID) for _, e := range eets { employeeEventMapper[e.EmployeeID] = e.ID } reviewers := make([]model.EmployeeEventReviewer, 0) for _, e := range eets { reviewers = append(reviewers, model.EmployeeEventReviewer{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, EventID: event.ID, EmployeeEventTopicID: e.ID, ReviewerID: e.EmployeeID, Relationship: model.RelationshipSelf, AuthorStatus: model.EventAuthorStatusSent, ReviewerStatus: model.EventReviewerStatusNew, IsShared: false, IsRead: false, }) } i = 0 for i < len(reviewers) { to := i + 100 if to > len(reviewers) { to = len(reviewers) } _, err = h.store.EmployeeEventReviewer.BatchCreate(db, reviewers[i:to]) if err != nil { return http.StatusInternalServerError, err } i = to } //5. create EmployeeEventQuestion questions, err := h.store.Question.AllByCategory(db, model.EventTypeSurvey, model.EventSubtypeWork) if err != nil { return http.StatusInternalServerError, err } eventQuestions := make([]model.EmployeeEventQuestion, 0) for _, r := range reviewers { for _, q := range questions { eventQuestions = append(eventQuestions, model.EmployeeEventQuestion{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, EmployeeEventReviewerID: r.ID, QuestionID: q.ID, EventID: r.EventID, Content: q.Content, Type: q.Type.String(), Order: q.Order, Domain: q.Domain, }) } } i = 0 for i < len(eventQuestions) { to := i + 100 if to > len(eventQuestions) { to = len(eventQuestions) } _, err = h.store.EmployeeEventQuestion.BatchCreate(db, eventQuestions[i:to]) if err != nil { return http.StatusInternalServerError, err } i = to } return http.StatusOK, nil } // SendSurvey godoc // @Summary Send the survey // @Description Send the survey // @id SendSurvey // @Tags Survey // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Feedback Event ID" // @Param Body body SendSurveyInput true "Body" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys/{id}/send [post] func (h *handler) SendSurvey(c *gin.Context) { eventID := c.Param("id") if eventID == "" || !model.IsUUIDFromString(eventID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventID, nil, "")) return } var input request.SendSurveyInput if err := c.ShouldBindJSON(&input); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } if !model.EventSubtype(input.Type).IsValid() { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventSubType, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "SendSurvey", "eventID": eventID, "input": input, }) // Begin transaction tx, done := h.repo.NewTransaction() event, err := h.store.FeedbackEvent.One(h.repo.DB(), eventID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrEventNotFound, "feedback event not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrEventNotFound), input, "")) return } l.Error(err, "failed to get feedback event") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), input, "")) return } switch input.Type { case model.EventSubtypeEngagement.String(): topicIDs := make([]model.UUID, 0) for _, topic := range event.Topics { topicIDs = append(topicIDs, topic.ID) } for _, data := range topicIDs { errCode, err := h.updateEventReviewer(tx.DB(), l, data, eventID) if err != nil { l.Error(err, "error when running function updateEventReviewer") c.JSON(errCode, view.CreateResponse[any](nil, nil, done(err), input, "")) return } } default: for _, data := range input.TopicIDs { errCode, err := h.updateEventReviewer(tx.DB(), l, model.UUID(data), eventID) if err != nil { l.Error(err, "error when running function updateEventReviewer") c.JSON(errCode, view.CreateResponse[any](nil, nil, done(err), input, "")) return } } } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, done(nil), "ok")) } func (h *handler) updateEventReviewer(db *gorm.DB, l logger.Logger, topicID model.UUID, eventID string) (int, error) { // Get all reviewers by topicID reviewers, err := h.store.EmployeeEventReviewer.GetByTopicID(db, topicID.String()) if err != nil { l.Error(err, "failed to get employee event reviewers") return http.StatusInternalServerError, err } // Validate EventID and TopicID _, err = h.store.EmployeeEventTopic.One(db, topicID.String(), eventID, false) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrTopicNotFound, "topic not found") return http.StatusNotFound, errs.ErrTopicNotFound } if err != nil { l.Error(err, "failed to get employee event topic") return http.StatusInternalServerError, err } // Update Event status to inprogress event, err := h.store.FeedbackEvent.One(db, eventID, true) if err != nil { l.Error(err, "failed to get feedback event") return http.StatusInternalServerError, err } if event.Status == model.EventStatusDraft { event.Status = model.EventStatusInProgress _, err = h.store.FeedbackEvent.UpdateSelectedFieldsByID(db, eventID, *event, "status") if err != nil { l.Error(err, "failed to update status of feedback event") return http.StatusInternalServerError, err } } // Update status for employee reviewers for _, eventReviewer := range reviewers { if eventReviewer.ReviewerStatus == model.EventReviewerStatusNone { eventReviewer.ReviewerStatus = model.EventReviewerStatusNew eventReviewer.AuthorStatus = model.EventAuthorStatusSent _, err = h.store.EmployeeEventReviewer.UpdateSelectedFieldsByID(db, eventReviewer.ID.String(), *eventReviewer, "reviewer_status", "author_status") if err != nil { l.Errorf(err, "failed to update employee reviewer for reviewer ", eventReviewer.ID.String()) return http.StatusInternalServerError, err } } } return http.StatusOK, nil } // DeleteSurvey godoc // @Summary Delete survey by id // @Description Delete survey by id // @id DeleteSurvey // @Tags Survey // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Feedback Event ID" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys/{id} [delete] func (h *handler) DeleteSurvey(c *gin.Context) { eventID := c.Param("id") if eventID == "" || !model.IsUUIDFromString(eventID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventID, eventID, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "DeleteSurvey", "eventID": eventID, }) tx, done := h.repo.NewTransaction() if statusCode, err := h.doSurveyDelete(tx.DB(), eventID); err != nil { l.Error(err, "failed to delete survey") c.JSON(statusCode, view.CreateResponse[any](nil, nil, done(err), eventID, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } func (h *handler) doSurveyDelete(db *gorm.DB, eventID string) (int, error) { l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "deleteSurvey", "eventID": eventID, }) // check feedback event existence exists, err := h.store.FeedbackEvent.IsExist(db, eventID) if err != nil { l.Error(err, "failed to check feedback event existence") return http.StatusInternalServerError, err } if !exists { l.Error(err, "feedback event not found") return http.StatusNotFound, errs.ErrEventNotFound } if err := h.store.EmployeeEventQuestion.DeleteByEventID(db, eventID); err != nil { l.Error(err, "failed to delete feedback events") return http.StatusInternalServerError, err } if err := h.store.EmployeeEventReviewer.DeleteByEventID(db, eventID); err != nil { l.Error(err, "failed to delete event reviewers") return http.StatusInternalServerError, err } if err := h.store.EmployeeEventTopic.DeleteByEventID(db, eventID); err != nil { l.Error(err, "failed to delete event topics") return http.StatusInternalServerError, err } if err := h.store.FeedbackEvent.DeleteByID(db, eventID); err != nil { l.Error(err, "failed to delete event") return http.StatusInternalServerError, err } return http.StatusOK, nil } // GetSurveyReviewDetail godoc // @Summary Get survey review detail // @Description Get survey review detail // @id GetSurveyReviewDetail // @Tags Survey // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} FeedbackReviewDetailResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys/{id}/topics/{topicID}/reviews/{reviewID} [get] func (h *handler) GetSurveyReviewDetail(c *gin.Context) { eventID := c.Param("id") if eventID == "" || !model.IsUUIDFromString(eventID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventID, nil, "")) return } topicID := c.Param("topicID") if topicID == "" || !model.IsUUIDFromString(topicID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidTopicID, nil, "")) return } reviewID := c.Param("reviewID") if reviewID == "" || !model.IsUUIDFromString(reviewID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidReviewerID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "GetSurveyReviewDetail", }) topic, err := h.store.EmployeeEventTopic.One(h.repo.DB(), topicID, eventID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("topic not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrTopicNotFound, nil, "")) return } l.Error(err, "failed when getting topic") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } review, err := h.store.EmployeeEventReviewer.One(h.repo.DB(), reviewID) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("review not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEventReviewerNotFound, nil, "")) return } l.Error(err, "failed when getting review") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if review.EmployeeEventTopicID != topic.ID { l.Info("review not belong topic") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrEventReviewerNotFound, nil, "")) return } questions, err := h.store.EmployeeEventQuestion.GetByEventReviewerID(h.repo.DB(), review.ID.String()) if err != nil { l.Error(err, "failed when getting questions") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } var project *model.Project if !topic.ProjectID.IsZero() { project, err = h.store.Project.One(h.repo.DB(), topic.ProjectID.String(), false) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrProjectNotFound, "project not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrProjectNotFound, nil, "")) return } if err != nil { l.Error(err, "failed to get project") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToFeedbackReviewDetail(questions, topic, review, project), nil, nil, nil, "")) } // DeleteSurveyTopic godoc // @Summary delete survey topic // @Description delete survey topic // @id DeleteSurveyTopic // @Tags Survey // @Accept json // @Produce json // @Security BearerAuth // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys/{id}/topics/{topicID} [delete] func (h *handler) DeleteSurveyTopic(c *gin.Context) { eventID := c.Param("id") if eventID == "" || !model.IsUUIDFromString(eventID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventID, nil, "")) return } topicID := c.Param("topicID") if topicID == "" || !model.IsUUIDFromString(topicID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidTopicID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "DeleteSurveyTopic", }) tx, done := h.repo.NewTransaction() // check feedback event existence exists, err := h.store.FeedbackEvent.IsExist(tx.DB(), eventID) if err != nil { l.Error(err, "failed to check feedback event existence") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } if !exists { l.Error(err, "feedback event not found") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, done(errs.ErrEventNotFound), nil, "")) return } _, err = h.store.EmployeeEventTopic.One(tx.DB(), topicID, eventID, false) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Info("topic not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, done(errs.ErrTopicNotFound), nil, "")) return } l.Error(err, "failed when getting topic") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } reviews, err := h.store.EmployeeEventReviewer.GetByTopicID(tx.DB(), topicID) if err != nil { l.Error(err, "failed when getting reviews") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } reviewIDList := make([]string, 0) for _, r := range reviews { if r.AuthorStatus != model.EventAuthorStatusDraft { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(errs.ErrReviewAlreadySent), nil, "")) return } reviewIDList = append(reviewIDList, r.ID.String()) } if err := h.store.EmployeeEventQuestion.DeleteByEventReviewerIDList(tx.DB(), reviewIDList); err != nil { l.Error(err, "failed to delete feedback events") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } if err := h.store.EmployeeEventReviewer.DeleteByTopicID(tx.DB(), topicID); err != nil { l.Error(err, "failed to delete event reviewers") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } if err := h.store.EmployeeEventTopic.DeleteByID(tx.DB(), topicID); err != nil { l.Error(err, "failed to delete event topics") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } // GetSurveyTopicDetail godoc // @Summary Get detail for peer review // @Description Get detail for peer review // @id GetSurveyTopicDetail // @Tags Survey // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Feedback Event ID" // @Param topicID path string true "Employee Event Topic ID" // @Success 200 {object} view.SurveyTopicDetailResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys/{id}/topics/{topicID} [get] func (h *handler) GetSurveyTopicDetail(c *gin.Context) { input := request.PeerReviewDetailInput{ EventID: c.Param("id"), TopicID: c.Param("topicID"), } if err := input.Validate(); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "GetSurveyTopicDetail", "input": input, }) // Check topic and feedback existence topic, err := h.store.EmployeeEventTopic.One(h.repo.DB(), input.TopicID, input.EventID, true) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrTopicNotFound, "topic not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrTopicNotFound, input, "")) return } if err != nil { l.Error(err, "failed when getting topic") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](view.ToPeerReviewDetail(topic), nil, nil, nil, "")) } // UpdateTopicReviewers godoc // @Summary Update reviewers in a topic // @Description Update reviewers in a topic // @id UpdateTopicReviewers // @Tags Survey // @Accept json // @Produce json // @Security BearerAuth // @Param Body body UpdateTopicReviewersBody true "Body" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys/{id}/topics/{topicID}/employees [put] func (h *handler) UpdateTopicReviewers(c *gin.Context) { input := request.UpdateTopicReviewersInput{ EventID: c.Param("id"), TopicID: c.Param("topicID"), } if err := c.ShouldBindJSON(&input.Body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "UpdateTopicReviewers", "input": input, }) if err := input.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } // check feedback event existence event, err := h.store.FeedbackEvent.One(h.repo.DB(), input.EventID, true) if err != nil { if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrEventNotFound, "feedback event not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEventNotFound, input, "")) return } l.Error(err, "failed to check feedback event existence") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } if event.Subtype != model.EventSubtypePeerReview { l.Error(errs.ErrCanNotUpdateParticipants, "event does not allow updating participants") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrCanNotUpdateParticipants, input, "")) return } tx, done := h.repo.NewTransaction() if code, err := h.updateTopicReviewer(tx.DB(), input.EventID, input.TopicID, input.Body); err != nil { l.Error(err, "failed to update topic reviewers") c.JSON(code, view.CreateResponse[any](nil, nil, done(err), input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } func (h *handler) updateTopicReviewer(db *gorm.DB, eventID string, topicID string, body request.UpdateTopicReviewersBody) (int, error) { l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "updateTopicReviewer", "eventID": eventID, "topicID": topicID, "body": body, }) employees, err := h.store.Employee.GetByWorkingStatus(db, model.WorkingStatusFullTime) if err != nil { l.Error(err, "failed to get employees by working status") return http.StatusInternalServerError, err } eventReviewers, err := h.store.EmployeeEventReviewer.GetByTopicID(db, topicID) if err != nil { l.Error(err, "failed to get event reviewers") return http.StatusInternalServerError, err } // check reviewer existence employeeMap := model.ToEmployeeMap(employees) mustCreateReviewerIDMap := map[model.UUID]bool{} for _, reviewerID := range body.ReviewerIDs { if _, ok := employeeMap[model.UUID(reviewerID)]; !ok { l.Errorf(errs.ErrEmployeeNotReady, "employee %v not ready", reviewerID) return http.StatusBadRequest, errs.ErrEmployeeNotReady } mustCreateReviewerIDMap[model.UUID(reviewerID)] = true } // delete event question and event topic if reviewerID is not exists in request for _, eventReviewer := range eventReviewers { if isExists := mustCreateReviewerIDMap[eventReviewer.ReviewerID]; isExists { mustCreateReviewerIDMap[eventReviewer.ReviewerID] = false continue } if err := h.store.EmployeeEventQuestion.DeleteByEventReviewerID(db, eventReviewer.ID.String()); err != nil { l.Error(err, "failed to delete event questions") return http.StatusInternalServerError, err } if err := h.store.EmployeeEventReviewer.DeleteByID(db, eventReviewer.ID.String()); err != nil { l.Error(err, "failed to delete event reviewer") return http.StatusInternalServerError, err } } eventTopic, err := h.store.EmployeeEventTopic.One(db, topicID, eventID, false) if err != nil { l.Error(err, "failed to get event topic") return http.StatusInternalServerError, err } // create event reviewer and event question if reviewerID not exist in database newEventReviewers := make([]model.EmployeeEventReviewer, 0) for reviewerID, mustCreate := range mustCreateReviewerIDMap { if mustCreate { relationship := model.RelationshipPeer if employeeMap[eventTopic.EmployeeID].LineManagerID == reviewerID || employeeMap[reviewerID].LineManagerID == eventTopic.EmployeeID { relationship = model.RelationshipLineManager } newEventReviewers = append(newEventReviewers, model.EmployeeEventReviewer{ EmployeeEventTopicID: model.MustGetUUIDFromString(topicID), ReviewerID: reviewerID, AuthorStatus: model.EventAuthorStatusDraft, ReviewerStatus: model.EventReviewerStatusNone, Relationship: relationship, EventID: model.MustGetUUIDFromString(eventID), }) } } if len(newEventReviewers) > 0 { newEventReviewers, err = h.store.EmployeeEventReviewer.BatchCreate(db, newEventReviewers) if err != nil { l.Error(err, "failed to batch create event reviews") return http.StatusInternalServerError, err } } if err := h.createEventQuestions(db, model.EventTypeSurvey, model.EventSubtypePeerReview, newEventReviewers); err != nil { l.Error(err, "failed to create event questions") return http.StatusInternalServerError, err } return http.StatusOK, nil } func (h *handler) createEventQuestions(db *gorm.DB, eventType model.EventType, eventSubtype model.EventSubtype, reviewers []model.EmployeeEventReviewer) error { l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "createEventQuestions", "eventType": eventType, "eventSubtype": eventSubtype, }) questions, err := h.store.Question.AllByCategory(db, eventType, eventSubtype) if err != nil { l.Error(err, "failed to get all questions by category") return err } eventQuestions := make([]model.EmployeeEventQuestion, 0) for _, r := range reviewers { for _, q := range questions { eventQuestions = append(eventQuestions, model.EmployeeEventQuestion{ BaseModel: model.BaseModel{ ID: model.NewUUID(), }, EmployeeEventReviewerID: r.ID, QuestionID: q.ID, EventID: r.EventID, Content: q.Content, Type: q.Type.String(), Order: q.Order, }) } } i := 0 for i < len(eventQuestions) { to := i + 100 if to > len(eventQuestions) { to = len(eventQuestions) } _, err = h.store.EmployeeEventQuestion.BatchCreate(db, eventQuestions[i:to]) if err != nil { l.Error(err, "failed to batch create event questions") return err } i = to } return nil } // MarkDone godoc // @Summary Mark done feedback event // @Description Mark done feedback event // @id MarkDone // @Tags Survey // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Feedback Event ID" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys/{id}/done [put] func (h *handler) MarkDone(c *gin.Context) { eventID := c.Param("id") if eventID == "" || !model.IsUUIDFromString(eventID) { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrInvalidEventID, nil, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "MarkDone", "eventID": eventID, }) // check feedback event existence exists, err := h.store.FeedbackEvent.IsExist(h.repo.DB(), eventID) if err != nil { l.Error(err, "failed to check feedback event existence") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, eventID, "")) return } if !exists { l.Error(errs.ErrEventNotFound, "feedback event not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEventNotFound, eventID, "")) return } tx, done := h.repo.NewTransaction() // Update event status event, err := h.store.FeedbackEvent.One(tx.DB(), eventID, true) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrEventNotFound, "feedback event not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrEventNotFound, eventID, "")) return } if err != nil { l.Error(err, "failed to get feedback event") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, eventID, "")) return } if event.Status == model.EventStatusDone { l.Error(errs.ErrEventHasBeenDone, "event has been done") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, errs.ErrEventHasBeenDone, eventID, "")) return } event.Status = model.EventStatusDone _, err = h.store.FeedbackEvent.UpdateSelectedFieldsByID(tx.DB(), eventID, *event, "status") if err != nil { l.Error(err, "failed to update feedback event") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, eventID, "")) return } // Get all topics topics, _, err := h.store.EmployeeEventTopic.All(tx.DB(), employeeeventtopic.GetByEventIDInput{EventID: eventID}, nil) if err != nil { l.Error(err, "failed to get all topics") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, done(err), eventID, "")) return } // Check done for each topic: all user have to done for _, topic := range topics { if code, err := h.forceEventReviewersToDone(tx.DB(), l, topic.ID.String()); err != nil { l.Errorf(err, "failed to force event reviewers of topic %s to done", topic.ID.String()) c.JSON(code, view.CreateResponse[any](nil, nil, done(err), eventID, "")) return } } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } func (h *handler) forceEventReviewersToDone(db *gorm.DB, l logger.Logger, topicID string) (int, error) { // Get all reviewers reviewers, err := h.store.EmployeeEventReviewer.GetByTopicID(db, topicID) if err != nil { l.Errorf(err, "failed to get all reviewers with topic ID %s", topicID) return http.StatusInternalServerError, err } for _, reviewer := range reviewers { if reviewer.AuthorStatus != model.EventAuthorStatusDone || reviewer.ReviewerStatus != model.EventReviewerStatusDone { reviewer.AuthorStatus = model.EventAuthorStatusDone reviewer.ReviewerStatus = model.EventReviewerStatusDone reviewer.IsForcedDone = true } _, err := h.store.EmployeeEventReviewer.UpdateSelectedFieldsByID(db, reviewer.ID.String(), *reviewer, "author_status", "reviewer_status", "is_forced_done") if err != nil { l.AddField("eventReviewerID", reviewer.ID).Error(err, "failed to update event reviewer status") return http.StatusInternalServerError, err } } return http.StatusOK, nil } // DeleteTopicReviewers godoc // @Summary Delete reviewers in a topic // @Description Delete reviewers in a topic // @id DeleteTopicReviewers // @Tags Survey // @Accept json // @Produce json // @Security BearerAuth // @Param id path string true "Feedback Event ID" // @Param topicID path string true "Employee Event Topic ID" // @Param Body body DeleteTopicReviewersBody true "Body" // @Success 200 {object} MessageResponse // @Failure 400 {object} ErrorResponse // @Failure 404 {object} ErrorResponse // @Failure 500 {object} ErrorResponse // @Router /surveys/{id}/topics/{topicID}/employees [delete] func (h *handler) DeleteTopicReviewers(c *gin.Context) { input := request.DeleteTopicReviewersInput{ EventID: c.Param("id"), TopicID: c.Param("topicID"), } if err := c.ShouldBindJSON(&input.Body); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "DeleteTopicReviewers", "input": input, }) if err := input.Validate(); err != nil { l.Error(err, "validate failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, input, "")) return } // Check topic and feedback existence _, err := h.store.EmployeeEventTopic.One(h.repo.DB(), input.TopicID, input.EventID, false) if errors.Is(err, gorm.ErrRecordNotFound) { l.Error(errs.ErrTopicNotFound, "topic not found") c.JSON(http.StatusNotFound, view.CreateResponse[any](nil, nil, errs.ErrTopicNotFound, input, "")) return } if err != nil { l.Error(err, "failed when getting topic") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, input, "")) return } tx, done := h.repo.NewTransaction() reviewerIDs := make([]model.UUID, 0) for _, id := range input.Body.ReviewerIDs { reviewerIDs = append(reviewerIDs, model.UUID(id)) } if code, err := h.deleteTopicReviewer(tx.DB(), input.EventID, input.TopicID, reviewerIDs); err != nil { l.Error(err, "failed to delete topic reviewers") c.JSON(code, view.CreateResponse[any](nil, nil, done(err), input, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, done(nil), nil, "ok")) } func (h *handler) deleteTopicReviewer(db *gorm.DB, eventID string, topicID string, reviewerIDs []model.UUID) (int, error) { l := h.logger.Fields(logger.Fields{ "handler": "survey", "method": "deleteTopicReviewer", "eventID": eventID, "topicID": topicID, "reviewerIDs": reviewerIDs, }) for _, reviewer := range reviewerIDs { eventReviewer, err := h.store.EmployeeEventReviewer.OneByReviewerID(db, reviewer.String(), topicID) if errors.Is(err, gorm.ErrRecordNotFound) { l.Errorf(errs.ErrEventReviewerNotFound, "reviewer not found with reviewerID ", reviewer) return http.StatusNotFound, errs.ErrEventReviewerNotFound } if err != nil { l.Errorf(err, "failed when get employee event reviewer with reviewerID ", reviewer) return http.StatusNotFound, errs.ErrEventReviewerNotFound } // Delete employee question if err := h.store.EmployeeEventQuestion.DeleteByEventReviewerID(db, eventReviewer.ID.String()); err != nil { l.Error(err, "failed to delete employee event question") return http.StatusInternalServerError, err } // Delete employee reviewer if err := h.store.EmployeeEventReviewer.DeleteByID(db, eventReviewer.ID.String()); err != nil { l.Error(err, "failed to delete employee event reviewer") return http.StatusInternalServerError, err } } return http.StatusOK, nil }
```

# pkg/handler/valuation/interface.go

```go
package valuation import "github.com/gin-gonic/gin" type IHandler interface { One(c *gin.Context) }
```

# pkg/handler/valuation/valuation.go

```go
// please edit this file only with approval from hnh package valuation import ( "net/http" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/utils" "github.com/dwarvesf/fortress-api/pkg/view" "github.com/gin-gonic/gin" ) type handler struct { store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } // New returns a handler func New(store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, } } // One godoc // @Summary Get valuation by year // @Description Get valuation // @Tags valuation // @Accept json // @Produce json // @Param year path int true "Year" // @Success 200 {object} Valuation // @Failure 400 {object} ErrorResponse func (h *handler) One(c *gin.Context) { // parse params & prepare logger year := c.Param("year") if !utils.IsNumber(year) { c.JSON(400, gin.H{"message": "year must be number"}) return } // we convert all number to usd convertTo := "USD" l := h.logger.Fields(logger.Fields{ "handler": "valuation", "method": "Details", "year": year, }) // account receivable is a number of money that company has to receive from customer // in our case, receivable is an amount of unpaid invoice receivable, err := h.store.Valuation.GetAccountReceivable(h.repo.DB(), year) if err != nil { l.Error(err, "can't get account receivable from this year") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get account receivable from this year")) return } // revenue equal all paid invoice, yield from investment & bank interest revenue, err := h.store.Valuation.GetRevenue(h.repo.DB(), year) if err != nil { l.Error(err, "can't get revenue from this year") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get revenue from this year")) return } // liabilities is a money that company has to pay in the future liabilities, amount, err := h.store.Valuation.GetLiabilities(h.repo.DB(), year) if err != nil { l.Error(err, "can't get liabilities from this year") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get liabilities from this year")) return } items := make([]model.AccountingItem, 0) for i := range liabilities { items = append(items, model.AccountingItem{ Name: liabilities[i].Name, Amount: liabilities[i].Total, }) } // get investment investment, err := h.store.Valuation.GetInvestment(h.repo.DB(), year) if err != nil { l.Error(err, "can't get investment from this year") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get investment from this year")) return } // assets is a total worth of assets that company holds assets, err := h.store.Valuation.GetAssetAmount(h.repo.DB(), year) if err != nil { l.Error(err, "can't get liabilities from this year") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get liabilities from this year")) return } // expenses is a total amount we spent for operation expenses expenses, err := h.store.Valuation.GetExpense(h.repo.DB(), year) if err != nil { l.Error(err, "can't get expense from this year") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get expense from this year")) return } // payroll is a total amount we spent for salary payroll, err := h.store.Valuation.GetPayroll(h.repo.DB(), year) if err != nil { l.Error(err, "can't get expense from this year") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, year, "can't get expense from this year")) return } // build up response var valuation view.Valuation valuation.Year = year valuation.Currency = convertTo valuation.Assets = assets // we temporary doesn't need to return detail item for this rn valuation.AccountReceivable.Total = h.convertCurrency(receivable, convertTo) valuation.Liabilities.Total = h.convertCurrency(amount, convertTo) viewItems := make([]view.AccountingItem, 0) for _, item := range items { viewItems = append(viewItems, view.AccountingItem{ Name: item.Name, Amount: h.convertCurrency(&model.CurrencyView{VND: item.Amount}, convertTo), }) } valuation.Liabilities.Items = viewItems valuation.Income.Total = h.convertCurrency(revenue, convertTo) valuation.Outcome.Detail.Expense = h.convertCurrency(expenses, convertTo) valuation.Outcome.Detail.Payroll = h.convertCurrency(payroll, convertTo) valuation.Outcome.Detail.Investment = h.convertCurrency(investment, convertTo) valuation.Outcome.Total = valuation.Outcome.Detail.Expense + valuation.Outcome.Detail.Payroll + valuation.Outcome.Detail.Investment // return c.JSON(http.StatusOK, view.CreateResponse[any](valuation, nil, nil, year, "get valuation successfully")) } func (h *handler) convertCurrency(currency *model.CurrencyView, convertTo string) (convertedAmount float64) { if currency == nil { h.logger.Warn("currency struct is nil") return 0 } // convert currency vndSource, _, _ := h.service.Wise.Convert(currency.VND, "VND", convertTo) usdSource, _, _ := h.service.Wise.Convert(currency.USD, "USD", convertTo) gbpSource, _, _ := h.service.Wise.Convert(currency.GBP, "GBP", convertTo) eurSource, _, _ := h.service.Wise.Convert(currency.EUR, "EUR", convertTo) sgdSource, _, _ := h.service.Wise.Convert(currency.SGD, "SGD", convertTo) return vndSource + usdSource + gbpSource + eurSource + sgdSource }
```

# pkg/handler/webhook/basecamp_accounting.go

```go
package webhook import ( "encoding/json" "fmt" "regexp" "strconv" "strings" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" "github.com/dwarvesf/fortress-api/pkg/service/currency" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" ) func (h *handler) StoreAccountingTransactionFromBasecamp(msg model.BasecampWebhookMessage) error { operationInfo, err := h.getManagementTodoInfo(&msg) if err != nil { return err } data := regexp. MustCompile(`[S|s]alary\s*(1st|15th)|(.*)\|\s*([0-9\.]+)\s*\|\s*([a-zA-Z]{3})`). FindStringSubmatch(msg.Recording.Title) if len(data) == 0 { return fmt.Errorf(`unknown title format`) } err = h.storeAccountingTransaction(operationInfo, data, msg.Recording.ID) if err != nil { return err } return nil } type managementTodoInfo struct { month int year int } func (h *handler) getManagementTodoInfo(msg *model.BasecampWebhookMessage) (*managementTodoInfo, error) { todoList, err := h.service.Basecamp.Todo.GetList(msg.Recording.Parent.URL) if err != nil { return nil, err } if todoList == nil || todoList.Parent == nil { return nil, nil } managementInfo := regexp. MustCompile(`Accounting \| (.+) ([0-9]{4})`). FindStringSubmatch(todoList.Parent.Title) accountingID := consts.PlaygroundID if h.config.Env == "prod" { accountingID = consts.AccountingID } if len(managementInfo) != 3 && msg.Recording.Bucket.ID == accountingID { return nil, nil } month, err := timeutil.GetMonthFromString(managementInfo[1]) if err != nil { return nil, fmt.Errorf(`format of operation todolist title got wrong %s`, err.Error()) } year, err := strconv.Atoi(managementInfo[2]) if err != nil { return nil, fmt.Errorf(`format of operation todolist title got wrong %d is not a year number`, year) } return &managementTodoInfo{month, year}, nil } func (h *handler) storeAccountingTransaction(date *managementTodoInfo, data []string, id int) error { amount, err := strconv.Atoi(strings.ReplaceAll(data[3], ".", "")) if err != nil { return err } c, err := h.store.Currency.GetByName(h.repo.DB(), data[4]) if err != nil { if err == gorm.ErrRecordNotFound { return fmt.Errorf(`unknown currency`) } return err } now := time.Now() m := model.AccountingMetadata{ Source: "basecamp_accounting", ID: fmt.Sprintf("%v", id), } bonusBytes, err := json.Marshal(&m) if err != nil { return err } temp, rate, err := h.service.Wise.Convert(float64(amount), c.Name, currency.VNDCurrency) if err != nil { return nil } am := model.NewVietnamDong(int64(temp)) transaction := &model.AccountingTransaction{ Name: data[2], Amount: float64(amount), Date: &now, CurrencyID: &c.ID, Currency: c.Name, Category: checkCategory(strings.ToLower(data[2])), Type: model.AccountingOP, ConversionAmount: am.Format(), ConversionRate: rate, Metadata: bonusBytes, } err = h.StoreOperationAccountingTransaction(transaction) if err != nil { return err } return nil } func (h *handler) StoreOperationAccountingTransaction(t *model.AccountingTransaction) error { if err := h.store.Accounting.CreateTransaction(h.repo.DB(), t); err != nil { return err } return nil } func checkCategory(content string) string { switch { case strings.Contains(content, "office rental") || strings.Contains(content, "cbre"): return model.AccountingOfficeSpace default: return model.AccountingOfficeServices } }
```

# pkg/handler/webhook/basecamp_expense.go

```go
package webhook import ( "errors" "fmt" "strings" "github.com/dwarvesf/fortress-api/pkg/model" bc "github.com/dwarvesf/fortress-api/pkg/service/basecamp" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) func (h *handler) basecampExpenseValidate(msg model.BasecampWebhookMessage) error { recordingBucketName := consts.BucketNameWoodLand assigneeIDs := []int{consts.HanBasecampID} projectID := consts.WoodlandID if h.config.Env != "prod" { recordingBucketName = consts.BucketNamePlayGround assigneeIDs = []int{consts.NamNguyenBasecampID} projectID = consts.PlaygroundID } if msg.Recording.Bucket.Name != recordingBucketName { return nil } // Todo ref: https://3.basecamp.com/4108948/buckets/9410372/todos/3204666678 // Assign HanNgo whenever expense todo was created if msg.Kind == consts.TodoCreate { todo, err := h.service.Basecamp.Todo.Get(msg.Recording.URL) if err != nil { return err } todo.AssigneeIDs = assigneeIDs _, err = h.service.Basecamp.Todo.Update(projectID, *todo) if err != nil { return err } } _, err := h.extractExpenseData(msg) if err != nil { m, err := h.service.Basecamp.BasecampMention(msg.Creator.ID) if err != nil { return err } errMsg := fmt.Sprintf( `Hi %v, I'm not smart enough to understand your expense submission. Please ensure the following format ðŸ˜Š Title: < Reason > | < Amount > | < VND/USD > Assign To: Han Ngo, < payee > Example: Title: Tiá»n mÃ¨o | 400.000 | VND Assign To: Han Ngo, < payee >`, m) h.worker.Enqueue(bcModel.BasecampCommentMsg, h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, errMsg, "")) return nil } commentMessage := h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, "Your format looks good ðŸ‘", "", ) h.worker.Enqueue(bcModel.BasecampCommentMsg, commentMessage) return nil } func (h *handler) createBasecampExpense(msg model.BasecampWebhookMessage, rawData []byte) error { commentMessage := h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, consts.CommentCreateExpenseFailed, bcModel.CommentMsgTypeFailed) defer func() { h.worker.Enqueue(bcModel.BasecampCommentMsg, commentMessage) }() obj, err := h.extractExpenseData(msg) if err != nil { return err } if obj == nil { return nil } err = obj.MetaData.UnmarshalJSON(rawData) if err != nil { return err } err = h.service.Basecamp.CreateBasecampExpense(*obj) if err != nil { return err } commentMessage = h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, consts.CommentCreateExpenseSuccessfully, bcModel.CommentMsgTypeCompleted) return nil } func (h *handler) UncheckBasecampExpenseHandler(msg model.BasecampWebhookMessage, rawData []byte) error { commentMsg := h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, consts.CommentDeleteExpenseFailed, bcModel.CommentMsgTypeFailed) defer func() { h.worker.Enqueue(bcModel.BasecampCommentMsg, commentMsg) }() obj, err := h.extractExpenseData(msg) if err != nil { return err } err = obj.MetaData.UnmarshalJSON(rawData) if err != nil { return err } if obj == nil { return nil } err = h.service.Basecamp.UncheckBasecampExpenseHandler(*obj) if err != nil { return err } commentMsg = h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, consts.CommentDeleteExpenseSuccessfully, bcModel.CommentMsgTypeCompleted) return nil } // extractExpenseData takes a webhook message and parse it into BasecampExpenseData structure func (h *handler) extractExpenseData(msg model.BasecampWebhookMessage) (*bc.BasecampExpenseData, error) { res := &bc.BasecampExpenseData{BasecampID: msg.Recording.ID} parts := strings.Split(msg.Recording.Title, "|") if len(parts) < 3 { err := errors.New("invalid expense format") return nil, err } // extract reason datetime := fmt.Sprintf(" %s %v", msg.Recording.UpdatedAt.Month().String(), msg.Recording.UpdatedAt.Year()) res.Reason = strings.TrimSpace(parts[0]) res.Reason += datetime // extract amount amount := h.service.Basecamp.ExtractBasecampExpenseAmount(strings.TrimSpace(parts[1])) if amount == 0 { err := errors.New("invalid amount section of expense format") return nil, err } res.Amount = amount // extract currency type t := strings.ToLower(strings.TrimSpace(parts[2])) if t != "vnd" && t != "usd" { return nil, errors.New("invalid format in currency type section (VND or USD) of expense format") } url, err := h.service.Basecamp.Recording.TryToGetInvoiceImageURL(msg.Recording.URL) if err != nil { return nil, fmt.Errorf("failed to get image url by error %v", err) } res.CurrencyType = strings.ToUpper(t) list, err := h.service.Basecamp.Todo.GetList(msg.Recording.Parent.URL) if err != nil { return nil, err } msg.Recording.Parent.Title = list.Parent.Title if msg.IsExpenseComplete() { res.CreatorEmail = msg.Recording.Creator.Email res.CreatorID = msg.Recording.Creator.ID } if msg.IsOperationComplete() { res.CreatorEmail = msg.Creator.Email } res.InvoiceImageURL = url return res, nil }
```

# pkg/handler/webhook/basecamp_invoice.go

```go
package webhook import ( "fmt" "regexp" "strings" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" "github.com/dwarvesf/fortress-api/pkg/store/invoice" ) func (h *handler) GetInvoiceViaBasecampTitle(msg *model.BasecampWebhookMessage) (*model.Invoice, error) { if msg.Creator.ID == consts.AutoBotID { return nil, nil } reTitle := regexp.MustCompile(`.*([1-9]|0[1-9]|1[0-2])/(20[0-9]{2}) - #(20[0-9]+-[A-Z]+-[0-9]+)`) invoiceInfo := reTitle.FindStringSubmatch(msg.Recording.Title) if len(invoiceInfo) != 4 { return nil, fmt.Errorf(`Todo title have wrong format`) } invoiceNumber := invoiceInfo[3] invoice, err := h.store.Invoice.One(h.repo.DB(), &invoice.Query{Number: invoiceNumber}) if err != nil { return nil, fmt.Errorf(`Can't get invoice %v`, err.Error()) } if invoice.Status != model.InvoiceStatusSent && invoice.Status != model.InvoiceStatusOverdue { return nil, fmt.Errorf(`Update invoice failed, invoice has status %s`, invoice.Status) } comments, err := h.service.Basecamp.Comment.Gets(msg.Recording.Bucket.ID, msg.Recording.ID) if err != nil { return nil, fmt.Errorf(`can't get basecamp comment %v`, err.Error()) } reCmt := regexp.MustCompile(fmt.Sprintf(`(^Paid|^<div>Paid).*#%s`, invoiceNumber)) for i := range comments { // TODO: wtf if reCmt.MatchString(strings.ReplaceAll(comments[i].Content, "\n", "")) && !(!(msg.Creator.ID == consts.HanBasecampID) && h.config.Env == "prod") { return invoice, nil } } return nil, fmt.Errorf("missing confirm comment") }
```

# pkg/handler/webhook/basecamp.go

```go
package webhook import ( "net/http" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/view" ) func basecampWebhookMessageFromCtx(c *gin.Context) (model.BasecampWebhookMessage, error) { var msg model.BasecampWebhookMessage err := msg.Decode(msg.Read(c.Request.Body)) if err != nil { return msg, err } return msg, nil } // ValidateBasecampExpense dry-run expense request for validation func (h *handler) ValidateBasecampExpense(c *gin.Context) { msg, err := basecampWebhookMessageFromCtx(c) if err != nil { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "")) return } err = h.basecampExpenseValidate(msg) if err != nil { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "")) } // CreateBasecampExpense runs expense process in basecamp func (h *handler) CreateBasecampExpense(c *gin.Context) { msg, err := basecampWebhookMessageFromCtx(c) if err != nil { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "")) return } err = h.createBasecampExpense(msg, msg.Read(c.Request.Body)) if err != nil { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "")) } // UncheckBasecampExpense will remove expesne record after expense todo complete func (h *handler) UncheckBasecampExpense(c *gin.Context) { msg, err := basecampWebhookMessageFromCtx(c) if err != nil { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "")) return } err = h.UncheckBasecampExpenseHandler(msg, msg.Read(c.Request.Body)) if err != nil { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "")) } // StoreAccountingTransaction run commpany accouting expense process func (h *handler) StoreAccountingTransaction(c *gin.Context) { msg, err := basecampWebhookMessageFromCtx(c) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } err = h.StoreAccountingTransactionFromBasecamp(msg) if err != nil { c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "")) } // MarkInvoiceAsPaidViaBasecamp -- func (h *handler) MarkInvoiceAsPaidViaBasecamp(c *gin.Context) { msg, err := basecampWebhookMessageFromCtx(c) if err != nil { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "")) return } if err := h.markInvoiceAsPaid(&msg); err != nil { c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "")) } func (h *handler) markInvoiceAsPaid(msg *model.BasecampWebhookMessage) error { invoice, err := h.GetInvoiceViaBasecampTitle(msg) if err != nil { h.worker.Enqueue(bcModel.BasecampCommentMsg, h.service.Basecamp.BuildCommentMessage(msg.Recording.Bucket.ID, msg.Recording.ID, err.Error(), bcModel.CommentMsgTypeFailed)) return err } if invoice == nil { return nil } if _, err := h.controller.Invoice.MarkInvoiceAsPaidByBasecampWebhookMessage(invoice, msg); err != nil { return err } // log discord as audit log _ = h.controller.Discord.Log(model.LogDiscordInput{ Type: "invoice_paid", Data: map[string]interface{}{ "invoice_number": invoice.Number, }, }) return nil } // ValidateOnLeaveRequest validates on-leave request and give feedback comments func (h *handler) ValidateOnLeaveRequest(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "basecamp", "method": "ValidateOnLeaveRequest", }) var msg model.BasecampWebhookMessage err := msg.Decode(msg.Read(c.Request.Body)) if err != nil { l.Error(err, "decode Basecamp msg failed") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } err = h.handleOnLeaveValidation(msg) if err != nil { l.Error(err, "onleave validation failed") } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "")) } // ApproveOnLeaveRequest saves on-leave request in a database func (h *handler) ApproveOnLeaveRequest(c *gin.Context) { l := h.logger.Fields(logger.Fields{ "handler": "basecamp", "method": "ApproveOnLeaveRequest", }) var msg model.BasecampWebhookMessage err := msg.Decode(msg.Read(c.Request.Body)) if err != nil { l.Error(err, "failed to decode basecamp message") c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, nil, "")) return } err = h.handleApproveOnLeaveRequest(msg) if err != nil { l.Error(err, "failed to handle approve on leave request") } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, err, nil, "")) }
```

# pkg/handler/webhook/constant.go

```go
package webhook const ( KindGcalEvent = "google#calendar#event" )
```

# pkg/handler/webhook/interface.go

```go
package webhook import "github.com/gin-gonic/gin" type IHandler interface { N8n(c *gin.Context) CreateBasecampExpense(c *gin.Context) MarkInvoiceAsPaidViaBasecamp(c *gin.Context) StoreAccountingTransaction(c *gin.Context) UncheckBasecampExpense(c *gin.Context) ValidateBasecampExpense(c *gin.Context) ValidateOnLeaveRequest(c *gin.Context) ApproveOnLeaveRequest(c *gin.Context) }
```

# pkg/handler/webhook/n8n.go

```go
package webhook import ( "net/http" "time" "github.com/gin-gonic/gin" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) func (h *handler) N8n(c *gin.Context) { var req n8nEvent if err := c.ShouldBindJSON(&req); err != nil { c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, nil, err, req, "")) return } req.CalendarData.ShouldSyncDiscord = req.ShouldSyncDiscord var err error switch req.Kind { case KindGcalEvent: err = h.handleGcalEvent(req.CalendarData) } if err != nil { h.logger.Fields(logger.Fields{ "kind": req.Kind, "data": req, }).Error(err, "can't execute webhook") } } func (h *handler) handleGcalEvent(event *n8nCalendarEvent) error { // first, we get event from db existedEv, err := h.store.Schedule.GetOneByGcalID(h.repo.DB(), event.ID) if err != nil { if err != gorm.ErrRecordNotFound { h.logger.Error(err, "can't get schedule from db") return err } // if the schedule doesn't exists in db, we create a new one return h.handleNewEvent(event) } // in case the event already exists, we check if the event is updated if existedEv.GoogleCalendar.HangoutLink != event.HangoutLink || existedEv.Name != event.Summary || *existedEv.StartTime != event.Start.DateTime || *existedEv.EndTime != event.End.DateTime { return h.handleUpdateEvent(existedEv, event) } return nil } func (h *handler) handleUpdateEvent(existedEv *model.Schedule, event *n8nCalendarEvent) error { // update schedule existedEv.Name = event.Summary existedEv.StartTime = &event.Start.DateTime existedEv.EndTime = &event.End.DateTime existedEv.GoogleCalendar.Description = event.Description existedEv.GoogleCalendar.HangoutLink = event.HangoutLink schedule, err := h.store.Schedule.Update(h.repo.DB(), existedEv) if err != nil { h.logger.Error(err, "can't update schedule") return err } // update discord event if schedule.DiscordEvent != nil { _, err = h.service.Discord.UpdateEvent(schedule) if err != nil { h.logger.Error(err, "can't update discord event") // return err } } return nil } func (h *handler) handleNewEvent(event *n8nCalendarEvent) error { // first, we create a schedule record in db sch := &model.Schedule{ GoogleCalendar: &model.ScheduleGoogleCalendar{ GoogleCalendarID: event.ID, Description: event.Description, HangoutLink: event.HangoutLink, }, Name: event.Summary, StartTime: &event.Start.DateTime, EndTime: &event.End.DateTime, } schedule, err := h.store.Schedule.Create(h.repo.DB(), sch) if err != nil { h.logger.Error(err, "can't create schedule") return err } // this case, we create a discord event // check if time in the past if event.ShouldSyncDiscord == "true" { if !schedule.StartTime.Before(time.Now()) { discordEvent, err := h.service.Discord.CreateEvent(schedule) if err != nil { h.logger.Error(err, "can't create discord event") // return err } else { _, err = h.store.Schedule.CreateDiscord(h.repo.DB(), &model.ScheduleDiscordEvent{ ScheduleID: schedule.ID, DiscordEventID: discordEvent.ID, VoiceChannelID: discordEvent.ChannelID, }) if err != nil { h.logger.Error(err, "can't create discord event") } } } } return nil }
```

# pkg/handler/webhook/onleave.go

```go
package webhook import ( "fmt" "strings" "time" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" ) type OnLeaveData struct { ParentID int64 Name string Type string StartDate time.Time EndDate time.Time Shift string Title string Description string AssigneeIDs []int CreatorBasecampID int ApproverBasecampID int AssigneeBasecampIDs []int CompletionSubscriberIDs []int } func parseOnLeaveDataFromMessage(todo *bcModel.Todo, msg model.BasecampWebhookMessage) (OnLeaveData, error) { data := OnLeaveData{} data.ParentID = msg.Recording.Parent.ID data.Title = msg.Recording.Title split := strings.Split(msg.Recording.Title, "|") if len(split) < 3 { return data, nil } // set name and off type data.Name = strings.TrimSpace(split[0]) data.Type = strings.TrimSpace(split[1]) // set start and end date times, err := timeutil.GetTimeRange(strings.TrimSpace(split[2])) if err != nil { return data, err } data.StartDate = *times[0] data.EndDate = *times[0] if len(times) == 2 { data.EndDate = *times[1] } // set shift if len(split) > 3 { data.Shift = strings.TrimSpace(split[3]) } // set email infos data.CreatorBasecampID = msg.Recording.Creator.ID data.ApproverBasecampID = msg.Creator.ID assigneeIds := []int{ msg.Creator.ID, msg.Recording.Creator.ID, consts.AutoBotID, } if todo != nil { data.Description = strings.TrimSuffix(strings.TrimPrefix(todo.Description, "<div>"), "</div>") data.CompletionSubscriberIDs = getSubscriberIDs(todo.CompletionSubscribers) for _, v := range todo.Assignees { assigneeIds = append(assigneeIds, v.ID) } } data.AssigneeIDs = assigneeIds return data, nil } func (h *handler) handleOnLeaveValidation(msg model.BasecampWebhookMessage) error { if h.config.Env == "prod" { if msg.Recording.Bucket.Name != "Woodland" { return nil } } projectID := msg.Recording.Bucket.ID recordingID := msg.Recording.ID var commentMsg bcModel.BasecampCommentMessage defer func() { h.worker.Enqueue(bcModel.BasecampCommentMsg, commentMsg) }() err := h.validateOnLeaveData(msg) if err != nil { errMsg := fmt.Sprintf( ` Your request has encountered an error: %v Your Name | Off | Date (in range, format dd/mm/yyyy) | Shift (if any) e.g: Huy Nguyen | Off | 29/01/2019 | Morning Nam Nguyen | Off | 29/01/2019 - 01/02/2020`, err.Error()) commentMsg = h.service.Basecamp.BuildCommentMessage(projectID, recordingID, errMsg, "") return err } commentMsg = h.service.Basecamp.BuildCommentMessage(projectID, recordingID, "Your format looks good to go ðŸ‘", "") return nil } func (h *handler) validateOnLeaveData(msg model.BasecampWebhookMessage) error { data, err := parseOnLeaveDataFromMessage(nil, msg) if err != nil { return err } // Validate if request belongs to the onLeave group onLeaveID := consts.OnleavePlaygroundID if h.config.Env == "prod" { onLeaveID = consts.OnleaveID } if data.ParentID != int64(onLeaveID) { list, err := h.service.Basecamp.Todo.GetList(msg.Recording.Parent.URL) if err != nil { return fmt.Errorf("cannot get todo list: %v", err.Error()) } if list.Parent.ID != onLeaveID { return fmt.Errorf("invalid group id: %v %v", list.Parent.ID, list.Parent.Title) } } // Validate title format split := strings.Split(msg.Recording.Title, "|") if len(split) < 3 { return fmt.Errorf("invalid title format: %v", msg.Recording.Title) } // Validate off type offtype := strings.ToLower(data.Type) if offtype != "off" && offtype != "remote" { return fmt.Errorf("invalid off type: %v (needs to be off or remote)", offtype) } // Validate time range if data.StartDate.Before(time.Now()) && !timeutil.IsSameDay(data.StartDate, time.Now()) { return fmt.Errorf("start date cannot be in the past: %v", timeutil.ParseTimeToDateFormat(&data.StartDate)) } if data.EndDate.Before(data.StartDate) { return fmt.Errorf("end date must be after start date: start date is %v - end date is %v", timeutil.ParseTimeToDateFormat(&data.StartDate), timeutil.ParseTimeToDateFormat(&data.EndDate)) } return nil } func (h *handler) handleApproveOnLeaveRequest(msg model.BasecampWebhookMessage) error { todo, err := h.service.Basecamp.Todo.Get(msg.Recording.URL) if err != nil { h.logger.Errorf(err, "failed to get basecamp todo: %v", err.Error()) return fmt.Errorf("failed to get basecamp todo: %v", err.Error()) } data, err := parseOnLeaveDataFromMessage(todo, msg) if err != nil { return err } r := model.OnLeaveRequest{ Type: data.Type, StartDate: &data.StartDate, EndDate: &data.EndDate, Shift: data.Shift, Title: data.Title, Description: data.Description, } // assign assignees id for _, assignee := range todo.Assignees { data.AssigneeBasecampIDs = append(data.AssigneeBasecampIDs, assignee.ID) } assignees, err := h.store.Employee.GetByBasecampIDs(h.repo.DB(), data.AssigneeBasecampIDs) if err != nil { h.logger.Errorf(err, "failed to get assignees with basecamp_ids", err.Error()) return fmt.Errorf("failed to get assignees with basecamp_ids %v: %v", data.AssigneeBasecampIDs, err.Error()) } for _, assignee := range assignees { r.AssigneeIDs = append(r.AssigneeIDs, assignee.ID.String()) } // assign creator id creator, err := h.store.Employee.OneByBasecampID(h.repo.DB(), data.CreatorBasecampID) if err != nil { h.logger.Errorf(err, "failed to get creator with basecamp_id", err.Error()) return fmt.Errorf("failed to get creator with basecamp_id %v: %v", data.CreatorBasecampID, err.Error()) } r.CreatorID = creator.ID // assign approver id approver, err := h.store.Employee.OneByBasecampID(h.repo.DB(), data.ApproverBasecampID) if err != nil { h.logger.Errorf(err, "failed to get approver with basecamp_id", err.Error()) return fmt.Errorf("failed to get approver with basecamp_id %v: %v", data.ApproverBasecampID, err.Error()) } r.ApproverID = approver.ID _, err = h.store.OnLeaveRequest.Create(h.repo.DB(), &r) if err != nil { h.logger.Errorf(err, "failed to create onLeaveRequest", err.Error()) return fmt.Errorf("failed to create onLeaveRequest: %v", err.Error()) } dateChunks := timeutil.ChunkDateRange(data.StartDate, data.EndDate) for _, dateChunk := range dateChunks { startDate := dateChunk[0] endDate := dateChunk[1] basecampSchedule := bcModel.ScheduleEntry{ Summary: fmt.Sprintf("âš ï¸ %s", data.Title), StartsAt: startDate.Format(time.RFC3339), EndsAt: endDate.Format(time.RFC3339), AllDay: true, Description: r.Description, } woodlandID := consts.PlaygroundID woodlandScheduleID := consts.PlaygroundScheduleID opsTeamIDs := []int{consts.NamNguyenBasecampID} if h.config.Env == "prod" { woodlandID = consts.WoodlandID woodlandScheduleID = consts.WoodlandScheduleID opsTeamIDs = []int{consts.HuyNguyenBasecampID, consts.GiangThanBasecampID} if msg.Recording.Bucket.Name != "Woodland" { return nil } } var subscriberIDs []int subscriberIDs = append(subscriberIDs, data.AssigneeIDs...) subscriberIDs = append(subscriberIDs, data.CompletionSubscriberIDs...) subscriberIDs = append(subscriberIDs, opsTeamIDs...) se, err := h.service.Basecamp.Schedule.CreateScheduleEntry(int64(woodlandID), woodlandScheduleID, basecampSchedule) if err != nil { h.logger.Errorf(err, "failed to create basecamp schedule", err.Error()) return fmt.Errorf("failed to create basecamp schedule: %v", err.Error()) } if len(data.AssigneeIDs) > 0 { err = h.service.Basecamp.Subscription.Subscribe( se.SubscriptionUrl, &bcModel.SubscriptionList{Subscriptions: subscriberIDs}, ) if err != nil { h.logger.Errorf(err, "failed to set basecamp event subscriber", err.Error()) return err } } } return nil } // Get list IDs from list subscribers func getSubscriberIDs(list []bcModel.Subscriber) []int { res := make([]int, len(list)) for i := range list { res[i] = list[i].ID } return res }
```

# pkg/handler/webhook/request.go

```go
package webhook import "time" type n8nCalendarEvent struct { ID string `json:"id"` Kind string `json:"kind"` Created time.Time `json:"created"` Updated time.Time `json:"updated"` Summary string `json:"summary"` Creator struct { Email string `json:"email"` } `json:"creator"` Description string `json:"description"` HangoutLink string `json:"hangoutLink"` Organizer struct { Email string `json:"email"` DisplayName string `json:"displayName"` Self bool `json:"self"` } `json:"organizer"` Start struct { DateTime time.Time `json:"dateTime"` Timezone string `json:"timezone"` } `json:"start"` End struct { DateTime time.Time `json:"dateTime"` Timezone string `json:"timezone"` } `json:"end"` Attendees []struct { Email string `json:"email"` ResponseStatus string `json:"responseStatus"` } `json:"attendees"` ShouldSyncDiscord string `json:"shouldSyncDiscord"` } type n8nEvent struct { Kind string `json:"kind"` CalendarData *n8nCalendarEvent `json:"calendarData"` ShouldSyncDiscord string `json:"shouldSyncDiscord"` }
```

# pkg/handler/webhook/webhook.go

```go
package webhook import ( "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/worker" ) type handler struct { store *store.Store service *service.Service controller *controller.Controller logger logger.Logger repo store.DBRepo config *config.Config worker *worker.Worker } // New returns a handler func New(ctrl *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config, worker *worker.Worker) IHandler { return &handler{ store: store, repo: repo, service: service, logger: logger, config: cfg, worker: worker, controller: ctrl, } }
```

# pkg/handler/youtube/file.go

```go
package youtube import ( "os" ) func (h *handler) createFile(path, fileName, content string) error { if _, err := os.Stat(path); os.IsNotExist(err) { if err := os.MkdirAll(path, os.ModePerm); err != nil { return err } } newFile := path + "/" + fileName file, err := os.Create(newFile) if err != nil { return err } defer file.Close() _, err = file.WriteString(content) return err }
```

# pkg/handler/youtube/interface.go

```go
package youtube import "github.com/gin-gonic/gin" type IHandler interface { LatestBroadcast(c *gin.Context) TranscribeBroadcast(c *gin.Context) }
```

# pkg/handler/youtube/youtube.go

```go
package youtube import ( "fmt" "net/http" "os" "strconv" "strings" "time" "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/service/git" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/view" ) type handler struct { controller *controller.Controller store *store.Store service *service.Service logger logger.Logger repo store.DBRepo config *config.Config } func New(controller *controller.Controller, store *store.Store, repo store.DBRepo, service *service.Service, logger logger.Logger, cfg *config.Config) IHandler { return &handler{ controller: controller, store: store, repo: repo, service: service, logger: logger, config: cfg, } } func (h *handler) LatestBroadcast(c *gin.Context) { broadcast, err := h.service.Youtube.GetLatestBroadcast() if err != nil { h.logger.Error(err, "failed to get latest broadcast") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } c.JSON(http.StatusOK, view.CreateResponse[any](broadcast, nil, nil, nil, "")) } func (h *handler) TranscribeBroadcast(c *gin.Context) { broadcast, err := h.service.Youtube.GetLatestBroadcast() if err != nil { h.logger.Error(err, "failed to get latest broadcast") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } link := "https://www.youtube.com/live/" + broadcast.Id broadCastTime := strings.Split(broadcast.Snippet.ActualStartTime, "T") broadCastDate := time.Now().Format("2006-01-02") if len(broadCastTime) == 2 { broadCastDate = broadCastTime[0] broadCastDate = strings.ReplaceAll(broadCastDate, "-", "") } content, err := h.service.Dify.SummarizeOGIFMemo(link) if err != nil { h.logger.Error(err, "failed to summarize OGIF memo") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } gitSvc := git.New("https://github.com/dwarvesf/brainery", "lmquang", h.config.Github.Token) branch := fmt.Sprintf("docs/ogif-memo-summary-%v", time.Now().Format("20060102")) if err := gitSvc.CreateBranch(branch); err != nil { h.logger.Error(err, "failed to create branch") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } fileNum := 1 // check the latest file path := gitSvc.Dest() + "/updates/ogif" // walk through the directory to get the latest file // if the file is not exist, create the first file if _, err := os.Stat(path); os.IsNotExist(err) { if err := os.MkdirAll(path, os.ModePerm); err != nil { h.logger.Error(err, "failed to create directory") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } } else { files, err := os.ReadDir(path) if err != nil { h.logger.Error(err, "failed to read directory") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // get the latest file number follow this format: 1-ogif-office-hours-20210101.md for _, file := range files { if file.IsDir() { continue } name := file.Name() if strings.Contains(name, "ogif-office-hours") { num := strings.Split(name, "-")[0] if n, err := strconv.Atoi(num); err == nil { if n > fileNum { fileNum = n } } } } fileNum++ } if err := h.createFile(gitSvc.Dest()+"/updates/ogif", fmt.Sprintf("%v-ogif-office-hours-%v.md", fileNum, broadCastDate), content); err != nil { h.logger.Error(err, "failed to create file") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if err := gitSvc.Commit(fmt.Sprintf("docs: ogif memo summary %v", broadCastDate)); err != nil { h.logger.Error(err, "failed to commit") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if err := gitSvc.Push(); err != nil { h.logger.Error(err, "failed to push") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } prNumber, err := gitSvc.CreatePullRequest("dwarvesf", "brainery", branch, "main", fmt.Sprintf("docs: ogif memo summary %v", broadCastDate), "") if err != nil { h.logger.Error(err, "failed to create PR") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } if err := gitSvc.RequestReview( "dwarvesf", "brainery", *prNumber, h.config.Github.BraineryReviewers, ); err != nil { h.logger.Error(err, "failed to request review") c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, nil, err, nil, "")) return } // remove the directory after finish if err := os.RemoveAll(gitSvc.Dest()); err != nil { h.logger.Error(err, "failed to remove directory") } c.JSON(http.StatusOK, view.CreateResponse[any](nil, nil, nil, nil, "ok")) }
```

# pkg/model/accounting.go

```go
package model import ( "time" "gorm.io/datatypes" ) const ( AccountingSE = "SE" AccountingOP = "OP" AccountingOV = "OV" AccountingCA = "CA" AccountingIncome = "In" AccountingOfficeSupply = "Office Supply" AccountingOfficeServices = "Office Services" AccountingOfficeSpace = "Office Space" AccountingIn = "In" AccountingTools = "Tools" AccountingAssets = "Assets" AccountingOps = "Payroll for Operation" AccountingRec = "Payroll for Recruit" AccountingEng = "Payroll for Engineer" AccountingMar = "Payroll for Marketing" AccountingVen = "Payroll for Venture" AccountingMng = "Payroll for Middle Mngr" AccountingSal = "Payroll for Sales" AccountingDsg = "Payroll for Design" AccountingCommLead = "Commission for Lead" AccountingCommSales = "Commission for Sales" AccountingCommAccount = "Commission for Account" AccountingCommHiring = "Commission for Hiring" ) // AccountingTransaction -- type AccountingTransaction struct { BaseModel Name string `json:"name"` Date *time.Time `json:"date"` Amount float64 `json:"amount"` ConversionAmount VietnamDong `json:"conversion_amount"` Organization string `json:"organization"` Category string `json:"category_name"` Type string `json:"type"` Currency string `json:"currency_name"` CurrencyID *UUID `json:"-"` ConversionRate float64 `json:"conversion_rate"` Metadata datatypes.JSON `json:"metadata"` CurrencyInfo *Currency `json:"currency" gorm:"foreignkey:ID;association_foreignkey:CurrencyID"` AccountingCategory *AccountingCategory `json:"category" gorm:"foreignkey:Type;association_foreignkey:Type"` } type AccountingCategory struct { BaseModel Name string `json:"name"` Type string `json:"type"` } type SheetExpense struct { Name string `json:"name"` Amount string `json:"amount"` Category string `json:"category"` Currency string `json:"currency"` Date string `json:"date"` } type AccountingMetadata struct { Source string `json:"source"` ID string `json:"id"` }
```

# pkg/model/action_item_snapshot.go

```go
package model type ActionItemSnapshot struct { BaseModel ProjectID UUID AuditCycleID UUID High int64 Medium int64 Low int64 } func CompareActionItemSnapshot(old, new *ActionItemSnapshot) bool { return old.High == new.High && old.Medium == new.Medium && old.Low == new.Low }
```

# pkg/model/action_items.go

```go
package model import ( "strings" "github.com/dstotijn/go-notion" ) type ActionItemStatus string // values for action_item_status const ( ActionItemStatusPending ActionItemStatus = "pending" ActionItemStatusInProgess ActionItemStatus = "in-progress" ActionItemStatusDone ActionItemStatus = "done" ) // IsValid validation for ActionItemStatus func (e ActionItemStatus) IsValid() bool { switch e { case ActionItemStatusPending, ActionItemStatusInProgess, ActionItemStatusDone: return true } return false } // String returns the string representation func (e ActionItemStatus) String() string { return string(e) } type ActionItemPriority string // values for action_item_priority const ( ActionItemPriorityHigh ActionItemPriority = "high" ActionItemPriorityLow ActionItemPriority = "low" ActionItemPriorityMedium ActionItemPriority = "medium" ) // IsValid validation for ActionItemPriority func (e ActionItemPriority) IsValid() bool { switch e { case ActionItemPriorityHigh, ActionItemPriorityLow, ActionItemPriorityMedium: return true } return false } // String returns the string representation func (e ActionItemPriority) String() string { return string(e) } type ActionItem struct { BaseModel ProjectID UUID NotionDBID UUID PICID UUID AuditCycleID *UUID Name string Description string NeedHelp bool Priority *ActionItemPriority Status ActionItemStatus } func ActionItemToMap(actionItems []*ActionItem) map[UUID]*ActionItem { rs := map[UUID]*ActionItem{} for _, s := range actionItems { rs[s.ID] = s } return rs } func NewActionItemFromNotionPage(page notion.Page, picID UUID, notionDB string) *ActionItem { properties := page.Properties.(notion.DatabasePageProperties) rs := &ActionItem{ BaseModel: BaseModel{ID: MustGetUUIDFromString(page.ID)}, NotionDBID: MustGetUUIDFromString(notionDB), Status: ActionItemStatus(strings.ReplaceAll(strings.ToLower(properties["Status"].Status.Name), " ", "-")), // TODO:Description: } if properties["Project"].Relation != nil && len(properties["Project"].Relation) > 0 { rs.ProjectID = MustGetUUIDFromString(properties["Project"].Relation[0].ID) } if !picID.IsZero() { rs.PICID = picID } if properties["NEED HELP???"].Checkbox != nil { rs.NeedHelp = *properties["NEED HELP???"].Checkbox } if properties["Name"].Title != nil && len(properties["Name"].Title) > 0 { rs.Name = properties["Name"].Title[0].PlainText } if properties["Priority"].Select != nil { priority := MappingAuditActionPriority(properties["Priority"].Select.Name) if priority.IsValid() { rs.Priority = &priority } } if len(properties["ðŸ‘ Audit Changelog"].Relation) > 0 { auditCycleID := MustGetUUIDFromString(properties["ðŸ‘ Audit Changelog"].Relation[0].ID) rs.AuditCycleID = &auditCycleID } return rs } func MappingAuditActionPriority(auditGrade string) ActionItemPriority { switch auditGrade { case "High": return ActionItemPriorityHigh case "Medium": return ActionItemPriorityMedium case "Low": return ActionItemPriorityLow default: return "" } } func CompareActionItem(old, new *ActionItem) bool { return ((old.Priority == nil && new.Priority == nil) || (old.Priority != nil && new.Priority != nil && *old.Priority == *new.Priority)) && ((old.AuditCycleID == nil && new.AuditCycleID == nil) || (old.AuditCycleID != nil && new.AuditCycleID != nil && *old.AuditCycleID == *new.AuditCycleID)) && old.ProjectID == new.ProjectID && old.NotionDBID == new.NotionDBID && old.PICID == new.PICID && old.Name == new.Name && old.Description == new.Description && old.NeedHelp == new.NeedHelp && old.Status == new.Status }
```

# pkg/model/answer_drafts.go

```go
package model // AnswerDraft model for answer_drafts table type AnswerDraft struct { BaseModel QuestionID UUID AnswerBy UUID Answer string Note string }
```

# pkg/model/answer.go

```go
package model // Answer model for answers table type Answer struct { BaseModel QuestionID UUID AnswerBy UUID Answer string Note string }
```

# pkg/model/api_key_roles.go

```go
package model type APIKeyRole struct { BaseModel APIKeyID UUID `gorm:"column:api_key_id;default:null"` RoleID UUID ApiKey APIKey Role Role }
```

# pkg/model/api_key.go

```go
package model type APIKey struct { BaseModel ClientID string SecretKey string Status APIKeyStatus ApikeyRoles []APIKeyRole Roles []Role `gorm:"many2many:api_key_roles;"` } type APIKeyStatus string // values for working_status const ( ApikeyStatusValid APIKeyStatus = "valid" ApikeyStatusInvalid APIKeyStatus = "invalid" ) // IsValid validation for APIKeyStatus func (e APIKeyStatus) IsValid() bool { switch e { case ApikeyStatusValid, ApikeyStatusInvalid: return true } return false } type TokenType string const ( TokenTypeJWT TokenType = "JWT" TokenTypeAPIKey TokenType = "ApiKey" ) func (t TokenType) String() string { return string(t) }
```

# pkg/model/asset.go

```go
package model import "time" type Asset struct { BaseModel Name string Price int64 Quantity string Note string Location string PurchaseDate *time.Time }
```

# pkg/model/audit_action_item.go

```go
package model type AuditActionItem struct { BaseModel AuditID UUID ActionItemID UUID } type AuditAction struct { AuditID UUID ActionItemID UUID } func AuditActionItemToMap(aais []*AuditActionItem) map[AuditAction]AuditActionItem { rs := make(map[AuditAction]AuditActionItem) for _, aai := range aais { rs[AuditAction{AuditID: aai.AuditID, ActionItemID: aai.ActionItemID}] = *aai } return rs }
```

# pkg/model/audit_cycles.go

```go
package model import ( "fmt" "strings" "time" "github.com/dstotijn/go-notion" ) type AuditStatus string // values for audit_status const ( AuditStatusPending AuditStatus = "pending" AuditStatusAudited AuditStatus = "audited" ) // IsValid validation for AuditStatus func (e AuditStatus) IsValid() bool { switch e { case AuditStatusPending, AuditStatusAudited: return true } return false } // String returns the string representation func (e AuditStatus) String() string { return string(e) } type AuditFlag string // values for audit_flag const ( AuditFlagRed AuditFlag = "red" AuditFlagYellow AuditFlag = "yellow" AuditFlagGreen AuditFlag = "green" AuditFlagNone AuditFlag = "none" ) // IsValid validation for AuditFlag func (e AuditFlag) IsValid() bool { switch e { case AuditFlagRed, AuditFlagYellow, AuditFlagGreen, AuditFlagNone: return true } return false } // String returns the string representation func (e AuditFlag) String() string { return string(e) } type AuditCycle struct { BaseModel ProjectID UUID NotionDBID UUID HealthAuditID *UUID ProcessAuditID *UUID BackendAuditID *UUID FrontendAuditID *UUID SystemAuditID *UUID MobileAuditID *UUID BlockchainAuditID *UUID Cycle int64 AverageScore float64 Status AuditStatus Flag AuditFlag Quarter string ActionItemHigh int64 ActionItemMedium int64 ActionItemLow int64 SyncAt *time.Time Project *Project } func AuditCycleToMap(auditCycles []*AuditCycle) map[UUID]*AuditCycle { rs := map[UUID]*AuditCycle{} for _, s := range auditCycles { rs[s.ID] = s } return rs } func NewAuditCycleFromNotionPage(page *notion.Page, notionDBID string) *AuditCycle { properties := page.Properties.(notion.DatabasePageProperties) now := time.Now() rs := &AuditCycle{ BaseModel: BaseModel{ID: MustGetUUIDFromString(page.ID)}, NotionDBID: MustGetUUIDFromString(notionDBID), Status: AuditStatusPending, Flag: AuditFlag(strings.ToLower(properties["Flag"].Status.Name)), SyncAt: &now, } if properties["Score"].Number != nil { rs.AverageScore = *properties["Score"].Number } if properties["Cycle"].Number != nil { rs.Cycle = int64(*properties["Cycle"].Number) } if properties["Date"].Date != nil { date := properties["Date"].Date.Start.Time rs.Quarter = fmt.Sprintf("%d/Q%d", date.Year(), (date.Month()-1)/3+1) } else { date := time.Now() rs.Quarter = fmt.Sprintf("%d/Q%d", date.Year(), (date.Month()-1)/3+1) } if properties["Project"].Relation != nil && len(properties["Project"].Relation) > 0 { rs.ProjectID = MustGetUUIDFromString(properties["Project"].Relation[0].ID) } return rs } func AuditMap(ac AuditCycle) map[UUID]AuditType { rs := make(map[UUID]AuditType) if !ac.HealthAuditID.IsZero() { rs[*ac.HealthAuditID] = AuditTypeHealth } if !ac.ProcessAuditID.IsZero() { rs[*ac.ProcessAuditID] = AuditTypeProcess } if !ac.BackendAuditID.IsZero() { rs[*ac.BackendAuditID] = AuditTypeBackend } if !ac.FrontendAuditID.IsZero() { rs[*ac.FrontendAuditID] = AuditTypeFrontend } if !ac.SystemAuditID.IsZero() { rs[*ac.SystemAuditID] = AuditTypeSystem } if !ac.MobileAuditID.IsZero() { rs[*ac.MobileAuditID] = AuditTypeMobile } if !ac.BlockchainAuditID.IsZero() { rs[*ac.BlockchainAuditID] = AuditTypeBlockchain } return rs } func CheckTypeExists(auditMap map[UUID]AuditType, auditType AuditType) UUID { for k, v := range auditMap { if v == auditType { return k } } return UUID{} } func CompareAuditCycle(currAC *AuditCycle, newAC *AuditCycle) bool { return currAC.ProjectID == newAC.ProjectID && currAC.NotionDBID == newAC.NotionDBID && currAC.Cycle == newAC.Cycle && currAC.AverageScore == newAC.AverageScore && currAC.Flag == newAC.Flag && currAC.Quarter == newAC.Quarter }
```

# pkg/model/audit_item.go

```go
package model import ( "strings" "github.com/dstotijn/go-notion" ) type AuditItemSeverity string // values for audit_item_severity const ( AuditItemSeverityHigh AuditItemSeverity = "high" AuditItemSeverityLow AuditItemSeverity = "low" AuditItemSeverityMedium AuditItemSeverity = "medium" ) // IsValid validation for AuditItemSeverity func (e AuditItemSeverity) IsValid() bool { switch e { case AuditItemSeverityHigh, AuditItemSeverityLow, AuditItemSeverityMedium: return true } return false } // String returns the string representation func (e AuditItemSeverity) String() string { return string(e) } // values for audit_area field const ( AuditItemAreaDelivery string = "Delivery performance" AuditItemAreaQuality string = "Quality assurance" AuditItemAreaCollaborating string = "Collaborating" AuditItemAreaFeedback string = "Engineering feedback" ) type AuditItem struct { BaseModel AuditID UUID NotionDBID UUID Name string Area string Requirements string Grade int64 Severity *AuditItemSeverity Notes string ActionItemID *UUID } func NewAuditItemFromNotionPage(page notion.Page, auditID string, notionDBID string) *AuditItem { properties := page.Properties.(notion.DatabasePageProperties) rs := &AuditItem{ BaseModel: BaseModel{ID: MustGetUUIDFromString(page.ID)}, AuditID: MustGetUUIDFromString(auditID), Name: properties["Name"].Title[0].PlainText, NotionDBID: MustGetUUIDFromString(notionDBID), } if properties["Area"].Select != nil { rs.Area = properties["Area"].Select.Name } if properties["Grade"].Select != nil { rs.Grade = MappingAuditItemGrade(properties["Grade"].Select.Name) } if properties["Severity"].Select != nil { severity := AuditItemSeverity(strings.ToLower(properties["Severity"].Select.Name)) if severity.IsValid() { rs.Severity = &severity } } if len(properties["Requirements"].RichText) > 0 { rs.Requirements = properties["Requirements"].RichText[0].PlainText } if len(properties["Notes"].RichText) > 0 { rs.Notes = properties["Notes"].RichText[0].PlainText } return rs } func MappingAuditItemGrade(auditGrade string) int64 { switch auditGrade { case "Very Good": return 5 case "Good": return 4 case "Acceptable": return 3 case "Poor": return 2 case "Very Poor": return 1 default: return 0 } } func CompareAuditItem(currAuditItem *AuditItem, newAuditItem *AuditItem) bool { return ((currAuditItem.Severity == nil && newAuditItem.Severity == nil) || (currAuditItem.Severity != nil && newAuditItem.Severity != nil && *currAuditItem.Severity == *newAuditItem.Severity)) && currAuditItem.Name == newAuditItem.Name && currAuditItem.Area == newAuditItem.Area && currAuditItem.Requirements == newAuditItem.Requirements && currAuditItem.Grade == newAuditItem.Grade && currAuditItem.Notes == newAuditItem.Notes && currAuditItem.AuditID == newAuditItem.AuditID && currAuditItem.NotionDBID == newAuditItem.NotionDBID } func AuditItemToMap(ai []*AuditItem) map[UUID]AuditItem { rs := make(map[UUID]AuditItem) for _, item := range ai { rs[item.ID] = *item } return rs }
```

# pkg/model/audit_participants.go

```go
package model type AuditParticipant struct { BaseModel AuditID UUID EmployeeID UUID } func AuditParticipantToMap(auditParticipant []*AuditParticipant) map[UUID]AuditParticipant { rs := make(map[UUID]AuditParticipant) for _, ap := range auditParticipant { rs[ap.EmployeeID] = *ap } return rs }
```

# pkg/model/audits.go

```go
package model import ( "strings" "time" "github.com/dstotijn/go-notion" ) type AuditType string // values for audit_type const ( AuditTypeHealth AuditType = "engineering-health" AuditTypeProcess AuditType = "engineering-process" AuditTypeFrontend AuditType = "frontend" AuditTypeBackend AuditType = "backend" AuditTypeSystem AuditType = "system" AuditTypeMobile AuditType = "mobile" AuditTypeBlockchain AuditType = "blockchain" ) // IsValid validation for AuditType func (e AuditType) IsValid() bool { switch e { case AuditTypeHealth, AuditTypeProcess, AuditTypeFrontend, AuditTypeBackend, AuditTypeSystem, AuditTypeMobile, AuditTypeBlockchain: return true } return false } // String returns the string representation func (e AuditType) String() string { return string(e) } type Audit struct { BaseModel ProjectID UUID NotionDBID UUID AuditorID UUID Name string Type AuditType Score float64 Status AuditStatus Flag AuditFlag ActionItem int64 Duration float64 AuditedAt *time.Time SyncAt *time.Time } func NewAuditFromNotionPage(page notion.Page, projectID string, auditorID UUID, flag AuditFlag, notionDBID string) *Audit { properties := page.Properties.(notion.DatabasePageProperties) now := time.Now() rs := &Audit{ BaseModel: BaseModel{ID: MustGetUUIDFromString(page.ID)}, NotionDBID: MustGetUUIDFromString(notionDBID), Name: properties["Name"].Title[0].PlainText, SyncAt: &now, Flag: flag, } if !auditorID.IsZero() { rs.AuditorID = auditorID } if properties["Score"].Number != nil { rs.Score = *properties["Score"].Number rs.Status = AuditStatusAudited } else { rs.Status = AuditStatusPending } if properties["Duration (hours)"].Number != nil { rs.Duration = *properties["Duration (hours)"].Number } if properties["Date"].Date != nil { rs.AuditedAt = &properties["Date"].Date.Start.Time } if len(properties["Name"].Title) > 0 { if MappingAuditType(properties["Name"].Title[0].PlainText) != "" { rs.Type = MappingAuditType(properties["Name"].Title[0].PlainText) } else { return nil } } else { return nil } if projectID != "" { rs.ProjectID = MustGetUUIDFromString(projectID) } return rs } func MappingAuditType(auditType string) AuditType { switch strings.ToLower(auditType) { case "engineering health checklist": return AuditTypeHealth case "engineering process checklist": return AuditTypeProcess case "frontend checklist": return AuditTypeFrontend case "backend checklist": return AuditTypeBackend case "system checklist": return AuditTypeSystem case "mobile checklist": return AuditTypeMobile case "blockchain checklist": return AuditTypeBlockchain } return "" } func CompareAudit(currAudit Audit, newAudit Audit) bool { return ((currAudit.AuditedAt == nil && newAudit.AuditedAt == nil) || (currAudit.AuditedAt != nil && newAudit.AuditedAt != nil && currAudit.AuditedAt.Equal(*newAudit.AuditedAt))) && currAudit.ProjectID == newAudit.ProjectID && currAudit.NotionDBID == newAudit.NotionDBID && currAudit.AuditorID == newAudit.AuditorID && currAudit.Name == newAudit.Name && currAudit.Type == newAudit.Type && currAudit.Score == newAudit.Score && currAudit.Status == newAudit.Status && currAudit.Flag == newAudit.Flag && currAudit.Duration == newAudit.Duration }
```

# pkg/model/auth.go

```go
package model import ( "github.com/golang-jwt/jwt/v4" ) // AuthenticationInfo .. type AuthenticationInfo struct { jwt.StandardClaims UserID string `json:"id"` Avatar string `json:"avatar"` Email string `json:"email"` } type CurrentLoggedUserInfo struct { UserID string Permissions map[string]string Projects map[UUID]*Project Role string }
```

# pkg/model/bank_account.go

```go
package model // BankAccount contain company information type BankAccount struct { BaseModel AccountNumber string BankName string OwnerName string Address *string SwiftCode string RoutingNumber string Name string UKSortCode string IntermediaryBankName string IntermediaryBankAddress string CurrencyID UUID Currency *Currency }
```

# pkg/model/banks.go

```go
package model type Bank struct { BaseModel Name string Code string Bin string ShortName string Logo string SwiftCode string }
```

# pkg/model/base_salary.go

```go
package model import "time" type BaseSalary struct { BaseModel EmployeeID UUID `json:"employee_id"` Employee *Employee ContractAmount int64 `json:"contract_amount"` CompanyAccountAmount int64 `json:"company_account_amount"` PersonalAccountAmount int64 `json:"personal_account_amount"` InsuranceAmount VietnamDong `json:"insurance_amount"` Type string `json:"type"` Category string `json:"category"` CurrencyID UUID `json:"currency_id"` Currency *Currency Batch int EffectiveDate *time.Time `json:"effective_date"` } func (BaseSalary) TableName() string { return "base_salaries" }
```

# pkg/model/base.go

```go
package model import ( "time" "gorm.io/gorm" ) // BaseModel base model for domain type type BaseModel struct { ID UUID `sql:",type:uuid" json:"id" gorm:"default:uuid()"` CreatedAt time.Time `sql:"default:now()" json:"createdAt"` UpdatedAt *time.Time `sql:"default:now()" json:"updatedAt"` DeletedAt *gorm.DeletedAt `json:"deletedAt,omitempty"` } // BeforeCreate prepare data before create data // func (m *BaseModel) BeforeCreate(tx *gorm.DB) (err error) { // m.ID = NewUUID() // m.CreatedAt = time.Now() // return // } // BeforeUpdate prepare data before create data func (m *BaseModel) BeforeUpdate(tx *gorm.DB) (err error) { tx.Statement.SetColumn("updated_at", time.Now()) return }
```

# pkg/model/basecamp.go

```go
package model import "time" // BasecampRecording is a data structure define basecamp todo type BasecampRecording struct { ID int `json:"id,omitempty"` Status string `json:"status,omitempty"` CreatedAt time.Time `json:"created_at,omitempty"` UpdatedAt time.Time `json:"updated_at,omitempty"` Title string `json:"title,omitempty"` URL string `json:"url,omitempty"` Parent BasecampParent `json:"parent,omitempty"` Creator BasecampUser `json:"creator,omitempty"` Bucket BasecampBucket `json:"bucket,omitempty"` Content string `json:"content,omitempty"` } type BasecampParent struct { ID int64 `json:"id,omitempty"` Title string `json:"title,omitempty"` URL string `json:"url,omitempty"` } type BasecampUser struct { ID int `json:"id,omitempty"` Email string `json:"email_address,omitempty"` Name string `json:"name,omitempty"` } // BasecampBucket is type BasecampBucket struct { ID int `json:"id,omitempty"` Name string `json:"name,omitempty"` Type string `json:"type,omitempty"` }
```

# pkg/model/brainery_log.go

```go
package model import ( "time" "github.com/shopspring/decimal" ) type BraineryLog struct { BaseModel Title string URL string GithubID string DiscordID string EmployeeID UUID Tags JSONArrayString PublishedAt *time.Time Reward decimal.Decimal }
```

# pkg/model/cached_payroll.go

```go
package model import ( "gorm.io/datatypes" "gorm.io/gorm" ) type CachedPayroll struct { ID UUID `sql:",type:uuid" json:"id"` Month int `json:"month"` Year int `json:"year"` Batch int `json:"batch"` Payrolls datatypes.JSON `json:"payrolls"` } func (p *CachedPayroll) BeforeCreate(scope *gorm.DB) error { p.ID = NewUUID() return nil } func (CachedPayroll) TableName() string { return "cached_payrolls" }
```

# pkg/model/candidate.go

```go
package model import ( "strings" "time" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" ) type CandidateStatus string const ( ApproachCandidateStatus CandidateStatus = "approach" OfferedCandidateStatus CandidateStatus = "offered" FailedCandidateStatus CandidateStatus = "failed" HiredCandidateStatus CandidateStatus = "hired" RejectCandidateStatus CandidateStatus = "reject" ) type Candidate struct { BaseModel Name string `json:"name"` Email string `json:"email"` Detail string `json:"detail"` Note string `json:"-" gorm:"-"` CVUrl string `json:"cv_url"` Role string `json:"role"` Source string `json:"source"` Type HiringType `json:"type"` Status CandidateStatus `json:"status"` Phone string `json:"phone"` CCAT int `gorm:"column:CCAT" json:"CCAT"` EPP int `gorm:"column:EPP" json:"EPP"` IsReferral bool `json:"is_referral"` ReferralInfo JSON `json:"referral_info"` BasecampTodoID int `json:"basecamp_todo_id"` OfferSalary int `json:"offer_salary"` OfferStartDate *time.Time `json:"offer_start_date"` ProbationDuration int `json:"probation_duration"` IsEmailSent bool `json:"is_email_sent"` OnboardTodoID int `json:"onboard_todo_id"` PdfFile []byte `json:"-" gorm:"-"` GroupRole string `json:"-" gorm:"-"` DisplayName string `json:"-" gorm:"-"` DisplayStartDate string `json:"-" gorm:"-"` DisplaySalary string `json:"-" gorm:"-"` } type ReferralInfo struct { Name string `json:"name"` Email string `json:"email"` PhoneNumber string `json:"phone_number"` } func (r Candidate) FindHiringInCharge() int { switch r.Role { case "Backend": return consts.HuyNguyenBasecampID case "Frontend": return consts.HuyGiangBasecampID case "QA/QC": return consts.PhuongTruongBasecampID case "iOs", "MacOS": return consts.TrungPhanBasecampID case "Android": return consts.ThanhNguyenBasecampID case "Sales", "Client Partner": return consts.NamTranBasecampID case "Designer", "Ventures Designer", "Visual Designer": return consts.KhaiLeBasecampID } return consts.HuyNguyenBasecampID } func GroupRole(role string) string { switch role { case "Golang": return "Backend" case "React", "Vue": return "Frontend" case "undefined": return "Other" default: return role } } func DisplayRole(role string) string { switch role { case "Golang", "Backend": return "Back-end Engineer" case "React", "Vue", "Frontend": return "Front-end Engineer" default: return role } } func DisplayName(name string) string { parts := strings.Split(name, " ") return parts[len(parts)-1] }
```

# pkg/model/chapters.go

```go
package model type Chapter struct { BaseModel Name string `json:"name"` Code string `json:"code"` LeadID *UUID `json:"lead_id"` } // ToChapterMap create map from chapters func ToChapterMap(chapters []*Chapter) map[UUID]string { rs := map[UUID]string{} for _, s := range chapters { rs[s.ID] = s.Name } return rs }
```

# pkg/model/client_contact.go

```go
package model import ( "gorm.io/datatypes" ) // ClientContact is the model for the client_contact table type ClientContact struct { BaseModel Name string ClientID UUID Role string Emails datatypes.JSON IsMainContact bool } type ClientEmail struct { Emails []string `json:"emails"` }
```

# pkg/model/client.go

```go
package model // Client store information of a Client type Client struct { BaseModel Name string Description string RegistrationNumber string Avatar string Address string Country string City string Industry string Website string IsPublic bool Lat string Long string CompanySize string SolutionType string Contacts []ClientContact Projects []Project }
```

# pkg/model/commission.go

```go
package model import "github.com/shopspring/decimal" type CommissionModel struct { Beneficiary BasicEmployeeInfo CommissionType string CommissionRate decimal.Decimal Description string Sub *CommissionModel } type BasicEmployeeInfo struct { ID string FullName string DisplayName string Avatar string Username string ReferredBy string }
```

# pkg/model/communitynft.go

```go
package model // Client store information of a Client type NftMetadata struct { Name string Description string Image string BackgroundColor string Attributes []NftAttribute } type NftAttribute struct { TraitType string Value string }
```

# pkg/model/company_info.go

```go
package model import "github.com/jackc/pgtype" // CompanyInfo contain company information type CompanyInfo struct { BaseModel Name string `json:"name"` Description string `json:"description"` RegistrationNumber string `json:"registrationNumber"` Info pgtype.JSONB `json:"info"` } type CompanyContactInfo struct { Address string `json:"address"` Phone string `json:"phone"` }
```

# pkg/model/config.go

```go
package model const ( ConfigKeySalaryAdvanceMaxCap = "salary-advance-max-cap" ConfigKeyIcyUSDRate = "icy-usd-rate" ) type Config struct { BaseModel `json:"base_model"` Key string `json:"key"` Value string `json:"value"` } func (Config) TableName() string { return "configs" }
```

# pkg/model/content.go

```go
package model import ( "time" uuid "github.com/satori/go.uuid" "gorm.io/gorm" ) type Content struct { ID UUID `sql:",type:uuid" json:"id"` CreatedAt time.Time `sql:"default:now()" json:"createdAt"` UpdatedAt *time.Time `sql:"default:now()" json:"updatedAt"` DeletedAt *time.Time `json:"deletedAt,omitempty"` Type string `json:"type"` Extension string `json:"extension"` Path string `json:"path"` UploadBy UUID `json:"uploadBy"` TargetID UUID `json:"target_id"` TargetType string `json:"target_type"` AuthType string `json:"auth_type"` } // BeforeCreate prepare data before create data func (m *Content) BeforeCreate(tx *gorm.DB) error { m.ID = UUID(uuid.NewV4()) return nil } type ContentExtension string const ( ContentExtensionJpg ContentExtension = ".jpg" ContentExtensionPng ContentExtension = ".png" ContentExtensionPdf ContentExtension = ".pdf" ) type ContentTargetType string const ( ContentTargetTypeEmployee ContentTargetType = "employees" ContentTargetTypeProject ContentTargetType = "projects" ContentTargetTypeChangeLog ContentTargetType = "change-logs" ContentTargetTypeInvoice ContentTargetType = "invoices" ) type ContentType string const ( ContentTypeImage ContentType = "image" ContentTypeDoc ContentType = "doc" ) const ( MaxFileSizeImage = 2202099 MaxFileSizePdf = 5347737 ) func (e ContentExtension) Valid() bool { switch e { case ContentExtensionJpg, ContentExtensionPng, ContentExtensionPdf: return true } return false } func (e ContentExtension) ImageValid() bool { switch e { case ContentExtensionJpg, ContentExtensionPng: return true } return false } func (e ContentExtension) String() string { return string(e) } func (e ContentTargetType) Valid() bool { switch e { case ContentTargetTypeEmployee, ContentTargetTypeProject, ContentTargetTypeInvoice, ContentTargetTypeChangeLog: return true } return false } func (e ContentTargetType) String() string { return string(e) } func (e ContentType) Valid() bool { switch e { case ContentTypeImage, ContentTypeDoc: return true } return false } func (e ContentType) String() string { return string(e) } type DocumentType string const ( DocumentTypeAvatar DocumentType = "avatar" DocumentTypeIDPhotoFront DocumentType = "id_photo_front" DocumentTypeIDPhotoBack DocumentType = "id_photo_back" ) func (e DocumentType) Valid() bool { switch e { case DocumentTypeAvatar, DocumentTypeIDPhotoFront, DocumentTypeIDPhotoBack: return true } return false } func (e DocumentType) String() string { return string(e) }
```

# pkg/model/conversion_rate.go

```go
package model import "github.com/shopspring/decimal" type ConversionRate struct { BaseModel CurrencyID UUID Currency Currency ToUSD decimal.Decimal ToVND decimal.Decimal }
```

# pkg/model/country.go

```go
package model import ( "database/sql/driver" "encoding/json" "fmt" ) type Country struct { BaseModel Name string `json:"name"` Code string `json:"code"` Cities Cities `json:"cities"` } type City struct { Name string `json:"name"` Lat string `json:"lat"` Long string `json:"long"` } type Cities []City func (j Cities) Value() (driver.Value, error) { return json.Marshal(j) } func (j *Cities) Scan(value interface{}) error { if value == nil { *j = nil return nil } switch t := value.(type) { case []uint8: jsonData := value.([]uint8) if string(jsonData) == "null" { return nil } return json.Unmarshal(jsonData, j) default: return fmt.Errorf("could not scan type %T into json", t) } } func (j Cities) GetCity(city string) *City { for _, itm := range j { if itm.Name == city { return &itm } } return nil }
```

# pkg/model/currency.go

```go
package model import "github.com/dwarvesf/fortress-api/pkg/utils" type Currency struct { BaseModel Name string Symbol string Locale string Type string } type VietnamDong int64 func (vnd *VietnamDong) Scan(b interface{}) error { if b == nil { return nil } *vnd = VietnamDong(b.(int64)) vnd.format() return nil } func NewVietnamDong(i int64) VietnamDong { return VietnamDong(i) } func (vnd VietnamDong) String() string { return utils.FormatNumber(int64(vnd)) } func (vnd *VietnamDong) format() { *vnd = NewVietnamDong(int64(*vnd) / 1000 * 1000) } func (vnd *VietnamDong) Format() VietnamDong { vnd.format() return *vnd }
```

# pkg/model/dashboard.go

```go
package model import "time" type ProjectSize struct { ID UUID `json:"id"` Name string `json:"name"` Code string `json:"code"` Avatar string `json:"avatar"` Size int64 `json:"size"` } type WorkSurvey struct { EndDate time.Time `json:"endDate"` Workload float64 `json:"workload"` Deadline float64 `json:"deadline"` Learning float64 `json:"learning"` } type ActionItemReport struct { Quarter string `json:"quarter"` High int64 `json:"high"` Medium int64 `json:"medium"` Low int64 `json:"low"` } type AverageEngineeringHealth struct { Quarter string `json:"quarter"` Avg float64 `json:"avg"` } type GroupEngineeringHealth struct { Quarter string `json:"quarter"` Avg float64 `json:"avg"` Area string `json:"area"` } type GroupAudit struct { Quarter string `json:"quarter"` Frontend float64 `json:"frontend"` Backend float64 `json:"backend"` System float64 `json:"system"` Process float64 `json:"process"` Blockchain float64 `json:"blockchain"` Mobile float64 `json:"mobile"` } type AverageAudit struct { Quarter string `json:"quarter"` Avg float64 `json:"avg"` } type ActionItemSquashReport struct { SnapDate time.Time `json:"snapDate"` All int64 `json:"all"` High int64 `json:"high"` Medium int64 `json:"medium"` Low int64 `json:"low"` } type ResolvedActionItem struct { ID UUID `json:"id"` Quarter string `json:"quarter"` Count int64 `json:"count"` } type AuditSummary struct { Quarter string `json:"quarter"` ID UUID `json:"id"` Name string `json:"name"` Avatar string `json:"avatar"` Size int64 `json:"size"` Code string `json:"code"` High int64 `json:"high"` Medium int64 `json:"medium"` Low int64 `json:"low"` Done int64 `json:"done"` Health float64 `json:"health"` Audit float64 `json:"audit"` } type ResourceUtilization struct { Date time.Time `json:"date"` Staffed int `json:"staffed"` Internal int `json:"internal"` Available int `json:"available"` } type TotalWorkUnitDistribution struct { TotalLineManagerCount int64 TotalProjectHead int64 TotalLearning int64 TotalDevelopment int64 TotalManagement int64 TotalTraining int64 } type ManagementInfo struct { ID UUID `json:"id"` Name string `json:"name"` Code string `json:"code"` Avatar string `json:"avatar"` Type ProjectType `json:"type"` Status ProjectStatus `json:"status"` Position HeadPosition `json:"position"` }
```

# pkg/model/date_time.go

```go
package model import "time" type DateTime struct { Time time.Time `json:"time"` HasTime bool `json:"has_time"` }
```

# pkg/model/delivery_metric.go

```go
package model import ( "time" "github.com/shopspring/decimal" ) type DeliveryMetric struct { BaseModel Weight decimal.Decimal Effort decimal.Decimal Effectiveness decimal.Decimal EmployeeID UUID ProjectID UUID Date *time.Time Ref int } type TopWeightMetric struct { EmployeeID UUID SumWeight decimal.Decimal SumEffort decimal.Decimal } type DeliveryMetrics []DeliveryMetric type LeaderBoard struct { Date *time.Time Items []LeaderBoardItem } type MonthlyLeaderBoard struct { Date *time.Time Items []LeaderBoardItem } type LeaderBoardItem struct { EmployeeID string EmployeeName string Points decimal.Decimal Effectiveness decimal.Decimal DiscordID string DiscordUsername string Rank int } type WeeklyReport struct { LastWeek WeekReport `json:"last_week"` CurrentWeek WeekReport `json:"current_week"` TotalPointChangePercentage float32 `json:"total_point_change_percentage"` EffortChangePercentage float32 `json:"effort_change_percentage"` AvgPointChangePercentage float32 `json:"avg_point_change_percentage"` AvgEffortChangePercentage float32 `json:"avg_effort_change_percentage"` } type WeekReport struct { Date *time.Time `json:"date"` TotalPoints float32 `json:"total_points"` Effort float32 `json:"effort"` AvgPoint float32 `json:"avg_point"` AvgEffort float32 `json:"avg_effort"` } type MonthlyReport struct { Reports []MonthReport `json:"reports"` } type MonthReport struct { Month *time.Time `json:"date"` TotalWeight float32 `json:"total_weight"` Effort float32 `json:"effort"` AvgWeight float32 `json:"avg_weight"` AvgEffort float32 `json:"avg_effort"` AvgWeeklyWeight float32 `json:"avg_weekly_weight"` AvgWeeklyEffort float32 `json:"avg_weekly_effort"` TotalPointChangePercentage float32 `json:"total_point_change_percentage"` EffortChangePercentage float32 `json:"effort_change_percentage"` AvgWeightChangePercentage float32 `json:"avg_weight_change_percentage"` AvgEffortChangePercentage float32 `json:"avg_effort_change_percentage"` AvgWeeklyPointChangePercentage float32 `json:"avg_weekly_point_change_percentage"` AvgWeeklyEffortChangePercentage float32 `json:"avg_weekly_effort_change_percentage"` }
```

# pkg/model/discord_account.go

```go
package model import "github.com/lib/pq" type DiscordAccount struct { BaseModel DiscordID string DiscordUsername string `json:"discord_username"` MemoUsername string `json:"memo_username"` Roles pq.StringArray `json:"role" gorm:"type:text[]"` GithubUsername string `json:"github_username"` PersonalEmail string `json:"personal_email"` Employee *Employee `json:"employee"` }
```

# pkg/model/discord_message.go

```go
package model import "github.com/bwmarrin/discordgo" type DiscordMessage struct { AvatarURL string `json:"avatar_url"` Content string `json:"content"` Embeds []DiscordMessageEmbed `json:"embeds"` Components []DiscordMessageComponents `json:"components"` } type DiscordMessageEmbed struct { Author DiscordMessageAuthor `json:"author"` Title string `json:"title"` URL string `json:"url"` Description string `json:"description"` Color int64 `json:"color"` Fields []DiscordMessageField `json:"fields"` Thumbnail DiscordMessageImage `json:"thumbnail"` Image DiscordMessageImage `json:"image"` Footer DiscordMessageFooter `json:"footer"` Timestamp string `json:"timestamp"` } type DiscordMessageAuthor struct { Name string `json:"name"` URL string `json:"url"` IconURL string `json:"icon_url"` } type DiscordMessageField struct { Name string `json:"name"` Value string `json:"value"` Inline *bool `json:"inline,omitempty"` } type DiscordMessageFooter struct { Text string `json:"text"` IconURL string `json:"icon_url"` } type DiscordMessageImage struct { URL string `json:"url"` } type DiscordMessageComponents struct { Components []DiscordMessageComponent `json:"components"` Type int64 `json:"type"` } type DiscordMessageComponent struct { CustomID string `json:"custom_id"` Disabled bool `json:"disabled"` Emoji interface{} `json:"emoji"` Label string `json:"label"` Style int64 `json:"style"` Type int64 `json:"type"` URL interface{} `json:"url"` } type OriginalDiscordMessage struct { RawContent string ContentArgs []string ChannelId string GuildId string Author *discordgo.User Roles []string }
```

# pkg/model/discord.go

```go
package model type LogDiscordInput struct { Type string Data interface{} } type DiscordLogTemplate struct { ID string `json:"id"` Description string Content string } type DiscordRole string func (r DiscordRole) String() string { return string(r) } const ( DiscordRolePeeps DiscordRole = "peeps" )
```

# pkg/model/earn.go

```go
package model type Earn struct { Title string Bounty string Status string PICs []string Function string URL string }
```

# pkg/model/email.go

```go
package model import "github.com/sendgrid/sendgrid-go/helpers/mail" type Email struct { HTMLContent string Subject string From *mail.Email To []*mail.Email Bcc []*mail.Email Categories []string }
```

# pkg/model/employee_bonus.go

```go
package model // EmployeeBonus represents employeeBonus table // save the commission when invoice is paid for an employee type EmployeeBonus struct { ID UUID `json:"id"` EmployeeID UUID `json:"employee_id"` Amount VietnamDong `json:"amount"` IsActive bool `json:"is_active"` Name string `json:"name"` } func (EmployeeBonus) TableName() string { return "employee_bonuses" }
```

# pkg/model/employee_chapters.go

```go
package model type EmployeeChapter struct { BaseModel EmployeeID UUID ChapterID UUID Chapter Chapter }
```

# pkg/model/employee_commissions.go

```go
package model import "time" // EmployeeCommission represents EmployeeCommission table // save the commission when invoice is paid for an Employee type EmployeeCommission struct { BaseModel EmployeeID UUID InvoiceID UUID Project string IsPaid bool Amount VietnamDong ConversionRate float64 Formula string Note string PaidAt *time.Time Employee *Employee Invoice *Invoice } // New create new Employee commission func New(employeeID, invoiceID UUID, project string, amount VietnamDong, rate float64) EmployeeCommission { return EmployeeCommission{ EmployeeID: employeeID, InvoiceID: invoiceID, Amount: amount, Project: project, ConversionRate: rate, } }
```

# pkg/model/employee_earns.go

```go
package model import "github.com/dwarvesf/fortress-api/pkg/service/mochipay" type EmployeeEarnTransactions []mochipay.TransactionData
```

# pkg/model/employee_event_questions.go

```go
package model import "time" // EmployeeEventQuestion model for employee_event_questions table type EmployeeEventQuestion struct { BaseModel EmployeeEventReviewerID UUID QuestionID UUID EventID UUID Content string Answer string Note string Type string Order int64 Domain QuestionDomain } type StatisticEngagementDashboard struct { Name string Content string Title string Point float64 QuestionID UUID StartDate time.Time } type EngagementDashboardFilter string const ( EngagementDashboardFilterDepartment EngagementDashboardFilter = "department" EngagementDashboardFilterChapter EngagementDashboardFilter = "chapter" EngagementDashboardFilterSeniority EngagementDashboardFilter = "seniority" EngagementDashboardFilterProject EngagementDashboardFilter = "project" ) // String returns the string type from the EngagementDashboardFilter type func (e EngagementDashboardFilter) String() string { return string(e) } func (e EngagementDashboardFilter) IsValid() bool { switch e { case EngagementDashboardFilterDepartment, EngagementDashboardFilterChapter, EngagementDashboardFilterSeniority, EngagementDashboardFilterProject: return true } return false } // ToQuestionMap create map from EmployeeEventQuestion func ToQuestionMap(questionList []*EmployeeEventQuestion) map[UUID]string { rs := map[UUID]string{} for _, q := range questionList { rs[q.ID] = q.Answer } return rs } // ToQuestionMapType create map from Question to type func ToQuestionMapType(questionList []*EmployeeEventQuestion) map[UUID]string { rs := map[UUID]string{} for _, q := range questionList { rs[q.ID] = q.Type } return rs }
```

# pkg/model/employee_event_reviewer.go

```go
package model // EmployeeEventReviewer model for table employee_event_reviewer type EmployeeEventReviewer struct { BaseModel EmployeeEventTopicID UUID ReviewerID UUID ReviewerStatus EventReviewerStatus AuthorStatus EventAuthorStatus Relationship Relationship IsShared bool IsRead bool IsForcedDone bool EventID UUID Event FeedbackEvent EmployeeEventTopic EmployeeEventTopic Reviewer *Employee EmployeeEventQuestions []EmployeeEventQuestion } // EventReviewerStatus event_reviewer_status for table employee event reviewer type EventReviewerStatus string // @name EventReviewerStatus // EventReviewerStatus values const ( EventReviewerStatusNone EventReviewerStatus = "none" EventReviewerStatusNew EventReviewerStatus = "new" EventReviewerStatusDraft EventReviewerStatus = "draft" EventReviewerStatusDone EventReviewerStatus = "done" ) // IsValid validation for EventReviewerStatus func (e EventReviewerStatus) IsValid() bool { switch e { case EventReviewerStatusNone, EventReviewerStatusDraft, EventReviewerStatusDone, EventReviewerStatusNew: return true } return false } // String returns the string type from the EventReviewerStatus type func (e EventReviewerStatus) String() string { return string(e) } // EventAuthorStatus event_reviewer_status for table employee event reviewer type EventAuthorStatus string // EventAuthorStatus values const ( EventAuthorStatusDraft EventAuthorStatus = "draft" EventAuthorStatusSent EventAuthorStatus = "sent" EventAuthorStatusDone EventAuthorStatus = "done" ) // IsValid validation for EventAuthorStatus func (e EventAuthorStatus) IsValid() bool { switch e { case EventAuthorStatusDraft, EventAuthorStatusSent, EventAuthorStatusDone: return true } return false } // String returns the string type from the EventReviewerStatus type func (e EventAuthorStatus) String() string { return string(e) }
```

# pkg/model/employee_event_topic.go

```go
package model // Relationship relationships for table employee_event_topics type Relationship string // values for Relationship const ( RelationshipPeer Relationship = "peer" RelationshipLineManager Relationship = "line-manager" RelationshipChapterLead Relationship = "chapter-lead" RelationshipSelf Relationship = "self" ) // IsValid validation for Relationship func (e Relationship) IsValid() bool { switch e { case RelationshipPeer, RelationshipLineManager, RelationshipChapterLead, RelationshipSelf: return true } return false } // IsValid validation for Relationship func (e Relationship) String() string { return string(e) } // EmployeeEventTopic model for table employee_event_topics type EmployeeEventTopic struct { BaseModel Title string EventID UUID EmployeeID UUID ProjectID UUID Event FeedbackEvent Employee *Employee Project *Project EmployeeEventReviewers []EmployeeEventReviewer }
```

# pkg/model/employee_invitations.go

```go
package model type EmployeeInvitation struct { BaseModel EmployeeID UUID InvitedBy UUID InvitationCode string IsCompleted bool IsInfoUpdated bool IsDiscordRoleAssigned bool IsBasecampAccountCreated bool IsTeamEmailCreated bool Employee *Employee } type InvitationEmail struct { Name string `json:"name"` Email string `json:"email"` Link string `json:"link"` Inviter string `json:"inviter"` }
```

# pkg/model/employee_mentees.go

```go
package model // EmployeeMentee define the model for table employee_mentees type EmployeeMentee struct { BaseModel MenteeID UUID MentorID UUID Mentee *Employee `gorm:"foreignKey:MenteeID"` }
```

# pkg/model/employee_mma_score.go

```go
package model import ( "time" "github.com/shopspring/decimal" ) // EmployeeMMAScore define the model for table employee_mma_scores type EmployeeMMAScore struct { BaseModel EmployeeID UUID MasteryScore decimal.Decimal AutonomyScore decimal.Decimal MeaningScore decimal.Decimal RatedAt *time.Time } type EmployeeMMAScoreData struct { EmployeeID UUID FullName string MMAID UUID MasteryScore decimal.Decimal AutonomyScore decimal.Decimal MeaningScore decimal.Decimal RatedAt *time.Time }
```

# pkg/model/employee_organizations.go

```go
package model type EmployeeOrganization struct { BaseModel EmployeeID UUID OrganizationID UUID Organization Organization }
```

# pkg/model/employee_positions.go

```go
package model type EmployeePosition struct { BaseModel EmployeeID UUID PositionID UUID Position Position }
```

# pkg/model/employee_roles.go

```go
package model type EmployeeRole struct { BaseModel EmployeeID UUID RoleID UUID Role Role }
```

# pkg/model/employee_salary.go

```go
package model import "gorm.io/datatypes" // const ( // rateUSD = 22500 // ) type EmployeeSalary struct { ID UUID `json:"-"` EmployeeID UUID `json:"employee_id"` Employee *Employee `json:"-"` CommissionAmount int64 `json:"commission_amount"` CommissionDetail datatypes.JSON `json:"commission_detail"` ReimbursementAmount int64 `json:"reimbursement_amount"` ReimbursementDetail datatypes.JSON `json:"reimbursement_detail"` BonusAmount int64 `json:"bonus_amount"` BonusDetail datatypes.JSON `json:"bonus_detail"` TotalAmount int64 `json:"total_amount"` Month uint8 `json:"month"` Year int32 `json:"year"` ActualPayDay int8 `json:"actual_pay_day"` PlanPayDay int8 `json:"plan_pay_day"` IsDone bool `json:"is_done"` }
```

# pkg/model/employee_stacks.go

```go
package model type EmployeeStack struct { BaseModel EmployeeID UUID StackID UUID Stack Stack }
```

# pkg/model/employees.go

```go
package model import ( "strings" "time" ) // WorkingStatus working_status type for employee table type WorkingStatus string // values for working_status const ( WorkingStatusOnBoarding WorkingStatus = "on-boarding" WorkingStatusLeft WorkingStatus = "left" WorkingStatusProbation WorkingStatus = "probation" WorkingStatusFullTime WorkingStatus = "full-time" WorkingStatusContractor WorkingStatus = "contractor" ) // IsValid validation for WorkingStatus func (e WorkingStatus) IsValid() bool { switch e { case WorkingStatusOnBoarding, WorkingStatusContractor, WorkingStatusLeft, WorkingStatusProbation, WorkingStatusFullTime: return true } return false } // String returns the string type from the WorkingStatus type func (e WorkingStatus) String() string { return string(e) } // AccountRole account_role type for employee table type AccountRole string // values for account_role const ( AccountRoleAdmin AccountRole = "admin" AccountRoleMember AccountRole = "member" ) // IsValid validation for AccountRole func (e AccountRole) IsValid() bool { switch e { case AccountRoleAdmin, AccountRoleMember: return true } return false } // String returns the string representation func (e AccountRole) String() string { return string(e) } // Employee define the model for table employees type Employee struct { BaseModel // basic info FullName string `gorm:"default:null"` DisplayName string `gorm:"default:null"` Username string `gorm:"default:null"` TeamEmail string `gorm:"default:null"` PersonalEmail string `gorm:"default:null"` IsKeepFwdEmail bool `gorm:"default:false"` Avatar string `gorm:"default:null"` PhoneNumber string `gorm:"default:null"` Address string `gorm:"default:null"` PlaceOfResidence string `gorm:"default:null"` MBTI string `gorm:"default:null"` Gender string `gorm:"default:null"` Horoscope string `gorm:"default:null"` PassportPhotoFront string `gorm:"default:null"` PassportPhotoBack string `gorm:"default:null"` IdentityCardPhotoFront string `gorm:"default:null"` IdentityCardPhotoBack string `gorm:"default:null"` DateOfBirth *time.Time `gorm:"default:null"` Country string `gorm:"default:null"` City string `gorm:"default:null"` Lat string `gorm:"default:null"` Long string `gorm:"default:null"` // working info WorkingStatus WorkingStatus `gorm:"default:null"` JoinedDate *time.Time `gorm:"default:null"` LeftDate *time.Time `gorm:"default:null"` SeniorityID UUID `gorm:"default:null"` LineManagerID UUID `gorm:"default:null"` ReferredBy UUID `gorm:"default:null"` // social services BasecampID int `gorm:"default:null"` BasecampAttachableSGID string `gorm:"column:basecamp_attachable_sgid;default:null"` DiscordAccountID UUID `gorm:"default:null"` // payroll info WiseRecipientEmail string `gorm:"default:null"` WiseRecipientID string `gorm:"default:null"` WiseRecipientName string `gorm:"default:null"` WiseAccountNumber string `gorm:"default:null"` WiseCurrency string `gorm:"default:null"` LocalBankBranch string `gorm:"default:null"` LocalBankNumber string `gorm:"default:null"` LocalBankCurrency string `gorm:"default:null"` LocalBranchName string `gorm:"default:null"` LocalBankRecipientName string `gorm:"default:null"` BeneficiaryBankName string `gorm:"default:null"` BeneficiaryBankPostcode string `gorm:"default:null"` BeneficiaryBankAddress string `gorm:"default:null"` BeneficiaryBankCity string `gorm:"default:null"` BeneficiaryRoutingNumber string `gorm:"default:null"` Seniority *Seniority LineManager *Employee Referrer *Employee `gorm:"foreignKey:referred_by;"` ProjectMembers []ProjectMember Organizations []Organization `gorm:"many2many:employee_organizations;"` Roles []Role `gorm:"many2many:employee_roles;"` Positions []Position `gorm:"many2many:employee_positions;"` EmployeeRoles []EmployeeRole EmployeePositions []EmployeePosition EmployeeOrganizations []EmployeeOrganization EmployeeStacks []EmployeeStack EmployeeChapters []EmployeeChapter EmployeeMMAScores []EmployeeMMAScore SocialAccounts []SocialAccount Mentees []*Employee `gorm:"references:ID;foreignKey:LineManagerID"` WorkUnitMembers []WorkUnitMember Heads []ProjectHead EmployeeSalary *EmployeeSalary `json:"employee_salary"` BaseSalary BaseSalary `json:"base_salary"` DiscordAccount *DiscordAccount } // ToEmployeeMap create map from employees func ToEmployeeMap(employees []*Employee) map[UUID]Employee { rs := map[UUID]Employee{} for _, e := range employees { rs[e.ID] = *e } return rs } func (e Employee) GetFirstNameFromFullName() string { if e.FullName == "" { return "" } s := strings.Split(e.FullName, " ") return s[len(s)-1] } type Employees []Employee func (e Employees) ToTeamEmailIDMap() map[string]UUID { rs := map[string]UUID{} for _, e := range e { rs[e.TeamEmail] = e.ID } return rs } type OffboardingEmail struct { Name string `json:"name"` PersonalEmail string `json:"personalEmail"` TeamEmail string `json:"teamEmail"` }
```

# pkg/model/engagement_rollup.go

```go
package model type EngagementsRollup struct { BaseModel DiscordUserID int64 `gorm:"default:null"` LastMessageID int64 `gorm:"default:null"` DiscordUsername string `gorm:"default:null"` ChannelID int64 `gorm:"default:null"` CategoryID int64 `gorm:"default:null"` MessageCount int `gorm:"default:null"` ReactionCount int `gorm:"default:null"` }
```

# pkg/model/event.go

```go
package model import ( "time" ) // Event struct type Event struct { BaseModel Name string `json:"name"` Description string `json:"description"` Date time.Time `json:"date"` Image string `json:"image" gorm:"-"` DiscordEventID string `json:"discordEventId"` DiscordChannelID string `json:"discordChannelId"` DiscordMessageID string `json:"discordMessageId"` DiscordCreatorID string `json:"discordCreatorId"` EventType DiscordScheduledEventType `json:"type"` EventSpeakers []EventSpeaker `json:"eventSpeakers"` IsOver bool `json:"isOver" gorm:"-"` } // EventSpeaker struct type EventSpeaker struct { EventID UUID `json:"eventId"` DiscordAccountID UUID `json:"discordAccountId"` Topic string `json:"topic,omitempty"` Event *Event `json:"event"` } type DiscordScheduledEventType string const ( DiscordScheduledEventTypeOGIF DiscordScheduledEventType = "OGIF" DiscordScheduledEventTypeDemo DiscordScheduledEventType = "DEMO" ) // IsValid validation for DiscordScheduledEventType func (e DiscordScheduledEventType) IsValid() bool { switch e { case DiscordScheduledEventTypeOGIF, DiscordScheduledEventTypeDemo: return true } return false } // String returns the string type from the DiscordScheduledEventType type func (e DiscordScheduledEventType) String() string { return string(e) } // OgifLeaderboardRecord represents an element in the OGIF leaderboard type OgifLeaderboardRecord struct { DiscordID string `json:"discordID"` SpeakCount int64 `json:"speakCount"` }
```

# pkg/model/expense.go

```go
package model import ( "time" "gorm.io/datatypes" ) // Expense for slack command type Expense struct { BaseModel EmployeeID UUID `json:"employee_id"` CurrencyID UUID `json:"currency_id"` Amount int `json:"amount"` IssuedDate time.Time `sql:"default: now()" json:"issued_date"` Reason string `json:"reason"` InvoiceImageURL string `json:"invoice_image_url"` Metadata datatypes.JSON `json:"metadata"` BasecampID int `json:"basecamp_id"` AccountingTransactionID *UUID `json:"accounting_transaction_id"` }
```

# pkg/model/feedback_events.go

```go
package model import ( "time" ) // EventType event_type for table feedback events type EventType string type EventStatus string // values for EventType const ( EventTypeFeedback EventType = "feedback" EventTypeSurvey EventType = "survey" ) const ( EventStatusDraft EventStatus = "draft" EventStatusDone EventStatus = "done" EventStatusInProgress EventStatus = "in-progress" ) // IsValid validation for EventStatus func (e EventStatus) IsValid() bool { switch e { case EventStatusDraft, EventStatusDone, EventStatusInProgress: return true } return false } // IsValid validation for EventType func (e EventType) IsValid() bool { switch e { case EventTypeFeedback, EventTypeSurvey: return true } return false } // String returns the string type from the EventStatus type func (e EventStatus) String() string { return string(e) } // String returns the string type from the EventType type func (e EventType) String() string { return string(e) } // EventSubtype event_subtype for table feedback events type EventSubtype string // values for EventSubtype const ( EventSubtypePeerReview EventSubtype = "peer-review" EventSubtypeEngagement EventSubtype = "engagement" EventSubtypeWork EventSubtype = "work" EventSubtypeAppreciation EventSubtype = "appreciation" EventSubtypeComment EventSubtype = "comment" ) // IsValid validation for EventSubtype func (e EventSubtype) IsValid() bool { switch e { case EventSubtypePeerReview, EventSubtypeEngagement, EventSubtypeWork, EventSubtypeAppreciation, EventSubtypeComment: return true } return false } // IsSurveyValid validation for subtype of survey func (e EventSubtype) IsSurveyValid() bool { switch e { case EventSubtypePeerReview, EventSubtypeEngagement, EventSubtypeWork: return true } return false } // String returns the string type from the EventSubtype type func (e EventSubtype) String() string { return string(e) } // IsValidSurvey validation for EventSubType func (e EventSubtype) IsValidSurvey() bool { switch e { case EventSubtypePeerReview, EventSubtypeEngagement, EventSubtypeWork: return true } return false } // FeedbackEvent model for feedback_events table type FeedbackEvent struct { BaseModel Title string Type EventType Subtype EventSubtype Status EventStatus CreatedBy UUID StartDate *time.Time EndDate *time.Time Employee Employee `gorm:"foreignKey:CreatedBy"` Topics []*EmployeeEventTopic `gorm:"foreignKey:EventID"` QuestionDomainCounts []QuestionDomainCount `gorm:"-"` }
```

# pkg/model/google_mail.go

```go
package model // GoogleMailThread -- type GoogleMailThread struct { ID string `json:"id"` Messages []GoogleMailMessage `json:"messages"` } // GoogleMailMessage -- type GoogleMailMessage struct { ID string `json:"id"` ThreadID string `json:"threadId"` Payload *Payload `json:"payload"` } type Payload struct { Headers []Header `json:"headers"` } type Header struct { Name string `json:"name"` Value string `json:"value"` }
```

# pkg/model/icy_distribution.go

```go
package model // IcyDistribution is a model for icy_distribution table type IcyDistribution struct { BaseModel Team string `json:"team"` Period string `json:"period"` Amount string `json:"amount"` }
```

# pkg/model/icy_transaction.go

```go
package model import ( "time" ) type IcyTransaction struct { BaseModel Category string TxnTime time.Time Amount string Note string SrcEmployeeID UUID DestEmployeeID UUID Sender string Target string }
```

# pkg/model/icy.go

```go
package model type IcyAccounting struct { ICY *TokenInfo `json:"icy"` USDT *TokenInfo `json:"usdt"` IcySwap *ContractInfo `json:"icy_swap"` ConversionRate float32 `json:"conversion_rate"` CirculatingICY string `json:"circulating_icy"` ContractFundInUSDT string `json:"contract_fund_in_usdt"` OffsetUSDT string `json:"offset_usdt"` // how many usdt left need to be issued } type TokenInfo struct { Name string `json:"name"` Symbol string `json:"symbol"` Address string `json:"address"` Decimals int `json:"decimals"` Chain string `json:"chain"` ChainID string `json:"chain_id"` TotalSupply string `json:"total_supply"` } type ContractInfo struct { Name string `json:"name"` Address string `json:"address"` Chain string `json:"chain"` }
```

# pkg/model/invoice_number_caching.go

```go
package model type InvoiceNumberCaching struct { BaseModel Key string `json:"key"` Number int `json:"number"` } func (InvoiceNumberCaching) TableName() string { return "invoice_number_caching" } type InvoiceCachingKeyStr struct { YearInvoiceNumberPrefix string ProjectInvoiceNumberPrefix string ProjectTemplateNumberPrefix string TplNumberPrefix string } // InvoiceCachingKey present current keys of max numbers var InvoiceCachingKey = InvoiceCachingKeyStr{ YearInvoiceNumberPrefix: "year_invoice", ProjectInvoiceNumberPrefix: "project_invoice", ProjectTemplateNumberPrefix: "Project_Template_Number", TplNumberPrefix: "Tpl", }
```

# pkg/model/invoice.go

```go
package model import ( "encoding/json" "errors" "strings" "time" ) type InvoiceStatus string const ( InvoiceStatusDraft InvoiceStatus = "draft" InvoiceStatusSent InvoiceStatus = "sent" InvoiceStatusOverdue InvoiceStatus = "overdue" InvoiceStatusPaid InvoiceStatus = "paid" InvoiceStatusError InvoiceStatus = "error" InvoiceStatusScheduled InvoiceStatus = "scheduled" ) func (i InvoiceStatus) IsValid() bool { switch i { case InvoiceStatusDraft, InvoiceStatusSent, InvoiceStatusOverdue, InvoiceStatusPaid, InvoiceStatusError, InvoiceStatusScheduled: return true } return false } func (i InvoiceStatus) String() string { return string(i) } // Invoice contain company information type Invoice struct { BaseModel Number string InvoicedAt *time.Time DueAt *time.Time PaidAt *time.Time FailedAt *time.Time Status InvoiceStatus Email string CC JSON Description string Note string SubTotal float64 Tax float64 Discount float64 Total float64 ConversionAmount float64 InvoiceFileURL string ErrorInvoiceID *UUID LineItems JSON Month int Year int SentBy *UUID Sender *Employee `gorm:"foreignKey:sent_by;"` ThreadID string ScheduledDate *time.Time ConversionRate float64 Bonus float64 TotalWithoutBonus float64 BankID UUID Bank *BankAccount ProjectID UUID Project *Project InvoiceFileContent []byte `gorm:"-"` // we not store this in db MessageID string `gorm:"-"` References string `gorm:"-"` TodoAttachment string `gorm:"-"` } func (i *Invoice) Validate() error { if i == nil { return errors.New("nil structure") } if i.Project == nil { return errors.New("missing project") } if i.Bank.Currency.Name == "" { return errors.New("missing bank info") } return nil } func GatherAddresses(CCs JSON) (string, error) { if CCs == nil { return "", nil } var ccList []string if err := json.Unmarshal(CCs, &ccList); err != nil { return "", err } for _, v := range ccList { if v == "" { continue } } return strings.Join(ccList, ", "), nil } type InvoiceItem struct { Quantity float64 `json:"quantity"` UnitCost float64 `json:"unit_cost"` Discount float64 `json:"discount"` Cost float64 `json:"cost"` Description string `json:"description"` IsExternal bool `json:"is_external"` } func GetInfoItems(lineItems JSON) ([]InvoiceItem, error) { var items []InvoiceItem if len(lineItems) == 0 || string(lineItems) == "null" { return items, nil } if err := json.Unmarshal(lineItems, &items); err != nil { return nil, err } return items, nil }
```

# pkg/model/json.go

```go
package model import ( "bytes" "database/sql" "database/sql/driver" "encoding/json" "fmt" "strings" ) // JSONArrayString custom type for handling string array in postgreSQL type JSONArrayString []string func (j JSONArrayString) Value() (driver.Value, error) { return strings.ReplaceAll(fmt.Sprintf("%q", j), " ", ","), nil } func (j *JSONArrayString) Scan(value interface{}) error { if value == nil { *j = nil return nil } switch t := value.(type) { case []uint8: return json.Unmarshal(value.([]uint8), j) default: return fmt.Errorf("could not scan type %T into JSONArrayString", t) } } // JSON custom type for storing db & responding API req purpose only type JSON []byte func (j JSON) Value() (driver.Value, error) { if j == nil { return "null", nil } return string(j), nil } func (j *JSON) Scan(value interface{}) error { if value == nil { *j = nil return nil } switch t := value.(type) { case []uint8: jsonData := value.([]uint8) if string(jsonData) == "null" { return nil } *j = JSON(jsonData) return nil default: return fmt.Errorf("could not scan type %T into json", t) } } func (j JSON) MarshalJSON() ([]byte, error) { switch true { case j == nil, len(j) == 0: return []byte("null"), nil case len(j) <= 2: if (j[0]) == '[' { return []byte("[]"), nil } return []byte("null"), nil default: return []byte(j), nil } } func (j *JSON) UnmarshalJSON(raw []byte) error { if string(raw) == "null" { *j = nil return nil } var out bytes.Buffer err := json.Compact(&out, raw) if err == nil { *j = JSON(out.Bytes()) return nil } *j = JSON(raw) return nil } type JSONNullString struct { sql.NullString } func (v JSONNullString) MarshalJSON() ([]byte, error) { if v.Valid { return json.Marshal(v.String) } else { return json.Marshal(nil) } } func (v *JSONNullString) UnmarshalJSON(raw []byte) error { err := json.Unmarshal(raw, &v.NullString.String) v.NullString.Valid = err == nil return err } type JSONNullInt64 struct { sql.NullInt64 } func (v JSONNullInt64) MarshalJSON() ([]byte, error) { if v.Valid { return json.Marshal(v.Int64) } else { return json.Marshal(nil) } } func (v *JSONNullInt64) UnmarshalJSON(raw []byte) error { err := json.Unmarshal(raw, &v.NullInt64.Int64) v.NullInt64.Valid = err == nil return err }
```

# pkg/model/liability.go

```go
package model import "time" type Liability struct { BaseModel PaidAt *time.Time `json:"paidAt"` Name string `json:"name"` Total float64 `json:"total"` CurrencyID UUID `json:"currencyID"` }
```

# pkg/model/memo_author.go

```go
package model import ( "time" "gorm.io/gorm" "gorm.io/gorm/clause" ) // MemoAuthor is the join table for memo log and discord account type MemoAuthor struct { MemoLogID UUID `gorm:"primaryKey"` DiscordAccountID UUID `gorm:"primaryKey"` CreatedAt time.Time } func (b *MemoAuthor) BeforeCreate(tx *gorm.DB) (err error) { cols := []clause.Column{} for _, field := range tx.Statement.Schema.PrimaryFields { cols = append(cols, clause.Column{Name: field.DBName}) } tx.Statement.AddClause(clause.OnConflict{ Columns: cols, DoNothing: true, }) return nil }
```

# pkg/model/memo_log.go

```go
package model import ( "time" "github.com/lib/pq" "github.com/shopspring/decimal" "gorm.io/gorm" ) type MemoLog struct { BaseModel Title string URL string Tags JSONArrayString Description string PublishedAt *time.Time Reward decimal.Decimal Category pq.StringArray `json:"value" gorm:"type:text[]"` Authors []DiscordAccount `json:"authors" gorm:"many2many:memo_authors;"` // This field is used to make sure response always contains authors AuthorMemoUsernames []string `json:"-" gorm:"-"` } type DiscordAccountMemoRank struct { DiscordID string DiscordUsername string MemoUsername string TotalMemos int Rank int } func (MemoLog) BeforeCreate(db *gorm.DB) error { return db.SetupJoinTable(&MemoLog{}, "Authors", &MemoAuthor{}) }
```

# pkg/model/memopr.go

```go
package model import ( "time" ) type MemoPullRequest struct { Number int `json:"number"` Title string `json:"title"` DiscordId string `json:"discord_id"` GithubUserName string `json:"github_user_name"` Url string `json:"url"` Timestamp time.Time `json:"timestamp"` }
```

# pkg/model/mochi.go

```go
package model type VaultTransaction struct { ID int64 GuildID string VaultID int64 VaultName string Action string FromAddress string ToAddress string Target string Sender string Amount string Token string Threshold string CreatedAt string UpdatedAt string }
```

# pkg/model/monthly_delivery_metric.go

```go
package model import ( "time" "github.com/shopspring/decimal" ) type MonthlyDeliveryMetric struct { Month *time.Time SumWeight decimal.Decimal SumEffort decimal.Decimal } type AvgMonthlyDeliveryMetric struct { Weight decimal.Decimal Effort decimal.Decimal }
```

# pkg/model/news.go

```go
package model import "time" const ( RedditPlatform = "reddit" LobstersPlatform = "lobsters" ) type News struct { Title string URL string Popularity int64 CommentCount int64 Flag int64 Description string Tags []string CreatedAt time.Time }
```

# pkg/model/notion_event.go

```go
package model import ( "time" ) type NotionEvent struct { ID string `json:"id"` Name string `json:"name"` Date DateTime `json:"date"` ActivityType string `json:"activity_type"` CreatedAt time.Time `json:"created_at"` }
```

# pkg/model/notion.go

```go
package model import "time" // ProjectChangelogPage -- notion project changelog page type ProjectChangelogPage struct { RowID string `json:"row_id"` Name string `json:"name"` Title string `json:"title"` ChangelogURL string `json:"changelog_url"` } type NotionMemo struct { ID string `json:"id"` Name string `json:"name"` Tags []string `json:"tags"` Author string `json:"author"` CreatedAt time.Time `json:"created_at"` } type NotionUpdate struct { ID string `json:"id"` Name string `json:"name"` Audience string `json:"audience"` CreatedAt time.Time `json:"created_at"` } type NotionEarn struct { ID string `json:"id"` Name string `json:"name"` Reward int `json:"reward"` Priority string `json:"priority"` Tags []string `json:"tags"` PICs []Employee `json:"pics"` Status string `json:"status"` Function []string `json:"function"` SubItems []NotionEarn `json:"sub_items"` ParentID string `json:"-"` DueDate *time.Time `json:"due_date"` } type NotionAudience struct { ID string `json:"id"` FullName string `json:"full_name"` Email string `json:"email"` Sources []string `json:"source"` CreatedAt time.Time `json:"created_at"` } type NotionTechRadar struct { ID string `json:"id"` Name string `json:"name"` Assign string `json:"assign"` Categories []string `json:"categories"` Tags []string `json:"tags"` Quadrant string `json:"quadrant"` Ring string `json:"ring"` } // @name NotionTechRadar type NotionDigest struct { ID string `json:"id"` Name string `json:"name"` CreatedAt time.Time `json:"created_at"` } type NotionStaffingDemand struct { ID string `json:"id"` Name string `json:"name"` Request string `json:"request"` } type NotionIssue struct { ID string `json:"id"` Name string `json:"name"` RootCause string `json:"rootcause"` Resolution string `json:"resolution"` Scope string `json:"scope"` Priority string `json:"priority"` Severity string `json:"severity"` IncidentDate *time.Time `json:"incident_date"` SolvedDate *time.Time `json:"solve_date"` PIC string `json:"pic"` Projects []string `json:"projects"` Status string `json:"status"` Source string `json:"source"` Profile string `json:"profile"` } type HiringType string const ( HiringTypeDirect HiringType = "direct" HiringTypeReferral HiringType = "referral" HiringTypeInternship HiringType = "internship" ) type NotionHiringRelationship struct { BaseModel UserID UUID `json:"user_id"` SupplierID UUID `json:"supplier_id"` HiringType HiringType `json:"hiring_type"` Employee Employee `json:"user"` } type NotionHiringPosition struct { ID string `json:"id"` Name string `json:"name"` Projects []string `json:"project"` Status string `json:"status"` CreatedAt time.Time `json:"created_at"` } type NotionProjectMilestone struct { ID string `json:"id"` Project string `json:"-"` Name string `json:"name"` StartDate time.Time `json:"start_date"` EndDate time.Time `json:"end_date"` SubMilestones []*NotionProjectMilestone `json:"sub_milestones"` } func (o *NotionProjectMilestone) GetSubMilestones() []*NotionProjectMilestone { return o.SubMilestones }
```

# pkg/model/onleave_request.go

```go
package model import ( "time" ) type OnLeaveRequest struct { BaseModel Type string StartDate *time.Time EndDate *time.Time Shift string Title string Description string CreatorID UUID ApproverID UUID AssigneeIDs JSONArrayString Creator *Employee Approver *Employee }
```

# pkg/model/operational_service.go

```go
package model import "time" type OperationalService struct { BaseModel Name string Amount int Note string RegisterDate time.Time StartAt time.Time EndAt time.Time IsActive bool CurrencyID UUID Currency *Currency `gorm:"foreignKey:CurrencyID;references:ID"` }
```

# pkg/model/organization.go

```go
package model const ( OrganizationCodeDwarves = "dwarves-foundation" OrganizationNameDwarves = "Dwarves Foundation" ) type Organization struct { BaseModel Name string `json:"name"` Code string `json:"code"` Avatar string `json:"avatar"` } // ToOrganizationMap create map from organizations func ToOrganizationMap(organizations []*Organization) map[UUID]string { rs := map[UUID]string{} for _, s := range organizations { rs[s.ID] = s.Name } return rs }
```

# pkg/model/pagination.go

```go
package model import ( "fmt" "regexp" "strings" ) var maxPageSize int64 = 999 type SortOrder string // @name SortOrder type Pagination struct { Page int64 `json:"page" form:"page,default=0"` // page index Size int64 `json:"size" form:"size"` // page size Sort string `json:"sort" form:"sort" swaggerignore:"true"` // sort by field Standardized bool `json:"-" form:"-" swaggerignore:"true"` } // @name Pagination const ( SortOrderASC SortOrder = "asc" SortOrderDESC SortOrder = "desc" ) func (e SortOrder) IsValid() bool { switch e { case SortOrderASC, SortOrderDESC: return true } return false } func (e SortOrder) String() string { return string(e) } func (p *Pagination) Standardize() { if p.Standardized { return } if p.Page < 0 { p.Page = 0 } if p.Size <= 0 || p.Size >= maxPageSize { p.Size = maxPageSize } if p.Sort == "" { return } p.Sort = standardizeSortQuery(p.Sort) p.Standardized = true } func (p *Pagination) ToLimitOffset() (limit int, offset int) { limit = int(p.Size) offset = limit * (int(p.Page) - 1) if offset < 0 { offset = 0 } return limit, offset } func standardizeSortQuery(sortQ string) string { if sortQ == "" { return sortQ } f := func(c rune) bool { return c == ',' } sorts := strings.FieldsFunc(sortQ, f) re, err := regexp.Compile(`[^\w|-]`) if err != nil { return "" } for i := range sorts { sort := re.ReplaceAllString(sorts[i], "") operator := "ASC" if sort[0] == '-' { operator = "DESC" sort = strings.Replace(sort, "-", "", 1) } sorts[i] = fmt.Sprintf("%s %s", sort, operator) } return strings.Join(sorts, ",") }
```

# pkg/model/payroll.go

```go
package model import ( "time" "gorm.io/datatypes" "gorm.io/gorm" // "git.d.foundation/fortress/ragnarok/src/service/vault" ) type Payroll struct { ID UUID `sql:",type:uuid" json:"id"` EmployeeID UUID `json:"employee_id"` BaseSalaryAmount int64 `json:"base_salary_amount"` ContractAmount int64 `json:"contract_amount"` Total VietnamDong `json:"total"` ConversionAmount VietnamDong `json:"conversion_amount"` Month int64 `json:"month"` Year int64 `json:"year"` CommissionAmount VietnamDong `json:"commission_amount"` CommissionExplain datatypes.JSON `json:"commission_explain"` UserRankSnapshot datatypes.JSON `json:"user_rank_snapshot"` TotalExplain datatypes.JSON `json:"total_explain"` ProjectBonusAmount VietnamDong `json:"project_bonus"` ProjectBonusExplain datatypes.JSON `json:"project_bonus_explain"` DueDate *time.Time `json:"due_date"` IsPaid bool `json:"is_paid"` SalaryAdvanceAmount float64 `json:"salary_advance_amount"` Employee Employee `json:"employee"` TotalAllowance float64 `json:"total_allowance" gorm:"-"` // TotalAllowance is amount of allowance in email template CommissionExplains []CommissionExplain `json:"commission_explains" gorm:"-"` // CommissionExplains is commission explains in email template ProjectBonusExplains []ProjectBonusExplain `json:"project_bonus_explains" gorm:"-"` // ProjectBonusExplains is project bonus explains in email template TWAmount float64 `json:"twAmount" gorm:"-"` // TotalAllowance is amount of allowance in email template TWRate float64 `json:"twRate" gorm:"-"` // TWRate is rate of allowance in email template TWFee float64 `json:"twFee" gorm:"-"` } func (p *Payroll) BeforeCreate(tx *gorm.DB) error { p.ID = NewUUID() return nil } func (Payroll) TableName() string { return "payrolls" } // ProjectBonusExplain explain where and when // the project bonus come from // in each row of table payroll type ProjectBonusExplain struct { Name string `json:"name"` Month int `json:"month"` Year int `json:"year"` Amount VietnamDong `json:"amount"` FormattedAmount string `json:"formatted_amount"` Description string `json:"description"` BasecampTodoID int `json:"todo_id"` BasecampBucketID int `json:"bucket_id"` } // CommissionExplain explain where and when // the commission come from // in each row of table payroll type CommissionExplain struct { ID UUID `json:"id"` Name string `json:"name"` Month int `json:"month"` Year int `json:"year"` Amount VietnamDong `json:"amount"` FormattedAmount string `json:"formatted_amount"` BasecampTodoID int `json:"todo_id"` BasecampBucketID int `json:"bucket_id"` } // Batch enumeration type Batch int const ( // FirstBatch represent payroll batch that due date in date: 1st of a month FirstBatch Batch = 1 // SecondBatch represent payroll batch that due date in date: 15th of a month SecondBatch Batch = 15 )
```

# pkg/model/permissions.go

```go
package model type Permission struct { BaseModel Code string Name string } func ToPermissionMap(perms []*Permission) map[string]string { m := make(map[string]string) for _, v := range perms { m[v.Code] = v.Name } return m } type PermissionCode string const ( PermissionAssetUpload PermissionCode = "assets.upload" PermissionAuthCreate PermissionCode = "auth.create" PermissionAuthRead PermissionCode = "auth.read" PermissionBankAccountRead PermissionCode = "bankAccounts.read" PermissionClientCreate PermissionCode = "clients.create" PermissionClientDelete PermissionCode = "clients.delete" PermissionClientEdit PermissionCode = "clients.edit" PermissionClientRead PermissionCode = "clients.read" PermissionCompanyInfoRead PermissionCode = "companyInfos.read" PermissionCronjobExecute PermissionCode = "cronjobs.execute" PermissionDashBoardEngagementRead PermissionCode = "dashboards.engagement.read" PermissionDashBoardProjectsRead PermissionCode = "dashboards.projects.read" PermissionDashBoardRead PermissionCode = "dashboards.read" PermissionDashBoardResourcesRead PermissionCode = "dashboards.resources.read" PermissionEarnRead PermissionCode = "earns.read" PermissionEmployeeEventQuestionsCreate PermissionCode = "employeeEventQuestions.create" PermissionEmployeeEventQuestionsDelete PermissionCode = "employeeEventQuestions.delete" PermissionEmployeeEventQuestionsEdit PermissionCode = "employeeEventQuestions.edit" PermissionEmployeeEventQuestionsRead PermissionCode = "employeeEventQuestions.read" PermissionEmployeeMenteesCreate PermissionCode = "employeeMentees.create" PermissionEmployeeMenteesDelete PermissionCode = "employeeMentees.delete" PermissionEmployeeMenteesEdit PermissionCode = "employeeMentees.edit" PermissionEmployeeMenteesRead PermissionCode = "employeeMentees.read" PermissionEmployeeRolesCreate PermissionCode = "employeeRoles.create" PermissionEmployeeRolesDelete PermissionCode = "employeeRoles.delete" PermissionEmployeeRolesEdit PermissionCode = "employeeRoles.edit" PermissionEmployeeRolesRead PermissionCode = "employeeRoles.read" PermissionEmployeesBaseSalaryEdit PermissionCode = "employees.baseSalary.edit" PermissionEmployeesBaseSalaryRead PermissionCode = "employees.baseSalary.read" PermissionEmployeesCreate PermissionCode = "employees.create" PermissionEmployeesDiscordRead PermissionCode = "employees.discord.read" PermissionEmployeesDiscordEdit PermissionCode = "employees.discord.edit" PermissionEmployeesDiscordCreate PermissionCode = "employees.discord.create" PermissionEmployeesDelete PermissionCode = "employees.delete" PermissionEmployeesEdit PermissionCode = "employees.edit" PermissionEmployeesRead PermissionCode = "employees.read" PermissionEmployeesReadFilterByAllStatuses PermissionCode = "employees.read.filterByAllStatuses" PermissionEmployeesReadFilterByProject PermissionCode = "employees.read.filterByProject" PermissionEmployeesReadFullAccess PermissionCode = "employees.read.fullAccess" PermissionEmployeesReadGeneralInfoFullAccess PermissionCode = "employees.read.generalInfo.fullAccess" PermissionEmployeesReadLineManagerFullAccess PermissionCode = "employees.read.lineManager.fullAccess" PermissionEmployeesReadPersonalInfoFullAccess PermissionCode = "employees.read.personalInfo.fullAccess" PermissionEmployeesReadProjectsFullAccess PermissionCode = "employees.read.projects.fullAccess" PermissionEmployeesReadProjectsReadActive PermissionCode = "employees.read.projects.readActive" PermissionEmployeesReadReadActive PermissionCode = "employees.read.readActive" PermissionFeedbacksCreate PermissionCode = "feedbacks.create" PermissionFeedbacksDelete PermissionCode = "feedbacks.delete" PermissionFeedbacksEdit PermissionCode = "feedbacks.edit" PermissionFeedbacksRead PermissionCode = "feedbacks.read" PermissionInvoiceCreate PermissionCode = "invoices.create" PermissionInvoiceDelete PermissionCode = "invoices.delete" PermissionInvoiceEdit PermissionCode = "invoices.edit" PermissionInvoiceRead PermissionCode = "invoices.read" PermissionMetadataCreate PermissionCode = "metadata.create" PermissionMetadataDelete PermissionCode = "metadata.delete" PermissionMetadataEdit PermissionCode = "metadata.edit" PermissionMetadataRead PermissionCode = "metadata.read" PermissionNotionCreate PermissionCode = "notion.create" PermissionNotionRead PermissionCode = "notion.read" PermissionNotionSend PermissionCode = "notion.send" PermissionPayrollsCreate PermissionCode = "payrolls.create" PermissionPayrollsEdit PermissionCode = "payrolls.edit" PermissionPayrollsRead PermissionCode = "payrolls.read" PermissionProjectMembersCreate PermissionCode = "projectMembers.create" PermissionProjectMembersDelete PermissionCode = "projectMembers.delete" PermissionProjectMembersEdit PermissionCode = "projectMembers.edit" PermissionProjectMembersRateEdit PermissionCode = "projectMembers.rate.edit" PermissionProjectMembersRateRead PermissionCode = "projectMembers.rate.read" PermissionProjectMembersRead PermissionCode = "projectMembers.read" PermissionProjectWorkUnitsCreate PermissionCode = "projectWorkUnits.create" PermissionProjectWorkUnitsCreateFullAccess PermissionCode = "projectWorkUnits.create.fullAccess" PermissionProjectWorkUnitsDelete PermissionCode = "projectWorkUnits.delete" PermissionProjectWorkUnitsDeleteFullAccess PermissionCode = "projectWorkUnits.delete.fullAccess" PermissionProjectWorkUnitsEdit PermissionCode = "projectWorkUnits.edit" PermissionProjectWorkUnitsEditFullAccess PermissionCode = "projectWorkUnits.edit.fullAccess" PermissionProjectWorkUnitsRead PermissionCode = "projectWorkUnits.read" PermissionProjectWorkUnitsReadFullAccess PermissionCode = "projectWorkUnits.read.fullAccess" PermissionProjectsCommissionRateEdit PermissionCode = "projects.commissionRate.edit" PermissionProjectsCommissionRateRead PermissionCode = "projects.commissionRate.read" PermissionProjectsCreate PermissionCode = "projects.create" PermissionProjectsEdit PermissionCode = "projects.edit" PermissionProjectsRead PermissionCode = "projects.read" PermissionProjectsReadFullAccess PermissionCode = "projects.read.fullAccess" PermissionProjectsReadMonthlyRevenue PermissionCode = "projects.read.monthlyRevenue" PermissionProjectsReadReadActive PermissionCode = "projects.read.readActive" PermissionProjectsCommissionModelsRead PermissionCode = "projects.commissionModels.read" PermissionSurveysCreate PermissionCode = "surveys.create" PermissionSurveysDelete PermissionCode = "surveys.delete" PermissionSurveysEdit PermissionCode = "surveys.edit" PermissionSurveysRead PermissionCode = "surveys.read" PermissionValuationRead PermissionCode = "valuations.read" PermissionEngagementMetricsWrite PermissionCode = "engagementMetrics.write" PermissionEngagementMetricsRead PermissionCode = "engagementMetrics.read" PermissionIcyDistributionRead PermissionCode = "icyDistribution.read" PermissionBraineryLogsWrite PermissionCode = "braineryLogs.write" PermissionBraineryLogsRead PermissionCode = "braineryLogs.read" PermissionDeliveryMetricsRead PermissionCode = "deliveryMetrics.read" PermissionDeliveryMetricsLeaderBoardRead PermissionCode = "deliveryMetrics.leaderBoard.read" PermissionDeliveryMetricsSync PermissionCode = "deliveryMetrics.sync" PermissionTransferCheckinIcy PermissionCode = "employees.transferCheckinIcy.fullAccess" ) func (p PermissionCode) String() string { return string(p) }
```

# pkg/model/physical_checkin_transactions.go

```go
package model import "time" type PhysicalCheckinTransaction struct { ID UUID EmployeeID UUID Date time.Time IcyAmount float64 MochiTxID int64 } func (PhysicalCheckinTransaction) TableName() string { return "physical_checkin_transactions" }
```

# pkg/model/positions.go

```go
package model type Position struct { BaseModel Name string `json:"name"` Code string `json:"code"` } // ToPositionMap create map from position func ToPositionMap(positions []*Position) map[UUID]Position { rs := map[UUID]Position{} for _, s := range positions { rs[s.ID] = *s } return rs } type Positions []Position func (p Positions) IsSales() bool { for _, position := range p { if position.Code == "sales" { return true } } return false }
```

# pkg/model/project_commission_configs.go

```go
package model import "github.com/shopspring/decimal" type ProjectCommissionConfig struct { BaseModel ProjectID UUID Position HeadPosition CommissionRate decimal.Decimal } type ProjectCommissionConfigs []ProjectCommissionConfig func (m *ProjectCommissionConfigs) ToMap() map[string]decimal.Decimal { rs := make(map[string]decimal.Decimal) for _, itm := range *m { rs[itm.Position.String()] = itm.CommissionRate } return rs }
```

# pkg/model/project_info.go

```go
package model type ProjectInfo struct { BaseModel ProjectID *UUID `json:"project_id"` BasecampBucketID int64 `json:"basecamp_bucket_id"` BasecampScheduleID int64 `json:"basecamp_schedule_id"` BasecampCampfireID int64 `json:"basecamp_campfire_id"` BasecampTodolistID int64 `json:"basecamp_todolist_id"` BasecampMessageBoardID int64 `json:"basecamp_message_board_id"` BasecampSentryID int64 `json:"basecamp_sentry_id"` GitlabID int64 `json:"gitlab_id"` Repositories JSON `json:"repositories"` Project *Project `json:"project"` }
```

# pkg/model/project_issue.go

```go
package model type ProjectIssue struct { ID int `json:"id"` Name string `json:"name"` Link string `json:"link"` }
```

# pkg/model/project_member_positions.go

```go
package model type ProjectMemberPosition struct { BaseModel ProjectMemberID UUID PositionID UUID Position Position }
```

# pkg/model/project_notion.go

```go
package model type ProjectNotion struct { BaseModel ProjectID UUID AuditNotionID UUID Project *Project `gorm:"foreignKey:project_id"` }
```

# pkg/model/project_slot_positions.go

```go
package model type ProjectSlotPosition struct { BaseModel ProjectSlotID UUID PositionID UUID Position Position }
```

# pkg/model/projects.go

```go
package model import ( "database/sql/driver" "encoding/json" "time" "github.com/shopspring/decimal" ) type Project struct { BaseModel Name string `gorm:"default:null"` CountryID UUID `gorm:"default:null"` Type ProjectType `gorm:"default:null"` StartDate *time.Time `gorm:"default:null"` EndDate *time.Time `gorm:"default:null"` Status ProjectStatus `gorm:"default:null"` ProjectEmail string `gorm:"default:null"` ClientEmail string `gorm:"default:null"` Avatar string `gorm:"default:null"` AllowsSendingSurvey bool `gorm:"default:null"` Code string `gorm:"default:null"` Function ProjectFunction `gorm:"default:null"` BankAccountID UUID `gorm:"default:null"` CompanyInfoID UUID `gorm:"default:null"` ClientID UUID `gorm:"default:null"` OrganizationID UUID `gorm:"default:null"` AccountRating int DeliveryRating int LeadRating int ImportantLevel ProjectImportantLevel ProjectNotion *ProjectNotion `gorm:"foreignKey:project_id"` Organization *Organization BankAccount *BankAccount Country *Country Client *Client CompanyInfo *CompanyInfo Slots []ProjectSlot Heads []*ProjectHead ProjectMembers []ProjectMember ProjectStacks []ProjectStack CommissionConfigs ProjectCommissionConfigs ProjectInfo *ProjectInfo `json:"-" gorm:"foreignkey:ProjectID;association_foreignkey:ID"` } type ProjectType string const ( ProjectTypeDwarves ProjectType = "dwarves" ProjectTypeFixedCost ProjectType = "fixed-cost" ProjectTypeTimeMaterial ProjectType = "time-material" ) func (e ProjectType) IsValid() bool { switch e { case ProjectTypeDwarves, ProjectTypeFixedCost, ProjectTypeTimeMaterial: return true } return false } func (e ProjectType) String() string { return string(e) } type ProjectStatus string const ( ProjectStatusOnBoarding ProjectStatus = "on-boarding" ProjectStatusActive ProjectStatus = "active" ProjectStatusPaused ProjectStatus = "paused" ProjectStatusClosed ProjectStatus = "closed" ) func (e ProjectStatus) IsValid() bool { switch e { case ProjectStatusOnBoarding, ProjectStatusActive, ProjectStatusPaused, ProjectStatusClosed: return true } return false } func (e ProjectStatus) String() string { return string(e) } type DeploymentType string const ( MemberDeploymentTypeOfficial DeploymentType = "official" MemberDeploymentTypeShadow DeploymentType = "shadow" MemberDeploymentTypePartTime DeploymentType = "part-time" ) func (e DeploymentType) IsValid() bool { switch e { case MemberDeploymentTypeOfficial, MemberDeploymentTypeShadow, MemberDeploymentTypePartTime: return true } return false } func (e DeploymentType) String() string { return string(e) } type ProjectMemberStatus string const ( ProjectMemberStatusPending ProjectMemberStatus = "pending" ProjectMemberStatusOnBoarding ProjectMemberStatus = "on-boarding" ProjectMemberStatusActive ProjectMemberStatus = "active" ProjectMemberStatusInactive ProjectMemberStatus = "inactive" ) func (e ProjectMemberStatus) IsValid() bool { switch e { case ProjectMemberStatusOnBoarding, ProjectMemberStatusActive, ProjectMemberStatusInactive, ProjectMemberStatusPending: return true } return false } func (e ProjectMemberStatus) String() string { return string(e) } type ProjectImportantLevel string const ( ProjectImportantLevelLow ProjectImportantLevel = "low" ProjectImportantLevelMediumLow ProjectImportantLevel = "medium-" ProjectImportantLevelMedium ProjectImportantLevel = "medium" ProjectImportantLevelMediumHigh ProjectImportantLevel = "medium+" ProjectImportantLevelHigh ProjectImportantLevel = "high" ) func (e ProjectImportantLevel) IsValid() bool { switch e { case ProjectImportantLevelLow, ProjectImportantLevelMediumLow, ProjectImportantLevelMedium, ProjectImportantLevelMediumHigh, ProjectImportantLevelHigh: return true } return false } func (e ProjectImportantLevel) String() string { return string(e) } type ProjectSlot struct { BaseModel ProjectID UUID SeniorityID UUID UpsellPersonID UUID DeploymentType DeploymentType Status ProjectMemberStatus Rate decimal.Decimal Discount decimal.Decimal Note string Seniority Seniority Project Project ProjectMember ProjectMember ProjectSlotPositions []ProjectSlotPosition UpsellPerson *Employee } type ProjectMember struct { BaseModel ProjectID UUID EmployeeID UUID ProjectSlotID UUID StartDate *time.Time EndDate *time.Time Status ProjectMemberStatus Rate decimal.Decimal Discount decimal.Decimal DeploymentType DeploymentType UpsellPersonID UUID UpsellCommissionRate decimal.Decimal SeniorityID UUID Note string IsLead bool `gorm:"-"` Employee Employee `gorm:"foreignKey:EmployeeID"` UpsellPerson *Employee `gorm:"foreignKey:UpsellPersonID"` Project Project Seniority *Seniority ProjectMemberPositions []ProjectMemberPosition Positions []Position `gorm:"-"` Head *ProjectHead `gorm:"-"` } type HeadPosition string const ( HeadPositionTechnicalLead HeadPosition = "technical-lead" HeadPositionDeliveryManager HeadPosition = "delivery-manager" HeadPositionAccountManager HeadPosition = "account-manager" HeadPositionSalePerson HeadPosition = "sale-person" ) func (e HeadPosition) IsValid() bool { switch e { case HeadPositionTechnicalLead, HeadPositionDeliveryManager, HeadPositionAccountManager, HeadPositionSalePerson: return true } return false } func (e HeadPosition) String() string { return string(e) } type ProjectHead struct { BaseModel ProjectID UUID EmployeeID UUID StartDate time.Time EndDate *time.Time CommissionRate decimal.Decimal Position HeadPosition Employee Employee Project Project } func (p ProjectHead) IsLead() bool { return p.Position == HeadPositionTechnicalLead } func (p ProjectHead) IsAccountManager() bool { return p.Position == HeadPositionAccountManager } func (p ProjectHead) IsSalePerson() bool { return p.Position == HeadPositionSalePerson } func (p ProjectHead) IsDeliveryManager() bool { return p.Position == HeadPositionDeliveryManager } type ProjectStack struct { BaseModel ProjectID UUID StackID UUID Stack Stack } type ProjectFunction string const ( ProjectFunctionDevelopment ProjectFunction = "development" ProjectFunctionLearning ProjectFunction = "learning" ProjectFunctionTraining ProjectFunction = "training" ProjectFunctionManagement ProjectFunction = "management" ) func (e ProjectFunction) IsValid() bool { switch e { case ProjectFunctionDevelopment, ProjectFunctionLearning, ProjectFunctionTraining, ProjectFunctionManagement: return true } return false } func (e ProjectFunction) String() string { return string(e) } func IsUserActiveInProject(userID string, pm []ProjectMember) bool { for _, p := range pm { if p.EmployeeID.String() == userID && p.Status == ProjectMemberStatusActive { return true } } return false } func (pm *ProjectMember) IsActive() bool { if pm.StartDate != nil && !pm.StartDate.After(time.Now()) && // start_date <= now() (pm.EndDate == nil || pm.EndDate.After(time.Now())) { // end_date > now() return true } return false } var priority = []string{"us", "eu", "vn"} func (p Project) GetCompanyContactInfo() (*CompanyContactInfo, error) { res := CompanyContactInfo{} if p.CompanyInfo == nil { return &res, nil } m := map[string]*CompanyContactInfo{} v, err := p.CompanyInfo.Info.Value() if err != nil { return nil, err } if !driver.IsValue(v) || v == nil { return &res, nil } if err = json.Unmarshal(v.([]byte), &m); err != nil { return nil, err } for _, v := range priority { if m[v] != nil { return m[v], nil } } return &res, nil } type Projects []Project func (p Projects) ToNameIDMap() map[string]UUID { rs := map[string]UUID{} for _, itm := range p { rs[itm.Name] = itm.ID } return rs }
```

# pkg/model/questions.go

```go
package model // QuestionType type of question type QuestionType string // valid values for QuestionType const ( QuestionTypeScale QuestionType = "likert-scale" QuestionTypeGeneral QuestionType = "general" ) // IsValid validation for QuestionType func (e QuestionType) IsValid() bool { switch e { case QuestionTypeScale, QuestionTypeGeneral: return true } return false } // String returns a string representation of QuestionType func (e QuestionType) String() string { return string(e) } // Question model for questions table type Question struct { BaseModel Type QuestionType Category EventType Subcategory EventSubtype Content string Order int64 Domain QuestionDomain EventID UUID } // LikertScaleAnswer type of question type LikertScaleAnswer string // valid values for LikertScaleAnswer const ( LikertScaleAnswerStronglyDisagree LikertScaleAnswer = "strongly-disagree" LikertScaleAnswerDisagree LikertScaleAnswer = "disagree" LikertScaleAnswerMixed LikertScaleAnswer = "mixed" LikertScaleAnswerAgree LikertScaleAnswer = "agree" LikertScaleAnswerStronglyAgree LikertScaleAnswer = "strongly-agree" ) // IsValid validation for LikertScaleAnswer func (e LikertScaleAnswer) IsValid() bool { switch e { case LikertScaleAnswerStronglyDisagree, LikertScaleAnswerDisagree, LikertScaleAnswerMixed, LikertScaleAnswerAgree, LikertScaleAnswerStronglyAgree: return true } return false } // String returns a string representation of LikertScaleAnswer func (e LikertScaleAnswer) String() string { return string(e) } // QuestionDomain type for domain of questions table type QuestionDomain string // QuestionDomain values const ( QuestionDomainEngagement QuestionDomain = "engagement" QuestionDomainWorkload QuestionDomain = "workload" QuestionDomainDeadline QuestionDomain = "deadline" QuestionDomainLearning QuestionDomain = "learning" ) // IsValid validation for QuestionDomain func (e QuestionDomain) IsValid() bool { switch e { case QuestionDomainWorkload, QuestionDomainDeadline, QuestionDomainLearning: return true } return false } // String returns the string type from the QuestionDomain type func (e QuestionDomain) String() string { return string(e) } // LikertScaleCount represent for counted likert-scale answer model type LikertScaleCount struct { StronglyDisagree int `json:"stronglyDisagree" gorm:"column:strongly_disagree"` Disagree int `json:"disagree" gorm:"column:disagree"` Mixed int `json:"mixed" gorm:"column:mixed"` Agree int `json:"agree" gorm:"column:agree"` StronglyAgree int `json:"stronglyAgree" gorm:"column:strongly_agree"` } type QuestionDomainCount struct { Domain QuestionDomain LikertScaleCount } // AgreementLevel type for work survey answer type AgreementLevel string // AgreementLevel values const ( AgreementLevelStronglyDisagree AgreementLevel = "strongly-disagree" AgreementLevelDisagree AgreementLevel = "disagree" AgreementLevelMixed AgreementLevel = "mixed" AgreementLevelAgree AgreementLevel = "agree" AgreementLevelStronglyAgree AgreementLevel = "strongly-agree" ) // IsValid validation for AgreementLevel func (e AgreementLevel) IsValid() bool { switch e { case AgreementLevelStronglyDisagree, AgreementLevelDisagree, AgreementLevelMixed, AgreementLevelAgree, AgreementLevelStronglyAgree: return true } return false } // String returns the string type of AgreementLevel func (e AgreementLevel) String() string { return string(e) } var AgreementLevelMap = map[AgreementLevel]string{ AgreementLevelStronglyDisagree: "1", AgreementLevelDisagree: "2", AgreementLevelMixed: "3", AgreementLevelAgree: "4", AgreementLevelStronglyAgree: "5", } var AgreementLevelValueMap = map[string]AgreementLevel{ "1": AgreementLevelStronglyDisagree, "2": AgreementLevelDisagree, "3": AgreementLevelMixed, "4": AgreementLevelAgree, "5": AgreementLevelStronglyAgree, }
```

# pkg/model/research_topic.go

```go
package model import "time" // DiscordResearchTopic represents discord research topic type DiscordResearchTopic struct { Name string URL string MsgCount int64 SortedActiveUsers []DiscordTopicActiveUser LastActiveTime time.Time } // DiscordTopicActiveUser represents active users who send most messages in topic type DiscordTopicActiveUser struct { UserID string MsgCount int64 }
```

# pkg/model/roles.go

```go
package model const ( RoleFullTimeCode = "full-time" RoleProjectLeadCode = "project-lead" ) type Role struct { BaseModel Name string `json:"name"` Code string `json:"code"` Level int64 `json:"level"` Color string `json:"color"` IsShow bool `json:"isShow"` Employees []Employee `gorm:"many2many:employee_roles;"` }
```

# pkg/model/salary_advance.go

```go
package model import "time" type SalaryAdvance struct { BaseModel `json:"base_model"` EmployeeID UUID `json:"employee_id"` Employee *Employee `json:"employee"` CurrencyID UUID `json:"currency_id"` Currency *Currency `json:"currency"` AmountIcy int64 `json:"amount_icy"` AmountUSD float64 `json:"amount_usd"` BaseAmount float64 `json:"base_amount"` ConversionRate float64 `json:"conversion_rate"` IsPaidBack bool `json:"is_paid_back"` PaidAt *time.Time `json:"paid_at"` } func (SalaryAdvance) TableName() string { return "salary_advance_histories" } type AggregatedSalaryAdvance struct { EmployeeID string Employee *Employee AmountICY int64 AmountUSD float64 } type SalaryAdvanceReport struct { SalaryAdvances []AggregatedSalaryAdvance TotalICY int64 TotalUSD float64 Count int64 }
```

# pkg/model/schedule.go

```go
package model import "time" type Schedule struct { BaseModel Name string Description string ScheduleType string SyncedAt *time.Time StartTime *time.Time EndTime *time.Time GoogleCalendar *ScheduleGoogleCalendar DiscordEvent *ScheduleDiscordEvent NotionPage *ScheduleNotionPage } type ScheduleGoogleCalendar struct { BaseModel ScheduleID UUID GoogleCalendarID string Description string HangoutLink string } type ScheduleDiscordEvent struct { BaseModel ScheduleID UUID DiscordEventID string Description string VoiceChannelID string } type ScheduleNotionPage struct { BaseModel ScheduleID UUID NotionPageID string Description string }
```

# pkg/model/senitorities.go

```go
package model type Seniority struct { BaseModel Name string `json:"name"` Code string `json:"code"` Level int `json:"level"` }
```

# pkg/model/social_account.go

```go
package model type SocialAccount struct { BaseModel EmployeeID UUID Type SocialAccountType AccountID string Email string Name string } // SocialAccountType social type for social_account table type SocialAccountType string // values for working_status const ( SocialAccountTypeGitHub SocialAccountType = "github" SocialAccountTypeGitLab SocialAccountType = "gitlab" SocialAccountTypeNotion SocialAccountType = "notion" SocialAccountTypeLinkedIn SocialAccountType = "linkedin" SocialAccountTypeTwitter SocialAccountType = "twitter" ) // IsValid validation for SocialAccountType func (e SocialAccountType) IsValid() bool { switch e { case SocialAccountTypeGitHub, SocialAccountTypeGitLab, SocialAccountTypeNotion, SocialAccountTypeLinkedIn, SocialAccountTypeTwitter: return true } return false } // String returns the string type from the SocialAccountType type func (e SocialAccountType) String() string { return string(e) } type SocialAccounts []SocialAccount func (e SocialAccounts) GetGithub() *SocialAccount { for _, account := range e { if account.Type == SocialAccountTypeGitHub { return &account } } return nil } func (e SocialAccounts) ToMap() (map[string]string, map[string]string) { m := make(map[string]string) rm := make(map[string]string) for _, account := range e { if account.AccountID != "" { m[account.AccountID] = account.EmployeeID.String() } rm[account.EmployeeID.String()] = account.AccountID } return m, rm } type SocialAccountInput struct { GithubID string NotionID string NotionName string NotionEmail string LinkedInName string }
```

# pkg/model/stacks.go

```go
package model type Stack struct { BaseModel Name string `json:"name"` Code string `json:"code"` Avatar string `json:"avatar"` } // ToStackMap create map from stacks func ToStackMap(stacks []*Stack) map[UUID]string { rs := map[UUID]string{} for _, s := range stacks { rs[s.ID] = s.Name } return rs }
```

# pkg/model/transferwise.go

```go
package model // TWQuote defines a structure for quote request in transferwise type TWQuote struct { SourceAmount float64 `json:"sourceAmount"` Fee float64 `json:"fee"` Rate float64 `json:"rate"` } type TWRate struct { Rate float64 `json:"rate"` Source string `json:"source"` Target string `json:"target"` }
```

# pkg/model/user_bank_accounts.go

```go
package model type UserBankAccount struct { BaseModel EmployerID UUID DiscordAccountID UUID BankID UUID AccountNumber string Branch string }
```

# pkg/model/uuid.go

```go
package model import ( "database/sql/driver" "errors" uuid "github.com/satori/go.uuid" ) // UUID implement for go-pg convert uuid type UUID [16]byte // NewUUID create new UUID with V4 func NewUUID() UUID { return UUID(uuid.NewV4()) } // UUIDFromString convert string to UUID func UUIDFromString(s string) (UUID, error) { id, err := uuid.FromString(s) return UUID(id), err } // IsZero check uuid is zero func (u *UUID) IsZero() bool { if u == nil { return true } for _, c := range u { if c != 0 { return false } } return true } func (u UUID) String() string { if u.IsZero() { return "" } return uuid.UUID(u).String() } // MarshalJSON implement for json encoding func (u UUID) MarshalJSON() ([]byte, error) { if len(u) == 0 { return []byte(`""`), nil } return []byte(`"` + u.String() + `"`), nil } // UnmarshalJSON implement for json decoding func (u *UUID) UnmarshalJSON(data []byte) error { if len(data) == 0 || string(data) == `""` { return nil } if len(data) < 2 || data[0] != '"' || data[len(data)-1] != '"' { return errors.New("invalid UUID format") } data = data[1 : len(data)-1] uu, err := uuid.FromString(string(data)) if err != nil { return errors.New("invalid UUID format") } *u = UUID(uu) return nil } // Value . func (u UUID) Value() (driver.Value, error) { if u.IsZero() { return nil, nil } return uuid.UUID(u).String(), nil } // Scan . func (u *UUID) Scan(b interface{}) error { if b == nil { for i := range u { u[i] = 0 } return nil } // postgres store DB as a string id, err := uuid.FromString(string(b.([]byte))) if err != nil { return err } copy(u[:], id[:]) return nil } func NewUUIDFromString(s string) (*UUID, error) { uuid, err := uuid.FromString(s) if err != nil { return nil, err } id := &UUID{} copy(id[:], uuid[:]) return id, nil } func IsUUIDFromString(s string) bool { _, err := uuid.FromString(s) return err == nil } // MustGetUUIDFromString get uuid from string if failed throw panic, // CAUTION: IT ONLY USE FOR TESTING func MustGetUUIDFromString(s string) UUID { id, err := uuid.FromString(s) if err != nil { panic(err) } return UUID(id) } type UUIDStruct struct { ID UUID }
```

# pkg/model/valuation.go

```go
// please edit this file only with approval from hnh package model type Valuation struct { // basic info Year string `json:"year"` Rate float64 `json:"rate"` Currency string `json:"currency"` // valuation info Assets float64 `json:"assets"` // money that company will receive in the future AccountReceivable struct { Total float64 `json:"total"` Items []AccountingItem `json:"items"` } `json:"accountReceivable"` // money that company will pay in the future Liabilities struct { Total float64 `json:"total"` Items []AccountingItem `json:"items"` } `json:"liabilities"` // Total paid invoice, investment & bank interest Income struct { Total float64 `json:"total"` Detail struct { ConsultantService float64 `json:"consultantService"` Investment float64 `json:"investment"` Interest float64 `json:"interest"` } `json:"detail"` } `json:"income"` // Sum of Expenses and payroll Outcome struct { Total float64 `json:"total"` Detail struct { Payroll float64 `json:"payroll"` Expense float64 `json:"expense"` Investment float64 `json:"investment"` } `json:"detail"` } `json:"outcome"` } type AccountingItem struct { Name string `json:"name"` Amount float64 `json:"amount"` } type CurrencyView struct { USD float64 VND float64 EUR float64 GBP float64 SGD float64 }
```

# pkg/model/webhook.go

```go
package model import ( "encoding/json" "io" "strings" ) // BasecampWebhookMessage is a structure display basecamp webhook message type BasecampWebhookMessage struct { Kind string `json:"kind,omitempty"` Recording BasecampRecording `json:"recording,omitempty"` Creator BasecampUser `json:"creator,omitempty"` } func (msg *BasecampWebhookMessage) Decode(body []byte) error { return json.Unmarshal(body, &msg) } func (msg *BasecampWebhookMessage) Read(rc io.ReadCloser) []byte { defer rc.Close() body, _ := io.ReadAll(rc) return body } // IsOperationComplete true when parent (Todolist) title contain "Operations" example title ("Operations | July 2019") func (msg *BasecampWebhookMessage) IsOperationComplete() bool { split := strings.Split(strings.Replace(msg.Recording.Parent.Title, " ", "", -1), "|") if len(split) < 2 { return false } if strings.ToLower(split[0]) != "operations" { return false } return true } func (msg *BasecampWebhookMessage) IsExpenseComplete() bool { pt := msg.Recording.Parent.Title if len(pt) < 8 || strings.ToLower(pt[:8]) != "expenses" { return false } return true }
```

# pkg/model/weekly_delivery_metric.go

```go
package model import ( "time" "github.com/shopspring/decimal" ) type WeeklyDeliveryMetric struct { Date *time.Time SumWeight decimal.Decimal SumEffort decimal.Decimal } type AvgWeeklyDeliveryMetric struct { Weight decimal.Decimal Effort decimal.Decimal } type AvgMonthWeeklyDeliveryMetric struct { Date *time.Time Weight decimal.Decimal Effort decimal.Decimal }
```

# pkg/model/wise.go

```go
package model type WiseConversionRate struct { Rate float64 `json:"rate"` Source string `json:"source"` Target string `json:"target"` }
```

# pkg/model/work_unit_members.go

```go
package model import ( "time" ) type WorkUnitMember struct { BaseModel Status string StartDate time.Time EndDate *time.Time EmployeeID UUID WorkUnitID UUID ProjectID UUID Employee Employee WorkUnit WorkUnit } type WorkUnitPeer struct { EmployeeID UUID ReviewerID UUID } type WorkUnitMemberStatus string const ( WorkUnitMemberStatusActive WorkUnitMemberStatus = "active" WorkUnitMemberStatusInactive WorkUnitMemberStatus = "inactive" ) func (e WorkUnitMemberStatus) IsValid() bool { switch e { case WorkUnitMemberStatusActive, WorkUnitMemberStatusInactive: return true } return false } func (e WorkUnitMemberStatus) String() string { return string(e) }
```

# pkg/model/work_unit_stacks.go

```go
package model type WorkUnitStack struct { BaseModel StackID UUID WorkUnitID UUID Stack Stack }
```

# pkg/model/work_units.go

```go
package model import ( "gorm.io/datatypes" ) type WorkUnit struct { BaseModel Name string SourceURL string Status WorkUnitStatus Type WorkUnitType SourceMetadata datatypes.JSON ProjectID UUID WorkUnitMembers []*WorkUnitMember WorkUnitStacks []*WorkUnitStack Project *Project } type WorkUnitStatus string const ( WorkUnitStatusActive WorkUnitStatus = "active" WorkUnitStatusArchived WorkUnitStatus = "archived" ) func (e WorkUnitStatus) IsValid() bool { switch e { case WorkUnitStatusActive, WorkUnitStatusArchived: return true } return false } func (e WorkUnitStatus) String() string { return string(e) } type WorkUnitType string const ( WorkUnitTypeDevelopment WorkUnitType = "development" WorkUnitTypeManagement WorkUnitType = "management" WorkUnitTypeTraining WorkUnitType = "training" WorkUnitTypeLearning WorkUnitType = "learning" ) func (e WorkUnitType) IsValid() bool { switch e { case WorkUnitTypeDevelopment, WorkUnitTypeManagement, WorkUnitTypeTraining, WorkUnitTypeLearning: return true } return false } func (e WorkUnitType) String() string { return string(e) }
```

# pkg/model/worker_message.go

```go
package model type Action uint8 type WorkerMessage struct { Type string Payload interface{} }
```

# pkg/request/validator.go

```go
package request import ( "reflect" "strconv" "strings" "github.com/gin-gonic/gin" "github.com/gin-gonic/gin/binding" "github.com/go-playground/validator/v10" "github.com/dwarvesf/fortress-api/pkg/logger" ) func RegisCustomValidators(engine *gin.Engine) { if v, ok := binding.Validator.Engine().(*validator.Validate); ok { regisCrossFieldGte(v) } } func regisCrossFieldGte(v *validator.Validate) { err := v.RegisterValidation("fieldgte", func(fl validator.FieldLevel) bool { field := fl.Field() kind := field.Kind() params := strings.Split(fl.Param(), " ") currentField, currentKind, _, found := fl.GetStructFieldOKAdvanced2(fl.Parent(), params[0]) if !found || currentKind != kind { return false } gteValue, err := strconv.ParseInt(params[1], 10, 64) if err != nil { return false } switch kind { case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: return field.Int()-currentField.Int() >= gteValue case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: return field.Uint()-currentField.Uint() >= uint64(gteValue) case reflect.Float32, reflect.Float64: return field.Float()-currentField.Float() >= float64(gteValue) } return len(field.String())-len(currentField.String()) >= int(gteValue) }) if err != nil { logger.L.Error(err, "failed to register validation") } }
```

# pkg/routes/routes.go

```go
package routes import ( "strings" "github.com/gin-contrib/cors" "github.com/gin-contrib/pprof" "github.com/gin-gonic/gin" swaggerFiles "github.com/swaggo/files" // swagger embed files ginSwagger "github.com/swaggo/gin-swagger" // gin-swagger middleware "github.com/dwarvesf/fortress-api/docs" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/controller" "github.com/dwarvesf/fortress-api/pkg/handler" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service" "github.com/dwarvesf/fortress-api/pkg/store" "github.com/dwarvesf/fortress-api/pkg/worker" ) func setupCORS(r *gin.Engine, cfg *config.Config) { corsOrigins := strings.Split(cfg.ApiServer.AllowedOrigins, ";") r.Use(func(c *gin.Context) { cors.New( cors.Config{ AllowOrigins: corsOrigins, AllowMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD"}, AllowHeaders: []string{ "Origin", "Host", "Content-Type", "Content-Length", "Accept-Encoding", "Accept-Language", "Accept", "X-CSRF-Token", "Authorization", "X-Requested-With", "X-Access-Token", }, AllowCredentials: true, }, )(c) }) } func NewRoutes(cfg *config.Config, svc *service.Service, s *store.Store, repo store.DBRepo, worker *worker.Worker, logger logger.Logger) *gin.Engine { // programmatically set swagger info docs.SwaggerInfo.Title = "Swagger API" docs.SwaggerInfo.Description = "This is a swagger for API." docs.SwaggerInfo.Version = "1.0" docs.SwaggerInfo.Schemes = []string{"https", "http"} r := gin.New() pprof.Register(r) ctrl := controller.New(s, repo, svc, worker, logger, cfg) h := handler.New(s, repo, svc, ctrl, worker, logger, cfg) r.Use( gin.LoggerWithWriter(gin.DefaultWriter, "/healthz"), gin.Recovery(), ) // config CORS setupCORS(r, cfg) r.GET("/healthz", h.Healthcheck.Healthz) // use ginSwagger middleware to serve the API docs r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler)) // load API here loadV1Routes(r, h, repo, s, cfg) return r }
```

# pkg/routes/v1.go

```go
package routes import ( "github.com/gin-gonic/gin" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/handler" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/mw" "github.com/dwarvesf/fortress-api/pkg/store" ) func loadV1Routes(r *gin.Engine, h *handler.Handler, repo store.DBRepo, s *store.Store, cfg *config.Config) { pmw := mw.NewPermissionMiddleware(s, repo, cfg) amw := mw.NewAuthMiddleware(cfg, s, repo) ///////////////// // Cronjob GROUP ///////////////// cronjob := r.Group("/cronjobs") { cronjob.POST("/audits", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Audit.Sync) cronjob.POST("/birthday", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.BirthdayDailyMessage) cronjob.POST("/on-leaves", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.OnLeaveMessage) cronjob.POST("/sync-discord-info", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.SyncDiscordInfo) cronjob.POST("/sync-monthly-accounting-todo", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Accounting.CreateAccountingTodo) cronjob.POST("/sync-project-member-status", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Project.SyncProjectMemberStatus) cronjob.POST("/store-vault-transaction", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Vault.StoreVaultTransaction) cronjob.POST("/index-engagement-messages", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Engagement.IndexMessages) cronjob.POST("/brainery-reports", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.ReportBraineryMetrics) cronjob.POST("/delivery-metric-reports", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.DeliveryMetricsReport) cronjob.POST("/sync-delivery-metrics", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.DeliveryMetric.Sync) cronjob.POST("/sync-conversion-rates", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.ConversionRate.Sync) cronjob.POST("/sync-memo", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.SyncMemo) cronjob.POST("/sweep-memo", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.SweepMemo) cronjob.POST("/notify-weekly-memos", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.NotifyWeeklyMemos) cronjob.POST("/transcribe-youtube-broadcast", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Youtube.TranscribeBroadcast) cronjob.POST("/sweep-ogif-event", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.Discord.SweepOgifEvent) } ///////////////// // Webhook GROUP ///////////////// webhook := r.Group("/webhooks") { webhook.POST("/n8n", h.Webhook.N8n) basecampGroup := webhook.Group("/basecamp") { expenseGroup := basecampGroup.Group("/expense") { expenseGroup.POST("/validate", h.Webhook.ValidateBasecampExpense) expenseGroup.POST("", h.Webhook.CreateBasecampExpense) expenseGroup.DELETE("", h.Webhook.UncheckBasecampExpense) } operationGroup := basecampGroup.Group("/operation") { operationGroup.POST("/accounting-transaction", h.Webhook.StoreAccountingTransaction) operationGroup.PUT("/invoice", h.Webhook.MarkInvoiceAsPaidViaBasecamp) } onLeaveGroup := basecampGroup.Group("/onleave") { onLeaveGroup.POST("/validate", h.Webhook.ValidateOnLeaveRequest) onLeaveGroup.POST("", h.Webhook.ApproveOnLeaveRequest) } } } ///////////////// // API GROUP ///////////////// v1 := r.Group("/api/v1") // assets assetGroup := v1.Group("/assets") { assetGroup.POST("/upload", amw.WithAuth, h.Asset.Upload) } lineManagerGroup := v1.Group("/line-managers") { lineManagerGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesRead), h.Employee.GetLineManagers) } // auth authRoute := v1.Group("/auth") { authRoute.POST("", h.Auth.Auth) authRoute.GET("/me", amw.WithAuth, pmw.WithPerm(model.PermissionAuthRead), h.Auth.Me) authRoute.POST("/api-key", amw.WithAuth, pmw.WithPerm(model.PermissionAuthCreate), h.Auth.CreateAPIKey) } // user profile profileGroup := v1.Group("/profile") { profileGroup.GET("", amw.WithAuth, h.Profile.GetProfile) profileGroup.PUT("", amw.WithAuth, h.Profile.UpdateInfo) profileGroup.POST("/upload-avatar", amw.WithAuth, h.Profile.UploadAvatar) profileGroup.POST("/upload", amw.WithAuth, h.Profile.Upload) } // employees employeeRoute := v1.Group("/employees") { employeeRoute.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesCreate), h.Employee.Create) employeeRoute.POST("/search", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesRead), h.Employee.List) employeeRoute.GET("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesRead), h.Employee.Details) employeeRoute.PUT("/:id/general-info", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesEdit), h.Employee.UpdateGeneralInfo) employeeRoute.PUT("/:id/personal-info", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesEdit), h.Employee.UpdatePersonalInfo) employeeRoute.PUT("/:id/skills", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesEdit), h.Employee.UpdateSkills) employeeRoute.PUT("/:id/employee-status", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesEdit), h.Employee.UpdateEmployeeStatus) employeeRoute.POST("/:id/upload-avatar", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesEdit), h.Employee.UploadAvatar) employeeRoute.PUT("/:id/roles", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeeRolesEdit), h.Employee.UpdateRole) employeeRoute.PUT("/:id/base-salary", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesBaseSalaryEdit), h.Employee.UpdateBaseSalary) } // metadata metadataRoute := v1.Group("/metadata") { metadataRoute.GET("/working-status", h.Metadata.WorkingStatuses) metadataRoute.GET("/banks", h.Metadata.Banks) metadataRoute.GET("/stacks", h.Metadata.Stacks) metadataRoute.GET("/seniorities", h.Metadata.Seniorities) metadataRoute.GET("/chapters", h.Metadata.Chapters) metadataRoute.GET("/organizations", h.Metadata.Organizations) metadataRoute.GET("/roles", h.Metadata.GetRoles) metadataRoute.GET("/positions", h.Metadata.Positions) metadataRoute.GET("/countries", h.Metadata.GetCountries) metadataRoute.GET("/currencies", h.Metadata.GetCurrencies) metadataRoute.GET("/countries/:country_id/cities", h.Metadata.GetCities) metadataRoute.GET("/project-statuses", h.Metadata.ProjectStatuses) metadataRoute.GET("/questions", h.Metadata.GetQuestions) metadataRoute.PUT("/stacks/:id", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataEdit), h.Metadata.UpdateStack) metadataRoute.POST("/stacks", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataCreate), h.Metadata.CreateStack) metadataRoute.DELETE("/stacks/:id", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataDelete), h.Metadata.DeleteStack) metadataRoute.PUT("/positions/:id", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataEdit), h.Metadata.UpdatePosition) metadataRoute.POST("/positions", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataCreate), h.Metadata.CreatePosition) metadataRoute.DELETE("/positions/:id", amw.WithAuth, pmw.WithPerm(model.PermissionMetadataDelete), h.Metadata.DeletePosition) } // projects projectGroup := v1.Group("projects") { projectGroup.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsCreate), h.Project.Create) projectGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsRead), h.Project.List) projectGroup.GET("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsRead), h.Project.Details) projectGroup.PUT("/:id/sending-survey-state", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsEdit), h.Project.UpdateSendingSurveyState) projectGroup.POST("/:id/upload-avatar", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsEdit), h.Project.UploadAvatar) projectGroup.PUT("/:id/status", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsEdit), h.Project.UpdateProjectStatus) projectGroup.POST("/:id/members", amw.WithAuth, pmw.WithPerm(model.PermissionProjectMembersCreate), h.Project.AssignMember) projectGroup.GET("/:id/members", amw.WithAuth, pmw.WithPerm(model.PermissionProjectMembersRead), h.Project.GetMembers) projectGroup.PUT("/:id/members", amw.WithAuth, pmw.WithPerm(model.PermissionProjectMembersEdit), h.Project.UpdateMember) projectGroup.DELETE("/:id/members/:memberID", amw.WithAuth, pmw.WithPerm(model.PermissionProjectMembersDelete), h.Project.DeleteMember) projectGroup.DELETE("/:id/slots/:slotID", amw.WithAuth, pmw.WithPerm(model.PermissionProjectMembersDelete), h.Project.DeleteSlot) projectGroup.PUT("/:id/general-info", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsEdit), h.Project.UpdateGeneralInfo) projectGroup.PUT("/:id/contact-info", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsEdit), h.Project.UpdateContactInfo) projectGroup.GET("/:id/work-units", amw.WithAuth, pmw.WithPerm(model.PermissionProjectWorkUnitsRead), h.Project.GetWorkUnits) projectGroup.POST("/:id/work-units", amw.WithAuth, pmw.WithPerm(model.PermissionProjectWorkUnitsCreate), h.Project.CreateWorkUnit) projectGroup.PUT("/:id/work-units/:workUnitID", amw.WithAuth, pmw.WithPerm(model.PermissionProjectWorkUnitsEdit), h.Project.UpdateWorkUnit) projectGroup.PUT("/:id/work-units/:workUnitID/archive", amw.WithAuth, pmw.WithPerm(model.PermissionProjectWorkUnitsEdit), h.Project.ArchiveWorkUnit) projectGroup.PUT("/:id/work-units/:workUnitID/unarchive", amw.WithAuth, pmw.WithPerm(model.PermissionProjectWorkUnitsEdit), h.Project.UnarchiveWorkUnit) projectGroup.GET("/:id/commission-models", amw.WithAuth, pmw.WithPerm(model.PermissionProjectsCommissionModelsRead), h.Project.CommissionModels) projectGroup.GET("/icy-distribution/weekly", amw.WithAuth, pmw.WithPerm(model.PermissionIcyDistributionRead), h.Project.IcyWeeklyDistribution) } clientGroup := v1.Group("/clients") { clientGroup.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionClientCreate), h.Client.Create) clientGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionClientRead), h.Client.List) clientGroup.GET("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionClientEdit), h.Client.Detail) clientGroup.PUT("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionClientRead), h.Client.Update) clientGroup.DELETE("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionClientDelete), h.Client.Delete) } feedbackGroup := v1.Group("/feedbacks") { feedbackGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionFeedbacksRead), h.Feedback.List) feedbackGroup.GET("/:id/topics/:topicID", amw.WithAuth, pmw.WithPerm(model.PermissionFeedbacksRead), h.Feedback.Detail) feedbackGroup.POST("/:id/topics/:topicID/submit", amw.WithAuth, pmw.WithPerm(model.PermissionFeedbacksCreate), h.Feedback.Submit) feedbackGroup.GET("/unreads", amw.WithAuth, pmw.WithPerm(model.PermissionFeedbacksRead), h.Feedback.CountUnreadFeedback) } surveyGroup := v1.Group("/surveys") { surveyGroup.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysCreate), h.Survey.CreateSurvey) surveyGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysRead), h.Survey.ListSurvey) surveyGroup.GET("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysRead), h.Survey.GetSurveyDetail) surveyGroup.DELETE("/:id", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysDelete), h.Survey.DeleteSurvey) surveyGroup.POST("/:id/send", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysCreate), h.Survey.SendSurvey) surveyGroup.GET("/:id/topics/:topicID/reviews/:reviewID", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeeEventQuestionsRead), h.Survey.GetSurveyReviewDetail) surveyGroup.DELETE("/:id/topics/:topicID", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysDelete), h.Survey.DeleteSurveyTopic) surveyGroup.GET("/:id/topics/:topicID", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysRead), h.Survey.GetSurveyTopicDetail) surveyGroup.PUT("/:id/topics/:topicID/employees", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysEdit), h.Survey.UpdateTopicReviewers) surveyGroup.PUT("/:id/done", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysEdit), h.Survey.MarkDone) surveyGroup.DELETE("/:id/topics/:topicID/employees", amw.WithAuth, pmw.WithPerm(model.PermissionSurveysEdit), h.Survey.DeleteTopicReviewers) } bankGroup := v1.Group("/bank-accounts") { bankGroup.GET("", pmw.WithPerm(model.PermissionBankAccountRead), h.BankAccount.List) } companyInfoGroup := v1.Group("/company-infos") { companyInfoGroup.GET("", pmw.WithPerm(model.PermissionCompanyInfoRead), h.CompanyInfo.List) } invoiceGroup := v1.Group("/invoices") { invoiceGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionInvoiceRead), h.Invoice.List) invoiceGroup.PUT("/:id/status", amw.WithAuth, pmw.WithPerm(model.PermissionInvoiceEdit), h.Invoice.UpdateStatus) invoiceGroup.GET("/template", amw.WithAuth, pmw.WithPerm(model.PermissionInvoiceRead), h.Invoice.GetTemplate) invoiceGroup.POST("/send", amw.WithAuth, pmw.WithPerm(model.PermissionInvoiceRead), h.Invoice.Send) } valuation := v1.Group("/valuation") { valuation.GET("/:year", pmw.WithPerm(model.PermissionValuationRead), h.Valuation.One) } notion := v1.Group("/notion") { earn := notion.Group("/earn") { earn.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListEarns) } techRadar := notion.Group("/tech-radar") { techRadar.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListTechRadars) techRadar.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionCreate), h.Notion.CreateTechRadar) } audience := notion.Group("/audiences") { audience.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListAudiences) } event := notion.Group("/events") { event.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListEvents) } digest := notion.Group("/digests") { digest.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListDigests) } update := notion.Group("/updates") { update.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListUpdates) } memo := notion.Group("/memos") { memo.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListMemos) } issue := notion.Group("/issues") { issue.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListIssues) } staffingDemand := notion.Group("/staffing-demands") { staffingDemand.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListStaffingDemands) } hiring := notion.Group("/hiring-positions") { hiring.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListHiringPositions) } projectNotion := notion.Group("/projects") { projectNotion.GET("/milestones", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.ListProjectMilestones) } dfUpdates := notion.Group("df-updates") { dfUpdates.POST("/:id/send", amw.WithAuth, pmw.WithPerm(model.PermissionNotionSend), h.Notion.SendNewsLetter) } notionChangelog := notion.Group("changelogs") { notionChangelog.GET("/projects/available", amw.WithAuth, pmw.WithPerm(model.PermissionNotionRead), h.Notion.GetAvailableProjectsChangelog) notionChangelog.POST("/project", amw.WithAuth, pmw.WithPerm(model.PermissionNotionSend), h.Notion.SendProjectChangelog) } } dashboard := v1.Group("/dashboards") { engagementDashboardGroup := dashboard.Group("/engagement", amw.WithAuth, pmw.WithPerm(model.PermissionDashBoardEngagementRead)) { engagementDashboardGroup.GET("/info", h.Dashboard.GetEngagementInfo) engagementDashboardGroup.GET("/detail", h.Dashboard.GetEngagementInfoDetail) } projectDashboardGroup := dashboard.Group("/projects", amw.WithAuth, pmw.WithPerm(model.PermissionDashBoardProjectsRead)) { projectDashboardGroup.GET("/sizes", h.Dashboard.GetProjectSizes) projectDashboardGroup.GET("/work-surveys", h.Dashboard.GetWorkSurveys) projectDashboardGroup.GET("/action-items", h.Dashboard.GetActionItemReports) projectDashboardGroup.GET("/engineering-healths", h.Dashboard.GetEngineeringHealth) projectDashboardGroup.GET("/audits", h.Dashboard.GetAudits) projectDashboardGroup.GET("/action-item-squash", h.Dashboard.GetActionItemSquashReports) projectDashboardGroup.GET("/summary", h.Dashboard.GetSummary) } resourceDashboardGroup := dashboard.Group("/resources", amw.WithAuth, pmw.WithPerm(model.PermissionDashBoardResourcesRead)) { resourceDashboardGroup.GET("/availabilities", h.Dashboard.GetResourcesAvailability) resourceDashboardGroup.GET("/utilization", h.Dashboard.GetResourceUtilization) resourceDashboardGroup.GET("/work-unit-distribution", h.Dashboard.GetWorkUnitDistribution) resourceDashboardGroup.GET("/work-unit-distribution-summary", h.Dashboard.GetWorkUnitDistributionSummary) resourceDashboardGroup.GET("/work-survey-summaries", h.Dashboard.GetResourceWorkSurveySummaries) } } payroll := v1.Group("payrolls") { payroll.PUT("", amw.WithAuth, pmw.WithPerm(model.PermissionPayrollsEdit), h.Payroll.MarkPayrollAsPaid) payroll.GET("/detail", amw.WithAuth, pmw.WithPerm(model.PermissionPayrollsRead), h.Payroll.GetPayrollsByMonth) payroll.GET("/bhxh", amw.WithAuth, pmw.WithPerm(model.PermissionPayrollsRead), h.Payroll.GetPayrollsBHXH) payroll.POST("/commit", amw.WithAuth, pmw.WithPerm(model.PermissionPayrollsCreate), h.Payroll.CommitPayroll) } invitationGroup := v1.Group("/invite") { invitationGroup.GET("", amw.WithAuth, h.Profile.GetInvitation) invitationGroup.PUT("/submit", amw.WithAuth, h.Profile.SubmitOnboardingForm) } engagementsGroup := v1.Group("/engagements") { engagementsGroup.POST( "/rollup", amw.WithAuth, pmw.WithPerm(model.PermissionEngagementMetricsWrite), h.Engagement.UpsertRollup, ) engagementsGroup.GET( "/channels/:channel-id/last-message-id", amw.WithAuth, pmw.WithPerm(model.PermissionEngagementMetricsRead), h.Engagement.GetLastMessageID, ) } braineryGroup := v1.Group("/brainery-logs") { braineryGroup.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionBraineryLogsWrite), h.BraineryLog.Create) braineryGroup.GET("/metrics", amw.WithAuth, pmw.WithPerm(model.PermissionBraineryLogsRead), h.BraineryLog.GetMetrics) braineryGroup.POST("/sync", amw.WithAuth, pmw.WithPerm(model.PermissionCronjobExecute), h.BraineryLog.Sync) } memoGroup := v1.Group("/memos") { memoGroup.POST("", amw.WithAuth, h.MemoLog.Create) memoGroup.POST("/sync", amw.WithAuth, h.MemoLog.Sync) memoGroup.GET("", amw.WithAuth, h.MemoLog.List) memoGroup.GET("/discords", amw.WithAuth, h.MemoLog.ListByDiscordID) memoGroup.GET("/prs", amw.WithAuth, h.MemoLog.ListOpenPullRequest) memoGroup.GET("/top-authors", amw.WithAuth, h.MemoLog.GetTopAuthors) } earnGroup := v1.Group("/earns") { earnGroup.GET("", amw.WithAuth, h.Earn.ListEarn) } // Delivery metrics { deliveryGroup := v1.Group("/delivery-metrics") deliveryGroup.POST("/report/sync", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsSync), h.DeliveryMetric.Sync) deliveryGroup.GET("/report/weekly", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsRead), h.DeliveryMetric.GetWeeklyReport) deliveryGroup.GET("/report/monthly", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsRead), h.DeliveryMetric.GetMonthlyReport) deliveryGroup.GET("/leader-board/weekly", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsLeaderBoardRead), h.DeliveryMetric.GetWeeklyLeaderBoard) deliveryGroup.GET("/leader-board/monthly", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsLeaderBoardRead), h.DeliveryMetric.GetMonthlyLeaderBoard) // API for fortress-discord deliveryGroup.GET("/report/weekly/discord-msg", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsRead), h.DeliveryMetric.GetWeeklyReportDiscordMsg) deliveryGroup.GET("/report/monthly/discord-msg", amw.WithAuth, pmw.WithPerm(model.PermissionDeliveryMetricsRead), h.DeliveryMetric.GetMonthlyReportDiscordMsg) } discordGroup := v1.Group("/discords") { discordGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.ListByDiscordRequest) discordGroup.GET("/mma-scores", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.ListWithMMAScore) discordGroup.POST("/advance-salary", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.SalaryAdvance) discordGroup.POST("/check-advance-salary", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.CheckSalaryAdvance) discordGroup.GET("/salary-advance-report", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.SalaryAdvanceReport) discordGroup.GET("/:discord_id/earns/transactions", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.GetEmployeeEarnTransactions) discordGroup.GET("/:discord_id/earns/total", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.GetEmployeeTotalEarn) discordGroup.GET("/earns/total", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Employee.GetTotalEarn) discordGroup.POST("/office-checkin", amw.WithAuth, pmw.WithPerm(model.PermissionTransferCheckinIcy), h.Employee.OfficeCheckIn) discordGroup.GET("/icy-accounting", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Icy.Accounting) scheduledEventGroup := discordGroup.Group("/scheduled-events") { scheduledEventGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Discord.ListScheduledEvent) scheduledEventGroup.POST("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordCreate), h.Discord.CreateScheduledEvent) scheduledEventGroup.PUT("/:id/speakers", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordEdit), h.Discord.SetScheduledEventSpeakers) } discordGroup.GET("/research-topics", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Discord.ListDiscordResearchTopics) } conversionRateGroup := v1.Group("/conversion-rates") { conversionRateGroup.GET("", amw.WithAuth, h.ConversionRate.List) } newsGroup := v1.Group("/news") { newsGroup.GET("", amw.WithAuth, h.News.Fetch) } ogifGroup := v1.Group("/ogif") { ogifGroup.GET("", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Discord.UserOgifStats) ogifGroup.GET("/leaderboard", amw.WithAuth, pmw.WithPerm(model.PermissionEmployeesDiscordRead), h.Discord.OgifLeaderboard) } ///////////////// // PUBLIC API GROUP ///////////////// // assets publicGroup := v1.Group("/public") { publicGroup.GET("/employees", h.Employee.PublicList) publicGroup.GET("/clients", h.Client.PublicList) publicGroup.GET("/community-nfts/:id", h.CommunityNft.GetNftMetadata) publicGroup.GET("/youtube/broadcast", h.Youtube.LatestBroadcast) } }
```

# pkg/service/basecamp/attachment/attachment.go

```go
package attachment import ( "bytes" "encoding/json" "fmt" "net/http" "net/url" "strconv" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type AttachmentService struct { client client.Service } func NewService(client client.Service) Service { return &AttachmentService{ client: client, } } func (a *AttachmentService) Create(contentType, fileName string, file []byte) (string, error) { url := fmt.Sprintf("%v/%v/attachments.json?name=%v", model.BasecampAPIEndpoint, model.CompanyID, url.QueryEscape(fileName)) req, err := http.NewRequest("POST", url, bytes.NewBuffer(file)) if err != nil { return "", err } req.Header.Add("content-type", contentType) req.Header.Add("content-length", strconv.Itoa(len(file))) resp, err := a.client.Do(req) if err != nil { return "", err } defer resp.Body.Close() if resp.StatusCode != http.StatusCreated { return "", fmt.Errorf("create attachment failed") } attachRes := &struct { SgID string `json:"attachable_sgid"` }{} if err := json.NewDecoder(resp.Body).Decode(attachRes); err != nil { return "", err } defer resp.Body.Close() return attachRes.SgID, nil }
```

# pkg/service/basecamp/attachment/service.go

```go
package attachment type Service interface { Create(contentType string, fileName string, file []byte) (id string, err error) }
```

# pkg/service/basecamp/basecamp.go

```go
package basecamp import ( "fmt" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/attachment" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/campfire" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/comment" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/messageboard" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/people" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/project" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/recording" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/schedule" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/subscription" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/todo" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/webhook" "github.com/dwarvesf/fortress-api/pkg/service/wise" "github.com/dwarvesf/fortress-api/pkg/store" ) type Service struct { store *store.Store repo store.DBRepo config *config.Config logger logger.Logger Basecamp *model.Basecamp Client client.Service Attachment attachment.Service Campfire campfire.Service Comment comment.Service MsgBoard messageboard.Service People people.Service Project project.Service Recording recording.Service Schedule schedule.Service Subscription subscription.Service Todo todo.Service Webhook webhook.Service Wise wise.IService } func New(store *store.Store, repo store.DBRepo, cfg *config.Config, bc *model.Basecamp, logger logger.Logger) *Service { c, err := client.NewClient(bc, cfg) if err != nil { logger.Error(err, "init basecamp service") return nil } return &Service{ store: store, repo: repo, config: cfg, logger: logger, Basecamp: bc, Client: c, Attachment: attachment.NewService(c), Campfire: campfire.NewService(c, logger, cfg), Comment: comment.NewService(c), MsgBoard: messageboard.NewService(c), People: people.NewService(c), Project: project.NewService(c), Recording: recording.NewService(c), Schedule: schedule.NewService(c, logger), Subscription: subscription.NewService(c), Todo: todo.NewService(c, cfg), Webhook: webhook.NewService(c), Wise: wise.New(cfg, logger), } } func (s *Service) BuildCommentMessage(bucketID, recordID int, content string, msgType string) model.BasecampCommentMessage { var cmtPayload *model.Comment switch msgType { case model.CommentMsgTypeFailed: cmtPayload = s.buildFailedComment(content) case model.CommentMsgTypeCompleted: cmtPayload = s.buildCompletedComment(content) default: cmtPayload = &model.Comment{Content: content} } return model.BasecampCommentMessage{ RecordingID: recordID, ProjectID: bucketID, Payload: cmtPayload, } } func (s *Service) BasecampMention(basecampID int) (res string, err error) { if basecampID == consts.AutoBotID { return fmt.Sprintf(`<bc-attachment sgid="%s" content-type="application/vnd.basecamp.mention"></bc-attachment>`, consts.AutoBotSgID), nil } employee, err := s.store.Employee.OneByBasecampID(s.repo.DB(), basecampID) if err != nil { return } if employee.BasecampAttachableSGID == "" { u, err := s.People.GetByID(basecampID) if err != nil { return res, err } employee.BasecampAttachableSGID = u.AttachableSgID if _, err = s.store.Employee.UpdateSelectedFieldsByID(s.repo.DB(), employee.ID.String(), *employee, "basecamp_attachable_sgid"); err != nil { return res, err } } return fmt.Sprintf(`<bc-attachment sgid="%s" content-type="application/vnd.basecamp.mention"></bc-attachment>`, employee.BasecampAttachableSGID), nil } func (s *Service) buildFailedComment(content string) *model.Comment { if s.config.Env == "prod" { m, _ := s.BasecampMention(consts.HuyNguyenBasecampID) return &model.Comment{Content: fmt.Sprintf(`<img width="17" class="thread-entry__icon" src="https://3.basecamp-static.com/assets/icons/thread_events/uncompleted-6066b80e80b6463243d7773fa67373b62e2a7d159ba12a17c94b1e18b30a5770.svg"><div><em>%s</em> %s</div>`, content, m)} } return &model.Comment{Content: fmt.Sprintf(`<img width="17" class="thread-entry__icon" src="https://3.basecamp-static.com/assets/icons/thread_events/uncompleted-6066b80e80b6463243d7773fa67373b62e2a7d159ba12a17c94b1e18b30a5770.svg"><div><em>%s</em></div>`, content)} } func (s *Service) buildCompletedComment(content string) *model.Comment { return &model.Comment{Content: fmt.Sprintf(`<img width="17" class="thread-entry__icon" src="https://3.basecamp-static.com/assets/icons/thread_events/completed-12705cf5fc372d800bba74c8133d705dc43a12c939a8477099749e2ef056e739.svg"><div><em>%s</em></div>`, content)} }
```

# pkg/service/basecamp/campfire/campfire.go

```go
package campfire import ( "bytes" "encoding/json" "fmt" "io" "net/http" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type CampfireService struct { client client.Service logger logger.Logger cfg *config.Config } func NewService(client client.Service, logger logger.Logger, cfg *config.Config) Service { return &CampfireService{ client: client, logger: logger, cfg: cfg, } } func (c *CampfireService) CreateLine(projectID, campfireID int, line string) error { url := fmt.Sprintf("%v/%v/buckets/%v/chats/%v/lines.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, campfireID) jsonMessage, err := json.Marshal(model.CampfireLine{Content: line}) if err != nil { return err } req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonMessage)) if err != nil { return err } req.Header.Add("Content-Type", "application/json") res, err := c.client.Do(req) if err != nil { return err } defer res.Body.Close() return nil } func (c *CampfireService) BotCreateLine(projectID, campfireID int, line string) error { url := fmt.Sprintf("%v/%v/integrations/%v/buckets/%v/chats/%v/lines.json", model.BasecampAPIEndpoint, model.CompanyID, c.cfg.Basecamp.BotKey, projectID, campfireID) jsonMessage, err := json.Marshal(model.CampfireLine{Content: line}) if err != nil { return err } req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonMessage)) if err != nil { return err } req.Header.Add("Content-Type", "application/json") res, err := c.client.Do(req) if err != nil { return err } defer res.Body.Close() return nil } func (c *CampfireService) BotReply(callbackURL string, message string) error { campfireMessage := model.CampfireLine{Content: message} jsonMessage, err := json.Marshal(campfireMessage) if err != nil { c.logger.AddField("message", campfireMessage).Error(err, "failed to marshal message") return err } resp, err := http.Post(callbackURL, "application/json", bytes.NewBuffer(jsonMessage)) if err != nil { c.logger.Fields(logger.Fields{"message": campfireMessage, "url": callbackURL}).Error(err, "failed to send request") return err } defer resp.Body.Close() data, err := io.ReadAll(resp.Body) if err != nil { c.logger.Error(err, "read response body failed") return err } if resp.StatusCode/100 > 2 { err = fmt.Errorf(string(data)) c.logger.Fields(logger.Fields{"code": resp.StatusCode}).Error(err, "request failed") return err } return nil }
```

# pkg/service/basecamp/campfire/service.go

```go
package campfire type Service interface { CreateLine(projectID int, campfireID int, line string) (err error) BotCreateLine(projectID int, campfireID int, line string) (err error) BotReply(callbackURL string, message string) (err error) }
```

# pkg/service/basecamp/client/client.go

```go
package client import ( "context" "encoding/json" "errors" "fmt" "io" "net/http" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "golang.org/x/oauth2" ) var ( basecampOauthConfig = &oauth2.Config{ Endpoint: oauth2.Endpoint{ AuthURL: "https://launchpad.37signals.com/authorization/new?type=refresh", TokenURL: "https://launchpad.37signals.com/authorization/token?type=refresh", AuthStyle: oauth2.AuthStyleInParams, }, } ) // Client -- type Client struct { client *http.Client basecamp *model.Basecamp } // NewClient -- func NewClient(bc *model.Basecamp, cfg *config.Config) (Service, error) { newToken, err := getAccessToken(cfg) if err != nil { logger.L.Error(err, "can't init basecamp service") return nil, err } return &Client{ client: basecampOauthConfig.Client(context.Background(), newToken), basecamp: bc, }, nil } func getAccessToken(cfg *config.Config) (*oauth2.Token, error) { basecampOauthConfig.ClientID = cfg.Basecamp.ClientID basecampOauthConfig.ClientSecret = cfg.Basecamp.ClientSecret refreshToken := cfg.Basecamp.OAuthRefreshToken if refreshToken == "" { return nil, errors.New("missing basecampapp_oauth_refresh_token env variable") } token := new(oauth2.Token) token.RefreshToken = refreshToken newToken, err := basecampOauthConfig.TokenSource(context.Background(), token).Token() if err != nil { return nil, err } return newToken, nil } // func (c *Client) intervalRefreshToken() { // interval := time.Tick(15 * time.Minute) // for { // <-interval // newToken, _ := getAccessToken() // c.client = basecampOauthConfig.Client(oauth2.NoContext, newToken) // } // } func (c *Client) Get(url string) (resp *http.Response, err error) { return c.client.Get(url) } func (c *Client) Do(req *http.Request) (resp *http.Response, err error) { return c.client.Do(req) } // New -- func New(clientID, clientSecret string) *model.Basecamp { return &model.Basecamp{ ClientID: clientID, ClientSecret: clientSecret, } } // GetAccessToken return Basecamp AccessToken func (c *Client) GetAccessToken(code, redirectURI string) (string, error) { c.basecamp.RedirectURI = redirectURI url := fmt.Sprintf(model.BasecampEndpoint+"/token?type=web_server&client_id=%v&redirect_uri=%v&client_secret=%v&code=%v", c.basecamp.ClientID, redirectURI, c.basecamp.ClientSecret, code) r, err := http.Post(url, "application/json", nil) if err != nil { return "", err } body, err := io.ReadAll(r.Body) if err != nil { return "", err } defer r.Body.Close() var resp model.AuthenticationResponse if err = json.Unmarshal(body, &resp); err != nil { return "", err } return resp.AccessToken, nil }
```

# pkg/service/basecamp/client/service.go

```go
package client import "net/http" type Service interface { Get(url string) (resp *http.Response, err error) Do(req *http.Request) (resp *http.Response, err error) GetAccessToken(code string, redirectURI string) (accessToken string, err error) }
```

# pkg/service/basecamp/comment/comment.go

```go
package comment import ( "bytes" "encoding/json" "fmt" "net/http" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type CommentService struct { client client.Service } func NewService(client client.Service) Service { return &CommentService{ client: client, } } func (c *CommentService) Create(projectID int, recordingID int, comment *model.Comment) error { url := fmt.Sprintf("%v/%v/buckets/%v/recordings/%v/comments.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, recordingID) jsonGroup, err := json.Marshal(comment) if err != nil { return err } req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonGroup)) if err != nil { return err } req.Header.Add("Content-Type", "application/json") res, err := c.client.Do(req) if err != nil { return err } res.Body.Close() return nil } func (c *CommentService) Gets(projectID int, recordingID int) ([]model.Comment, error) { comments := []model.Comment{} url := fmt.Sprintf("%v/%v/buckets/%v/recordings/%v/comments.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, recordingID) req, err := http.NewRequest("GET", url, nil) if err != nil { return comments, err } res, err := c.client.Do(req) if err != nil { return comments, err } defer res.Body.Close() if err = json.NewDecoder(res.Body).Decode(&comments); err != nil { return comments, err } link := res.Header.Get("Link") page := 2 for link != "" { var request *http.Request request, err = http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil) if err != nil { return nil, err } request.Header.Add("Content-Type", "application/json") var response *http.Response response, err = c.client.Do(request) if err != nil { return nil, err } defer response.Body.Close() ss := []model.Comment{} if err := json.NewDecoder(response.Body).Decode(&ss); err != nil { return nil, err } comments = append(comments, ss...) link = response.Header.Get("Link") page++ } return comments, nil }
```

# pkg/service/basecamp/comment/service.go

```go
package comment import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" type Service interface { Create(projectID int, recordingID int, comment *model.Comment) (err error) Gets(projectID int, recordingID int) (res []model.Comment, err error) }
```

# pkg/service/basecamp/consts/consts.go

```go
package consts // Define basecamp resource id const ( WoodlandScheduleID int64 = 1346305137 PlaygroundScheduleID int64 = 1941398077 WoodlandID = 9403032 PlaygroundID = 12984857 PlaygroundCampfireID = 1941398072 HiringID = 13171568 HiringScheduleID = 1974612191 PlaygroundTodoID = 1941398075 PlaygroundDynamicsTodoID = 2235833582 PlaygroundExpenseTodoID = 2436015405 FoundationID = 9405283 FoundationTodoID = 1346687281 FoundationCampfireID = 1346687275 WoodlandDynamicsTodoID = 2566078344 VenturesID = 13484002 DesignID = 9404034 OperationID = 9403043 ManagementID = 15240223 AccountingID = 15258324 TechRadarID = 13307382 ReadifyID = 16277845 ReadifyCampfireID = 2502884934 HookID = 393058 WoodlandTodoID = 1346305133 OperationTodoID = 1346306047 ManagementTodoID = 2326974480 AccountingTodoID = 2329633561 ExpenseTodoID = 2353511928 AutoBotID = 25727627 WoodlandMessageBoardID = 1346305130 PlaygroundMessageBoardID = 1941398073 HiringMessageBoardID = 1974612189 CompanyBasecampID = 4108948 ProjectManagementID = 1970322248 TechRadarProjectID = 13307382 TechRadarMessageBoardID = 1998256729 TechRadarTodoSetID = 1998256730 TechRadarAssessTodoListID = 1998259939 // temporary hardcode HiringTodoSetID = 1974612190 HRTodoID = 2040601263 TechRadarCampfireID = 1998256728 OperationCampfireID = 1346306044 WoodlandCampfireID = 1346305126 FortressCampfireID = 1347531395 HiringCampfireID = 1974612188 FortressID = 9410372 OnleaveID = 6935836756 OnleavePlaygroundID = 2243342506 WarehouseID = 15921521 PlaygroundHRTodoID = 2475678340 BirthdayGift2020 = 2576503375 BirthdayGift2021 = 3338845535 PaperTrailTodoListID = 2685205937 PlaygroundPaperTrailTodoListID = 2685503124 ShareholderID = 16944388 ShareholderCampfireID = 2635581864 SudoID = 16473245 SudoCampfireID = 2538063314 OpsExpenseTodoID = 4665885355 PlaygroundBirthdayTodoID = 3942871393 BirthdayToDoListID = 3941578970 // People LyBasecampID = 21564173 HanBasecampID = 21562923 QuangBasecampID = 22659105 AnBasecampID = 21562943 HuyNguyenBasecampID = 22658825 HuyGiangBasecampID = 22658816 MinhTranBasecampID = 21564151 NamTranBasecampID = 21675130 DuyenBasecampID = 26160403 TrungPhanBasecampID = 21574701 PhuongTruongBasecampID = 21842626 ThanhNguyenBasecampID = 21572501 VanNguyenBasecampID = 26595807 KhaiLeBasecampID = 24006290 KhanhTruongBasecampID = 24419646 GiangThanBasecampID = 26160802 HelenBasecampID = 40439249 ThuongBasecampID = 38246363 NamNguyenBasecampID = 21581534 // BucketName BucketNameWoodLand = "Woodland" BucketNamePlayGround = "Fortress | Playground" // OrgChart ManagementLevel = 3 // Basecamp kind list TodoCreate = "todo_created" TodoComplete = "todo_completed" TodoUncomplete = "todo_uncompleted" CommentCreate = "comment_created" MessageBoardCreate = "message_created" MessageBoardActive = "message_active" AutoBotSgID = "BAh7CEkiCGdpZAY6BkVUSSIpZ2lkOi8vYmMzL1BlcnNvbi8yNTcyNzYyNz9leHBpcmVzX2luBjsAVEkiDHB1cnBvc2UGOwBUSSIPYXR0YWNoYWJsZQY7AFRJIg9leHBpcmVzX2F0BjsAVDA=--5a1528460315bfd57bc41cf6bd3f899b1c346e7b" // Basecamp Comment Message CommentThankYouEmailSent = "Thank you email has been sent" CommentThankYouEmailFailed = "Unable to send thank you email invoice." CommentUpdateInvoiceSuccessfully = "Invoice status has been set to paid" CommentUpdateInvoiceFailed = `Unable to update invoice status` CommentMoveInvoicePDFToPaidDirSuccessfully = "GDrive file has been updated" CommentMoveInvoicePDFToPaidDirFailed = "Unable to move invoice pdf to paid directory" CommentCantFindInvoice = "Invoice not found" CommentInvoiceFileMoved = "Invoice file has been moved to Paid folder in Google Drive" CommentUnableToUpdateGDLoc = "Unable to update Google Drive location" CommentMissingConfirmation = "Missing Confirmation" CommentInvalidOnLeaveFormat = "Invalid on leave format" CommentCreateScheduleSuccessfully = "Create schedule successfully" CommentCreateScheduleFailed = "Unable to create schedule" CommentCreateExpenseSuccessfully = "Create expense successfully" CommentCreateExpenseFailed = "Unable to create expense" CommentDeleteExpenseSuccessfully = "Delete expense successfully" CommentDeleteExpenseFailed = "Delete expense failed" CommentStoreAccountingTransactionFailed = "Store accounting transaction failed" CommentStoreAccountingTransactionSuccessfully = "Store accounting transaction successfully" CommentProbationReviewSuccessfully = "Probation review succeed" CommentThankYouEmailSentSuccessfully = "Thank you email sent successfully" CommentOfferEmailSentSuccessfully = "Offer email sent successfully" CommentHiringNoActionTaken = "Neither Offered nor Fail, no action taken" CommentHiredCandidate = "Candidate hired" CommentRejectedCandidate = "Candidate rejected" )
```

# pkg/service/basecamp/integration.go

```go
package basecamp import ( "encoding/json" "errors" "math" "regexp" "strconv" "strings" "time" "github.com/thoas/go-funk" "gorm.io/datatypes" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/currency" "github.com/dwarvesf/fortress-api/pkg/store/expense" ) const ( defaultCurrencyType = "VND" thousandUnit = 1000 millionUnit = 1000000 amountPat = "(\\d+(k|tr|m)\\d+|\\d+(k|tr|m)|\\d+)" ) // BasecampExpenseData -- type BasecampExpenseData struct { Reason string Amount int CurrencyType string CreatorEmail string InvoiceImageURL string MetaData datatypes.JSON BasecampID int CreatorID int } // ExtractBasecampExpenseAmount -- func (s *Service) ExtractBasecampExpenseAmount(source string) int { return getAmount(strings.Replace(source, ".", "", -1)) } // CreateBasecampExpense -- func (s *Service) CreateBasecampExpense( data BasecampExpenseData, ) error { employee, err := s.store.Employee.OneByBasecampID(s.repo.DB(), data.CreatorID) if err != nil { return errors.New("failed to get employee by basecampID: " + strconv.Itoa(data.BasecampID)) } c, err := s.store.Currency.GetByName(s.repo.DB(), data.CurrencyType) if err != nil { return errors.New("failed to get currency by name: " + data.CurrencyType) } date := time.Now() e, err := s.store.Expense.Create(s.repo.DB(), &model.Expense{ Amount: data.Amount, Reason: data.Reason, EmployeeID: employee.ID, CurrencyID: c.ID, InvoiceImageURL: data.InvoiceImageURL, Metadata: data.MetaData, BasecampID: data.BasecampID, }) if err != nil { return err } m := model.AccountingMetadata{ Source: "expense", ID: e.ID.String(), } bonusBytes, err := json.Marshal(&m) if err != nil { return err } temp, rate, err := s.Wise.Convert(float64(data.Amount), c.Name, currency.VNDCurrency) if err != nil { return nil } am := model.NewVietnamDong(int64(temp)) transaction := &model.AccountingTransaction{ Name: "Expense - " + data.Reason, Amount: float64(data.Amount), ConversionAmount: am.Format(), Date: &date, Category: model.AccountingOfficeSupply, CurrencyID: &c.ID, Currency: c.Name, ConversionRate: rate, Metadata: bonusBytes, Type: model.AccountingOV, } if err = s.store.Accounting.CreateTransaction( s.repo.DB(), transaction, ); err != nil { return err } e.AccountingTransactionID = &transaction.ID if _, err = s.store.Expense.Update(s.repo.DB(), e); err != nil { return err } return nil } func (s *Service) UncheckBasecampExpenseHandler( data BasecampExpenseData, ) error { e, err := s.store.Expense.GetByQuery(s.repo.DB(), &expense.ExpenseQuery{BasecampID: data.BasecampID}) if err != nil { return err } if _, err = s.store.Expense.Delete(s.repo.DB(), e); err != nil { return err } return nil } func getAmountStr(s string) string { c, _ := regexp.Compile(amountPat) return c.FindString(s) } // func getReason(s string) string { // amount := getAmountStr(s) // s = strings.Replace(s, amount, "", 1) // return strings.TrimSpace(strings.Replace(s, "for", "", 1)) // } func getAmount(source string) int { s := getAmountStr(source) if len(s) == 0 { return 0 } switch { case isThousand(s): return thousand(s) case isMillion(s): return million(s) default: a, _ := strconv.Atoi(s) return a } } func isThousand(s string) bool { return funk.Contains(s, "k") } func thousand(s string) int { a := strings.Index(s, "k") if len(s[a+1:]) > 3 { return 0 } prefix, _ := strconv.Atoi(s[0:a]) suffix, _ := strconv.Atoi(s[a+1:]) return prefix*thousandUnit + int(float64(suffix)/math.Pow10(len(s[a+1:])-1)*100) } func isMillion(s string) bool { return funk.Contains(s, "tr") || funk.Contains(s, "m") } func million(s string) int { newStr := strings.Replace(s, "tr", "m", -1) i := strings.Index(newStr, "m") if len(newStr[i+1:]) > 6 { return 0 } pref, _ := strconv.Atoi(newStr[0:i]) suf, _ := strconv.Atoi(newStr[i+1:]) return (pref * millionUnit) + int(float64(suf)/math.Pow10(len(newStr[i+1:])-1)*thousandUnit*100) }
```

# pkg/service/basecamp/messageboard/message_board.go

```go
package messageboard import ( "bytes" "encoding/json" "errors" "fmt" "io" "net/http" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type messageBoard struct { client client.Service } // NewService -- create new message board service func NewService(client client.Service) Service { return &messageBoard{ client: client, } } func (m *messageBoard) Create(message *model.Message, projectID int, messageBoardID int) error { url := fmt.Sprintf("%v/%v/buckets/%v/message_boards/%v/messages.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, messageBoardID) jsonMessage, err := json.Marshal(message) if err != nil { return err } req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonMessage)) if err != nil { return err } req.Header.Add("Content-Type", "application/json") res, err := m.client.Do(req) if err != nil { return err } b, err := io.ReadAll(res.Body) if err != nil { return err } if res.StatusCode != http.StatusCreated { err = errors.New(string(b)) return err } if err = json.Unmarshal(b, message); err != nil { return err } defer res.Body.Close() return nil } func (m *messageBoard) Get(projectID int, messageID int) (message model.Message, err error) { res := model.Message{} url := fmt.Sprintf("%v/%v/buckets/%v/messages/%v.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, messageID) req, err := http.NewRequest("GET", url, nil) if err != nil { return res, err } resp, err := m.client.Do(req) if err != nil { return res, err } if resp.StatusCode != http.StatusOK { b, err := io.ReadAll(resp.Body) if err != nil { return res, err } return res, errors.New(string(b)) } defer resp.Body.Close() if err := json.NewDecoder(resp.Body).Decode(&res); err != nil { return res, err } return res, nil } func (m *messageBoard) GetList(projectID int, messageBoardID int) ([]model.Message, error) { url := fmt.Sprintf("%v/%v/buckets/%v/message_boards/%v/messages.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, messageBoardID) res := []model.Message{} get := func(page int) (bool, error) { req, err := http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil) if err != nil { return false, err } resp, err := m.client.Do(req) if err != nil { return false, err } if resp.StatusCode != http.StatusOK { b, err := io.ReadAll(resp.Body) if err != nil { return false, err } return false, errors.New(string(b)) } defer resp.Body.Close() var msg []model.Message if err := json.NewDecoder(resp.Body).Decode(&msg); err != nil { return false, err } res = append(res, msg...) return (resp.Header.Get("Link") != ""), nil } page := 1 for { morePage, err := get(page) if err != nil { return nil, err } if !morePage { return res, nil } page++ } }
```

# pkg/service/basecamp/messageboard/service.go

```go
package messageboard import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" // Service -- message board service type Service interface { Create(message *model.Message, projectID, messageBoardID int) (err error) GetList(projectID int, messageBoardID int) (messages []model.Message, err error) Get(projectID int, messageID int) (message model.Message, err error) }
```

# pkg/service/basecamp/model/model.go

```go
package model import ( "encoding/json" "time" ) const ( CompanyID = "4108948" GetBasecampUserInfoURL = "https://launchpad.37signals.com/authorization.json" BasecampEndpoint = "https://launchpad.37signals.com/authorization" BasecampAPIEndpoint = "https://3.basecampapi.com" ) type Person struct { ID int `json:"id"` AttachableSgID string `json:"attachable_sgid"` Name string `json:"name"` EmailAddress string `json:"email_address"` Title string `json:"title"` Bio string `json:"bio"` } // UserInfo fully define basecamp user info struct type UserInfo struct { ExpiresAt time.Time `json:"expires_at"` Identity Identity `json:"identity"` } // Identity define User Identity type Identity struct { ID int `json:"id"` FirstName string `json:"first_name"` LastName string `json:"last_name"` EmailAddress string `json:"email_address"` } // AuthenticationResponse define basecamp auth response type AuthenticationResponse struct { AccessToken string `json:"access_token"` RefreshToken string `json:"refresh_token"` ExpiresIn int `json:"expires_in"` } // Basecamp define basecamp config struct type Basecamp struct { ClientID string ClientSecret string RedirectURI string } type SubscriptionList struct { Subscriptions []int `json:"subscriptions"` Unsubscriptions []int `json:"unsubscriptions"` } type TodoList struct { ID int `json:"id"` Name string `json:"name"` Description string `json:"description"` Title string `json:"title"` Type string `json:"type"` CreatedAt string `json:"created_at"` TodosURL string `json:"todos_url"` UpdatedAt string `json:"updated_at"` Parent *Parent `json:"parent"` SubscriptionURL string `json:"subscription_url"` } type TodoGroup struct { ID int `json:"id"` CreatedAt time.Time `json:"created_at"` UpdatedAt time.Time `json:"updated_at"` Title string `json:"title"` InheritsStatus bool `json:"inherits_status"` Type string `json:"type"` Parent *Parent `json:"parent"` Completed bool `json:"completed"` CompletedRatio string `json:"completed_ratio"` SubscriberIDs []int `json:"subscriber_ids"` Name string `json:"name"` } type Todo struct { ID int `json:"id"` Title string `json:"title"` Type string `json:"type"` Assignees []Assignee `json:"assignees"` AssigneeIDs []int `json:"assignee_ids"` CompletionSubscribers []Subscriber `json:"completion_subscribers"` Completed bool `json:"completed"` AppURL string `json:"app_url"` Content string `json:"content"` CommentsURL string `json:"comments_url"` Description string `json:"description"` DueOn string `json:"due_on"` InheritsStatus bool `json:"inherits_status"` StartsOn string `json:"starts_on"` Status string `json:"status"` Parent *Parent `json:"parent"` SubscriptionURL string `json:"subscription_url"` CreatedAt string `json:"created_at"` UpdatedAt string `json:"updated_at"` Notify bool `json:"notify"` Bucket Bucket `json:"bucket"` } type Subscriber struct { ID int `json:"id"` Name string `json:"name"` EmailAddress string `json:"email_address"` PersonableType string `json:"personable_type"` Title string `json:"title"` Bio string `json:"bio"` CreatedAt time.Time `json:"created_at"` UpdatedAt time.Time `json:"updated_at"` Admin bool `json:"admin"` Owner bool `json:"owner"` TimeZone string `json:"time_zone"` AvatarURL string `json:"avatar_url"` } type Comment struct { ID int64 `json:"id"` Status string `json:"status"` CreatedAt time.Time `json:"created_at"` UpdatedAt time.Time `json:"updated_at"` Title string `json:"title"` InheritsStatus bool `json:"inherits_status"` Type string `json:"type"` URL string `json:"url"` AppURL string `json:"app_url"` BookmarkURL string `json:"bookmark_url"` Parent Parent `json:"parent"` Bucket Bucket `json:"bucket"` Creator Assignee `json:"creator"` Content string `json:"content"` } type Parent struct { ID int `json:"id"` Title string `json:"title"` Type string `json:"type"` URL string `json:"url"` } type Bucket struct { ID int `json:"id"` Name string `json:"name"` Type string `json:"type"` } type Assignee struct { Admin bool `json:"admin"` AttachableSgid string `json:"attachable_sgid"` AvatarURL string `json:"avatar_url"` Bio interface{} `json:"bio"` CreatedAt string `json:"created_at"` EmailAddress string `json:"email_address"` ID int `json:"id"` Name string `json:"name"` Owner bool `json:"owner"` PersonableType string `json:"personable_type"` TimeZone string `json:"time_zone"` Title string `json:"title"` UpdatedAt string `json:"updated_at"` } type Project struct { CreatedAt string `json:"created_at"` Description string `json:"description"` Dock []ProjectDock `json:"dock"` ID int64 `json:"id"` Name string `json:"name"` Purpose string `json:"purpose"` Status string `json:"status"` UpdatedAt string `json:"updated_at"` URL string `json:"url"` } type ProjectDock struct { AppURL string `json:"app_url"` Enabled bool `json:"enabled"` ID int `json:"id"` Name string `json:"name"` Position int `json:"position"` Title string `json:"title"` URL string `json:"url"` } type ScheduleEntry struct { ID json.Number `json:"id"` Summary string `json:"summary"` Description string `json:"description"` ParticipantIDs []int `json:"participant_ids"` Participants []*Assignee `json:"participants"` AllDay bool `json:"all_day"` Notify bool `json:"notify"` AppUrl string `json:"app_url"` StartsAt string `json:"starts_at"` EndsAt string `json:"ends_at"` RecurrenceSchedule *RecurrenceSchedule `json:"recurrence_schedule"` SubscriptionUrl string `json:"subscription_url"` } type RecurrenceSchedule struct { Days []int `json:"days"` WeekInstance int `json:"week_instance"` Frequency string `json:"frequency"` StartDate string `json:"start_date"` EndDate string `json:"end_date"` } type PeopleCreate struct { Name string `json:"name"` EmailAddress string `json:"email_address"` CompanyName string `json:"company_name"` } type PeopleEntry struct { Grant []int64 `json:"grant"` Revoke []int64 `json:"revoke"` Create []PeopleCreate `json:"create"` } type CampfireLine struct { Content string `json:"content"` } type Hook struct { ID int `json:"id"` Active bool `json:"active"` CreatedAt time.Time `json:"created_at"` UpdatedAt time.Time `json:"updated_at"` PayloadURL string `json:"payload_url"` Types []string `json:"types"` URL string `json:"url"` AppURL string `json:"app_url"` } type Message struct { ID int `json:"id"` Subject string `json:"subject"` Content string `json:"content"` Status string `json:"status"` AppURL string `json:"app_url"` CommentsURL string `json:"comments_url"` CreatedAt *time.Time `json:"created_at"` } type Recording struct { ID int `json:"id"` Status string `json:"status"` VisibleToClients bool `json:"visible_to_clients"` CreatedAt time.Time `json:"created_at"` UpdatedAt time.Time `json:"updated_at"` Title string `json:"title"` InheritsStatus bool `json:"inherits_status"` Type string `json:"type"` URL string `json:"url"` AppURL string `json:"app_url"` BookmarkURL string `json:"bookmark_url"` SubscriptionURL string `json:"subscription_url"` CommentsCount int `json:"comments_count"` CommentsURL string `json:"comments_url"` Position int `json:"position,omitempty"` Parent Parent `json:"parent"` Bucket Bucket `json:"bucket"` Creator Person `json:"creator"` Description string `json:"description"` Completed bool `json:"completed"` Content string `json:"content"` StartsOn string `json:"starts_on"` DueOn string `json:"due_on"` } type Event struct { ID int `json:"id"` RecordingID int `json:"recording_id"` Action string `json:"action"` CreatedAt time.Time `json:"created_at"` Creator Person `json:"creator"` } // below is list of message model, use with caution const ( BasecampCommentMsg string = "basecamp_comment" BasecampTodoMsg string = "basecamp_todo" BasecampHiringTodoMsg string = "basecamp_todo_hiring" ) const ( CommentMsgTypeFailed string = "failed" CommentMsgTypeCompleted string = "completed" ) // BasecampCommentMessage is use for worker to create a basecamp comment type BasecampCommentMessage struct { ProjectID int RecordingID int Payload *Comment } type BasecampTodoMessageModel struct { ProjectID int ListID int Payload Todo }
```

# pkg/service/basecamp/people/people.go

```go
package people import ( "bytes" "encoding/json" "fmt" "io" "net/http" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/project" ) type PeopleService struct { client client.Service } func NewService(client client.Service) Service { return &PeopleService{ client: client, } } func (p *PeopleService) GetByID(id int) (*model.Person, error) { url := fmt.Sprintf(`https://3.basecampapi.com/%d/people/%d.json`, consts.CompanyBasecampID, id) req, err := http.NewRequest("GET", url, nil) if err != nil { return nil, err } res, err := p.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() var person model.Person if err := json.NewDecoder(res.Body).Decode(&person); err != nil { return nil, err } return &person, nil } // GetUserInfo get UserInfo func func (p *PeopleService) GetInfo() (*model.UserInfo, error) { req, err := http.NewRequest("GET", model.GetBasecampUserInfoURL, nil) if err != nil { return nil, err } res, err := p.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() var result model.UserInfo if err = json.NewDecoder(res.Body).Decode(&result); err != nil { return nil, err } return &result, nil } func (p *PeopleService) Create(name, email, organization string) (id int64, sgID string, err error) { woodlandEntry := model.PeopleEntry{ Create: []model.PeopleCreate{ { Name: name, EmailAddress: email, CompanyName: organization, }, }, } return p.UpdateInProject(consts.WoodlandID, woodlandEntry) } func (p *PeopleService) UpdateInProject(projectID int64, peopleEntry model.PeopleEntry) (int64, string, error) { url := fmt.Sprintf("%v/%v/projects/%v/people/users.json", model.BasecampAPIEndpoint, model.CompanyID, projectID) jsonAdd, err := json.Marshal(peopleEntry) if err != nil { return 0, "", err } req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonAdd)) if err != nil { return 0, "", err } req.Header.Add("Content-Type", "application/json") res, err := p.client.Do(req) if err != nil { return 0, "", err } defer res.Body.Close() response := struct { Granted []struct { ID int64 `json:"id"` SgID string `json:"attachable_sgid"` } `json:"granted"` Revoked []struct { ID int64 `json:"id"` SgID string `json:"attachable_sgid"` } `json:"revoked"` }{} err = json.NewDecoder(res.Body).Decode(&response) if err != nil { return 0, "", err } if len(response.Granted) == 0 && len(response.Revoked) == 0 { return 0, "", ErrNotInProject } if len(response.Granted) == 0 { return response.Revoked[0].ID, response.Revoked[0].SgID, nil } return response.Granted[0].ID, response.Granted[0].SgID, nil } func (p *PeopleService) Remove(userID int64) error { projects, err := project.NewService(p.client).GetAll() if err != nil { return err } peopleEntry := model.PeopleEntry{ Revoke: []int64{userID}, } for i := range projects { _, _, err = p.UpdateInProject(projects[i].ID, peopleEntry) if err != nil && err != ErrNotInProject { return err } } return nil } func (p *PeopleService) GetAllOnProject(projectID int) ([]model.Person, error) { url := fmt.Sprintf(`https://3.basecampapi.com/%d/projects/%d/people.json`, consts.CompanyBasecampID, projectID) var people []model.Person get := func(page int) (bool, error) { req, err := http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil) if err != nil { return false, err } res, err := p.client.Do(req) if err != nil { return false, err } defer res.Body.Close() var p []model.Person b, err := io.ReadAll(res.Body) if err != nil { return false, err } if err := json.Unmarshal(b, &p); err != nil { return false, err } people = append(people, p...) return (res.Header.Get("Link") != ""), nil } page := 1 for { morePage, err := get(page) if err != nil { return nil, err } if !morePage { return people, nil } page++ } }
```

# pkg/service/basecamp/people/service.go

```go
package people import ( "errors" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) var ( ErrNotInProject = errors.New("this account does not belong to this project") ) type Service interface { GetByID(id int) (res *model.Person, err error) GetInfo() (res *model.UserInfo, err error) Create(name string, email string, orgnization string) (id int64, sgID string, err error) Remove(userID int64) (err error) UpdateInProject(projectID int64, peopleEntry model.PeopleEntry) (id int64, sgID string, err error) GetAllOnProject(projectID int) (result []model.Person, err error) }
```

# pkg/service/basecamp/project/project.go

```go
package project import ( "encoding/json" "fmt" "net/http" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type ProjectService struct { client client.Service } func NewService(client client.Service) Service { return &ProjectService{ client: client, } } func (p *ProjectService) GetAll() ([]model.Project, error) { url := fmt.Sprintf(`https://3.basecampapi.com/%d/projects.json`, consts.CompanyBasecampID) req, err := http.NewRequest("GET", url, nil) if err != nil { return nil, err } res, err := p.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() var result []model.Project if err := json.NewDecoder(res.Body).Decode(&result); err != nil { return nil, err } return result, nil } func (p *ProjectService) Get(id int) (model.Project, error) { var result model.Project url := fmt.Sprintf(`https://3.basecampapi.com/%d/projects/%d.json`, consts.CompanyBasecampID, id) req, err := http.NewRequest("GET", url, nil) if err != nil { return result, err } res, err := p.client.Do(req) if err != nil { return result, err } defer res.Body.Close() if err := json.NewDecoder(res.Body).Decode(&result); err != nil { return result, err } return result, nil }
```

# pkg/service/basecamp/project/service.go

```go
package project import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" type Service interface { GetAll() (result []model.Project, err error) Get(id int) (result model.Project, err error) }
```

# pkg/service/basecamp/recording/recording.go

```go
package recording import ( "encoding/json" "fmt" "net/http" "strings" "time" "github.com/antchfx/htmlquery" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type RecordingService struct { client client.Service } func NewService(client client.Service) Service { return &RecordingService{ client: client, } } func (r *RecordingService) Trash(projectID, recordingID string) error { url := fmt.Sprintf("%v/%v/buckets/%v/recordings/%v/status/trashed.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, recordingID) req, err := http.NewRequest("PUT", url, nil) if err != nil { return err } res, err := r.client.Do(req) if err != nil { return err } defer res.Body.Close() return nil } func (r *RecordingService) TryToGetInvoiceImageURL(url string) (string, error) { resp, err := r.client.Get(url) if err != nil { return "", err } defer resp.Body.Close() tmp := make(map[string]interface{}) err = json.NewDecoder(resp.Body).Decode(&tmp) if err != nil { return "", err } strI, ok := tmp["description"] if !ok { return "", nil } str, ok := strI.(string) if !ok { return "", nil } return ensureToGetImageURLFromRawHTML(str), nil } func ensureToGetImageURLFromRawHTML(raw string) string { doc, err := htmlquery.Parse(strings.NewReader(raw)) if err != nil { return "" } // try to get first img url from raw html node := htmlquery.FindOne(doc, "//img") if node == nil { return "" } for _, v := range node.Attr { if v.Key == "src" { return v.Val } } return "" } func (r *RecordingService) Archive(projectID, recordingID int) error { url := fmt.Sprintf("%v/%v/buckets/%d/recordings/%d/status/archived.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, recordingID) req, err := http.NewRequest("PUT", url, nil) if err != nil { return err } res, err := r.client.Do(req) if err != nil { return err } defer res.Body.Close() return nil } func (r *RecordingService) GetFrom(from time.Time, recordingType string) ([]model.Recording, error) { url := fmt.Sprintf("%v/%v/projects/recordings.json?type=%v&sort=updated_at", model.BasecampAPIEndpoint, model.CompanyID, recordingType) req, err := http.NewRequest("GET", url, nil) if err != nil { return nil, err } res, err := r.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() var recordings, result []model.Recording if err := json.NewDecoder(res.Body).Decode(&result); err != nil { return nil, err } for _, recording := range recordings { if recording.UpdatedAt.Before(from) { return result, nil } result = append(result, recording) } link := res.Header.Get("Link") page := 2 for link != "" { var request *http.Request request, err = http.NewRequest("GET", fmt.Sprintf("%v&page=%v", url, page), nil) if err != nil { return nil, err } var response *http.Response response, err = r.client.Do(request) if err != nil { return nil, err } defer response.Body.Close() ss := []model.Recording{} if err := json.NewDecoder(response.Body).Decode(&ss); err != nil { return nil, err } for _, recording := range ss { if recording.UpdatedAt.Before(from) { return result, nil } result = append(result, recording) } link = response.Header.Get("Link") page++ } return result, nil } func (r *RecordingService) GetEvents(from time.Time, projectID, recordingID int) ([]model.Event, error) { url := fmt.Sprintf("%v/%v/buckets/%v/recordings/%v/events.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, recordingID) req, err := http.NewRequest("GET", url, nil) if err != nil { return nil, err } res, err := r.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() var events, result []model.Event if err := json.NewDecoder(res.Body).Decode(&events); err != nil { return nil, err } for _, event := range events { if event.CreatedAt.Before(from) { return result, nil } result = append(result, event) } link := res.Header.Get("Link") page := 2 for link != "" { var request *http.Request request, err = http.NewRequest("GET", fmt.Sprintf("%v&page=%v", url, page), nil) if err != nil { return nil, err } var response *http.Response response, err = r.client.Do(request) if err != nil { return nil, err } defer response.Body.Close() ss := []model.Event{} if err := json.NewDecoder(response.Body).Decode(&ss); err != nil { return nil, err } for _, event := range ss { if event.CreatedAt.Before(from) { return result, nil } result = append(result, event) } link = response.Header.Get("Link") page++ } return result, nil }
```

# pkg/service/basecamp/recording/service.go

```go
package recording import ( "time" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type Service interface { GetFrom(from time.Time, recordingType string) ([]model.Recording, error) GetEvents(from time.Time, projectID, recordingID int) ([]model.Event, error) Trash(projectID string, recordingID string) (err error) Archive(projectID, recordingID int) error TryToGetInvoiceImageURL(url string) (res string, err error) }
```

# pkg/service/basecamp/schedule/schedule.go

```go
package schedule import ( "bytes" "encoding/json" "fmt" "io" "net/http" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type ScheduleService struct { client client.Service logger logger.Logger } func NewService(client client.Service, logger logger.Logger) Service { return &ScheduleService{ client: client, logger: logger, } } func (s *ScheduleService) CreateScheduleEntry(projectID int64, scheduleID int64, scheduleEntry model.ScheduleEntry) (*model.ScheduleEntry, error) { url := fmt.Sprintf("%v/%v/buckets/%v/schedules/%v/entries.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, scheduleID) jsonTodo, err := json.Marshal(scheduleEntry) if err != nil { return nil, err } req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonTodo)) if err != nil { return nil, err } req.Header.Add("Content-Type", "application/json") resp, err := s.client.Do(req) if err != nil { return nil, err } defer resp.Body.Close() b, err := io.ReadAll(resp.Body) if err != nil { return nil, err } res := &model.ScheduleEntry{} err = json.Unmarshal(b, res) if err != nil { return nil, err } return res, nil } func (s *ScheduleService) GetScheduleEntries(projectID, scheduleID int64) ([]*model.ScheduleEntry, error) { url := fmt.Sprintf("%v/%v/buckets/%v/schedules/%v/entries.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, scheduleID) res := []*model.ScheduleEntry{} get := func(page int) (bool, error) { req, err := http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil) if err != nil { s.logger.AddField("url", url).Error(err, "failed to create req") return false, err } resp, err := s.client.Do(req) if err != nil { s.logger.Error(err, "failed to send req") return false, err } defer resp.Body.Close() if resp.StatusCode/100 > 2 { err = fmt.Errorf("failed to get schedule entries") s.logger.Fields(logger.Fields{ "StatusCode": resp.StatusCode, "ProjectID": projectID, "ScheduleID": scheduleID, }).Error(err, "request failed") return false, err } entries, err := responseToScheduleEntries(resp) if err != nil { return false, err } res = append(res, entries...) return (resp.Header.Get("Link") != ""), nil } page := 1 for { morePage, err := get(page) if err != nil { return nil, err } if !morePage { return res, nil } page++ } } func responseToScheduleEntries(res *http.Response) ([]*model.ScheduleEntry, error) { body, err := io.ReadAll(res.Body) if err != nil { return nil, err } var scheduleEntries []*model.ScheduleEntry err = json.Unmarshal(body, &scheduleEntries) if err != nil { logger.L.AddField("body", string(body)).Error(err, "failed to unmarshal body") return nil, err } return scheduleEntries, nil } func (s *ScheduleService) UpdateSheduleEntry(projectID int64, se *model.ScheduleEntry) error { url := fmt.Sprintf("%v/%v/buckets/%v/schedule_entries/%v.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, se.ID) jsonTodo, err := json.Marshal(se) if err != nil { return err } req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonTodo)) if err != nil { return err } req.Header.Add("Content-Type", "application/json") resp, err := s.client.Do(req) if err != nil { return err } defer resp.Body.Close() return err }
```

# pkg/service/basecamp/schedule/service.go

```go
package schedule import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" type Service interface { CreateScheduleEntry(projectID int64, scheduleID int64, scheduleEntry model.ScheduleEntry) (res *model.ScheduleEntry, err error) GetScheduleEntries(projectID int64, scheduleID int64) (res []*model.ScheduleEntry, err error) UpdateSheduleEntry(projectID int64, se *model.ScheduleEntry) (err error) }
```

# pkg/service/basecamp/subscription/service.go

```go
package subscription import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" type Service interface { Subscribe(url string, list *model.SubscriptionList) (err error) }
```

# pkg/service/basecamp/subscription/subscription.go

```go
package subscription import ( "bytes" "encoding/json" "net/http" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type SubscriptionService struct { client client.Service } func NewService(client client.Service) Service { return &SubscriptionService{ client: client, } } func (s *SubscriptionService) Subscribe(url string, list *model.SubscriptionList) error { json, err := json.Marshal(list) if err != nil { return err } req, err := http.NewRequest("PUT", url, bytes.NewBuffer(json)) if err != nil { return err } req.Header.Add("Content-Type", "application/json") resp, err := s.client.Do(req) if err != nil { return err } defer resp.Body.Close() return nil }
```

# pkg/service/basecamp/todo/service.go

```go
package todo import ( pkgmodel "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type Service interface { CreateList(projectID int, todoSetID int, todoList model.TodoList) (result *model.TodoList, err error) CreateGroup(projectID int, todoListID int, group model.TodoGroup) (result *model.TodoGroup, err error) Create(projectID int, todoListID int, todo model.Todo) (result *model.Todo, err error) Get(url string) (result *model.Todo, err error) GetAllInList(todoListID int, projectID int, query ...string) (result []model.Todo, err error) GetGroups(todoListID int, projectID int) (result []model.TodoGroup, err error) GetLists(projectID int, todoSetID int) (result []model.TodoList, err error) GetList(url string) (result *model.TodoList, err error) GetProjectsLatestIssue(projectNames []string) (result []*pkgmodel.ProjectIssue, err error) CreateHiring(cv *pkgmodel.Candidate) (err error) FirstOrCreateList(projectID int, todoSetID int, todoListName string) (result *model.TodoList, err error) FirstOrCreateGroup(projectID int, todoListID int, todoGroupName string) (result *model.TodoGroup, err error) FirstOrCreateInvoiceTodo(projectID, todoListID int, invoice *pkgmodel.Invoice) (result *model.Todo, err error) Update(projectID int, todo model.Todo) (result *model.Todo, err error) FirstOrCreateTodo(projectID, todoListID int, todoName string) (result *model.Todo, err error) Complete(projectID, todoID int) (err error) }
```

# pkg/service/basecamp/todo/todo.go

```go
package todo import ( "bytes" "encoding/json" "fmt" "io" "net/http" "regexp" "strings" "time" "github.com/dwarvesf/fortress-api/pkg/config" pkgmodel "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/consts" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/utils" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" ) type TodoService struct { client client.Service cfg *config.Config } func NewService(c client.Service, cfg *config.Config) Service { return &TodoService{ client: c, cfg: cfg, } } func (t *TodoService) CreateList(projectID int, todoSetID int, todoList model.TodoList) (*model.TodoList, error) { url := fmt.Sprintf("%v/%v/buckets/%v/todosets/%v/todolists.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todoSetID) jsonTodo, err := json.Marshal(todoList) if err != nil { return nil, err } req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonTodo)) if err != nil { return nil, err } req.Header.Add("Content-Type", "application/json") res, err := t.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() var result model.TodoList if err = json.NewDecoder(res.Body).Decode(&result); err != nil { return nil, err } return &result, nil } func (t *TodoService) CreateGroup(projectID int, todoListID int, group model.TodoGroup) (*model.TodoGroup, error) { url := fmt.Sprintf("%v/%v/buckets/%v/todolists/%v/groups.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todoListID) jsonGroup, err := json.Marshal(group) if err != nil { return nil, err } req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonGroup)) if err != nil { return nil, err } req.Header.Add("Content-Type", "application/json") res, err := t.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() rs := &model.TodoGroup{} if err := json.NewDecoder(res.Body).Decode(&rs); err != nil { return nil, err } return rs, err } func (t *TodoService) Create(projectID int, todoListID int, todo model.Todo) (*model.Todo, error) { url := fmt.Sprintf("%v/%v/buckets/%v/todolists/%v/todos.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todoListID) jsonGroup, err := json.Marshal(todo) if err != nil { return nil, err } req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonGroup)) if err != nil { return nil, err } req.Header.Add("Content-Type", "application/json") resp, err := t.client.Do(req) if err != nil { return nil, err } defer resp.Body.Close() res := &model.Todo{} body, err := io.ReadAll(resp.Body) if err != nil { return nil, err } if err := json.Unmarshal(body, res); err != nil { return nil, err } return res, nil } func (t *TodoService) Get(url string) (*model.Todo, error) { req, err := http.NewRequest("GET", url, nil) if err != nil { return nil, err } req.Header.Add("Content-Type", "application/json") res, err := t.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() rs := &model.Todo{} if err := json.NewDecoder(res.Body).Decode(&rs); err != nil { return nil, err } return rs, nil } func (t *TodoService) GetAllInList(todoListID, projectID int, query ...string) ([]model.Todo, error) { url := fmt.Sprintf(`https://3.basecampapi.com/%d/buckets/%d/todolists/%d/todos.json`, consts.CompanyBasecampID, projectID, todoListID) for _, v := range query { url += v } req, err := http.NewRequest("GET", url, nil) if err != nil { return nil, err } req.Header.Add("Content-Type", "application/json") res, err := t.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() rs := []model.Todo{} if err := json.NewDecoder(res.Body).Decode(&rs); err != nil { return nil, err } link := res.Header.Get("Link") page := 2 for link != "" { request, err := http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil) if err != nil { return nil, err } request.Header.Add("Content-Type", "application/json") response, err := t.client.Do(request) if err != nil { return nil, err } defer response.Body.Close() ss := []model.Todo{} if err := json.NewDecoder(response.Body).Decode(&ss); err != nil { if err == io.EOF { break } return nil, err } rs = append(rs, ss...) link = response.Header.Get("Link") page++ } return rs, nil } func (t *TodoService) GetGroups(todoListID, projectID int) ([]model.TodoGroup, error) { url := fmt.Sprintf(`https://3.basecampapi.com/%d/buckets/%d/todolists/%d/groups.json`, consts.CompanyBasecampID, projectID, todoListID) req, err := http.NewRequest("GET", url, nil) if err != nil { return nil, err } req.Header.Add("Content-Type", "application/json") res, err := t.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() rs := []model.TodoGroup{} if err := json.NewDecoder(res.Body).Decode(&rs); err != nil { return nil, err } return rs, nil } func (t *TodoService) GetLists(projectID, todoSetsID int) ([]model.TodoList, error) { url := fmt.Sprintf("%v/%v/buckets/%v/todosets/%v/todolists.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todoSetsID) req, err := http.NewRequest("GET", url, nil) if err != nil { return nil, err } req.Header.Add("Content-Type", "application/json") res, err := t.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() todoLists := []model.TodoList{} if err := json.NewDecoder(res.Body).Decode(&todoLists); err != nil { return nil, err } link := res.Header.Get("Link") page := 2 for link != "" { request, err := http.NewRequest("GET", fmt.Sprintf("%v?page=%v", url, page), nil) if err != nil { return nil, err } request.Header.Add("Content-Type", "application/json") response, err := t.client.Do(request) if err != nil { return nil, err } defer response.Body.Close() ss := []model.TodoList{} if err := json.NewDecoder(response.Body).Decode(&ss); err != nil { if err == io.EOF { break } return nil, err } todoLists = append(todoLists, ss...) link = response.Header.Get("Link") page++ } return todoLists, nil } func (t *TodoService) GetList(url string) (*model.TodoList, error) { req, err := http.NewRequest("GET", url, nil) if err != nil { return nil, err } req.Header.Add("Content-Type", "application/json") res, err := t.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() b, err := io.ReadAll(res.Body) if err != nil { return nil, err } rs := &model.TodoList{} if err := json.Unmarshal(b, rs); err != nil { return nil, err } return rs, nil } func (t *TodoService) GetProjectsLatestIssue(projectNames []string) ([]*pkgmodel.ProjectIssue, error) { issues := make([]*pkgmodel.ProjectIssue, len(projectNames)) todoGroups, err := t.GetGroups(consts.ProjectManagementID, consts.OperationID) if err != nil { return nil, err } for i := range todoGroups { for j, v := range projectNames { if strings.Contains(strings.ToLower(todoGroups[i].Title), strings.ToLower(v)) { todos, err := t.GetAllInList(todoGroups[i].ID, consts.OperationID) if err != nil { return nil, err } for k := range todos { if !todos[k].Completed { issues[j] = &pkgmodel.ProjectIssue{ID: todos[k].ID, Name: todos[k].Content, Link: todos[k].AppURL} } } } } } return issues, nil } func (t *TodoService) CreateHiring(cv *pkgmodel.Candidate) error { hiringID := consts.HiringID hiringTodoSetID := consts.HiringTodoSetID runMode := t.cfg.Env if runMode != "prod" { hiringID = consts.PlaygroundID hiringTodoSetID = consts.PlaygroundTodoID } now := time.Now() currentQuarter := fmt.Sprintf(`Q%d/%d`, timeutil.GetQuarterFromMonth(now.Month()), now.Year()) todoList, err := t.FirstOrCreateList(hiringID, hiringTodoSetID, currentQuarter) if err != nil { return err } todoGroup, err := t.FirstOrCreateGroup(hiringID, todoList.ID, pkgmodel.GroupRole(cv.Role)) if err != nil { return err } todo := model.Todo{Content: cv.Name, AssigneeIDs: []int{cv.FindHiringInCharge(), consts.HelenBasecampID}, Description: cv.Note, Notify: (runMode != "local"), } if cv.IsReferral { todo.Content = fmt.Sprintf("Referral: %v", cv.Name) } res, err := t.Create(hiringID, todoGroup.ID, todo) if err != nil { return err } cv.BasecampTodoID = res.ID return nil } func (t *TodoService) FirstOrCreateList(projectID, todoSetID int, todoListName string) (*model.TodoList, error) { todoLists, err := t.GetLists(projectID, todoSetID) if err != nil { return nil, err } for i := range todoLists { if todoLists[i].Title == todoListName { return &todoLists[i], nil } } return t.CreateList(projectID, todoSetID, model.TodoList{Name: todoListName}) } func (t *TodoService) FirstOrCreateGroup(projectID, todoListID int, todoGroupName string) (*model.TodoGroup, error) { todoGroups, err := t.GetGroups(todoListID, projectID) if err != nil { return nil, err } for i := range todoGroups { if todoGroups[i].Title == todoGroupName { return &todoGroups[i], nil } } return t.CreateGroup(projectID, todoListID, model.TodoGroup{Name: todoGroupName}) } func (t *TodoService) FirstOrCreateTodo(projectID, todoListID int, todoName string) (*model.Todo, error) { todos, err := t.GetAllInList(todoListID, projectID) if err != nil { return nil, err } for i := range todos { // if same project, proceed if todos[i].Title == todoName { return &todos[i], err } } return t.Create(projectID, todoListID, model.Todo{Content: todoName}) } func (t *TodoService) FirstOrCreateInvoiceTodo(projectID, todoListID int, invoice *pkgmodel.Invoice) (*model.Todo, error) { invoiceTodoName := fmt.Sprintf(`%v %v/%v - #%v`, invoice.Project.Name, invoice.Month, invoice.Year, invoice.Number) todos, err := t.GetAllInList(todoListID, projectID) if err != nil { return nil, err } re, err := regexp.Compile(utils.RemoveAllSpace(fmt.Sprintf(`%v (%v|0%v)\/%v$`, invoice.Project.Name, invoice.Month, invoice.Month, invoice.Year))) if err != nil { return nil, err } for i := range todos { if todos[i].Title == invoiceTodoName { return &todos[i], nil } // if same project, proceed if re.MatchString(utils.RemoveAllSpace(todos[i].Title)) { todos[i].Content = invoiceTodoName todos[i].Description = fmt.Sprintf(`<div>%v%v</div>`, todos[i].Description, invoice.TodoAttachment) return t.Update(projectID, todos[i]) } } return t.Create(projectID, todoListID, model.Todo{Content: invoiceTodoName, Description: fmt.Sprintf(`<div>%v</div>`, invoice.TodoAttachment)}) } func (t *TodoService) Update(projectID int, todo model.Todo) (*model.Todo, error) { url := fmt.Sprintf("%v/%v/buckets/%v/todos/%v.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todo.ID) jsonGroup, err := json.Marshal(todo) if err != nil { return nil, err } req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonGroup)) if err != nil { return nil, err } req.Header.Add("Content-Type", "application/json") resp, err := t.client.Do(req) if err != nil { return nil, err } defer resp.Body.Close() res := &model.Todo{} body, err := io.ReadAll(resp.Body) if err != nil { return nil, err } if err := json.Unmarshal(body, res); err != nil { return nil, err } return res, nil } func (t *TodoService) Complete(projectID, todoID int) error { url := fmt.Sprintf("%v/%v/buckets/%v/todos/%v/completion.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, todoID) req, err := http.NewRequest("POST", url, nil) if err != nil { return err } resp, err := t.client.Do(req) if err != nil { return err } defer resp.Body.Close() if resp.StatusCode != http.StatusNoContent { return fmt.Errorf(`complete req failed with code: %v`, resp.StatusCode) } return nil }
```

# pkg/service/basecamp/webhook/service.go

```go
package webhook import "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" type Service interface { FindWebHook(projectID int, hookID int) (result *model.Hook, err error) UpdateWebHook(projectID int, hookID int, hookBody model.Hook) (err error) }
```

# pkg/service/basecamp/webhook/webhook.go

```go
package webhook import ( "bytes" "encoding/json" "fmt" "net/http" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/client" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type WebhookService struct { client client.Service } func NewService(client client.Service) Service { return &WebhookService{ client: client, } } func (w *WebhookService) FindWebHook(projectID int, hookID int) (*model.Hook, error) { url := fmt.Sprintf("%v/%v/buckets/%v/webhooks/%v.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, hookID) req, err := http.NewRequest("GET", url, nil) if err != nil { return nil, err } res, err := w.client.Do(req) if err != nil { return nil, err } defer res.Body.Close() rs := model.Hook{} if err := json.NewDecoder(res.Body).Decode(&rs); err != nil { return nil, err } return &rs, nil } func (w *WebhookService) UpdateWebHook(projectID, hookID int, hookBody model.Hook) error { url := fmt.Sprintf("%v/%v/buckets/%v/webhooks/%v.json", model.BasecampAPIEndpoint, model.CompanyID, projectID, hookID) jsonHook, err := json.Marshal(hookBody) if err != nil { return err } req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonHook)) if err != nil { return err } req.Header.Add("Content-Type", "application/json") res, err := w.client.Do(req) if err != nil { return err } defer res.Body.Close() return nil }
```

# pkg/service/communitynft/communitynft.go

```go
package communitynft import ( "math/big" "github.com/ethereum/go-ethereum/common" "github.com/dwarvesf/fortress-api/pkg/config" erc721abi "github.com/dwarvesf/fortress-api/pkg/contracts/erc721" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service/evm" ) type IService interface { OwnerOf(tokenId int) (string, error) } type nft struct { instance *erc721abi.ERC721 evm evm.IService cfg *config.Config l logger.Logger } const ( DefaultCommunityNftContractAddress = "0x3150825A8b9990567790B22a4F987b6A82d89d54" ) func New(evm evm.IService, cfg *config.Config, l logger.Logger) (IService, error) { addr := cfg.CommunityNft.ContractAddress if addr == "" { addr = DefaultCommunityNftContractAddress } instance, err := erc721abi.NewERC721(common.HexToAddress(addr), evm.Client()) if err != nil { return nil, err } return &nft{ instance: instance, evm: evm, cfg: cfg, l: l, }, nil } func (n *nft) OwnerOf(tokenId int) (string, error) { owner, err := n.instance.OwnerOf(nil, big.NewInt(int64(tokenId))) if err != nil { return "", err } return owner.String(), nil }
```

# pkg/service/currency/currency.go

```go
package currency import ( "encoding/json" "math" "net/http" "time" "github.com/patrickmn/go-cache" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/model" ) type service struct { cacheMap *cache.Cache token string cfg *config.Config } func New(cfg *config.Config) IService { cacheMap := cache.New(24*time.Hour, 24*time.Hour) return &service{ token: cfg.CurrencyLayer.APIKey, cacheMap: cacheMap, cfg: cfg, } } // TODO: need test func (s *service) Convert(value float64, src, target string) (float64, float64, error) { rate, err := s.getRateForTwoCurrency(src, target) if err != nil { return 0, 0, err } return math.Ceil(value * rate), rate, nil } // here come the magic, since we can convert to USD only // 1 USD = X_src // 1 USD = Y_target // <=> X_src = Y_target // <=> src = Y/X target func (s *service) getRateForTwoCurrency(src, target string) (float64, error) { x, err := s.GetRate(src) if err != nil { return 0, err } y, err := s.GetRate(target) if err != nil { return 0, err } return y / x, nil } func (s *service) USDToVND(usd float64) (float64, error) { res, err := s.usdCentToVND(int64(usd) * 100) if err != nil { return 0, err } return float64(res / 100), nil } func (s *service) VNDToUSD(vnd float64) (float64, error) { res, err := s.vndToUSDCent(int64(vnd)) if err != nil { return 0, err } return float64(res / 100), nil } func (s *service) usdCentToVND(usd int64) (int64, error) { rate, err := s.getRate("VND") if err != nil { return 0, err } return usd * int64(rate), nil } func (s *service) vndToUSDCent(vnd int64) (int64, error) { rate, err := s.getRate("VND") if err != nil { return 0, err } float := float64(vnd) / rate return int64(math.Ceil(float) * 100), nil } func (s *service) GetByName(db *gorm.DB, name string) (*model.Currency, error) { c := model.Currency{} return &c, db.Where("name = ?", name).First(&c).Error } func (s *service) GetByID(db *gorm.DB, id model.UUID) (*model.Currency, error) { c := model.Currency{} return &c, db.Where("id = ?", id).First(&c).Error } // getRate will return the conversation rate between USD and target currency func (s *service) GetRate(target string) (float64, error) { return s.getRate(target) } // TODO: clean this up func (s *service) getRate(target string) (float64, error) { // first, we hit the cache t, _ := s.cacheMap.Get(target) if target, ok := t.(float64); ok { if target != 0 { return target, nil } } // move on, if on prod we do a real query, otherwise do fixed rate for reduce the cost if s.cfg.Env != "prod" { switch target { case "USD": return 1, nil case "CAD": return 1.34275, nil case "GBP": return 0.79185, nil case "EUR": return 0.89795, nil case "VND": return 23416, nil } } var client http.Client endpoint := "http://apilayer.net/api/live?currencies=USD,CAD,GBP,EUR,VND&access_key=" + s.token req, err := http.NewRequest("GET", endpoint, nil) if err != nil { return 0, err } resp, err := client.Do(req) if err != nil { return 0, err } defer resp.Body.Close() type out struct { Quotes struct { USDVND float64 `json:"USDVND" desc:"US Dollar to Vietnamese Dong"` USDCAD float64 `json:"USDCAD" desc:"US Dollar to Canadian Dollar"` USDGBP float64 `json:"USDGBP" desc:"US Dollar to British Pound Sterling"` USDEUR float64 `json:"USDEUR" desc:"US Dollar to Euro"` USDUSD float64 `json:"USDUSD" desc:"US Dollar to US Dollar (always 1.0)"` } `json:"quotes"` } o := out{} err = json.NewDecoder(resp.Body).Decode(&o) if err != nil { return 0, err } s.cacheMap.Set("USD", o.Quotes.USDUSD, time.Hour*24) s.cacheMap.Set("GBP", o.Quotes.USDGBP, time.Hour*24) s.cacheMap.Set("EUR", o.Quotes.USDEUR, time.Hour*24) s.cacheMap.Set("VND", o.Quotes.USDVND, time.Hour*24) switch target { case "USD": return o.Quotes.USDUSD, nil case "GBP": return o.Quotes.USDGBP, nil case "EUR": return o.Quotes.USDEUR, nil case "VND": return o.Quotes.USDVND, nil case "CAD": return o.Quotes.USDCAD, nil } return 0, nil } func (s *service) GetCurrencyOption(db *gorm.DB) ([]model.Currency, error) { res := []model.Currency{} return res, db.Find(&res).Error }
```

# pkg/service/currency/interface.go

```go
package currency import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type IService interface { USDToVND(usd float64) (float64, error) VNDToUSD(vnd float64) (float64, error) Convert(value float64, target, dest string) (float64, float64, error) GetByName(db *gorm.DB, name string) (*model.Currency, error) GetByID(db *gorm.DB, id model.UUID) (*model.Currency, error) GetCurrencyOption(db *gorm.DB) ([]model.Currency, error) GetRate(target string) (float64, error) } const ( // VNDCurrency : VietNam dong VNDCurrency = "VND" // USDCurrency : US dollar USDCurrency = "USD" // GBPCurrency : British Pound GBPCurrency = "GBP" // SGDCurrency : Singapore Dollar SGDCurrency = "SGD" // EURCurrency : Europe dollar EURCurrency = "EUR" // EURCurrency : Canadian dollar CADCurrency = "CAD" )
```

# pkg/service/discord/const.go

```go
package discord import "os" var mapEmoji = map[string]string{ "ARROW_DOWN_ANIMATED": "<a:arrow_down_animated:1131789144759214171>", "ARROW_UP_ANIMATED": "<a:arrow_up_animated:1131789319644921936>", "BADGE1": "<a:badge1:1131850989062852638>", "BADGE2": "<a:badge2:1131850991663337554>", "BADGE3": "<a:badge3:1131850996159610930>", "BADGE5": "<a:badge5:1131851001117294672>", "LOG_CHANNEL": "<:log_channel:1131863319377100841>", "STAR_ANIMATED": "<a:star_animated:1131862886592024586>", "INCREASING_ANIMATED": "<a:increasing_animated:1131862879319097394>", "CLOCK_NEW": "<:clock_new:1131863089185292428>", "PEPE_NOTE": "<:pepenote:885515949673951282>", } func getEmoji(emoji string) string { if os.Getenv("ENV") != "prod" { return mapEmojiDev[emoji] } return mapEmoji[emoji] } var mapEmojiDev = map[string]string{ "ARROW_DOWN_ANIMATED": "<a:arrow_up_animated:1131317348670902292>", "ARROW_UP_ANIMATED": "<a:arrow_down_animated:1131317344774397992>", "BADGE1": "<a:badge1:1133460615684440167>", "BADGE2": "<a:badge2:1133460619253796914>", "BADGE3": "<a:badge3:1133460622365958304>", "BADGE5": "<a:badge5:1133460625784320021>", "LOG_CHANNEL": "<:logchannel:1133460455906627614>", "STAR_ANIMATED": "<a:star_animated:1133460443550195832>", "INCREASING_ANIMATED": "<a:increasing_animated:1133460451091550289>", "CLOCK_NEW": "<:clock:1133460445257281658>", "PEPE_NOTE": "<:pepenote:1240695189622755530>", }
```

# pkg/service/discord/discord.go

```go
package discord import ( "bytes" "encoding/json" "fmt" "io" "net/http" "strconv" "strings" "time" "github.com/bwmarrin/discordgo" "github.com/shopspring/decimal" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/utils" "github.com/dwarvesf/fortress-api/pkg/view" ) var ( client = http.DefaultClient memoCategoryList = []string{memoCategoryFleeting, memoCategoryLiterature, memoCategoryEarn, memoCategoryOthers} ) const ( memoCategoryFleeting = "00_fleeting" memoCategoryLiterature = "01_literature" memoCategoryEarn = "earn" memoCategoryOthers = "others" discordEmbedMaxLen = 4096 ) type discordClient struct { cfg *config.Config session *discordgo.Session } func New(cfg *config.Config) IService { ses, _ := discordgo.New("Bot " + cfg.Discord.SecretToken) return &discordClient{ cfg: cfg, session: ses, } } func (d *discordClient) PostBirthdayMsg(msg string) (model.DiscordMessage, error) { discordMsg := model.DiscordMessage{Content: msg} reqByte, err := json.Marshal(discordMsg) if err != nil { return discordMsg, err } payload := bytes.NewReader(reqByte) if _, err := d.newRequest(http.MethodPost, d.cfg.Discord.Webhooks.Campfire, payload); err != nil { return discordMsg, err } return discordMsg, nil } func (d *discordClient) CreateEvent(event *model.Schedule) (*discordgo.GuildScheduledEvent, error) { discordEvent := &discordgo.GuildScheduledEventParams{ Name: event.Name, Description: event.Description, ScheduledStartTime: event.StartTime, ScheduledEndTime: event.EndTime, PrivacyLevel: discordgo.GuildScheduledEventPrivacyLevelGuildOnly, } // by default, set channel to unknown discordEvent.EntityType = discordgo.GuildScheduledEventEntityTypeExternal discordEvent.EntityMetadata = &discordgo.GuildScheduledEventEntityMetadata{ Location: "Unknown", } if event.GoogleCalendar.HangoutLink != "" { discordEvent.EntityType = discordgo.GuildScheduledEventEntityTypeExternal discordEvent.EntityMetadata = &discordgo.GuildScheduledEventEntityMetadata{ Location: event.GoogleCalendar.HangoutLink, } } return d.session.GuildScheduledEventCreate(d.cfg.Discord.IDs.DwarvesGuild, discordEvent) } func (d *discordClient) UpdateEvent(event *model.Schedule) (*discordgo.GuildScheduledEvent, error) { discordEvent := &discordgo.GuildScheduledEventParams{ Name: event.Name, Description: event.Description, ScheduledStartTime: event.StartTime, ScheduledEndTime: event.EndTime, } return d.session.GuildScheduledEventEdit(d.cfg.Discord.IDs.DwarvesGuild, event.DiscordEvent.DiscordEventID, discordEvent) } func (d *discordClient) DeleteEvent(event *model.Schedule) error { return d.session.GuildScheduledEventDelete(d.cfg.Discord.IDs.DwarvesGuild, event.DiscordEvent.DiscordEventID) } func (d *discordClient) ListEvents() ([]*discordgo.GuildScheduledEvent, error) { return d.session.GuildScheduledEvents(d.cfg.Discord.IDs.DwarvesGuild, false) } func (d *discordClient) newRequest(method string, url string, payload io.Reader) ([]byte, error) { req, err := http.NewRequest(method, url, payload) if err != nil { return nil, err } req.Header.Set("Content-Type", "application/json") var res *http.Response if res, err = client.Do(req); err != nil { return nil, err } defer res.Body.Close() resBody, err := io.ReadAll(res.Body) if err != nil { return nil, err } return resBody, nil } func (d *discordClient) GetMembers() ([]*discordgo.Member, error) { members := make([]*discordgo.Member, 0) after := "" limit := 1000 for { guildMembers, err := d.session.GuildMembers(d.cfg.Discord.IDs.DwarvesGuild, after, limit) if err != nil { return nil, err } members = append(members, guildMembers...) if len(guildMembers) < limit { break } after = guildMembers[len(guildMembers)-1].User.ID } return members, nil } func (d *discordClient) SendMessage(discordMsg model.DiscordMessage, webhookUrl string) (*model.DiscordMessage, error) { reqByte, err := json.Marshal(discordMsg) if err != nil { return &discordMsg, err } payload := bytes.NewReader(reqByte) res, err := d.session.Client.Post(webhookUrl, "application/json", payload) if err != nil { return &discordMsg, err } defer res.Body.Close() return &discordMsg, nil } func (d *discordClient) SearchMember(discordName string) ([]*discordgo.Member, error) { members := make([]*discordgo.Member, 0) guildMembers, err := d.session.GuildMembersSearch(d.cfg.Discord.IDs.DwarvesGuild, discordName, 1000) if err != nil { return nil, err } members = append(members, guildMembers...) return members, nil } func (d *discordClient) GetMember(userID string) (*discordgo.Member, error) { member, err := d.session.GuildMember(d.cfg.Discord.IDs.DwarvesGuild, userID) if err != nil { return nil, err } return member, nil } func (d *discordClient) GetMemberByName(discordName string) ([]*discordgo.Member, error) { members := make([]*discordgo.Member, 0) guildMembers, err := d.session.GuildMembersSearch(d.cfg.Discord.IDs.DwarvesGuild, discordName, 1000) if err != nil { return nil, err } members = append(members, guildMembers...) return members, nil } func (d *discordClient) GetMemberByUsername(username string) (*discordgo.Member, error) { if username == "" { return nil, nil } guildMembers, err := d.SearchMember(username) if err != nil { return nil, err } var discordMember *discordgo.Member for _, m := range guildMembers { if m.User.Username == username { discordMember = m } } return discordMember, nil } func (d *discordClient) GetRoles() (Roles, error) { roles, err := d.session.GuildRoles(d.cfg.Discord.IDs.DwarvesGuild) if err != nil { return nil, err } return roles, nil } func (d *discordClient) AddRole(userID, roleID string) error { return d.session.GuildMemberRoleAdd(d.cfg.Discord.IDs.DwarvesGuild, userID, roleID) } func (d *discordClient) RemoveRole(userID string, roleID string) error { return d.session.GuildMemberRoleRemove(d.cfg.Discord.IDs.DwarvesGuild, userID, roleID) } type Roles discordgo.Roles func (r Roles) DwarvesRoles() []*discordgo.Role { roleMap := getDwarvesRolesMap() dwarvesRoles := make([]*discordgo.Role, 0) for _, dRole := range r { _, ok := roleMap[dRole.Name] if ok { dwarvesRoles = append(dwarvesRoles, dRole) } } return dwarvesRoles } func (r Roles) ByCode(code string) *discordgo.Role { for _, dRole := range r { if dRole.Name == code { return dRole } } return nil } func (r Roles) ByID(id string) *discordgo.Role { for _, dRole := range r { if dRole.ID == id { return dRole } } return nil } func getDwarvesRolesMap() map[string]bool { return map[string]bool{ "moderator": true, "dwarf": true, "booster": true, "apprentice": true, "crafter": true, "specialist": true, "principal": true, "peeps": true, "learning": true, "engagement": true, "delivery": true, "labs": true, "baby dwarf": true, "ladies": true, "sers": true, "consultant": true, "chad": true, } } func (d *discordClient) GetChannels() ([]*discordgo.Channel, error) { return d.session.GuildChannels(d.cfg.Discord.IDs.DwarvesGuild) } func (d *discordClient) GetMessagesAfterCursor( channelID string, cursorMessageID string, lastMessageID string, ) ([]*discordgo.Message, error) { cursorMessageIDUint, err := strconv.ParseUint(cursorMessageID, 10, 64) if err != nil { return nil, err } lastMessageIDUint, err := strconv.ParseUint(lastMessageID, 10, 64) if err != nil { return nil, err } allMessages := make([]*discordgo.Message, 0) for cursorMessageIDUint < lastMessageIDUint { messages, err := d.session.ChannelMessages( channelID, 100, // 100 is the maximal number allowed "", cursorMessageID, "", ) if len(messages) == 0 { // early break to avoid index out of bound error break } if err != nil { return nil, err } // reversal is needed since messages are sorted by newest first for i, j := 0, len(messages)-1; i < j; i, j = i+1, j-1 { messages[i], messages[j] = messages[j], messages[i] } allMessages = append(allMessages, messages...) newestMessage := messages[len(messages)-1] cursorMessageID = newestMessage.ID cursorMessageIDUint, err = strconv.ParseUint(cursorMessageID, 10, 64) if err != nil { return nil, err } // a pause is needed to avoid Discord's rate limiting time.Sleep(500 * time.Millisecond) } return allMessages, nil } func (d *discordClient) ReportBraineryMetrics(queryView string, braineryMetric *view.BraineryMetric, channelID string) (*discordgo.Message, error) { var messageEmbed []*discordgo.MessageEmbedField totalICY := decimal.NewFromInt(0) content := "" var newBraineryPost []view.Post newBraineryPost = append(newBraineryPost, braineryMetric.Contributors...) newBraineryPost = append(newBraineryPost, braineryMetric.NewContributors...) if len(newBraineryPost) == 0 { content += "There is no new brainery note in this period. This is where we keep track of our **top 10 latest** Brainery notes:\n\n" for _, itm := range braineryMetric.LatestPosts { content += fmt.Sprintf("â€¢ [%s](%s) <@%v>\n", itm.Title, itm.URL, itm.DiscordID) } } else { newBraineryPostStr := "" for _, itm := range newBraineryPost { totalICY = totalICY.Add(itm.Reward) newBraineryPostStr += fmt.Sprintf("â€¢ [%s](%s) <@%v>\n", itm.Title, itm.URL, itm.DiscordID) } if len(newBraineryPostStr) > 0 { content += "**Latest Notes** :fire::fire::fire:\n" content += newBraineryPostStr + "\n" } } if queryView == "monthly" { topContributor := calculateTopContributor(braineryMetric.TopContributors) content += topContributor + "\n" } newContributor := "" if len(braineryMetric.NewContributors) > 0 { ids := make(map[string]bool) for _, itm := range braineryMetric.NewContributors { v, ok := ids[itm.DiscordID] if ok && v { continue } ids[itm.DiscordID] = true newContributor += fmt.Sprintf("<@%v> ", itm.DiscordID) } } if newContributor != "" { content += "**New Contributors**\n" content += newContributor + "\n" } if totalICY.GreaterThan(decimal.NewFromInt(0)) { content += "\n**Total Reward Distributed**\n" content += totalICY.String() + " ICY ðŸ§Š" } tags := "" if len(braineryMetric.Tags) > 0 { for _, tag := range braineryMetric.Tags { tags += fmt.Sprintf("#%v ", tag) } } if len(tags) > 0 { embedField := &discordgo.MessageEmbedField{ Name: "Tags", Value: tags, Inline: false, } messageEmbed = append(messageEmbed, embedField) } msg := &discordgo.MessageEmbed{ Title: fmt.Sprintf("BRAINERY %s REPORT", strings.ToTitle(queryView)), Fields: messageEmbed, Description: content, Footer: &discordgo.MessageEmbedFooter{ IconURL: "https://cdn.discordapp.com/avatars/564764617545482251/9c9bd4aaba164fc0b92f13f052405b4d.webp?size=160", Text: "?help to see all commands", }, } return d.SendEmbeddedMessageWithChannel(nil, msg, channelID) } func calculateTopContributor(topContributors []view.TopContributor) string { topContributorStr := "" if len(topContributors) == 0 { return "" } countMap := make(map[int][]string) var uniqueCounts []int for _, contributor := range topContributors { if contributor.Count > 1 { count := contributor.Count discordID := contributor.DiscordID countMap[count] = append(countMap[count], discordID) // Check if count is already in uniqueCounts found := false for _, uniqueCount := range uniqueCounts { if uniqueCount == count { found = true break } } // If count is not found, add it to uniqueCounts if !found { uniqueCounts = append(uniqueCounts, count) } } } emojiMap := map[int]string{ 0: ":first_place:", 1: ":second_place:", 2: ":third_place:", } // Iterate over uniqueCounts to access Discord IDs in order for idx, count := range uniqueCounts { discordIDs := countMap[count] discordIDStr := "" for i := 0; i < len(discordIDs); i++ { discordIDStr += "<@" + discordIDs[i] + ">, " } emojiIdx := idx if idx > 2 { emojiIdx = 2 } topContributorStr += fmt.Sprintf("%v %v (x%v) \n", emojiMap[emojiIdx], strings.TrimSuffix(discordIDStr, ", "), count) } topContributor := "" if len(topContributorStr) > 0 { topContributor += "**Top Contributors**\n" topContributor += topContributorStr } return topContributor } func CreateDeliveryMetricWeeklyReportMessage(deliveryMetric *view.DeliveryMetricWeeklyReport, leaderBoard *view.WeeklyLeaderBoard) *discordgo.MessageEmbed { var messageEmbed []*discordgo.MessageEmbedField content := "*Track software team's performance. Encourages competition and collaboration. Optimizes project delivery. Promotes accountability.*\n\n" if leaderBoard != nil { leaderBoardStr := getLeaderBoardAsString(leaderBoard.Items) content += "**Leaderboard**\n" content += leaderBoardStr content += "\n\n" } previousWeek := fmt.Sprintf("**Previous Week - %v**\n", deliveryMetric.LastWeek.Date.Format("02 Jan 2006")) previousWeek += fmt.Sprintf("%v`Total Point. %v pts`\n", getEmoji("STAR_ANIMATED"), utils.FloatToString(float64(deliveryMetric.LastWeek.TotalPoints))) previousWeek += fmt.Sprintf("%v`Effort. %v hrs`\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.LastWeek.Effort))) previousWeek += fmt.Sprintf("%v`AVG W.Point. %v pts`\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.LastWeek.AvgPoint))) previousWeek += fmt.Sprintf("%v`AVG W.Effort. %v hrs`\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.LastWeek.AvgEffort))) content += previousWeek emojiUp := getEmoji("ARROW_UP_ANIMATED") emojiDown := getEmoji("ARROW_DOWN_ANIMATED") pointChange := fmt.Sprintf("%v %v%%", emojiUp, deliveryMetric.TotalPointChangePercentage) if deliveryMetric.TotalPointChangePercentage < 0 { pointChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.TotalPointChangePercentage) } effortChange := fmt.Sprintf("%v%v%%", emojiUp, deliveryMetric.EffortChangePercentage) if deliveryMetric.EffortChangePercentage < 0 { effortChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.EffortChangePercentage) } avgPointChange := fmt.Sprintf("%v%v%%", emojiUp, deliveryMetric.AvgPointChangePercentage) if deliveryMetric.AvgPointChangePercentage < 0 { avgPointChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgPointChangePercentage) } avgEffortChange := fmt.Sprintf("%v %v%%", emojiUp, deliveryMetric.AvgEffortChangePercentage) if deliveryMetric.AvgEffortChangePercentage < 0 { avgEffortChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgEffortChangePercentage) } date := deliveryMetric.CurrentWeek.Date.Format("02 Jan 2006") currentWeek := fmt.Sprintf("\n**Current Week - %v**\n", deliveryMetric.CurrentWeek.Date.Format("02 Jan 2006")) currentWeek += fmt.Sprintf("%v`Total Point. %v pts` (%v)\n", getEmoji("STAR_ANIMATED"), utils.FloatToString(float64(deliveryMetric.CurrentWeek.TotalPoints)), pointChange) currentWeek += fmt.Sprintf("%v`Effort. %v hrs` (%v)\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.CurrentWeek.Effort)), effortChange) currentWeek += fmt.Sprintf("%v`AVG W.Point. %v pts` (%v)\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.CurrentWeek.AvgPoint)), avgPointChange) currentWeek += fmt.Sprintf("%v`AVG W.Effort. %v hrs` (%v)\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.CurrentWeek.AvgEffort)), avgEffortChange) content += currentWeek msg := &discordgo.MessageEmbed{ Title: "**ðŸ† DELIVERY WEEKLY REPORT ðŸ†**" + " - " + strings.ToUpper(date), Fields: messageEmbed, Description: content, Footer: &discordgo.MessageEmbedFooter{ IconURL: "https://cdn.discordapp.com/avatars/564764617545482251/9c9bd4aaba164fc0b92f13f052405b4d.webp?size=160", Text: "?help to see all commands", }, } return msg } func (d *discordClient) DeliveryMetricWeeklyReport(deliveryMetric *view.DeliveryMetricWeeklyReport, leaderBoard *view.WeeklyLeaderBoard, channelID string) (*discordgo.Message, error) { msg := CreateDeliveryMetricWeeklyReportMessage(deliveryMetric, leaderBoard) return d.SendEmbeddedMessageWithChannel(nil, msg, channelID) } func CreateDeliveryMetricMonthlyReportMessage(deliveryMetric *view.DeliveryMetricMonthlyReport, leaderBoard *view.WeeklyLeaderBoard) *discordgo.MessageEmbed { content := "*Track software team's performance. Encourages competition and collaboration. Optimizes project delivery. Promotes accountability.*\n\n" if leaderBoard != nil { leaderBoardStr := getLeaderBoardAsString(leaderBoard.Items) content += "**Leaderboard**\n" content += leaderBoardStr content += "\n\n" } previousMonth := fmt.Sprintf("**Previous Month - %v**\n", deliveryMetric.LastMonth.Month.Format("Jan 2006")) previousMonth += fmt.Sprintf("%v`Total Point. %v pts`\n", getEmoji("STAR_ANIMATED"), utils.FloatToString(float64(deliveryMetric.LastMonth.TotalWeight))) previousMonth += fmt.Sprintf("%v`Effort. %v hrs`\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.LastMonth.Effort))) previousMonth += fmt.Sprintf("%v`AVG Point. %v pts`\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.LastMonth.AvgWeight))) previousMonth += fmt.Sprintf("%v`AVG Effort. %v hrs`\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.LastMonth.AvgEffort))) previousMonth += fmt.Sprintf("%v`AVG W.Point. %v pts`\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.LastMonth.AvgWeeklyWeight))) previousMonth += fmt.Sprintf("%v`AVG W.Effort. %v hrs`\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.LastMonth.AvgWeeklyEffort))) content += previousMonth emojiUp := getEmoji("ARROW_UP_ANIMATED") emojiDown := getEmoji("ARROW_DOWN_ANIMATED") pointChange := fmt.Sprintf("%v %v%%", emojiUp, deliveryMetric.TotalPointChangePercentage) if deliveryMetric.TotalPointChangePercentage < 0 { pointChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.TotalPointChangePercentage) } effortChange := fmt.Sprintf("%v%v%%", emojiUp, deliveryMetric.EffortChangePercentage) if deliveryMetric.EffortChangePercentage < 0 { effortChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.EffortChangePercentage) } avgPointChange := fmt.Sprintf("%v%v%%", emojiUp, deliveryMetric.AvgWeightChangePercentage) if deliveryMetric.AvgWeightChangePercentage < 0 { avgPointChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgWeightChangePercentage) } avgEffortChange := fmt.Sprintf("%v %v%%", emojiUp, deliveryMetric.AvgEffortChangePercentage) if deliveryMetric.AvgEffortChangePercentage < 0 { avgEffortChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgEffortChangePercentage) } avgWeeklyPointChange := fmt.Sprintf("%v%v%%", emojiUp, deliveryMetric.AvgWeeklyPointChangePercentage) if deliveryMetric.AvgWeeklyPointChangePercentage < 0 { avgWeeklyPointChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgWeeklyPointChangePercentage) } avgWeeklyEffortChange := fmt.Sprintf("%v %v%%", emojiUp, deliveryMetric.AvgWeeklyEffortChangePercentage) if deliveryMetric.AvgWeeklyEffortChangePercentage < 0 { avgWeeklyEffortChange = fmt.Sprintf("%v%v%%", emojiDown, deliveryMetric.AvgWeeklyEffortChangePercentage) } currentMonth := fmt.Sprintf("\n**Current Month - %v**\n", deliveryMetric.CurrentMonth.Month.Format("Jan 2006")) currentMonth += fmt.Sprintf("%v`Total Point. %v pts` (%v)\n", getEmoji("STAR_ANIMATED"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.TotalWeight)), pointChange) currentMonth += fmt.Sprintf("%v`Effort. %v hrs` (%v)\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.Effort)), effortChange) currentMonth += fmt.Sprintf("%v`AVG Point. %v pts` (%v)\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.AvgWeight)), avgPointChange) currentMonth += fmt.Sprintf("%v`AVG Effort. %v hrs` (%v)\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.AvgEffort)), avgEffortChange) currentMonth += fmt.Sprintf("%v`AVG W.Point. %v pts` (%v)\n", getEmoji("INCREASING_ANIMATED"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.AvgWeeklyWeight)), avgWeeklyPointChange) currentMonth += fmt.Sprintf("%v`AVG W.Effort. %v hrs` (%v)\n", getEmoji("CLOCK_NEW"), utils.FloatToString(float64(deliveryMetric.CurrentMonth.AvgWeeklyEffort)), avgWeeklyEffortChange) content += currentMonth month := deliveryMetric.CurrentMonth.Month.Format("Jan 2006") msg := &discordgo.MessageEmbed{ Title: "**ðŸ† DELIVERY MONTHLY REPORT ðŸ†**" + " - " + strings.ToUpper(month), Description: content, Footer: &discordgo.MessageEmbedFooter{ IconURL: "https://cdn.discordapp.com/avatars/564764617545482251/9c9bd4aaba164fc0b92f13f052405b4d.webp?size=160", Text: "?help to see all commands", }, } return msg } func (d *discordClient) DeliveryMetricMonthlyReport(deliveryMetric *view.DeliveryMetricMonthlyReport, leaderBoard *view.WeeklyLeaderBoard, channelID string) (*discordgo.Message, error) { msg := CreateDeliveryMetricMonthlyReportMessage(deliveryMetric, leaderBoard) return d.SendEmbeddedMessageWithChannel(nil, msg, channelID) } func getLeaderBoardAsString(data []view.LeaderBoardItem) string { emojiMap := map[int]string{ 1: getEmoji("BADGE1"), 2: getEmoji("BADGE2"), 3: getEmoji("BADGE3"), 4: getEmoji("BADGE5"), 5: getEmoji("BADGE5"), } // Sort the data by rank in ascending order var currentRank int var leaderBoardString strings.Builder for _, employee := range data { rank := employee.Rank if rank > 5 { break } if rank == 5 { rank = 4 } if rank != currentRank { if currentRank > 0 { leaderBoardString.WriteString("\n") } currentRank = employee.Rank leaderBoardString.WriteString(fmt.Sprintf("%v ", emojiMap[currentRank])) } leaderBoardString.WriteString(fmt.Sprintf("<@%v> ", employee.DiscordID)) } return leaderBoardString.String() } func (d *discordClient) SendEmbeddedMessageWithChannel(original *model.OriginalDiscordMessage, embed *discordgo.MessageEmbed, channelId string) (*discordgo.Message, error) { msg, err := d.session.ChannelMessageSendEmbed(channelId, normalize(original, embed)) return msg, err } func (d *discordClient) SendNewMemoMessage(guildID string, memos []model.MemoLog, channelID string) (*discordgo.Message, error) { for i, content := range memos { if i <= 10 { var textMessage string authorField := "" for _, author := range content.Authors { if author.DiscordID != "" { authorField += fmt.Sprintf(" <@%s> ", author.DiscordID) } else if author.DiscordUsername != "" { authorField += fmt.Sprintf(" @%s ", author.DiscordUsername) } else { authorField += " **@unknown-user**" } } // Use memo username if discord username is not available if authorField == "" { for _, author := range content.AuthorMemoUsernames { authorField += fmt.Sprintf(" **%s** ", author) } } author := "" if authorField != "" { author = "from" + authorField } textMessage += fmt.Sprintf("New memo post %v \n [%s](%s)\n", author, content.Title, content.URL) msg := &discordgo.Message{ Content: textMessage, } err := d.SendDiscordMessageWithChannel(d.session, msg, channelID) if err != nil { return nil, err } } } return nil, nil } func (d *discordClient) SendWeeklyMemosMessage(guildID string, memos []model.MemoLog, weekRangeStr, channelID string) (*discordgo.Message, error) { bagde1Emoji := getEmoji("BADGE1") bagde5Emoji := getEmoji("BADGE5") pepeNoteEmoji := getEmoji("PEPE_NOTE") authorMap := make(map[string]int) var content strings.Builder var memolistString strings.Builder content.WriteString("*What is going on with our memo this week?*\n\n") content.WriteString("**OVERVIEW**\n") content.WriteString(fmt.Sprintf("%v `Total publication.` **%v** posts\n", bagde5Emoji, len(memos))) memolistString.WriteString("**PUBLICATIONS**\n") //Group by category memosByCategory := map[string][]model.MemoLog{ memoCategoryFleeting: make([]model.MemoLog, 0), memoCategoryLiterature: make([]model.MemoLog, 0), memoCategoryEarn: make([]model.MemoLog, 0), memoCategoryOthers: make([]model.MemoLog, 0), } for _, mem := range memos { isMapped := false for _, category := range mem.Category { if strings.EqualFold(category, memoCategoryFleeting) || strings.EqualFold(category, memoCategoryLiterature) || strings.EqualFold(category, memoCategoryEarn) { memosByCategory[category] = append(memosByCategory[category], mem) isMapped = true break } } if !isMapped { memosByCategory[memoCategoryOthers] = append(memosByCategory[memoCategoryOthers], mem) } } for _, category := range memoCategoryList { memos := memosByCategory[category] // Category memolistString.WriteString(fmt.Sprintf("ðŸ”¹ **%s** - %v posts\n", strings.ToUpper(category), len(memos))) for idx, mem := range memos { authorField := "" for _, author := range mem.Authors { authorMap[author.DiscordID] += 1 if author.DiscordID != "" { authorField += fmt.Sprintf(" <@%s> ", author.DiscordID) } else if author.DiscordUsername != "" { authorField += fmt.Sprintf(" @%s ", author.DiscordUsername) } else { authorField += " **@unknown-user**" } } if authorField == "" { authorField = "**@unknown-user**" } memolistString.WriteString(fmt.Sprintf("[[%v](%s)] %s - %v\n", idx+1, mem.URL, mem.Title, authorField)) } memolistString.WriteString("\n") } // update author count based on finally updated value content.WriteString(fmt.Sprintf("%v `Total author.` **%v** authors\n\n", pepeNoteEmoji, len(authorMap))) content.WriteString(memolistString.String()) msg := &discordgo.MessageEmbed{ Title: fmt.Sprintf("%v WEEKLY MEMO REPORT (%v) %v", bagde1Emoji, weekRangeStr, bagde1Emoji), Description: content.String(), } _, err := d.SendEmbeddedMessageWithChannel(nil, msg, channelID) if err != nil { return nil, err } return nil, nil } func (d *discordClient) SendDiscordMessageWithChannel(ses *discordgo.Session, msg *discordgo.Message, channelId string) error { _, err := ses.ChannelMessageSend(channelId, msg.Content) return err } func (d *discordClient) GetChannelMessages(channelID, before, after string, limit int) ([]*discordgo.Message, error) { return d.session.ChannelMessages(channelID, limit, before, after, "") } func (d *discordClient) GetEventByID(eventID string) (*discordgo.GuildScheduledEvent, error) { return d.session.GuildScheduledEvent(d.cfg.Discord.IDs.DwarvesGuild, eventID, false) } func (d *discordClient) ListActiveThreadsByChannelID(guildID, channelID string) ([]discordgo.Channel, error) { threadsList, err := d.session.GuildThreadsActive(guildID) if err != nil { return nil, err } result := make([]discordgo.Channel, 0) for _, thread := range threadsList.Threads { if thread.ParentID == channelID { result = append(result, *thread) } } return result, nil }
```

# pkg/service/discord/service.go

```go
package discord import ( "github.com/bwmarrin/discordgo" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/view" ) type IService interface { PostBirthdayMsg(msg string) (model.DiscordMessage, error) GetMembers() ([]*discordgo.Member, error) GetMember(userID string) (*discordgo.Member, error) GetMemberByUsername(username string) (*discordgo.Member, error) SearchMember(discordName string) ([]*discordgo.Member, error) GetRoles() (Roles, error) AddRole(userID, roleID string) error RemoveRole(userID string, roleID string) error CreateEvent(event *model.Schedule) (scheduledEvent *discordgo.GuildScheduledEvent, err error) UpdateEvent(event *model.Schedule) (scheduledEvent *discordgo.GuildScheduledEvent, err error) DeleteEvent(event *model.Schedule) error ListEvents() ([]*discordgo.GuildScheduledEvent, error) GetChannels() ([]*discordgo.Channel, error) GetMessagesAfterCursor(channelID string, cursorMessageID string, lastMessageID string) ([]*discordgo.Message, error) GetChannelMessages(channelID, before, after string, limit int) ([]*discordgo.Message, error) GetEventByID(eventID string) (*discordgo.GuildScheduledEvent, error) ReportBraineryMetrics(queryView string, braineryMetric *view.BraineryMetric, channelID string) (*discordgo.Message, error) DeliveryMetricWeeklyReport(deliveryMetrics *view.DeliveryMetricWeeklyReport, leaderBoard *view.WeeklyLeaderBoard, channelID string) (*discordgo.Message, error) DeliveryMetricMonthlyReport(deliveryMetrics *view.DeliveryMetricMonthlyReport, leaderBoard *view.WeeklyLeaderBoard, channelID string) (*discordgo.Message, error) SendNewMemoMessage(guildID string, memos []model.MemoLog, channelID string) (*discordgo.Message, error) SendWeeklyMemosMessage(guildID string, memos []model.MemoLog, weekRangeStr, channelID string) (*discordgo.Message, error) /* WEBHOOK */ // SendMessage logs a message to a Discord channel through a webhook SendMessage(discordMsg model.DiscordMessage, webhookUrl string) (*model.DiscordMessage, error) SendEmbeddedMessageWithChannel(original *model.OriginalDiscordMessage, embed *discordgo.MessageEmbed, channelId string) (*discordgo.Message, error) SendDiscordMessageWithChannel(ses *discordgo.Session, msg *discordgo.Message, channelId string) error ListActiveThreadsByChannelID(guildID, channelID string) ([]discordgo.Channel, error) }
```

# pkg/service/discord/utils.go

```go
package discord import ( "time" "github.com/bwmarrin/discordgo" "github.com/dwarvesf/fortress-api/pkg/model" ) // normalize add some default to embedded message if not set func normalize(original *model.OriginalDiscordMessage, response *discordgo.MessageEmbed) *discordgo.MessageEmbed { if response.Timestamp == "" { response.Timestamp = time.Now().Format(time.RFC3339) } // I did something tricky here, if timestamp is custom, we don't want to show it, because in case of user want to add a custom date time format in the footer // instead of automatically add it, we don't want to show it twice. if response.Timestamp == "custom" { response.Timestamp = "" } if response.Color == 0 { // default df color #D14960 response.Color = 13715808 } if response.Footer == nil { response.Footer = &discordgo.MessageEmbedFooter{ IconURL: "https://cdn.discordapp.com/avatars/564764617545482251/9c9bd4aaba164fc0b92f13f052405b4d.webp?size=160", Text: "?help to see all commands", } } return response }
```

# pkg/service/evm/evm.go

```go
package evm import ( "math/big" "github.com/ethereum/go-ethereum/common" "github.com/ethereum/go-ethereum/ethclient" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/contracts/erc20" "github.com/dwarvesf/fortress-api/pkg/logger" ) type IService interface { Client() *ethclient.Client ERC20Balance(address, owner common.Address) (*big.Int, error) } type evm struct { client *ethclient.Client cfg *config.Config l logger.Logger } func New(rpc RpcClient, cfg *config.Config, l logger.Logger) (IService, error) { client, err := ethclient.Dial(rpc.Url) if err != nil { return nil, err } return &evm{ client: client, cfg: cfg, l: l, }, nil } func (e *evm) Client() *ethclient.Client { return e.client } func (e *evm) ERC20Balance(address, owner common.Address) (*big.Int, error) { instance, err := erc20.NewErc20(address, e.client) if err != nil { return nil, err } balance, err := instance.BalanceOf(nil, owner) if err != nil { return nil, err } return balance, nil }
```

# pkg/service/evm/model.go

```go
package evm type RpcClient struct { Url string } var ( DefaultBASEClient = RpcClient{Url: "https://mainnet.base.org"} )
```

# pkg/service/git/git.go

```go
package git import ( "context" "errors" "fmt" "os" "strings" "time" "github.com/go-git/go-git/v5" "github.com/go-git/go-git/v5/plumbing" "github.com/go-git/go-git/v5/plumbing/object" "github.com/go-git/go-git/v5/plumbing/transport/http" "github.com/google/go-github/v52/github" "golang.org/x/oauth2" ) type gitService struct { dest string repo *git.Repository auth *http.BasicAuth w *git.Worktree client *github.Client } func New(url, username, password string) IService { repo := strings.Split(url, "/")[4] if repo == "" { fmt.Println("invalid repository url") return nil } auth := &http.BasicAuth{ Username: username, Password: password, } dest := "/tmp/" + repo r, err := git.PlainClone(dest, false, &git.CloneOptions{ URL: url, Progress: os.Stdout, Auth: auth, }) if err != nil { fmt.Println(err) return nil } ctx := context.Background() ts := oauth2.StaticTokenSource( &oauth2.Token{AccessToken: password}, ) tc := oauth2.NewClient(ctx, ts) return &gitService{ dest: dest, repo: r, auth: auth, client: github.NewClient(tc), } } func (g *gitService) Dest() string { return g.dest } // CreateBranch creates a new branch from the current HEAD, and check out to the new branch func (g *gitService) CreateBranch(branchName string) (err error) { if g.repo == nil { return errors.New("repository is not initialized") } headRef, err := g.repo.Head() if err != nil { return err } branchRefName := plumbing.NewBranchReferenceName(branchName) ref := plumbing.NewHashReference(branchRefName, headRef.Hash()) if err := g.repo.Storer.SetReference(ref); err != nil { return err } w, err := g.repo.Worktree() if err != nil { return err } if err := w.Checkout(&git.CheckoutOptions{ Branch: branchRefName, Force: true, }); err != nil { return err } g.w = w return nil } func (g *gitService) Commit(message string) (err error) { if g.w == nil { return errors.New("worktree is not initialized") } if err := g.w.AddWithOptions(&git.AddOptions{All: true}); err != nil { return err } _, err = g.w.Commit(message, &git.CommitOptions{ Author: &object.Signature{ Name: g.auth.Username, Email: "quanglm.ops@gmail.com", When: time.Now(), }, }) if err != nil { return err } return nil } func (g *gitService) Push() (err error) { if g.repo == nil { return errors.New("repository is not initialized") } if g.auth == nil { return errors.New("auth is not initialized") } return g.repo.Push(&git.PushOptions{Auth: g.auth}) } func (g *gitService) CreatePullRequest(owner, repo, head, base, title, body string) (*int, error) { newPR := &github.NewPullRequest{ Title: github.String(title), Head: github.String(head), Base: github.String(base), Body: github.String(body), } pr, _, err := g.client.PullRequests.Create(context.Background(), owner, repo, newPR) if err != nil { return nil, err } return pr.Number, nil } func (g *gitService) RequestReview(owner, repo string, pullRequestNumber int, reviewers []string) error { _, _, err := g.client.PullRequests.RequestReviewers(context.Background(), owner, repo, pullRequestNumber, github.ReviewersRequest{ Reviewers: reviewers, }) if err != nil { return err } return nil }
```

# pkg/service/git/inteface.go

```go
package git type IService interface { Dest() string CreateBranch(branchName string) (err error) Commit(message string) (err error) Push() (err error) CreatePullRequest(owner, repo, head, base, title, body string) (*int, error) RequestReview(owner, repo string, pullRequestNumber int, reviewers []string) error }
```

# pkg/service/github/errors.go

```go
package github import "errors" var ( ErrFailedToGetGithubAccount = errors.New("failed to get github account") ErrFoundOneMoreGithubAccount = errors.New("failed to get github account due to more than 1 github account found") )
```

# pkg/service/github/github.go

```go
package github import ( "context" "github.com/google/go-github/v52/github" "golang.org/x/oauth2" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) type githubService struct { Client *github.Client log logger.Logger } var ( defaultRole = "direct_member" dwarvesFoundationOrg = "dwarvesf" ) func New(cfg *config.Config, l logger.Logger) IService { if cfg.Github.Token == "" { return &githubService{} } return &githubService{ Client: github.NewClient( oauth2.NewClient(context.Background(), oauth2.StaticTokenSource( &oauth2.Token{ AccessToken: cfg.Github.Token, }, ))), log: l, } } func (s githubService) SendInvitationByEmail(ctx context.Context, e *model.Employee) error { if s.Client == nil { s.log.Warn("[SendInvitationByEmail] github token is empty") return nil } role := defaultRole opt := github.CreateOrgInvitationOptions{ Email: &e.PersonalEmail, Role: &role, TeamID: []int64{}, } s.log.Infof("[SendInvitationByEmail] Send invitation to user", "email", e.PersonalEmail) _, _, err := s.Client.Organizations.CreateOrgInvitation(ctx, dwarvesFoundationOrg, &opt) if err != nil { s.log.Errorf(err, "[SendInvitationByEmail] Fail to send invitation", "email", e.PersonalEmail) return err } return nil } func (s githubService) RemoveFromOrganizationByEmail(ctx context.Context, email string) error { if s.Client == nil { return nil } sOpts := github.SearchOptions{} result, _, err := s.Client.Search.Users(ctx, email, &sOpts) if err != nil { s.log.Errorf(err, "[RemoveFromOrganizationByEmail] fail to search user by email", "email", email) return err } switch { case len(result.Users) > 1: s.log.Errorf(ErrFoundOneMoreGithubAccount, "[RemoveFromOrganizationByEmail] more than 1 result return", "email", email) return ErrFoundOneMoreGithubAccount case len(result.Users) == 0: s.log.Errorf(ErrFailedToGetGithubAccount, "[RemoveFromOrganizationByEmail] can not found github account from user email", "email", email) return ErrFailedToGetGithubAccount } s.log.Infof("[RemoveFromOrganizationByEmail] Remove github member out of organization", "username", result.Users[0].GetLogin()) _, err = s.Client.Organizations.RemoveMember(ctx, dwarvesFoundationOrg, result.Users[0].GetLogin()) if err != nil { return err } return nil } func (s githubService) RemoveFromOrganizationByUsername(ctx context.Context, username string) error { if s.Client == nil { return nil } result, _, err := s.Client.Users.Get(ctx, username) if err != nil { s.log.Errorf(err, "[RemoveFromOrganizationByUsername] fail to search user by email", "username", username) return err } s.log.Infof("[RemoveFromOrganizationByUsername] remove github member out of organization", "username", result.GetLogin()) _, err = s.Client.Organizations.RemoveMember(ctx, dwarvesFoundationOrg, result.GetLogin()) if err != nil { return err } return nil } func (s githubService) RetrieveUsernameByID(ctx context.Context, id int64) (string, error) { user, _, err := s.Client.Users.GetByID(ctx, id) if err != nil { s.log.Errorf(err, "[RetrieveUsernameByID] fail to get user by id", "id", id) return "", err } return user.GetLogin(), nil } func (s githubService) FetchOpenPullRequest(ctx context.Context, repo string) (prs []*github.PullRequest, err error) { opts := &github.PullRequestListOptions{ State: "open", Sort: "created", Direction: "desc", ListOptions: github.ListOptions{ Page: 0, PerPage: 15, }, } prs, _, err = s.Client.PullRequests.List(ctx, dwarvesFoundationOrg, repo, opts) if err != nil { s.log.Errorf(err, "[FetchOpenPullRequest] fail to fetch pull request", "repo", repo) return prs, err } return prs, nil }
```

# pkg/service/github/service.go

```go
package github import ( "context" "github.com/google/go-github/v52/github" "github.com/dwarvesf/fortress-api/pkg/model" ) type IService interface { RemoveFromOrganizationByEmail(ctx context.Context, email string) error RemoveFromOrganizationByUsername(ctx context.Context, username string) error SendInvitationByEmail(ctx context.Context, e *model.Employee) error RetrieveUsernameByID(ctx context.Context, id int64) (string, error) FetchOpenPullRequest(ctx context.Context, repo string) ([]*github.PullRequest, error) }
```

# pkg/service/google/google.go

```go
package google import ( "context" "encoding/json" "fmt" "io" "net/http" "strings" "golang.org/x/oauth2" ) const ( state = "state-token" getGoogleUserInfoAPIEndpointLegacy = "https://www.googleapis.com/plus/v1/people/me" getGoogleUserInfoAPIEndpoint = "https://people.googleapis.com/v1/people/me" ) type googleService struct { config *oauth2.Config } // New function return Google service func New(config *oauth2.Config) (IService, error) { return &googleService{ config: config, }, nil } // GetLoginURL return url for user loggin to google account func (g *googleService) GetLoginURL() string { authURL := g.config.AuthCodeURL(state, oauth2.AccessTypeOffline) return authURL } // GetAccessToken return google access token func (g *googleService) GetAccessToken(code string, redirectURL string) (string, error) { g.config.RedirectURL = redirectURL fmt.Println("GetAccessToken: ", g.config.ClientID) token, err := g.config.Exchange(context.Background(), code) if err != nil { return "", fmt.Errorf("failed to exchange code for token. err: %v, client: %v", err, g.config.ClientID) } return token.AccessToken, nil } // GetGoogleEmailLegacy return google user info func (g *googleService) GetGoogleEmailLegacy(accessToken string) (email string, err error) { var gu struct { DisplayName string `json:"displayName"` ID string `json:"id"` Emails []struct { Type string `json:"type"` Value string `json:"value"` } `json:"emails"` } response, err := http.Get(getGoogleUserInfoAPIEndpointLegacy + "?access_token=" + accessToken) if err != nil { return "", err } defer response.Body.Close() body, err := io.ReadAll(response.Body) if err != nil { return "", err } if err = json.Unmarshal(body, &gu); err != nil { return "", err } var primaryEmail string for i := range gu.Emails { if strings.ToLower(gu.Emails[i].Type) == "account" || gu.Emails[i].Type == "primary" { primaryEmail = gu.Emails[i].Value break } } return primaryEmail, nil } // GetGoogleEmail return google user info func (g *googleService) GetGoogleEmail(accessToken string) (email string, err error) { var gu struct { DisplayName string `json:"displayName"` ID string `json:"id"` Emails []struct { Metadata struct { Primary bool `json:"primary"` Verified bool `json:"verified"` SourcePrimary bool `json:"sourcePrimary"` } `json:"metadata"` Value string `json:"value"` } `json:"emailAddresses"` } response, err := http.Get(getGoogleUserInfoAPIEndpoint + "?&personFields=emailAddresses&access_token=" + accessToken) if err != nil { return "", err } defer response.Body.Close() body, err := io.ReadAll(response.Body) if err != nil { return "", err } if err = json.Unmarshal(body, &gu); err != nil { return "", err } var primaryEmail string for i := range gu.Emails { if gu.Emails[i].Metadata.SourcePrimary { primaryEmail = gu.Emails[i].Value break } } return primaryEmail, nil }
```

# pkg/service/google/interface.go

```go
package google type IService interface { GetLoginURL() string GetAccessToken(code string, redirectURL string) (accessToken string, err error) GetGoogleEmailLegacy(accessToken string) (email string, err error) GetGoogleEmail(accessToken string) (email string, err error) }
```

# pkg/service/googleadmin/google_admin.go

```go
package googleadmin import ( "context" "errors" "fmt" "google.golang.org/api/option" "golang.org/x/oauth2" admin "google.golang.org/api/admin/directory/v1" "github.com/dwarvesf/fortress-api/pkg/config" ) type googleService struct { config *oauth2.Config token *oauth2.Token service *admin.Service appConfig *config.Config } // New function return Google service func New(config *oauth2.Config, appConfig *config.Config) IService { return &googleService{ config: config, appConfig: appConfig, } } func (g *googleService) DeleteAccount(mail string) error { if err := g.ensureToken(g.appConfig.Google.AdminGoogleRefreshToken); err != nil { return err } if err := g.prepareService(); err != nil { return err } err := g.service.Users.Delete(mail).Do() return err } func (g *googleService) GetGroupMemberEmails(groupEmail string) ([]string, error) { if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil { return nil, err } if err := g.prepareService(); err != nil { return nil, err } var memberEmails []string members, err := g.service.Members.List(groupEmail).Do() if err != nil { return nil, err } if members == nil { return nil, fmt.Errorf("No member in group %v", groupEmail) } for _, m := range members.Members { memberEmails = append(memberEmails, m.Email) } return memberEmails, nil } func (g *googleService) ensureToken(rToken string) error { token := &oauth2.Token{ RefreshToken: rToken, } if !g.token.Valid() { tks := g.config.TokenSource(context.Background(), token) tok, err := tks.Token() if err != nil { return err } g.token = tok } return nil } func (g *googleService) prepareService() error { client := g.config.Client(context.Background(), g.token) service, err := admin.NewService(context.Background(), option.WithHTTPClient(client)) if err != nil { return errors.New("failed to prepare google admin service " + err.Error()) } g.service = service return nil }
```

# pkg/service/googleadmin/interface.go

```go
package googleadmin // IService interface contain related google calendar method type IService interface { GetGroupMemberEmails(groupEmail string) ([]string, error) DeleteAccount(mail string) error }
```

# pkg/service/googledrive/google_drive.go

```go
package googledrive import ( "bytes" "context" "errors" "fmt" "io" "strconv" "golang.org/x/oauth2" "google.golang.org/api/drive/v3" "google.golang.org/api/option" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/model" ) const FullDriveAccessScope = "https://www.googleapis.com/auth/drive" type googleService struct { config *oauth2.Config token *oauth2.Token service *drive.Service appConfig *config.Config } // New function return Google service func New(config *oauth2.Config, appConfig *config.Config) IService { return &googleService{ config: config, appConfig: appConfig, } } func (g *googleService) UploadInvoicePDF(invoice *model.Invoice, dirName string) error { if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil { return err } if err := g.prepareService(); err != nil { return err } dir, err := g.findInvoiceDir(strconv.Itoa(invoice.Year), dirName) if err != nil { return err } _, err = g.newFile(fmt.Sprintf("#%s.pdf", invoice.Number), "application/pdf", bytes.NewReader(invoice.InvoiceFileContent), dir.Id) if err != nil { return err } return nil } func (g *googleService) MoveInvoicePDF(invoice *model.Invoice, fromDirName, toDirName string) error { if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil { return err } if err := g.prepareService(); err != nil { return err } fromDir, err := g.findInvoiceDir(strconv.Itoa(invoice.Year), fromDirName) if err != nil { return err } if fromDir == nil { return fmt.Errorf(`%v directory not found`, fromDirName) } toDir, err := g.findInvoiceDir(strconv.Itoa(invoice.Year), toDirName) if err != nil { return err } if toDir == nil { return fmt.Errorf(`%v directory not found`, toDirName) } invoicePdf, err := g.searchFile(fmt.Sprintf("#%s.pdf", invoice.Number), fromDir.Id, false) if err != nil { return err } if invoicePdf == nil { return ErrInvoicePDFNotFound } return g.updateInvoiceDir(invoicePdf.Id, fromDir.Id, toDir.Id) } func (g *googleService) updateInvoiceDir(fileID, oldDirID, newDirID string) error { _, err := g.service.Files.Update(fileID, nil). AddParents(newDirID). RemoveParents(oldDirID). Do() return err } func (g *googleService) findInvoiceDir(year, status string) (*drive.File, error) { yearDir, err := g.getDirID(year, g.appConfig.Invoice.DirID) if err != nil { return nil, err } return g.getDirID(status, yearDir.Id) } func (g *googleService) getDirID(dirName, parentDirID string) (*drive.File, error) { dir, err := g.searchFile(dirName, parentDirID, true) if err != nil { return nil, err } if dir != nil { return dir, nil } return g.newDir(dirName, parentDirID) } func (g *googleService) ensureToken(rToken string) error { token := &oauth2.Token{ RefreshToken: rToken, } if !token.Valid() { tks := g.config.TokenSource(context.Background(), token) tok, err := tks.Token() if err != nil { return err } g.token = tok } return nil } func (g *googleService) prepareService() error { client := g.config.Client(context.Background(), g.token) service, err := drive.NewService(context.Background(), option.WithHTTPClient(client)) if err != nil { return errors.New("Get Drive Service Failed " + err.Error()) } g.service = service return nil } func (g *googleService) searchFile(name, parentId string, isFolder bool) (*drive.File, error) { var folderQuery string if isFolder { folderQuery = "mimeType='application/vnd.google-apps.folder' and " } var parentQuery string if parentId != "root" { parentQuery = fmt.Sprintf("'%s' in parents and ", parentId) } r, err := g.service.Files.List(). Q(parentQuery + folderQuery + fmt.Sprintf("name='%s'", name)). Fields("nextPageToken, files(id, name)"). Do() if err != nil { return nil, err } if len(r.Files) == 0 { return nil, nil } return r.Files[0], nil } func (g *googleService) newDir(name string, parentId string) (*drive.File, error) { d := &drive.File{ Name: name, MimeType: "application/vnd.google-apps.folder", Parents: []string{parentId}, } return g.service.Files.Create(d).Do() } func (g *googleService) newFile(name string, mimeType string, content io.Reader, parentId string) (*drive.File, error) { f := &drive.File{ MimeType: mimeType, Name: name, Parents: []string{parentId}, } return g.service.Files.Create(f).Media(content).Do() } // func (g *googleService) deleteFile(id string) error { // return g.service.Files.Delete(id).Do() // } // func getDrivePreviewLink(fileID string) string { // return fmt.Sprintf(`https://drive.google.com/file/d/%s/view`, fileID) // } // func getFileIDFromLink(url string) string { // s := strings.Replace(url, "https://drive.google.com/file/d/", "", 1) // return strings.Replace(s, "/view", "", 1) // } func (g *googleService) DownloadInvoicePDF(invoice *model.Invoice, dirName string) ([]byte, error) { if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil { return nil, err } if err := g.prepareService(); err != nil { return nil, err } dir, err := g.findInvoiceDir(strconv.Itoa(invoice.Year), dirName) if err != nil { return nil, err } f, err := g.searchFile(fmt.Sprintf("#%s.pdf", invoice.Number), dir.Id, false) if err != nil { return nil, err } if f == nil { return nil, fmt.Errorf(`file not found`) } resp, err := g.service.Files.Get(f.Id).Download() if err != nil { return nil, err } defer resp.Body.Close() return io.ReadAll(resp.Body) }
```

# pkg/service/googledrive/interface.go

```go
package googledrive import ( "errors" "github.com/dwarvesf/fortress-api/pkg/model" ) var ( ErrInvoicePDFNotFound = errors.New("invoice pdf not found") ) type IService interface { UploadInvoicePDF(invoice *model.Invoice, dirName string) error MoveInvoicePDF(invoice *model.Invoice, fromDirName, toDirName string) error DownloadInvoicePDF(invoice *model.Invoice, dirName string) ([]byte, error) }
```

# pkg/service/googlemail/google_mail.go

```go
package googlemail import ( "context" "encoding/base64" "encoding/json" "errors" "fmt" "strings" "text/template" "time" "golang.org/x/oauth2" "google.golang.org/api/gmail/v1" "google.golang.org/api/option" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/utils" "github.com/dwarvesf/fortress-api/pkg/utils/mailutils" "github.com/dwarvesf/fortress-api/pkg/utils/timeutil" ) type googleService struct { config *oauth2.Config token *oauth2.Token StartHistoryId uint64 service *gmail.Service appConfig *config.Config } // New function return Google service func New(config *oauth2.Config, appConfig *config.Config) IService { return &googleService{ config: config, appConfig: appConfig, } } func (g *googleService) prepareService() error { client := g.config.Client(context.Background(), g.token) service, err := gmail.NewService(context.Background(), option.WithHTTPClient(client)) if err != nil { return errors.New("Get Gmail Service Failed " + err.Error()) } g.service = service return nil } func (g *googleService) ensureToken(refreshToken string) error { token := &oauth2.Token{ RefreshToken: refreshToken, } if !g.token.Valid() { tks := g.config.TokenSource(context.Background(), token) tok, err := tks.Token() if err != nil { return err } g.token = tok } return nil } // SendInvoiceMail function to send invoice email func (g *googleService) SendInvoiceMail(invoice *model.Invoice) (msgID string, err error) { err = g.filterReceiver(invoice) if err != nil { return "", err } if err = g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil { return "", err } if err := g.prepareService(); err != nil { return "", err } if !mailutils.Email(invoice.Email) { return "", errors.New("email invalid") } lastDayOfMonth := timeutil.LastDayOfMonth(invoice.Month, invoice.Year) addresses, err := model.GatherAddresses(invoice.CC) if err != nil { return "", err } funcMap := template.FuncMap{ "formatDate": func(t *time.Time) string { return timeutil.FormatDatetime(*t) }, "lastDayOfMonth": func() string { return timeutil.FormatDatetime(lastDayOfMonth) }, "encodedPDF": func() string { return base64.StdEncoding.EncodeToString(invoice.InvoiceFileContent) }, "description": func() string { if invoice.Description == "" { return "" } return "Description: " + invoice.Description + "." }, "gatherAddress": func() string { return addresses }, "toString": func(month int) string { return time.Month(month).String() }, } encodedEmail, err := composeMailContent(g.appConfig, &MailParseInfo{ accountingUser, "invoice.tpl", &invoice, funcMap, }) if err != nil { return } id := g.appConfig.Google.AccountingEmailID threadID, err := g.sendEmail(encodedEmail, id) if err != nil { return } return threadID, nil } // SendInvoiceThankYouMail function send thank you email func (g *googleService) SendInvoiceThankYouMail(invoice *model.Invoice) (err error) { err = g.filterReceiver(invoice) if err != nil { return err } if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil { return err } if err := g.prepareService(); err != nil { return err } if invoice.ThreadID == "" { return ErrMissingThreadID } id := g.appConfig.Google.AccountingEmailID thread, err := g.service.Users.Threads.Get(id, invoice.ThreadID).Do() if err != nil { return err } invoice.MessageID, invoice.References, err = getMessageIDFromThread(thread) if err != nil { return err } if !mailutils.Email(invoice.Email) { return ErrInvalidEmail } addresses, err := model.GatherAddresses(invoice.CC) if err != nil { return err } funcMap := template.FuncMap{ "gatherAddress": func() string { return addresses }, "toString": func(month int) string { return time.Month(month).String() }, } encodedEmail, err := composeMailContent(g.appConfig, &MailParseInfo{ accountingUser, "invoiceThankyou.tpl", &invoice, funcMap, }) if err != nil { return err } _, err = g.sendEmail(encodedEmail, id) return err } // SendInvoiceOverdueMail function send overdue email func (g *googleService) SendInvoiceOverdueMail(invoice *model.Invoice) error { if err := g.filterReceiver(invoice); err != nil { return err } if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil { return err } if invoice.ThreadID == "" { return ErrMissingThreadID } if err := g.prepareService(); err != nil { return err } id := g.appConfig.Google.AccountingEmailID thread, err := g.getEmailThread(invoice.ThreadID, id) if err != nil { return err } invoice.MessageID, invoice.References, err = getMessageIDFromThread(thread) if err != nil { return err } if !mailutils.Email(invoice.Email) { return ErrInvalidEmail } addresses, err := model.GatherAddresses(invoice.CC) if err != nil { return err } funcMap := template.FuncMap{ "gatherAddress": func() string { return addresses }, "toString": func(month int) string { return time.Month(month).String() }, } encodedEmail, err := composeMailContent(g.appConfig, &MailParseInfo{ accountingUser, "invoiceOverdue.tpl", &invoice, funcMap, }) if err != nil { return err } _, err = g.sendEmail(encodedEmail, id) return err } func (g *googleService) sendEmail(encodedEmail, id string) (msgID string, err error) { rs, err := g.service.Users.Messages.Send(id, &gmail.Message{ Raw: encodedEmail, }).Do() if err != nil { return } return rs.ThreadId, nil } func (g *googleService) getEmailThread(threadID, id string) (*gmail.Thread, error) { thread, err := g.service.Users.Threads.Get(id, threadID).Do() if err != nil { return nil, err } return thread, nil } func getMessageIDFromThread(thread *gmail.Thread) (msgID, references string, err error) { if len(thread.Messages) == 0 { return "", "", ErrEmptyMessageThread } for _, v := range thread.Messages[len(thread.Messages)-1].Payload.Headers { if strings.ToLower(v.Name) == "message-id" { msgID = v.Value } if strings.ToLower(v.Name) == "references" { references = v.Value } } if msgID == "" { return "", "", ErrCannotFindMessageID } return msgID, fmt.Sprintf(`%s %s`, references, msgID), nil } func (g *googleService) filterReceiver(i *model.Invoice) error { if g.appConfig.Env == "prod" { return nil } if !mailutils.IsDwarvesMail(i.Email) { i.Email = g.appConfig.Invoice.TestEmail } var ccList []string if err := json.Unmarshal(i.CC, &ccList); err != nil { return err } for idx := range ccList { if ccList[idx] == "" { continue } if !mailutils.IsDwarvesMail(ccList[idx]) { ccList[idx] = g.appConfig.Invoice.TestEmail } } b, err := json.Marshal(ccList) if err != nil { return err } var js model.JSON if err := js.Scan(b); err != nil { return err } i.CC = js return nil } // SendPayrollPaidMail after paid a payroll for a user to notify that // we have been paid their payroll func (g *googleService) SendPayrollPaidMail(p *model.Payroll) (err error) { if g.appConfig.Env == "local" { p.Employee.TeamEmail = "benjamin@d.foundation" } if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil { return err } if err := g.prepareService(); err != nil { return err } id := g.appConfig.Google.AccountingEmailID if !mailutils.Email(p.Employee.TeamEmail) { return errors.New("email invalid") } funcMap := g.getPaidSuccessfulEmailFuncMap(p) encodedEmail, err := composeMailContent(g.appConfig, &MailParseInfo{ accountingUser, "paidPayroll.tpl", p, funcMap, }) if err != nil { return err } _, err = g.sendEmail(encodedEmail, id) return err } // ToPaidSuccessfulEmailContent to parse the payroll object // into template when sending email after payroll is paid func (g *googleService) getPaidSuccessfulEmailFuncMap(p *model.Payroll) map[string]interface{} { // the salary will be the contract(companyAccountAmount in DB) // plus the base salary(personalAccountAmount in DB) var addresses string = "quang@d.foundation" if g.appConfig.Env == "prod" { addresses = "quang@d.foundation, accounting@d.foundation" } return template.FuncMap{ "ccList": func() string { return addresses }, "userFirstName": func() string { return p.Employee.GetFirstNameFromFullName() }, "currency": func() string { return p.Employee.BaseSalary.Currency.Symbol }, "currencyName": func() string { return p.Employee.BaseSalary.Currency.Name }, "formattedCurrentMonth": func() string { fm := time.Month(int(p.Month)) return fm.String() }, "formattedBaseSalaryAmount": func() string { return utils.FormatNumber(p.BaseSalaryAmount) }, "formattedTotalAllowance": func() string { return utils.FormatNumber(int64(p.TotalAllowance)) }, "formattedSalaryAdvance": func() string { return utils.FormatNumber(int64(p.SalaryAdvanceAmount)) }, "haveBonusOrCommission": func() bool { return len(p.CommissionExplains) > 0 || len(p.ProjectBonusExplains) > 0 }, "haveCommission": func() bool { return len(p.CommissionExplains) > 0 }, "haveBonus": func() bool { return len(p.ProjectBonusExplains) > 0 }, "commissionExplain": func() []model.CommissionExplain { return p.CommissionExplains }, "projectBonusExplains": func() []model.ProjectBonusExplain { return p.ProjectBonusExplains }, } } // SendInvitationMail ... func (g *googleService) SendInvitationMail(invitation *model.InvitationEmail) (err error) { if err := g.ensureToken(g.appConfig.Google.TeamGoogleRefreshToken); err != nil { return err } if err := g.prepareService(); err != nil { return err } invitation.Link = strings.Replace(invitation.Link, "=", "=3D", -1) encodedEmail, err := composeMailContent(g.appConfig, &MailParseInfo{ teamEmail, "invitation.tpl", &invitation, map[string]interface{}{}, }) if err != nil { return err } id := g.appConfig.Google.TeamEmailID _, err = g.sendEmail(encodedEmail, id) return err } // SendOffboardingMail ... func (g *googleService) SendOffboardingMail(offboarding *model.OffboardingEmail) (err error) { if err := g.ensureToken(g.appConfig.Google.TeamGoogleRefreshToken); err != nil { return err } if err := g.prepareService(); err != nil { return err } encodedEmail, err := composeMailContent(g.appConfig, &MailParseInfo{ teamEmail, "offboarding_keep_fwd_email.tpl", &offboarding, map[string]interface{}{}, }) if err != nil { return err } id := g.appConfig.Google.TeamEmailID _, err = g.sendEmail(encodedEmail, id) return err }
```

# pkg/service/googlemail/interface.go

```go
package googlemail import ( "errors" "github.com/dwarvesf/fortress-api/pkg/model" ) var ( ErrMissingThreadID = errors.New("missing thread_id") ErrInvalidEmail = errors.New("invalid email") ErrEmptyMessageThread = errors.New("empty message thread") ErrCannotFindMessageID = errors.New("cannot find message id") ) // IService interface contain related google calendar method type IService interface { SendInvitationMail(invitation *model.InvitationEmail) (err error) SendInvoiceMail(invoice *model.Invoice) (msgID string, err error) SendInvoiceOverdueMail(invoice *model.Invoice) (err error) SendInvoiceThankYouMail(invoice *model.Invoice) (err error) SendPayrollPaidMail(p *model.Payroll) (err error) SendOffboardingMail(offboarding *model.OffboardingEmail) (err error) }
```

# pkg/service/googlemail/utils.go

```go
package googlemail import ( "bytes" "encoding/base64" "os" "path/filepath" "text/template" "github.com/dwarvesf/fortress-api/pkg/config" ) var ( accountingUser = "accounting" teamEmail = "team" spawnEmail = "spawn" ) type MailParseInfo struct { Sender string TemplateFileName string Data interface{} FuncMap map[string]interface{} } func composeMailContent(appConfig *config.Config, m *MailParseInfo) (string, error) { templatePath := appConfig.Invoice.TemplatePath if appConfig.Env == "local" || templatePath == "" { pwd, err := os.Getwd() if err != nil { pwd = os.Getenv("GOPATH") + "/src/github.com/dwarvesf/fortress-api" } templatePath = filepath.Join(pwd, "pkg/templates") } m.FuncMap["signatureName"] = func() string { switch m.Sender { case accountingUser: return "Eddie Ng" case teamEmail: return "Dwarves Foundation" case spawnEmail: return "Team Dwarves" default: return "" } } m.FuncMap["signatureTitle"] = func() string { switch m.Sender { case accountingUser: return "Accountant" case teamEmail: return "Team Dwarves" case spawnEmail: return "Hiring" default: return "" } } tmpl, err := template.New("mail").Funcs(m.FuncMap).ParseFiles(filepath.Join(templatePath, m.TemplateFileName), filepath.Join(templatePath, "signature.tpl")) if err != nil { return "", err } var buf bytes.Buffer if err := tmpl.ExecuteTemplate(&buf, m.TemplateFileName, m.Data); err != nil { return "", err } return base64.URLEncoding.EncodeToString(buf.Bytes()), nil }
```

# pkg/service/googlesheet/google_sheet.go

```go
package googlesheet import ( "context" "encoding/json" "errors" "fmt" "github.com/dwarvesf/fortress-api/pkg/config" "golang.org/x/oauth2" "google.golang.org/api/option" "google.golang.org/api/sheets/v4" "strings" ) const SpreedSheetReadOnlyScope = "https://www.googleapis.com/auth/spreadsheets.readonly\t" type googleService struct { config *oauth2.Config token *oauth2.Token service *sheets.Service appConfig *config.Config } // New function return Google service func New(config *oauth2.Config, appConfig *config.Config) IService { return &googleService{ config: config, appConfig: appConfig, } } func (g *googleService) ensureToken(rToken string) error { token := &oauth2.Token{ RefreshToken: rToken, } if !token.Valid() { tks := g.config.TokenSource(context.Background(), token) tok, err := tks.Token() if err != nil { return err } g.token = tok } return nil } func (g *googleService) prepareService() error { client := g.config.Client(context.Background(), g.token) service, err := sheets.NewService(context.Background(), option.WithHTTPClient(client)) if err != nil { return errors.New("Get Sheets Service Failed " + err.Error()) } g.service = service return nil } func (g *googleService) FetchSheetContent(fromIdx int) ([]DeliveryMetricRawData, error) { DeliveryMetricSheetID := "1KXUVyDrC9199Dp6wpT6ovIkIvZRtf455eaqwZmvTAFU" DeliveryMetricSheetRange := "All Data" if err := g.ensureToken(g.appConfig.Google.AccountingGoogleRefreshToken); err != nil { return nil, err } if err := g.prepareService(); err != nil { return nil, err } // Fetch the content of the specified Google Sheets file resp, err := g.service.Spreadsheets.Values.Get(DeliveryMetricSheetID, DeliveryMetricSheetRange).Do() if err != nil { return nil, fmt.Errorf("unable to retrieve data from sheet: %v", err) } // Convert the response to JSON jsonData, err := json.Marshal(resp) if err != nil { return nil, fmt.Errorf("unable to convert sheet data to JSON: %v", err) } /// Create a struct instance to hold the data var sheetData SheetData // Unmarshal the JSON data into the struct err = json.Unmarshal(jsonData, &sheetData) if err != nil { return nil, fmt.Errorf("unable to unmarshal sheet data: %v", err) } deliveryMetricRawData := make([]DeliveryMetricRawData, 0) for idx := fromIdx - 1; idx < len(sheetData.Values); idx++ { itm := sheetData.Values[idx] c0 := strings.TrimSpace(itm[0]) c1 := strings.TrimSpace(itm[1]) c2 := strings.TrimSpace(itm[2]) c3 := strings.TrimSpace(itm[3]) c4 := strings.TrimSpace(itm[4]) c5 := strings.TrimSpace(itm[5]) c6 := strings.TrimSpace(itm[6]) if c4 == "" || c5 == "" || c6 == "" { continue } if c1 == "" { c1 = "0" } if c2 == "" { c2 = "0" } if c3 == "" { c3 = "0" } tmp := DeliveryMetricRawData{ Person: c0, Weight: c1, Effort: c2, Effectiveness: c3, Date: c4, Project: c5, Email: c6, } deliveryMetricRawData = append(deliveryMetricRawData, tmp) } return deliveryMetricRawData, nil }
```

# pkg/service/googlesheet/interface.go

```go
package googlesheet var () type IService interface { FetchSheetContent(fromIdx int) ([]DeliveryMetricRawData, error) }
```

# pkg/service/googlesheet/types.go

```go
package googlesheet type SheetData struct { Range string `json:"range"` MajorDimension string `json:"majorDimension"` Values [][]string `json:"values"` } type DeliveryMetricRawData struct { Person string `json:"person"` Weight string `json:"weight"` Effort string `json:"effort"` Effectiveness string `json:"effectiveness"` Date string `json:"date"` Project string `json:"project"` Email string `json:"email"` }
```

# pkg/service/googlestorage/gcs.go

```go
package googlestorage import ( "cloud.google.com/go/storage" ) type CloudStorage struct { client *storage.Client projectID string bucketName string }
```

# pkg/service/googlestorage/google.go

```go
package googlestorage import ( "context" "encoding/base64" "fmt" "io" "time" "cloud.google.com/go/storage" "google.golang.org/api/option" ) type service struct { gcs *CloudStorage } // New function return Google service func New(BucketName string, GCSProjectID string, GCSCredentials string) (IService, error) { decoded, err := base64.StdEncoding.DecodeString(GCSCredentials) if err != nil { return nil, fmt.Errorf("failed to decode gcs credentials: %v", err) } client, err := storage.NewClient(context.Background(), option.WithCredentialsJSON(decoded)) if err != nil { return nil, fmt.Errorf("failed to create client: %v", err) } return &service{ gcs: &CloudStorage{ client: client, projectID: GCSProjectID, bucketName: BucketName, }, }, nil } func (g *service) UploadContentGCS(file io.Reader, filePath string) error { ctx := context.Background() ctx, cancel := context.WithTimeout(ctx, time.Second*50) defer cancel() // Upload an object with storage.Writer. wc := g.gcs.client.Bucket(g.gcs.bucketName).Object(filePath).NewWriter(ctx) if _, err := io.Copy(wc, file); err != nil { return fmt.Errorf("io.Copy: %v", err) } if err := wc.Close(); err != nil { return fmt.Errorf("Writer.Close: %v", err) } return nil }
```

# pkg/service/googlestorage/interface.go

```go
package googlestorage import ( "io" ) type IService interface { UploadContentGCS(file io.Reader, fileName string) error }
```

# pkg/service/icyswap/icyswap.go

```go
package icyswap import ( "math/big" "github.com/ethereum/go-ethereum/common" "github.com/dwarvesf/fortress-api/pkg/config" icyswapabi "github.com/dwarvesf/fortress-api/pkg/contracts/icyswap" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service/evm" ) type IService interface { ConversionRate() (*big.Int, error) UsdcFund() (*big.Int, error) } type icyswap struct { instance *icyswapabi.IcySwap evm evm.IService cfg *config.Config l logger.Logger } const ( ICYSwapAddress = "0x982d2c5A654E4f7CC65ACDCa4ECc649fE4F4DAa4" USDCAddress = "0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA" ) func New(evm evm.IService, cfg *config.Config, l logger.Logger) (IService, error) { instance, err := icyswapabi.NewIcySwap(common.HexToAddress(ICYSwapAddress), evm.Client()) if err != nil { return nil, err } return &icyswap{ instance: instance, evm: evm, cfg: cfg, l: l, }, nil } func (i *icyswap) ConversionRate() (*big.Int, error) { rate, err := i.instance.IcyToUsdcConversionRate(nil) if err != nil { return nil, err } return rate, nil } func (i *icyswap) UsdcFund() (*big.Int, error) { balance, err := i.evm.ERC20Balance(common.HexToAddress(USDCAddress), common.HexToAddress(ICYSwapAddress)) if err != nil { return nil, err } return balance, nil }
```

# pkg/service/improvmx/improvmx.go

```go
package improvmx import ( "errors" "strings" "github.com/issyl0/go-improvmx" ) type improvMXService struct { service *improvmx.Client } // New function return Google service func New(token string) IService { return &improvMXService{ service: improvmx.NewClient(token), } } func (g *improvMXService) CreateAccount(email, emailFwd string) error { alias := strings.Replace(email, "@d.foundation", "", -1) resp := g.service.CreateEmailForward("d.foundation", alias, emailFwd) if !resp.Success { return errors.New(resp.Error) } return nil } func (g *improvMXService) DeleteAccount(mail string) error { alias := strings.Replace(mail, "@d.foundation", "", -1) resp := g.service.DeleteEmailForward("d.foundation", alias) if !resp.Success { return errors.New(resp.Error) } return nil }
```

# pkg/service/improvmx/service.go

```go
package improvmx type IService interface { CreateAccount(email, fwdEmail string) error DeleteAccount(email string) error }
```

# pkg/service/lobsters/interface.go

```go
package lobsters type IService interface { FetchNews(tag string) ([]LobsterPost, error) }
```

# pkg/service/lobsters/new.go

```go
package lobsters type service struct { } func New() IService { return &service{} }
```

# pkg/service/lobsters/news.go

```go
package lobsters import ( "encoding/json" "fmt" "io" "net/http" "strings" "time" ) type LobsterPost struct { ShortID string `json:"short_id"` ShortIDURL string `json:"short_id_url"` CreatedAt time.Time `json:"created_at"` Title string `json:"title"` URL string `json:"url"` Score int `json:"score"` Flags int `json:"flags"` CommentCount int `json:"comment_count"` Description string `json:"description"` DescriptionPlain string `json:"description_plain"` CommentsURL string `json:"comments_url"` SubmitterUser string `json:"submitter_user"` UserIsAuthor bool `json:"user_is_author"` Tags []string `json:"tags"` } const lobstersURL = "https://lobste.rs/" func (s service) FetchNews(tag string) ([]LobsterPost, error) { // Create a new HTTP client client := &http.Client{} if strings.TrimSpace(tag) == "" { return nil, nil } // Make the GET request resp, err := client.Get(lobstersURL + "t/" + tag + ".json") if err != nil { return nil, fmt.Errorf("make get request failed: %w", err) } defer resp.Body.Close() // Read the response body body, err := io.ReadAll(resp.Body) if err != nil { return nil, fmt.Errorf("read response body failed: %w", err) } // Unmarshal the response body var posts []LobsterPost err = json.Unmarshal(body, &posts) if err != nil { return nil, fmt.Errorf("unmarshal response body failed: %w", err) } return posts, nil }
```

# pkg/service/mochi/mochi.go

```go
package mochi import ( "encoding/json" "fmt" "io" "net/http" "strconv" mochisdk "github.com/consolelabs/mochi-go-sdk/mochi" mochiconfig "github.com/consolelabs/mochi-go-sdk/mochi/config" "github.com/consolelabs/mochi-go-sdk/mochi/model" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service/mochipay" ) type IService interface { GetVaultTransaction(req *VaultTransactionRequest) (*VaultTransactionResponse, error) SendFromAccountToUser(amount float64, discordID, description, references string) ([]model.Transaction, error) GetListVaults(noFetchAmount bool) ([]Vault, error) } type client struct { cfg *config.Config l logger.Logger mochiClient mochisdk.APIClient } func New(cfg *config.Config, l logger.Logger) IService { config := &mochiconfig.Config{ MochiPay: mochiconfig.MochiPay{ ApplicationID: cfg.Mochi.ApplicationID, ApplicationName: cfg.Mochi.ApplicationName, APIKey: cfg.Mochi.APIKey, }, } mochiClient := mochisdk.NewClient(config) return &client{ cfg: cfg, l: l, mochiClient: mochiClient, } } // SendFromAccountToUser implements IService. func (c *client) SendFromAccountToUser(amount float64, discordID, description, references string) ([]model.Transaction, error) { profile, err := c.mochiClient.GetByDiscordID(discordID) if err != nil { return nil, err } txs, err := c.mochiClient.Transfer(&model.TransferRequest{ RecipientIDs: []string{profile.ID}, Amounts: []string{strconv.FormatFloat(amount, 'f', -1, 64)}, TokenID: mochipay.ICYTokenMochiID, Description: description, References: references, }) if err != nil { return nil, err } return txs, nil } func (m *client) GetVaultTransaction(req *VaultTransactionRequest) (*VaultTransactionResponse, error) { var client = &http.Client{} request, err := http.NewRequest("GET", fmt.Sprintf("%s/api/v1/vault/%s/transaction?start_time=%s&end_time=%s", m.cfg.Mochi.BaseURL, req.VaultID, req.StartTime, req.EndTime), nil) if err != nil { return nil, err } response, err := client.Do(request) if err != nil { return nil, err } defer response.Body.Close() resBody, err := io.ReadAll(response.Body) if err != nil { return nil, err } res := &VaultTransactionResponse{} err = json.Unmarshal(resBody, res) if err != nil { return nil, err } return res, nil } // GetListVaults call to mochi-api to get all vaults func (m *client) GetListVaults(noFetchAmount bool) ([]Vault, error) { var client = &http.Client{} request, err := http.NewRequest("GET", fmt.Sprintf("%s/api/v1/vault?no_fetch_amount=%v", m.cfg.Mochi.BaseURL, noFetchAmount), nil) if err != nil { return nil, err } response, err := client.Do(request) if err != nil { return nil, err } defer response.Body.Close() resBody, err := io.ReadAll(response.Body) if err != nil { return nil, err } res := &GetListVaultsResponse{} err = json.Unmarshal(resBody, res) if err != nil { return nil, err } return res.Data, nil }
```

# pkg/service/mochi/model.go

```go
package mochi // Vault is the model for mochi vault that is fetched from mochi-api type Vault struct { ID int64 `json:"id"` GuildID string `json:"guild_id"` }
```

# pkg/service/mochi/request.go

```go
package mochi type VaultTransactionRequest struct { VaultID string `json:"vault_id"` StartTime string `json:"start_time"` EndTime string `json:"end_time"` } type VaultTransactionResponse struct { Data []VaultTransaction `json:"data"` } type VaultTransaction struct { ID int64 `json:"id"` GuildID string `json:"guild_id"` VaultID int64 `json:"vault_id"` VaultName string `json:"vault_name"` Action string `json:"action"` FromAddress string `json:"from_address"` ToAddress string `json:"to_address"` Target string `json:"target"` Sender string `json:"sender"` Amount string `json:"amount"` Token string `json:"token"` Threshold string `json:"threshold"` CreatedAt string `json:"created_at"` UpdatedAt string `json:"updated_at"` }
```

# pkg/service/mochi/response.go

```go
package mochi // GetListVaultsResponse is the response model for mochi-api GetListVaults type GetListVaultsResponse struct { Data []Vault `json:"data"` }
```

# pkg/service/mochipay/mochipay.go

```go
package mochipay import ( "bytes" "encoding/json" "fmt" "net/http" "net/url" "strings" "time" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" ) const ( ICYAddress = "0xf289e3b222dd42b185b7e335fa3c5bd6d132441d" BASEChainID = "8453" RewardDefaultMsg = "Send money to treasurer" ICYTokenMochiID = "9d25232e-add3-4bd8-b7c6-be6c14debc58" BaseChainName = "BASE" ) type IService interface { GetListTransactions(req ListTransactionsRequest) (*ListTransactionsResponse, error) GetBatchBalances(profileIds []string) (*BatchBalancesResponse, error) } type client struct { cfg *config.Config l logger.Logger } func New(cfg *config.Config, l logger.Logger) IService { return &client{ cfg: cfg, l: l, } } func (m *client) GetListTransactions(req ListTransactionsRequest) (*ListTransactionsResponse, error) { var client = &http.Client{ Timeout: 10 * time.Second, } queryParams := url.Values{} var pageSize int64 = 10 if req.Size != 0 { pageSize = req.Size } queryParams.Add("size", fmt.Sprintf("%v", pageSize)) queryParams.Add("page", fmt.Sprintf("%v", req.Page)) if len(req.ActionList) > 0 { actions := "" for i, a := range req.ActionList { if i == 0 { actions += string(a) continue } actions += fmt.Sprintf("|%s", a) } queryParams.Add("action", actions) } if req.Type != "" { queryParams.Add("type", string(req.Type)) } if req.Status != "" { queryParams.Add("status", string(req.Status)) } if req.TokenAddress != "" { queryParams.Add("token_address", req.TokenAddress) } if len(req.Platforms) != 0 { platforms := make([]string, 0) for _, p := range req.Platforms { platforms = append(platforms, string(p)) } queryParams.Add("platforms", strings.Join(platforms, "|")) } if len(req.ChainIDs) != 0 { queryParams.Add("chain_ids", strings.Join(req.ChainIDs, "|")) } if req.ProfileID != "" { queryParams.Add("profile_id", req.ProfileID) } if req.IsSender != nil { queryParams.Add("is_sender", fmt.Sprintf("%v", *req.IsSender)) } if req.SortBy != "" { queryParams.Add("sort_by", req.SortBy) } url := fmt.Sprintf("%s/api/v1/transactions?", m.cfg.MochiPay.BaseURL) + queryParams.Encode() r, err := client.Get(url) if err != nil { m.l.Errorf(err, "[mochipay.GetListTransaction] client.Get failed") return nil, err } defer r.Body.Close() res := &ListTransactionsResponse{} if err := json.NewDecoder(r.Body).Decode(&res); err != nil { m.l.Errorf(err, "[mochipay.GetListTransaction] decoder.Decode failed") return nil, err } return res, nil } func (m *client) GetBatchBalances(profileIds []string) (*BatchBalancesResponse, error) { var client = &http.Client{ Timeout: 10 * time.Second, } url := fmt.Sprintf("%s/api/v1/mochi-wallet/balances/multiple", m.cfg.MochiPay.BaseURL) body, err := json.Marshal(struct { ProfileIDs []string `json:"profile_ids"` }{ProfileIDs: profileIds}) if err != nil { m.l.Errorf(err, "[mochipay.GetchBatchbalances] json.Marshal failed") return nil, err } r, err := client.Post(url, "application/json", bytes.NewBuffer(body)) if err != nil { m.l.Errorf(err, "[mochipay.GetBatchBalances] client.Get failed") return nil, err } defer r.Body.Close() res := &BatchBalancesResponse{} if err := json.NewDecoder(r.Body).Decode(res); err != nil { m.l.Errorf(err, "[mochipay.GetBatchBalances] decoder.Decode failed") return nil, err } return res, nil }
```

# pkg/service/mochipay/request.go

```go
package mochipay import ( "time" ) type TransactionType string const ( TransactionTypeSend TransactionType = "out" TransactionTypeReceive TransactionType = "in" ) type TransactionStatus string const ( TransactionStatusPending TransactionStatus = "pending" TransactionStatusSubmitted TransactionStatus = "submitted" TransactionStatusSuccess TransactionStatus = "success" TransactionStatusFailed TransactionStatus = "failed" TransactionStatusExpired TransactionStatus = "expired" TransactionStatusCancelled TransactionStatus = "cancelled" //nolint:all ) type TransactionAction string const ( TransactionActionTransfer TransactionAction = "transfer" TransactionActionAirdrop TransactionAction = "airdrop" TransactionActionDeposit TransactionAction = "deposit" TransactionActionWithdraw TransactionAction = "withdraw" TransactionActionSwap TransactionAction = "icyswapbtc" TransactionActionVaultTransfer TransactionAction = "vault_transfer" ) type TransactionPlatform string const ( TransactionPlatformDiscord TransactionPlatform = "discord" ) type ListTransactionsRequest struct { Type TransactionType `json:"type"` Status TransactionStatus `json:"status"` ActionList []TransactionAction `json:"action_list"` TokenAddress string `json:"token_address"` ProfileID string `json:"profile_id"` Platforms []TransactionPlatform `json:"platforms"` ChainIDs []string `json:"chain_ids"` Page int64 `json:"page"` Size int64 `json:"size"` IsSender *bool `json:"is_sender"` SortBy string `json:"sort_by"` } type ListTransactionsResponse struct { Data []TransactionData `json:"data"` Pagination Pagination `json:"pagination"` } type Pagination struct { Total int64 `json:"total"` Page int64 `json:"page"` Size int64 `json:"size"` } type TransactionData struct { Id string `json:"id"` FromProfileId string `json:"from_profile_id"` OtherProfileId string `json:"other_profile_id"` FromProfileSource string `json:"from_profile_source"` OtherProfileSource string `json:"other_profile_source"` SourcePlatform string `json:"source_platform"` Amount string `json:"amount"` TokenId string `json:"token_id"` ChainId string `json:"chain_id"` InternalId int64 `json:"internal_id"` ExternalId string `json:"external_id"` OnchainTxHash string `json:"onchain_tx_hash"` Type TransactionType `json:"type"` Action TransactionAction `json:"action"` Status TransactionStatus `json:"status"` CreatedAt time.Time `json:"created_at"` UpdatedAt time.Time `json:"updated_at"` ExpiredAt *time.Time `json:"expired_at"` SettledAt *time.Time `json:"settled_at"` Token *Token `json:"token"` OriginalTxId string `json:"original_tx_id"` OtherProfile *MochiProfile `json:"other_profile"` FromProfile *MochiProfile `json:"from_profile"` OtherProfiles []MochiProfile `json:"other_profiles"` AmountEachProfiles []AmountEachProfiles `json:"amount_each_profiles"` UsdAmount float64 `json:"usd_amount"` Metadata map[string]interface{} `json:"metadata"` // used in airdrop response OtherProfileIds []string `json:"other_profile_ids"` TotalAmount string `json:"total_amount"` // used in icyswapbtc response FromTokenId string `json:"from_token_id"` ToTokenId string `json:"to_token_id"` FromToken *Token `json:"from_token,omitempty"` ToToken *Token `json:"to_token,omitempty"` FromAmount string `json:"from_amount"` ToAmount string `json:"to_amount"` } type Token struct { Id string `json:"id"` Name string `json:"name"` Symbol string `json:"symbol"` Decimal int64 `json:"decimal"` ChainId string `json:"chain_id"` Native bool `json:"native"` Address string `json:"address"` Icon string `json:"icon"` CoinGeckoId string `json:"coin_gecko_id"` Price float64 `json:"price"` Chain *Chain `json:"chain"` } type Chain struct { Id string `json:"id"` ChainId string `json:"chain_id"` Name string `json:"name"` Symbol string `json:"symbol"` Rpc string `json:"rpc"` Explorer string `json:"explorer"` Icon string `json:"icon"` Type string `json:"type"` } type MochiProfile struct { Id string `json:"id"` CreatedAt string `json:"created_at"` UpdatedAt string `json:"updated_at"` ProfileName string `json:"profile_name"` Avatar string `json:"avatar"` AssociatedAccounts []AssociatedAccounts `json:"associated_accounts"` Type string `json:"type"` Application *Application `json:"application"` } type Application struct { Id int `json:"id"` Name string `json:"name"` OwnerProfileId string `json:"owner_profile_id"` ServiceFee float64 `json:"service_fee"` ApplicationProfileId string `json:"application_profile_id"` Active bool `json:"active"` } type AssociatedAccounts struct { Id string `json:"id"` ProfileId string `json:"profile_id"` Platform string `json:"platform"` PlatformIdentifier string `json:"platform_identifier"` PlatformMetadata interface{} `json:"platform_metadata"` IsGuildMember bool `json:"is_guild_member"` CreatedAt string `json:"created_at"` UpdatedAt string `json:"updated_at"` } type AmountEachProfiles struct { ProfileId string `json:"profile_id"` Amount string `json:"amount"` UsdAmount float64 `json:"usd_amount"` } type TokenInfo struct { Address string `json:"address"` Chain *Chain `json:"chain"` ChainID string `json:"chain_id"` CoinGeckoID string `json:"coin_gecko_id"` Decimal int `json:"decimal"` Icon string `json:"icon"` ID string `json:"id"` Name string `json:"name"` Native bool `json:"native"` Price int `json:"price"` Symbol string `json:"symbol"` } type VaultRequest struct { Amount string `json:"amount"` Chain string `json:"chain"` ListNotify []string `json:"list_notify"` Message string `json:"message"` Name string `json:"name"` Platform string `json:"platform"` PrivateKey string `json:"private_key"` ProfileID string `json:"profile_id"` Receiver string `json:"receiver"` RequestID int `json:"request_id"` To string `json:"to"` Token string `json:"token"` TokenID string `json:"token_id"` TokenInfo *TokenInfo `json:"token_info"` VaultID int `json:"vault_id"` } type TransactionMetadata struct { Message string `json:"message"` RecipientProfileType string `json:"recipient_profile_type"` RequestID int `json:"request_id"` SenderProfileType string `json:"sender_profile_type"` TransferType string `json:"transfer_type"` TxHash string `json:"tx_hash"` VaultRequest *VaultRequest `json:"vault_request"` } type BatchBalancesResponse struct { Data []BatchBalancesData `json:"data"` } type BatchBalancesData struct { Id string `json:"id"` ProfileID string `json:"profile_id"` TokenID string `json:"token_id"` Amount string `json:"amount"` Token Token `json:"token"` }
```

# pkg/service/mochiprofile/mochiprofile.go

```go
package mochiprofile import ( "encoding/json" "fmt" "net/http" "net/url" "time" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" ) type IService interface { GetProfile(id string) (*MochiProfile, error) GetListProfiles(req ListProfilesRequest) (*GetMochiProfilesResponse, error) GetProfileByDiscordID(discordID string) (*MochiProfile, error) GetProfileByEvmAddress(address string) (*MochiProfile, error) } type client struct { cfg *config.Config l logger.Logger } func New(cfg *config.Config, l logger.Logger) IService { return &client{ cfg: cfg, l: l, } } func (m *client) GetProfile(id string) (*MochiProfile, error) { var client = &http.Client{ Timeout: 10 * time.Second, } url := fmt.Sprintf("%s/api/v1/profiles?ids=%s", m.cfg.MochiProfile.BaseURL, id) r, err := client.Get(url) if err != nil { m.l.Errorf(err, "[mochipay.GetListTransaction] client.Get failed") return nil, err } defer r.Body.Close() res := &GetMochiProfilesResponse{} if err := json.NewDecoder(r.Body).Decode(&res); err != nil { m.l.Errorf(err, "[mochiprofile.GetProfile] decoder.Decode failed") return nil, err } if len(res.Data) == 0 { return nil, nil } if len(res.Data) > 1 { m.l.Errorf(nil, "[mochiprofile.GetProfile] more than 1 profile") return nil, fmt.Errorf("more than 1 profile") } return &res.Data[0], handleErrorStatusCode("Get Mochi profile", r.StatusCode) } func (m *client) GetProfileByDiscordID(discordID string) (*MochiProfile, error) { var client = &http.Client{ Timeout: 10 * time.Second, } url := fmt.Sprintf("%s/api/v1/profiles/get-by-discord/%s", m.cfg.MochiProfile.BaseURL, discordID) r, err := client.Get(url) if err != nil { m.l.Errorf(err, "[mochipay.GetListTransaction] client.Get failed") return nil, err } defer r.Body.Close() res := &MochiProfile{} if err := json.NewDecoder(r.Body).Decode(&res); err != nil { m.l.Errorf(err, "[mochipay.GetListTransaction] decoder.Decode failed") return nil, err } return res, handleErrorStatusCode("Get Mochi profile by discord ID", r.StatusCode) } func (m *client) GetProfileByEvmAddress(address string) (*MochiProfile, error) { var client = &http.Client{ Timeout: 10 * time.Second, } url := fmt.Sprintf("%s/api/v1/profiles/get-by-evm/%s", m.cfg.MochiProfile.BaseURL, address) r, err := client.Get(url) if err != nil { m.l.Errorf(err, "[mochiprofile.GetProfileByEvmAddress] client.Get failed") return nil, err } defer r.Body.Close() res := &MochiProfile{} if err := json.NewDecoder(r.Body).Decode(&res); err != nil { m.l.Errorf(err, "[mochiprofile.GetProfileByEvmAddress] decoder.Decode failed") return nil, err } return res, handleErrorStatusCode("Get Mochi profile by evm address", r.StatusCode) } func (m *client) GetListProfiles(req ListProfilesRequest) (*GetMochiProfilesResponse, error) { var client = &http.Client{ Timeout: 10 * time.Second, } queryParams := url.Values{} var pageSize int64 = 10 if req.Size != 0 { pageSize = req.Size } queryParams.Add("size", fmt.Sprintf("%v", pageSize)) queryParams.Add("page", fmt.Sprintf("%v", req.Page)) if len(req.IDs) > 0 { ids := getListParams(req.IDs) queryParams.Add("ids", ids) } if len(req.Types) > 0 { types := getListParams(req.Types) queryParams.Add("types", types) } url := fmt.Sprintf("%s/api/v1/profiles?", m.cfg.MochiProfile.BaseURL) + queryParams.Encode() r, err := client.Get(url) if err != nil { m.l.Errorf(err, "[mochiprofile.GetListProfile] client.Get failed") return nil, err } defer r.Body.Close() res := &GetMochiProfilesResponse{} if err := json.NewDecoder(r.Body).Decode(res); err != nil { m.l.Errorf(err, "[mochiprofile.GetListProfiles] decoder.Decode failed") return nil, err } return res, nil } func handleErrorStatusCode(method string, statusCode int) error { if statusCode >= 200 && statusCode < 300 { return nil } return fmt.Errorf("%s status code: %d", method, statusCode) } func getListParams[T fmt.Stringer](data []T) string { param := "" for i, a := range data { if i == 0 { param += fmt.Sprintf("%s", a) continue } param += fmt.Sprintf("|%s", a) } return param }
```

# pkg/service/mochiprofile/request.go

```go
package mochiprofile import "time" type ProfilePlatform string const ( ProfilePlatformDiscord ProfilePlatform = "discord" ProfilePlatformGithub ProfilePlatform = "github" ) type Pagination struct { Total int64 `json:"total"` Page int64 `json:"page"` Size int64 `json:"size"` } type GetMochiProfilesResponse struct { Data []MochiProfile `json:"data"` Pagination Pagination `json:"pagination"` } type MochiProfile struct { ID string `json:"id"` ProfileName string `json:"profile_name"` Avatar string `json:"avatar"` AssociatedAccounts []AssociatedAccounts `json:"associated_accounts"` Type string `json:"type"` CreatedAt time.Time `json:"created_at"` UpdatedAt time.Time `json:"updated_at"` } type AssociatedAccounts struct { Id string `json:"id"` ProfileId string `json:"profile_id"` Platform ProfilePlatform `json:"platform"` PlatformIdentifier string `json:"platform_identifier"` PlatformMetadata map[string]interface{} `json:"platform_metadata"` IsGuildMember bool `json:"is_guild_member"` CreatedAt string `json:"created_at"` UpdatedAt string `json:"updated_at"` } type ListProfilesRequest struct { Types []ProfileType `json:"type"` IDs []ProfileID `json:"ids"` Page int64 `json:"page"` Size int64 `json:"size"` } type ProfileID string func (i ProfileID) String() string { return string(i) } type ProfileType string const ( ProfileTypeUser ProfileType = "user" ProfileTypeApplication ProfileType = "application" ProfileTypeVault ProfileType = "vault" ) func (t ProfileType) String() string { return string(t) }
```

# pkg/service/notion/interface.go

```go
package notion import ( nt "github.com/dstotijn/go-notion" "github.com/dwarvesf/fortress-api/pkg/model" ) type IService interface { GetPage(pageID string) (clientPage nt.Page, err error) GetDatabase(databaseID string, filter *nt.DatabaseQueryFilter, sorts []nt.DatabaseQuerySort, pageSize int) (database *nt.DatabaseQueryResponse, err error) GetDatabaseWithStartCursor(databaseID string, startCursor string) (*nt.DatabaseQueryResponse, error) FindClientPageForChangelog(clientID string) (clientPage nt.Page, err error) GetProjectInDB(pageID string) (project *nt.DatabasePageProperties, err error) GetProjectsInDB(pageIDs []string, projectPageID string) (projects map[string]nt.DatabasePageProperties, err error) GetBlockChildren(pageID string) (blockChildrenResponse *nt.BlockChildrenResponse, err error) GetBlock(pageID string) (blockResponse nt.Block, err error) ListProject() ([]model.ProjectChangelogPage, error) GetPagePropByID(pageID, propID string, query *nt.PaginationQuery) (*nt.PagePropResponse, error) // CreatePage create a page in notion CreatePage() error CreateDatabaseRecord(databaseID string, properties map[string]interface{}) (pageID string, err error) ToChangelogMJML(blocks []nt.Block, email model.Email) (string, error) QueryAudienceDatabase(audienceDBId, audience string) (records []nt.Page, err error) }
```

# pkg/service/notion/notion.go

```go
package notion import ( "context" "errors" "fmt" "strings" nt "github.com/dstotijn/go-notion" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/utils" ) type notionService struct { notionClient *nt.Client projectsDBID string l logger.Logger } func New(secret, projectID string, l logger.Logger) IService { return &notionService{ notionClient: nt.NewClient(secret), projectsDBID: projectID, l: l, } } // GetBlock implements IService func (n *notionService) GetBlock(pageID string) (blockResponse nt.Block, err error) { ctx := context.Background() res, err := n.notionClient.FindBlockByID(ctx, pageID) if err != nil { return nil, err } return res, nil } // ToChangelogMJML implements Service func (n *notionService) ToChangelogMJML(blocks []nt.Block, email model.Email) (string, error) { var resutl string for i, block := range blocks { switch v := block.(type) { case *nt.Heading1Block: // get array of plain text var plainText []string for _, text := range v.RichText { plainText = append(plainText, text.PlainText) } resutl = resutl + fmt.Sprintf(`<mj-text padding-bottom="0px" line-height="30px"> <h1 style="font-weight: bold"> %s </h1> </mj-text>`, strings.Join(plainText, " ")) case *nt.Heading2Block: // get array of plain text var plainText []string for _, text := range v.RichText { plainText = append(plainText, text.PlainText) } resutl = resutl + fmt.Sprintf(`<mj-text padding-bottom="0px" line-height="28px"> <h2 style="font-weight: bold"> %s </h2> </mj-text>`, strings.Join(plainText, " ")) case *nt.Heading3Block: // get array of plain text var plainText []string for _, text := range v.RichText { plainText = append(plainText, text.PlainText) } resutl = resutl + fmt.Sprintf(`<mj-text padding-bottom="0px" font-size="16px" line-height="24px"> <h3 style="font-weight: bold"> %s </h3> </mj-text>`, strings.Join(plainText, " ")) case *nt.ParagraphBlock: // get array of plain text var plainText []string for _, text := range v.RichText { if text.HRef != nil { link := *text.HRef // check if text.href is a link if !utils.HasDomain(*text.HRef) { link = fmt.Sprintf("https://www.notion.so/dwarves/%s", *text.HRef) } text.PlainText = fmt.Sprintf(`<a href="%s">%s</a>`, link, text.PlainText) } plainText = append(plainText, text.PlainText) } resutl = resutl + fmt.Sprintf(`<mj-text padding-bottom="0px" padding-top="0px"> <p style="margin:4px 0px;"> %s </p> </mj-text>`, strings.Join(plainText, " ")) case *nt.BulletedListItemBlock: // get array of plain text var plainText []string for _, text := range v.RichText { plainText = append(plainText, text.PlainText) } // if first block if i == 0 { resutl = resutl + fmt.Sprintf(`<mj-text padding="0px 0px"> <ul> <li style="margin: 4px 0px;"> %s </li>`, strings.Join(plainText, " ")) resutl = handleNestedBulletText(v, resutl) } else { // handle block in between first and last block // if block before this is a bullet list if _, ok := blocks[i-1].(*nt.BulletedListItemBlock); ok { if _, ok := blocks[i+1].(*nt.BulletedListItemBlock); ok { // and block after this is a bullet list resutl = resutl + fmt.Sprintf(` <li style="margin: 4px 0px;"> %s </li> `, strings.Join(plainText, " ")) resutl = handleNestedBulletText(v, resutl) } else { // and block after this is not a bullet list resutl = resutl + fmt.Sprintf(` <li style="margin: 4px 0px;"> %s </li> </ul> </mj-text>`, strings.Join(plainText, " ")) resutl = handleNestedBulletText(v, resutl) } } else { // if block before this is not a bullet list // if this is last block if i == len(blocks)-1 { resutl = resutl + fmt.Sprintf(`<mj-text padding="0px 0px"> <ul> <li style="margin: 4px 0px;"> %s </li> </ul> </mj-text>`, strings.Join(plainText, " ")) resutl = handleNestedBulletText(v, resutl) } else { // if this is not last block if _, ok := blocks[i+1].(*nt.BulletedListItemBlock); ok { // and block after this is a bullet list resutl = resutl + fmt.Sprintf(`<mj-text padding="0px 0px"> <ul> <li style="margin: 4px 0px;"> %s </li>`, strings.Join(plainText, " ")) resutl = handleNestedBulletText(v, resutl) } else { resutl = resutl + fmt.Sprintf(`<mj-text padding="0px 0px"> <ul> <li style="margin: 4px 0px;"> %s </li> </ul> </mj-text>`, strings.Join(plainText, " ")) resutl = handleNestedBulletText(v, resutl) } } } } case *nt.ImageBlock: if v.External != nil { resutl = resutl + fmt.Sprintf(` <mj-image width="600px" padding-top="0" src="%s"></mj-image>`, v.External.URL) } else { resutl = resutl + fmt.Sprintf(` <mj-image width="600px" padding-top="0" src="%s"></mj-image>`, v.File.URL) } } } return resutl, nil } func handleNestedBulletText(v *nt.BulletedListItemBlock, resutl string) string { for _, child := range v.Children { switch child := child.(type) { case *nt.BulletedListItemBlock: var plainTextChild []string for _, textChild := range child.RichText { plainTextChild = append(plainTextChild, textChild.PlainText) } resutl = resutl + fmt.Sprintf(`<mj-text padding="0px 0px"> <ul> <li style="margin: 4px 0px;"> %s </li> %s </ul> </mj-text>`, strings.Join(plainTextChild, " "), handleNestedBulletText(child, "")) } } return resutl } func (n *notionService) FindClientPageForChangelog(clientID string) (nt.Page, error) { ctx := context.Background() res, err := n.notionClient.FindPageByID(ctx, clientID) if err != nil { return nt.Page{}, err } return res, nil } func (n *notionService) GetDatabase(databaseID string, filter *nt.DatabaseQueryFilter, sorts []nt.DatabaseQuerySort, pageSize int) (*nt.DatabaseQueryResponse, error) { ctx := context.Background() q := &nt.DatabaseQuery{ Filter: filter, Sorts: sorts, } if pageSize > 0 { q.PageSize = pageSize } res, err := n.notionClient.QueryDatabase(ctx, databaseID, q) if err != nil { return nil, err } return &res, nil } func (n *notionService) GetDatabaseWithStartCursor(databaseID string, startCursor string) (*nt.DatabaseQueryResponse, error) { ctx := context.Background() res, err := n.notionClient.QueryDatabase(ctx, databaseID, &nt.DatabaseQuery{ StartCursor: startCursor, }) if err != nil { return nil, err } return &res, nil } func (n *notionService) GetBlockChildren(pageID string) (*nt.BlockChildrenResponse, error) { ctx := context.Background() res, err := n.notionClient.FindBlockChildrenByID(ctx, pageID, &nt.PaginationQuery{}) if err != nil { return nil, err } return &res, nil } func (n *notionService) GetPagePropByID(pageID, propID string, query *nt.PaginationQuery) (*nt.PagePropResponse, error) { ctx := context.Background() res, err := n.notionClient.FindPagePropertyByID(ctx, pageID, propID, query) if err != nil { return nil, err } return &res, nil } func (n *notionService) GetProjectInDB(pageID string) (*nt.DatabasePageProperties, error) { ctx := context.Background() // 1. get all project records in project page res, err := n.notionClient.QueryDatabase(ctx, n.projectsDBID, &nt.DatabaseQuery{}) if err != nil { return nil, err } // 2. loop through all projects to find the project by page id for _, r := range res.Results { if strings.ReplaceAll(r.ID, "-", "") == strings.ReplaceAll(pageID, "-", "") { p := r.Properties.(nt.DatabasePageProperties) if len(p["Project"].Title) != 0 && p["Changelog"].URL != nil { if *p["Changelog"].URL == "" { continue } clID := strings.Split(strings.Split(*p["Changelog"].URL, "/")[len(strings.Split(*p["Changelog"].URL, "/"))-1], "?")[0] cls, err := n.notionClient.QueryDatabase(ctx, clID, &nt.DatabaseQuery{ Sorts: []nt.DatabaseQuerySort{ { Property: "Created", Direction: nt.SortDirDesc, }, }, }) if err != nil { n.l.Errorf(err, "query project change log err", clID, p["Project"].Title[0].Text.Content) continue } if len(cls.Results) != 0 && len(cls.Results[0].Properties.(nt.DatabasePageProperties)["Title"].Title) != 0 { p["EmailSubject"] = nt.DatabasePageProperty{ Title: []nt.RichText{ { Type: nt.RichTextTypeText, Text: &nt.Text{Content: cls.Results[0].Properties.(nt.DatabasePageProperties)["Title"].Title[0].Text.Content}, PlainText: cls.Results[0].Properties.(nt.DatabasePageProperties)["Title"].Title[0].Text.Content, }, }, } } } return &p, nil } } return nil, errors.New("page not found") } func (n *notionService) GetProjectsInDB(pageIDs []string, projectPageID string) (map[string]nt.DatabasePageProperties, error) { ctx := context.Background() // 1. get all project records in project page res, err := n.notionClient.QueryDatabase(ctx, projectPageID, &nt.DatabaseQuery{}) if err != nil { return nil, err } // 2. loop through all projects to find the projects by page ids pages := map[string]nt.DatabasePageProperties{} for _, id := range pageIDs { pages[strings.ReplaceAll(id, "-", "")] = nt.DatabasePageProperties{} } for _, r := range res.Results { if _, ok := pages[strings.ReplaceAll(r.ID, "-", "")]; ok { pages[strings.ReplaceAll(r.ID, "-", "")] = r.Properties.(nt.DatabasePageProperties) } } return pages, nil } func (n *notionService) GetPage(pageID string) (nt.Page, error) { ctx := context.Background() res, err := n.notionClient.FindPageByID(ctx, pageID) if err != nil { return nt.Page{}, err } return res, nil } func (n *notionService) CreatePage() error { return nil } // create a record in notion database func (n *notionService) CreateDatabaseRecord(databaseID string, properties map[string]interface{}) (string, error) { ctx := context.Background() props, err := convertMapToProperties(properties) if err != nil { return "", err } p, err := n.notionClient.CreatePage(ctx, nt.CreatePageParams{ ParentType: nt.ParentTypeDatabase, ParentID: databaseID, DatabasePageProperties: &props, }) if err != nil { return "", err } return p.ID, nil } func convertMapToProperties(properties map[string]interface{}) (nt.DatabasePageProperties, error) { props := nt.DatabasePageProperties{} for key, value := range properties { switch key { case "Name": props["Name"] = nt.DatabasePageProperty{ Type: nt.DBPropTypeTitle, Title: []nt.RichText{{Text: &nt.Text{Content: value.(string)}}}, } case "Status": props["Status"] = nt.DatabasePageProperty{ Type: nt.DBPropTypeSelect, Select: &nt.SelectOptions{ Name: value.(string), }, } // case "Assign": // props["Assign"] = nt.DatabasePageProperty{ // Type: nt.DatabasePropertyType(nt.DBPropTypePeople), // People: []nt.User{ // { // BaseUser: nt.BaseUser{ // ID: value.(string), // }, // }, // }, // } default: return nil, fmt.Errorf("unsupported property: %s", key) } } return props, nil } func (n *notionService) ListProject() ([]model.ProjectChangelogPage, error) { ctx := context.Background() prjs, err := n.notionClient.QueryDatabase(ctx, n.projectsDBID, &nt.DatabaseQuery{ Filter: &nt.DatabaseQueryFilter{ Property: "Status", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{ Select: &nt.SelectDatabaseQueryFilter{ Equals: "Active", }, }, }, }) if err != nil { return nil, err } res := []model.ProjectChangelogPage{} for _, r := range prjs.Results { p := r.Properties.(nt.DatabasePageProperties) if len(p["Project"].Title) != 0 && p["Changelog"].URL != nil { if *p["Changelog"].URL == "" { continue } clID := strings.Split(strings.Split(*p["Changelog"].URL, "/")[len(strings.Split(*p["Changelog"].URL, "/"))-1], "?")[0] cls, err := n.notionClient.QueryDatabase(ctx, clID, &nt.DatabaseQuery{ Sorts: []nt.DatabaseQuerySort{ { Property: "Created", Direction: nt.SortDirDesc, }, }, }) if err != nil { n.l.Errorf(err, "query project change log err", clID, p["Project"].Title[0].Text.Content) continue } if len(cls.Results) != 0 && len(cls.Results[0].Properties.(nt.DatabasePageProperties)["Title"].Title) != 0 { res = append(res, model.ProjectChangelogPage{ RowID: r.ID, Name: p["Project"].Title[0].Text.Content, Title: cls.Results[0].Properties.(nt.DatabasePageProperties)["Title"].Title[0].Text.Content, ChangelogURL: cls.Results[0].URL, }) } } } return res, nil } func (n *notionService) QueryAudienceDatabase(audienceDBId, audience string) (records []nt.Page, err error) { ctx := context.Background() var t bool = true var cursor string = "" var filter *nt.DatabaseQueryFilter switch audience { case "Developers Only": filter = &nt.DatabaseQueryFilter{ And: []nt.DatabaseQueryFilter{ { Or: []nt.DatabaseQueryFilter{ {Property: "Personas", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{Contains: "Developer"}}}, {Property: "Personas", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{Contains: "Engineer"}}}, {Property: "Personas", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{Contains: "Tester"}}}, {Property: "Personas", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{Contains: "Product Manager"}}}, }, }, { And: []nt.DatabaseQueryFilter{ {Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Community"}}}, {Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Employee"}}}, {Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "CLient"}}}, {Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Past Client"}}}, {Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Fellowship"}}}, {Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Prospect"}}}, {Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Failed CV"}}}, {Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Failed Test"}}}, {Property: "Tags", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{MultiSelect: &nt.MultiSelectDatabaseQueryFilter{DoesNotContain: "Failed Interview"}}}, }, }, }, } case "Partner Updates", "Dwarves Updates": filter = &nt.DatabaseQueryFilter{ And: []nt.DatabaseQueryFilter{ { Property: audience, DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{ Checkbox: &nt.CheckboxDatabaseQueryFilter{ Equals: &t, }, }, }, }, } default: return nil, errors.New("audience not found") } // filter out unsubscribed var unsubscribed bool = false filter.And = append(filter.And, nt.DatabaseQueryFilter{ Property: "Unsubscribed", DatabaseQueryPropertyFilter: nt.DatabaseQueryPropertyFilter{ Checkbox: &nt.CheckboxDatabaseQueryFilter{ Equals: &unsubscribed, }, }, }) n.l.Info("start querying audience database") for { res, err := n.notionClient.QueryDatabase(ctx, audienceDBId, &nt.DatabaseQuery{ Filter: filter, Sorts: []nt.DatabaseQuerySort{ { Property: "Created Time", Direction: nt.SortDirAsc, }, }, StartCursor: cursor, PageSize: 100, }) if err != nil { return nil, err } records = append(records, res.Results...) if !res.HasMore { break } cursor = *res.NextCursor } n.l.Info("finish querying audience database") return records, nil }
```

# pkg/service/notion/template.go

```go
package notion // MJMLChangelogTemplate is the template for the MJML email const MJMLChangelogTemplate = ` <mjml> <mj-head> <mj-title>Changelog Email</mj-title> <mj-attributes> <mj-all font-family="Helvetica, sans-serif"></mj-all> <mj-section padding="0px"></mj-section> <mj-text font-weight="400" font-size="12px" line-height="16px" font-family="helvetica"></mj-text> </mj-attributes> </mj-head> <mj-body> <mj-section padding="20px 0"> <mj-column> %s </mj-column> </mj-section> <mj-section> <mj-column> <mj-table> <tr> <td style="font-family: arial, helvetica, sans-serif; font-size: 12px; font-style: normal; font-weight: 400; line-height: 16px; color: #222222; max-width: 640px;"> <p style="font-family: arial, helvetica, sans-serif; font-style: normal; font-weight: 400; font-size: 11px; line-height: 14px; margin-top: 10px; margin-bottom: 10px; color: #222222;">View full archive at <a href="%s">%s</a>.</p> <p style="font-family: arial, helvetica, sans-serif; font-style: italic; font-weight: 400; font-size: 11px; line-height: 14px; color: #222222; margin-top: 10px; margin-bottom: 10px;">Copyright Â© 2023 Dwarves, LLC, All rights reserved.</p> <p style="font-family: arial, helvetica, sans-serif; font-style: normal; font-weight: 400; font-size: 11px; line-height: 14px; margin-top: 10px; margin-bottom: 10px; color: #222222;">You're receiving this because we would love to have you as a part of the journey. If you don't want to be on the list, you can unsubscribe.</p> <p style="font-family: Helvetica; font-style: normal; font-weight: 700; font-size: 11px; line-height: 14px; color: #222222;">My mailing address is:</p> <p style="font-family: Helvetica; font-style: normal; font-weight: 400; font-size: 11px; line-height: 14px; color: #222222;">Hado Centrosa Garden</p> <p style="font-family: Helvetica; font-style: normal; font-weight: 400; font-size: 11px; line-height: 14px; color: #222222;">200 3/2 street</p> <p style="font-family: Helvetica; font-style: normal; font-weight: 400; font-size: 11px; line-height: 14px; color: #222222;">District 10</p> <p style="font-family: Helvetica; font-style: normal; font-weight: 400; font-size: 11px; line-height: 14px; color: #222222;">Ho Chi Minh City</p> <p style="font-family: Helvetica; font-style: normal; font-weight: 400; font-size: 11px; line-height: 14px; color: #222222;">Vietnam</p> </td> </tr> </mj-table> </mj-column> </mj-section> </mj-body> </mjml> ` // MJMLDFUpdateTemplate is the template for the Dwarves Updates email const MJMLDFUpdateTemplate = ` <mjml> <mj-head> <mj-title>Changelog Email</mj-title> <mj-attributes> <mj-all font-family="Helvetica, sans-serif"></mj-all> <mj-section padding="0px"></mj-section> <mj-text font-weight="400" font-size="14px" line-height="18px" font-family="helvetica"></mj-text> </mj-attributes> </mj-head> <mj-body> <mj-section padding="20px 0"> <mj-column> %s </mj-column> </mj-section> <mj-section> <mj-column> <mj-table> <tr> <td style="font-family: arial, helvetica, sans-serif; font-size: 12px; font-style: normal; font-weight: 400; line-height: 16px; color: #222222; max-width: 640px;"> <p style="font-family: arial, helvetica, sans-serif; font-style: italic; font-weight: 400; font-size: 11px; line-height: 14px; color: #222222; margin-top: 10px; margin-bottom: 10px;">Copyright Â© 2023 Dwarves, LLC, All rights reserved.</p> <p style="font-family: arial, helvetica, sans-serif; font-style: normal; font-weight: 400; font-size: 11px; line-height: 14px; margin-top: 10px; margin-bottom: 10px; color: #222222;">You're receiving this because we would love to have you as a part of the journey. If you don't want to be on the list, reply this email with "Unsubscribe".</p> </td> </tr> </mj-table> </mj-column> </mj-section> </mj-body> </mjml> `
```

# pkg/service/ogifmemosummarizer/dify.go

```go
package ogifmemosummarizer import ( "bufio" "bytes" "encoding/json" "fmt" "io" "net/http" "time" "github.com/dwarvesf/fortress-api/pkg/config" ) type difyService struct { appConfig *config.Config } // New function return dify service func New(appConfig *config.Config) IService { return &difyService{ appConfig: appConfig, } } // BaseEvent represents the common fields in the event type BaseEvent struct { Event string `json:"event,omitempty"` ConversationID string `json:"conversation_id,omitempty"` MessageID string `json:"message_id,omitempty"` CreatedAt int64 `json:"created_at,omitempty"` TaskID string `json:"task_id,omitempty"` ID string `json:"id,omitempty"` Position int `json:"position,omitempty"` } // AgentThought represents the specific fields for agent_thought events type AgentThought struct { BaseEvent Thought string `json:"thought,omitempty"` Observation string `json:"observation,omitempty"` Tool string `json:"tool,omitempty"` ToolLabels interface{} `json:"tool_labels,omitempty"` ToolInput string `json:"tool_input,omitempty"` MessageFiles interface{} `json:"message_files,omitempty"` } // AgentMessage represents the specific fields for agent_message events type AgentMessage struct { BaseEvent Answer string `json:"answer,omitempty"` } func (d *difyService) SummarizeOGIFMemo(youtubeURL string) (content string, err error) { // Define the URL and request body requestBody, err := json.Marshal(map[string]interface{}{ "inputs": map[string]interface{}{}, "query": youtubeURL, "response_mode": "streaming", "conversation_id": "", "user": "abc-123", }) if err != nil { return "", err } // Create the HTTP request req, err := http.NewRequest("POST", d.appConfig.Dify.URL, bytes.NewBuffer(requestBody)) if err != nil { return "", nil } // Set the required headers req.Header.Set("Authorization", "Bearer "+d.appConfig.Dify.Token) req.Header.Set("Content-Type", "application/json") // Send the request using http.Client client := &http.Client{Timeout: 5 * time.Minute} resp, err := client.Do(req) if err != nil { return "", err } defer resp.Body.Close() // Check the response status if resp.StatusCode != http.StatusOK { return "", fmt.Errorf("unexpected status code: %d", resp.StatusCode) } // Handle streaming response fmt.Println("Streaming response...") thoughts := []AgentThought{} reader := bufio.NewReader(resp.Body) for { line, err := reader.ReadBytes('\n') if err != nil { if err == io.EOF { break } return "", err } // Remove the "data: " prefix line = bytes.TrimPrefix(line, []byte("data: ")) line = bytes.TrimSpace(line) if len(line) == 0 { continue } // Parse the JSON event to a map to determine the event type var rawEvent map[string]interface{} err = json.Unmarshal(line, &rawEvent) if err != nil { fmt.Printf("Error unmarshal: %v\n", string(line)) continue } eventType, ok := rawEvent["event"].(string) if !ok { fmt.Println("Error: event type is missing or not a string") continue } // Process specific event types switch eventType { case "agent_thought": var event AgentThought err = json.Unmarshal(line, &event) if err != nil { fmt.Printf("Error parsing agent_thought JSON: %v\n", err) continue } thoughts = append(thoughts, event) case "agent_message": // just ignore agent_message event // var event AgentMessage // err = json.Unmarshal(line, &event) // if err != nil { // fmt.Printf("Error parsing agent_message JSON: %v\n", err) // continue // } // fmt.Printf("Agent Message: %s\n", event.Answer) default: // fmt.Printf("Unknown event type: %s\n", eventType) } } // get the last event if len(thoughts) == 0 { return "", fmt.Errorf("no thought found") } fmt.Println("Processing thoughts...") for i := len(thoughts) - 1; i >= 0; i-- { if thoughts[i].Thought != "" { content = thoughts[i].Thought break } } fmt.Println("Completed processing thoughts") return content, nil }
```

# pkg/service/ogifmemosummarizer/interface.go

```go
package ogifmemosummarizer type IService interface { SummarizeOGIFMemo(youtubeURL string) (content string, err error) }
```

# pkg/service/reddit/fetch_go_news.go

```go
package reddit import ( "context" "github.com/vartanbeno/go-reddit/v2/reddit" ) const ( redditGolangChannel = "golang" ) // FetchGolangNews fetches the latest Golang news posts from the rising posts. func (s *service) FetchGolangNews(ctx context.Context) ([]*reddit.Post, error) { risingPosts, _, err := s.client.Subreddit.RisingPosts(ctx, redditGolangChannel, &reddit.ListOptions{ Limit: 50, }) if err != nil { return nil, err } return risingPosts, nil }
```

# pkg/service/reddit/interface.go

```go
package reddit import ( "context" "github.com/vartanbeno/go-reddit/v2/reddit" ) type IService interface { // FetchGolangNews fetches the latest Golang news posts and filters the rising posts from the new posts. FetchGolangNews(ctx context.Context) ([]*reddit.Post, error) }
```

# pkg/service/reddit/new.go

```go
package reddit import ( "fmt" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/vartanbeno/go-reddit/v2/reddit" ) type service struct { client *reddit.Client } func New(cfg *config.Config, l logger.Logger) (IService, error) { clientID := cfg.Reddit.ClientID if clientID == "" { l.Warn("reddit client id is empty") } clientSecret := cfg.Reddit.ClientSecret if clientSecret == "" { l.Warn("reddit client secret is empty") } username := cfg.Reddit.Username if username == "" { l.Warn("reddit username is empty") } password := cfg.Reddit.Password if password == "" { l.Warn("reddit password is empty") } auth := reddit.Credentials{ ID: clientID, Secret: clientSecret, Username: username, Password: password, } client, err := reddit.NewClient(auth, reddit.WithUserAgent("fortress-bot")) if err != nil { return nil, fmt.Errorf("create reddit client failed: %w", err) } return &service{ client: client, }, nil }
```

# pkg/service/sendgrid/sendgrid.go

```go
package sendgrid import ( "net/http" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/sendgrid/sendgrid-go" "github.com/sendgrid/sendgrid-go/helpers/mail" ) type IService interface { SendEmail(*model.Email) error } type sendgridClient struct { client *sendgrid.Client cfg *config.Config l logger.Logger } func New(key string, cfg *config.Config, l logger.Logger) IService { client := sendgrid.NewSendClient(key) return &sendgridClient{ client: client, cfg: cfg, l: l, } } func (s *sendgridClient) SendEmail(email *model.Email) error { // boundary check to make sure we don't mess up if s.cfg.Env != "prod" { email.To = []*mail.Email{ mail.NewEmail("Minh Luu", "leo@d.foundation"), // mail.NewEmail("Nikki", "nikki@d.foundation"), } email.Bcc = []*mail.Email{} } m := mail.NewV3Mail() m.SetFrom(email.From) m.AddContent(mail.NewContent("text/html", email.HTMLContent)) m.AddCategories(email.Categories...) personalization := mail.NewPersonalization() personalization.Subject = email.Subject personalization.AddTos(email.To...) personalization.AddBCCs(email.Bcc...) m.AddPersonalizations(personalization) s.l.Infof("Sending email", m.Personalizations) response, err := s.client.Send(m) if err != nil { s.l.Error(err, "SendEmail() failed with ") return err } if response.StatusCode != http.StatusOK && response.StatusCode != http.StatusAccepted { s.l.Error(err, "Email not sent") return err } return nil }
```

# pkg/service/service.go

```go
package service import ( "time" "github.com/patrickmn/go-cache" "golang.org/x/oauth2" "golang.org/x/oauth2/google" admin "google.golang.org/api/admin/directory/v1" "google.golang.org/api/gmail/v1" "google.golang.org/api/sheets/v4" "google.golang.org/api/youtube/v3" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/service/basecamp" "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" "github.com/dwarvesf/fortress-api/pkg/service/communitynft" "github.com/dwarvesf/fortress-api/pkg/service/currency" "github.com/dwarvesf/fortress-api/pkg/service/discord" "github.com/dwarvesf/fortress-api/pkg/service/evm" "github.com/dwarvesf/fortress-api/pkg/service/github" googleauth "github.com/dwarvesf/fortress-api/pkg/service/google" "github.com/dwarvesf/fortress-api/pkg/service/googleadmin" "github.com/dwarvesf/fortress-api/pkg/service/googledrive" "github.com/dwarvesf/fortress-api/pkg/service/googlemail" "github.com/dwarvesf/fortress-api/pkg/service/googlesheet" "github.com/dwarvesf/fortress-api/pkg/service/googlestorage" "github.com/dwarvesf/fortress-api/pkg/service/icyswap" "github.com/dwarvesf/fortress-api/pkg/service/improvmx" "github.com/dwarvesf/fortress-api/pkg/service/lobsters" "github.com/dwarvesf/fortress-api/pkg/service/mochi" "github.com/dwarvesf/fortress-api/pkg/service/mochipay" "github.com/dwarvesf/fortress-api/pkg/service/mochiprofile" "github.com/dwarvesf/fortress-api/pkg/service/notion" "github.com/dwarvesf/fortress-api/pkg/service/ogifmemosummarizer" "github.com/dwarvesf/fortress-api/pkg/service/reddit" "github.com/dwarvesf/fortress-api/pkg/service/sendgrid" "github.com/dwarvesf/fortress-api/pkg/service/tono" "github.com/dwarvesf/fortress-api/pkg/service/wise" yt "github.com/dwarvesf/fortress-api/pkg/service/youtube" "github.com/dwarvesf/fortress-api/pkg/store" ) type Service struct { Basecamp *basecamp.Service Cache *cache.Cache Currency currency.IService Discord discord.IService Github github.IService Google googleauth.IService GoogleStorage googlestorage.IService GoogleAdmin googleadmin.IService GoogleDrive googledrive.IService GoogleMail googlemail.IService GoogleSheet googlesheet.IService ImprovMX improvmx.IService Mochi mochi.IService MochiPay mochipay.IService MochiProfile mochiprofile.IService Notion notion.IService Sendgrid sendgrid.IService Wise wise.IService BaseClient evm.IService IcySwap icyswap.IService CommunityNft communitynft.IService Tono tono.IService Reddit reddit.IService Lobsters lobsters.IService Youtube yt.IService Dify ogifmemosummarizer.IService } func New(cfg *config.Config, store *store.Store, repo store.DBRepo) *Service { cch := cache.New(5*time.Minute, 10*time.Minute) googleAuthSvc, err := googleauth.New( &oauth2.Config{ ClientID: cfg.Google.ClientID, ClientSecret: cfg.Google.ClientSecret, Endpoint: google.Endpoint, Scopes: []string{"email", "profile"}, }, ) if err != nil { logger.L.Error(err, "failed to init google auth") } gcsSvc, err := googlestorage.New( cfg.Google.GCSBucketName, cfg.Google.GCSProjectID, cfg.Google.GCSCredentials, ) if err != nil { logger.L.Error(err, "failed to init gcs") } driveConfig := &oauth2.Config{ ClientID: cfg.Google.ClientID, ClientSecret: cfg.Google.ClientSecret, Endpoint: google.Endpoint, Scopes: []string{googledrive.FullDriveAccessScope}, } googleDriveSvc := googledrive.New(driveConfig, cfg) googleAdminConfig := &oauth2.Config{ ClientID: cfg.Google.ClientID, ClientSecret: cfg.Google.ClientSecret, Endpoint: google.Endpoint, Scopes: []string{admin.AdminDirectoryUserScope, admin.AdminDirectoryGroupScope, }, } googleAdminSvc := googleadmin.New(googleAdminConfig, cfg) mailConfig := &oauth2.Config{ ClientID: cfg.Google.ClientID, ClientSecret: cfg.Google.ClientSecret, Endpoint: google.Endpoint, Scopes: []string{gmail.MailGoogleComScope}, } googleMailSvc := googlemail.New( mailConfig, cfg, ) youtubeSvc := yt.New(&oauth2.Config{ ClientID: cfg.Youtube.ClientID, ClientSecret: cfg.Youtube.ClientSecret, Endpoint: google.Endpoint, Scopes: []string{youtube.YoutubeForceSslScope}, }, cfg) gSheetConfig := &oauth2.Config{ ClientID: cfg.Google.ClientID, ClientSecret: cfg.Google.ClientSecret, Endpoint: google.Endpoint, Scopes: []string{ sheets.DriveScope, sheets.DriveFileScope, sheets.DriveReadonlyScope, sheets.SpreadsheetsScope, sheets.SpreadsheetsReadonlyScope, }, } gSheetSvc := googlesheet.New( gSheetConfig, cfg, ) bc := model.Basecamp{ ClientID: cfg.Basecamp.ClientID, ClientSecret: cfg.Basecamp.ClientSecret, } Currency := currency.New(cfg) baseClient, err := evm.New(evm.DefaultBASEClient, cfg, logger.L) if err != nil { logger.L.Error(err, "failed to init base client service") } icySwap, err := icyswap.New(baseClient, cfg, logger.L) if err != nil { logger.L.Error(err, "failed to init icyswap service") } communityNft, err := communitynft.New(baseClient, cfg, logger.L) if err != nil { logger.L.Error(err, "failed to init community nft service") } reddit, err := reddit.New(cfg, logger.L) if err != nil { logger.L.Error(err, "failed to init reddit service") } difySvc := ogifmemosummarizer.New(cfg) return &Service{ Basecamp: basecamp.New(store, repo, cfg, &bc, logger.L), Cache: cch, Currency: Currency, Discord: discord.New(cfg), Github: github.New(cfg, logger.L), Google: googleAuthSvc, GoogleStorage: gcsSvc, GoogleAdmin: googleAdminSvc, GoogleDrive: googleDriveSvc, GoogleMail: googleMailSvc, GoogleSheet: gSheetSvc, ImprovMX: improvmx.New(cfg.ImprovMX.Token), Mochi: mochi.New(cfg, logger.L), MochiPay: mochipay.New(cfg, logger.L), MochiProfile: mochiprofile.New(cfg, logger.L), Notion: notion.New(cfg.Notion.Secret, cfg.Notion.Databases.Project, logger.L), Sendgrid: sendgrid.New(cfg.Sendgrid.APIKey, cfg, logger.L), Wise: wise.New(cfg, logger.L), BaseClient: baseClient, IcySwap: icySwap, CommunityNft: communityNft, Tono: tono.New(cfg, logger.L), Reddit: reddit, Lobsters: lobsters.New(), Youtube: youtubeSvc, Dify: difySvc, } }
```

# pkg/service/tono/request.go

```go
package tono type GetGuildProfileResponse struct { Data GuildProfile `json:"data"` } type GuildProfile struct { ID string `json:"id"` CurrentLevel *ConfigXpLevel `json:"current_level"` NextLevel *ConfigXpLevel `json:"next_level"` GuildXP int `json:"guild_xp"` NrOfActions int `json:"nr_of_actions"` Progress float64 `json:"progress"` GuildRank int `json:"guild_rank"` } type ConfigXpLevel struct { Level int `json:"level" gorm:"primaryKey"` MinXP int `json:"min_xp"` }
```

# pkg/service/tono/tono.go

```go
package tono import ( "encoding/json" "fmt" "net/http" "time" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" ) type IService interface { GetGuildUserProfile(profileId, guildId string) (*GuildProfile, error) } type client struct { cfg *config.Config l logger.Logger } func New(cfg *config.Config, l logger.Logger) IService { return &client{ cfg: cfg, l: l, } } func (m *client) GetGuildUserProfile(profileId, guildId string) (*GuildProfile, error) { var client = &http.Client{ Timeout: 10 * time.Second, } url := fmt.Sprintf("%s/api/v1/users/profiles?profile_id=%s&guild_id=%s", m.cfg.Tono.BaseURL, profileId, guildId) r, err := client.Get(url) if err != nil { m.l.Errorf(err, "[tono.GetGuildUserProfile] client.Get failed") return nil, err } defer r.Body.Close() res := &GetGuildProfileResponse{} if err := json.NewDecoder(r.Body).Decode(&res); err != nil { m.l.Errorf(err, "[tono.GetGuildUserProfile] decoder.Decode failed") return nil, err } return &res.Data, handleErrorStatusCode("Get Guild User Profile", r.StatusCode) } func handleErrorStatusCode(method string, statusCode int) error { if statusCode >= 200 && statusCode < 300 { return nil } return fmt.Errorf("%s status code: %d", method, statusCode) }
```

# pkg/service/vault/interface.go

```go
package vault type IService interface { GetString(key string) string GetBool(key string) bool }
```

# pkg/service/vault/vault.go

```go
package vault import ( "fmt" "strconv" "github.com/dwarvesf/fortress-api/pkg/config" vault "github.com/hashicorp/vault/api" ) type Vault struct { data map[string]interface{} } func New(cfg *config.Config) (IService, error) { defaultConfig := vault.DefaultConfig() defaultConfig.Address = cfg.Vault.Address client, err := vault.NewClient(defaultConfig) if err != nil { return nil, fmt.Errorf("unable to initialize Vault client: %v", err) } client.SetToken(cfg.Vault.Token) secret, err := client.Logical().Read(cfg.Vault.Path) if err != nil { return nil, fmt.Errorf("unable to read secret: %v", err) } data, ok := secret.Data["data"].(map[string]interface{}) if !ok { return nil, fmt.Errorf("unable to read secret data") } return &Vault{ data: data, }, nil } func (v *Vault) GetString(key string) string { value, _ := v.data[key].(string) return value } func (v *Vault) GetBool(key string) bool { data, _ := v.data[key].(string) value, _ := strconv.ParseBool(data) return value }
```

# pkg/service/wise/interface.go

```go
package wise import "github.com/dwarvesf/fortress-api/pkg/model" type IService interface { Convert(amount float64, source, target string) (convertedAmount float64, rate float64, error error) GetPayrollQuotes(sourceCurrency, targetCurrency string, targetAmount float64) (*model.TWQuote, error) GetRate(source, target string) (rate float64, err error) }
```

# pkg/service/wise/wise.go

```go
package wise import ( "encoding/json" "errors" "fmt" "io" "net/http" "strings" "sync" "time" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" ) var ( // default for now client = http.Client{ Timeout: 5 * time.Second, } ) const ( // api version apiV1 = "v1/" // get quote url quotes = "quotes" // get transfer rates rates = "rates" ) type wiseService struct { sync.Mutex cacheMap map[string]float64 profile string cfg *config.Config l logger.Logger } func New(cfg *config.Config, l logger.Logger) IService { client := &wiseService{ cfg: cfg, l: l, profile: cfg.Wise.Profile, cacheMap: make(map[string]float64), } go client.janitor() return client } func (w *wiseService) janitor() { t := time.NewTicker(5 * time.Minute) for { <-t.C w.Lock() w.cacheMap = map[string]float64{} w.Unlock() } } func (w *wiseService) Convert(amount float64, sourceCurrency, targetCurrency string) (float64, float64, error) { rate, err := w.GetRate(sourceCurrency, targetCurrency) if err != nil { return 0, 0, err } return amount * rate, rate, nil } func (w *wiseService) GetRate(sourceCurrency, targetCurrency string) (float64, error) { if sourceCurrency == targetCurrency { return 1, nil } return w.getTWRate(sourceCurrency, targetCurrency) } func (w *wiseService) getTWRate(sourceCurrency, targetCurrency string) (float64, error) { // if run_mode is non-prod, we use mock data if w.cfg.Env != "prod" { sourceRate, err := getLocalRate(sourceCurrency) if err != nil { return 0, err } targetRate, err := getLocalRate(targetCurrency) if err != nil { return 0, err } return targetRate / sourceRate, nil } var conversionRate []model.WiseConversionRate l := w.l.Fields(logger.Fields{ "handler": "wise", "method": "getTWRate", }) // try to get from cache to reduce api call rate := w.getCache(sourceCurrency + targetCurrency) if rate != 0 { return rate, nil } // build up request url := fmt.Sprintf("%v?source=%v&target=%v", w.getUrl(rates), sourceCurrency, targetCurrency) req, err := w.newRequest("GET", url, nil) if err != nil { l.Error(err, "can't build request") return 0, err } client := http.Client{ Timeout: 5 * time.Second, } // read response resp, err := client.Do(req) if err != nil { l.Error(err, "can't get response") return 0, err } defer resp.Body.Close() body := resp.Body res, err := io.ReadAll(body) if err != nil { l.Error(err, "can't read response") return 0, err } err = json.Unmarshal(res, &conversionRate) if len(conversionRate) == 0 { l.Fields(logger.Fields{"msg": string(res)}).Error(err, "can't unmarshal response") return 0, errors.New("cannot get exchange rates") } // save to cache for further request within 5 minutes w.setCache(sourceCurrency+targetCurrency, conversionRate[0].Rate) return conversionRate[0].Rate, nil } // /////////////////// // INTERNAL FUNCTIONS // /////////////////// func (w *wiseService) getCache(key string) float64 { if rate, ok := w.cacheMap[key]; ok { return rate } return 0 } func (w *wiseService) setCache(key string, val float64) { w.Lock() defer w.Unlock() w.cacheMap[key] = val } // getLocalRate get conversion rate without making api call, for non-prod env func getLocalRate(target string) (float64, error) { switch target { case "USD": return 1, nil case "CAD": return 1.34275, nil case "GBP": return 0.79185, nil case "EUR": return 0.89795, nil case "VND": return 23416, nil case "SGD": return 1.3845, nil } return 1, nil } func (w *wiseService) getUrl(api string) string { return w.cfg.Wise.Url + apiV1 + api } func (w *wiseService) getAuthHeader() string { return "Bearer " + w.cfg.Wise.APIKey } func (w *wiseService) newRequest(method, url string, body io.Reader) (*http.Request, error) { req, err := http.NewRequest(method, url, body) req.Header.Set("Authorization", w.getAuthHeader()) req.Header.Set("Content-Type", "application/json") return req, err } func (w *wiseService) GetPayrollQuotes(sourceCurrency, targetCurrency string, targetAmount float64) (*model.TWQuote, error) { var q *model.TWQuote if w.cfg.Env != "prod" { return &model.TWQuote{ SourceAmount: 0, Fee: 0, Rate: 0, }, nil } // Todo: (hnh) payload := strings.NewReader(fmt.Sprintf("{\n\t\"profile\": %v,\n\t\"source\": \"%s\",\n\t\"target\": \"%s\",\n\t\"rateType\": \"FIXED\",\n\t\"targetAmount\": %v,\n\t\"type\": \"BALANCE_PAYOUT\"\n}", w.profile, sourceCurrency, targetCurrency, targetAmount)) req, _ := w.newRequest("POST", w.getUrl(quotes), payload) resp, err := client.Do(req) if err != nil { return nil, err } defer resp.Body.Close() body := resp.Body res, _ := io.ReadAll(body) return q, json.Unmarshal(res, &q) }
```

# pkg/service/youtube/interface.go

```go
package youtube import ( "github.com/dwarvesf/fortress-api/pkg/model" "google.golang.org/api/youtube/v3" ) // IService interface contain related google calendar method type IService interface { GetLatestBroadcast() (*youtube.LiveBroadcast, error) CreateBroadcast(*model.Event) (err error) }
```

# pkg/service/youtube/youtube.go

```go
package youtube import ( "context" "errors" "fmt" "io" "net/http" "os" "time" "golang.org/x/oauth2" "google.golang.org/api/option" "google.golang.org/api/youtube/v3" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/model" ) type youtubeService struct { config *oauth2.Config token *oauth2.Token service *youtube.Service appConfig *config.Config } // New function return Google service func New(config *oauth2.Config, appConfig *config.Config) IService { return &youtubeService{ config: config, appConfig: appConfig, } } func (yt *youtubeService) prepareService() error { client := yt.config.Client(context.Background(), yt.token) service, err := youtube.NewService(context.Background(), option.WithHTTPClient(client)) if err != nil { return errors.New("Get Youtube Service Failed " + err.Error()) } yt.service = service return nil } func (yt *youtubeService) ensureToken(refreshToken string) error { token := &oauth2.Token{ RefreshToken: refreshToken, } if !yt.token.Valid() { tks := yt.config.TokenSource(context.Background(), token) tok, err := tks.Token() if err != nil { return err } yt.token = tok } return nil } // CreateBroadcast function create broadcast on youtube func (yt *youtubeService) CreateBroadcast(e *model.Event) (err error) { // Load the Vietnam timezone location location, err := time.LoadLocation("Asia/Ho_Chi_Minh") if err != nil { return err } // Get the current time in the Vietnam timezone t := time.Now().In(location) // check if the event is before 17h, then set the broadcast to 17h in Vietnam if t.Hour() < 17 { // set the broadcast to 17h in timezone vietnam t = time.Date(t.Year(), t.Month(), t.Day(), 17, 0, 0, 0, location) } // Insert broadcast return yt.insertBroadcast(e, t) } func (yt *youtubeService) insertBroadcast(e *model.Event, startTime time.Time) error { if err := yt.ensureToken(yt.appConfig.Youtube.RefreshToken); err != nil { return err } if err := yt.prepareService(); err != nil { return err } liveBroadcast := &youtube.LiveBroadcast{ Snippet: &youtube.LiveBroadcastSnippet{ Title: e.Name, Description: e.Description, ScheduledStartTime: startTime.Format(time.RFC3339), }, Status: &youtube.LiveBroadcastStatus{ PrivacyStatus: "unlisted", }, } lbc, err := yt.service.LiveBroadcasts.Insert([]string{"snippet", "status"}, liveBroadcast).Do() if err != nil { return err } if e.Image == "" { return nil } // download by url and open the image file imgPath := fmt.Sprintf("/tmp/%v.png", e.Image) err = yt.downloadImage(fmt.Sprintf("https://cdn.discordapp.com/guild-events/%v/%v.png?size=4096", e.DiscordEventID, e.Image), imgPath) if err != nil { return err } // Upload a thumbnail file, err := os.Open(imgPath) if err != nil { return err } defer file.Close() thumbnailCall := yt.service.Thumbnails.Set(lbc.Id) _, err = thumbnailCall.Media(file).Do() if err != nil { return err } return nil } func (yt *youtubeService) downloadImage(url, filepath string) error { // Get the data resp, err := http.Get(url) if err != nil { return fmt.Errorf("error downloading image: %w", err) } defer resp.Body.Close() // Create the file out, err := os.Create(filepath) if err != nil { return fmt.Errorf("error creating file: %w", err) } defer out.Close() // Write the body to file _, err = io.Copy(out, resp.Body) if err != nil { return fmt.Errorf("error saving image: %w", err) } return nil } // get the latest broadcast func (yt *youtubeService) GetLatestBroadcast() (*youtube.LiveBroadcast, error) { if err := yt.ensureToken(yt.appConfig.Youtube.RefreshToken); err != nil { return nil, err } if err := yt.prepareService(); err != nil { return nil, err } broadcasts, err := yt.listBroadcasts("completed") if err != nil { return nil, err } if len(broadcasts) == 0 { return nil, nil } return broadcasts[0], nil } // listBroadcasts function list all broadcasts on youtube // status: all, active, completed, upcoming func (yt *youtubeService) listBroadcasts(status string) ([]*youtube.LiveBroadcast, error) { if err := yt.ensureToken(yt.appConfig.Youtube.RefreshToken); err != nil { return nil, err } if err := yt.prepareService(); err != nil { return nil, err } broadcasts, err := yt.service.LiveBroadcasts.List([]string{"id", "snippet", "status"}).BroadcastStatus(status).Do() if err != nil { return nil, err } return broadcasts.Items, nil }
```

# pkg/store/accounting/accounting.go

```go
package accounting import ( "fmt" "strings" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type accountingService struct { } // New create new pg service func New() IStore { return &accountingService{} } func (s *accountingService) GetAccountingTransactions(db *gorm.DB) ([]model.AccountingTransaction, error) { var transactions []model.AccountingTransaction return transactions, db. Joins(`left join accounting_categories on accounting_transactions.category = accounting_categories.name`). Preload("CurrencyInfo"). Preload("AccountingCategory"). Order(`date DESC`). Order(` CASE accounting_categories.type WHEN 'IN' THEN 1 WHEN 'SE' THEN 2 WHEN 'OP' THEN 3 WHEN 'OV' THEN 4 WHEN 'CA' THEN 5 ELSE 6 END`). Find(&transactions). Error } func (s *accountingService) CreateTransaction(db *gorm.DB, transaction *model.AccountingTransaction) error { return db.Create(transaction).Error } func (s *accountingService) DeleteTransaction(db *gorm.DB, t *model.AccountingTransaction) error { return db.Delete(&t).Error } func (s *accountingService) GetAccountingCategories(db *gorm.DB) ([]model.AccountingCategory, error) { var categories []model.AccountingCategory return categories, db.Find(&categories).Error } func (s *accountingService) CreateMultipleTransaction(db *gorm.DB, transactions []*model.AccountingTransaction) error { if len(transactions) == 0 { return nil } var valueStrings []string var valueArgs []interface{} for _, v := range transactions { valueStrings = append(valueStrings, "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)") valueArgs = append(valueArgs, v.Name) valueArgs = append(valueArgs, v.Amount) valueArgs = append(valueArgs, v.Category) valueArgs = append(valueArgs, v.Currency) valueArgs = append(valueArgs, v.CurrencyID) valueArgs = append(valueArgs, v.Date) valueArgs = append(valueArgs, v.ConversionAmount) valueArgs = append(valueArgs, v.Organization) valueArgs = append(valueArgs, v.ConversionRate) valueArgs = append(valueArgs, v.Type) valueArgs = append(valueArgs, v.Metadata) } smt := ` INSERT INTO accounting_transactions(name,amount,category,currency,currency_id,date,conversion_amount,organization,conversion_rate, type, metadata) VALUES %s ON CONFLICT ON CONSTRAINT transaction_info_unique DO UPDATE SET amount = EXCLUDED.amount, category = EXCLUDED.category, currency_id = EXCLUDED.currency_id, currency = EXCLUDED.currency, conversion_amount = EXCLUDED.conversion_amount, type = EXCLUDED.type, metadata = EXCLUDED.metadata` smt = fmt.Sprintf(smt, strings.Join(valueStrings, ",")) tx := db.Begin() if err := tx.Exec(smt, valueArgs...).Error; err != nil { tx.Rollback() return err } tx.Commit() return nil }
```

# pkg/store/accounting/interface.go

```go
package accounting import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) // IStore implement calendar method type IStore interface { CreateTransaction(db *gorm.DB, transaction *model.AccountingTransaction) error GetAccountingTransactions(db *gorm.DB) ([]model.AccountingTransaction, error) GetAccountingCategories(db *gorm.DB) ([]model.AccountingCategory, error) DeleteTransaction(db *gorm.DB, t *model.AccountingTransaction) error CreateMultipleTransaction(db *gorm.DB, transactions []*model.AccountingTransaction) error }
```

# pkg/store/actionitem/action_item.go

```go
package actionitem import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get action item by id func (s *store) One(db *gorm.DB, id string) (*model.ActionItem, error) { var actionItem *model.ActionItem return actionItem, db.Where("id = ?", id).First(&actionItem).Error } // All get all action item func (s *store) All(db *gorm.DB) ([]*model.ActionItem, error) { var actionItems []*model.ActionItem return actionItems, db.Find(&actionItems).Error } // Delete delete 1 action item by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.ActionItem{}).Error } // Create creates a new action item func (s *store) Create(db *gorm.DB, e *model.ActionItem) (actionItem *model.ActionItem, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, actionItem *model.ActionItem) (*model.ActionItem, error) { return actionItem, db.Model(&actionItem).Where("id = ?", actionItem.ID).Updates(&actionItem).First(&actionItem).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ActionItem, updatedFields ...string) (*model.ActionItem, error) { actionItem := model.ActionItem{} return &actionItem, db.Model(&actionItem).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error }
```

# pkg/store/actionitem/interface.go

```go
package actionitem import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (actionItem *model.ActionItem, err error) All(db *gorm.DB) (actionItems []*model.ActionItem, err error) Delete(db *gorm.DB, id string) (err error) Create(db *gorm.DB, e *model.ActionItem) (actionItem *model.ActionItem, err error) Update(db *gorm.DB, actionItem *model.ActionItem) (ac *model.ActionItem, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, actionItem model.ActionItem, updatedFields ...string) (ac *model.ActionItem, err error) }
```

# pkg/store/actionitemsnapshot/action_item_snapshot.go

```go
package actionitemsnapshot import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get action item snapshot by id func (s *store) One(db *gorm.DB, id string) (*model.ActionItemSnapshot, error) { var actionItemSnapshot *model.ActionItemSnapshot return actionItemSnapshot, db.Where("id = ?", id).First(&actionItemSnapshot).Error } // All get all action item snapshot func (s *store) All(db *gorm.DB) ([]*model.ActionItemSnapshot, error) { var actionItemSnapshots []*model.ActionItemSnapshot return actionItemSnapshots, db.Find(&actionItemSnapshots).Error } // Delete delete 1 action item snapshot by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.ActionItemSnapshot{}).Error } // Create creates a new action item snapshot func (s *store) Create(db *gorm.DB, e *model.ActionItemSnapshot) (actionItemSnapshot *model.ActionItemSnapshot, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, actionItemSnapshot *model.ActionItemSnapshot) (*model.ActionItemSnapshot, error) { return actionItemSnapshot, db.Model(&actionItemSnapshot).Where("id = ?", actionItemSnapshot.ID).Updates(&actionItemSnapshot).First(&actionItemSnapshot).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ActionItemSnapshot, updatedFields ...string) (*model.ActionItemSnapshot, error) { actionItemSnapshot := model.ActionItemSnapshot{} return &actionItemSnapshot, db.Model(&actionItemSnapshot).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // OneByAuditCycleIDAndTime get one snapshot by audit cycle id and time func (s *store) OneByAuditCycleIDAndTime(db *gorm.DB, auditCycleID string, today string) (*model.ActionItemSnapshot, error) { var actionItemSnapshot *model.ActionItemSnapshot return actionItemSnapshot, db.Where("audit_cycle_id = ? AND created_at >= ? AND created_at < ?", auditCycleID, today, today+" 24:00:00").First(&actionItemSnapshot).Error }
```

# pkg/store/actionitemsnapshot/interface.go

```go
package actionitemsnapshot import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (actionItemSnapshot *model.ActionItemSnapshot, err error) All(db *gorm.DB) (actionItemSnapshots []*model.ActionItemSnapshot, err error) Delete(db *gorm.DB, id string) (err error) Create(db *gorm.DB, e *model.ActionItemSnapshot) (actionItemSnapshot *model.ActionItemSnapshot, err error) Update(db *gorm.DB, actionItemSnapshot *model.ActionItemSnapshot) (ac *model.ActionItemSnapshot, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, actionItemSnapshot model.ActionItemSnapshot, updatedFields ...string) (ac *model.ActionItemSnapshot, err error) OneByAuditCycleIDAndTime(db *gorm.DB, auditCycleID string, today string) (actionItemSnapshot *model.ActionItemSnapshot, err error) }
```

# pkg/store/apikey/api_key.go

```go
package apikey import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) GetByClientID(db *gorm.DB, id string) (*model.APIKey, error) { var apikey *model.APIKey return apikey, db.Where("client_id = ?", id). First(&apikey).Error } func (s *store) Create(db *gorm.DB, e *model.APIKey) (apiKey *model.APIKey, err error) { return e, db.Create(e).Error }
```

# pkg/store/apikey/interface.go

```go
package apikey import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { GetByClientID(db *gorm.DB, id string) (*model.APIKey, error) Create(db *gorm.DB, e *model.APIKey) (apiKey *model.APIKey, err error) }
```

# pkg/store/apikeyrole/api_key_role.go

```go
package apikeyrole import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type store struct{} func New() IStore { return &store{} } func (s *store) Create(db *gorm.DB, e *model.APIKeyRole) (*model.APIKeyRole, error) { return e, db.Create(e).Error }
```

# pkg/store/apikeyrole/interface.go

```go
package apikeyrole import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, e *model.APIKeyRole) (*model.APIKeyRole, error) }
```

# pkg/store/audit/audit.go

```go
package audit import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get audit by id func (s *store) One(db *gorm.DB, id string) (*model.Audit, error) { var audit *model.Audit return audit, db.Where("id = ?", id).First(&audit).Error } // All get all audit func (s *store) All(db *gorm.DB) ([]*model.Audit, error) { var audit []*model.Audit return audit, db.Find(&audit).Error } // Delete delete 1 audit by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.Audit{}).Error } // Create creates a new audit func (s *store) Create(db *gorm.DB, e *model.Audit) (audit *model.Audit, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, audit *model.Audit) (*model.Audit, error) { return audit, db.Model(&audit).Where("id = ?", audit.ID).Updates(&audit).First(&audit).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Audit, updatedFields ...string) (*model.Audit, error) { audit := model.Audit{} return &audit, db.Model(&audit).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // ResetActionItem reset action item in audit table func (s *store) ResetActionItem(db *gorm.DB) error { return db.Model(&model.Audit{}).Where("deleted_at IS NULL").Updates(map[string]interface{}{"action_item": 0}).Error }
```

# pkg/store/audit/interface.go

```go
package audit import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (audit *model.Audit, err error) All(db *gorm.DB) (audits []*model.Audit, err error) Delete(db *gorm.DB, id string) (err error) Create(db *gorm.DB, e *model.Audit) (audit *model.Audit, err error) Update(db *gorm.DB, audit *model.Audit) (a *model.Audit, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, audit model.Audit, updatedFields ...string) (a *model.Audit, err error) ResetActionItem(db *gorm.DB) (err error) }
```

# pkg/store/auditactionitem/audit_action_item.go

```go
package auditactionitem import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // All get all audit action item func (s *store) All(db *gorm.DB) ([]*model.AuditActionItem, error) { var auditActionItems []*model.AuditActionItem return auditActionItems, db.Find(&auditActionItems).Error } // All get all audit action item func (s *store) AllByAuditID(db *gorm.DB, auditID string) ([]*model.AuditActionItem, error) { var auditActionItems []*model.AuditActionItem return auditActionItems, db.Where("audit_id = ?", auditID).Find(&auditActionItems).Error } // Delete delete 1 audit action item by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.AuditActionItem{}).Error } // DeleteByAuditID delete 1 audit action item by id func (s *store) DeleteByAuditID(db *gorm.DB, auditID string) error { return db.Where("id = ?", auditID).Delete(&model.AuditActionItem{}).Error } // Create creates a new audit action item func (s *store) Create(db *gorm.DB, e *model.AuditActionItem) (auditActionItem *model.AuditActionItem, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, auditActionItem *model.AuditActionItem) (*model.AuditActionItem, error) { return auditActionItem, db.Model(&auditActionItem).Where("id = ?", auditActionItem.ID).Updates(&auditActionItem).First(&auditActionItem).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.AuditActionItem, updatedFields ...string) (*model.AuditActionItem, error) { auditActionItem := model.AuditActionItem{} return &auditActionItem, db.Model(&auditActionItem).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error }
```

# pkg/store/auditactionitem/interface.go

```go
package auditactionitem import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB) (auditActionItems []*model.AuditActionItem, err error) AllByAuditID(db *gorm.DB, auditID string) (auditActionItems []*model.AuditActionItem, err error) Delete(db *gorm.DB, id string) (err error) DeleteByAuditID(db *gorm.DB, auditID string) (err error) Create(db *gorm.DB, e *model.AuditActionItem) (auditActionItem *model.AuditActionItem, err error) Update(db *gorm.DB, auditActionItem *model.AuditActionItem) (ac *model.AuditActionItem, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, auditActionItem model.AuditActionItem, updatedFields ...string) (ac *model.AuditActionItem, err error) }
```

# pkg/store/auditcycle/audit_cycle.go

```go
package auditcycle import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get audit cycle by id func (s *store) One(db *gorm.DB, id string) (*model.AuditCycle, error) { var auditCycle *model.AuditCycle return auditCycle, db.Where("id = ?", id).First(&auditCycle).Error } // All get all audit cycle func (s *store) All(db *gorm.DB) ([]*model.AuditCycle, error) { var auditCycles []*model.AuditCycle return auditCycles, db.Preload("Project", "deleted_at IS NULL").Find(&auditCycles).Error } // Delete delete 1 audit cycle by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.AuditCycle{}).Error } // Create creates a new audit cycle func (s *store) Create(db *gorm.DB, e *model.AuditCycle) (auditCycle *model.AuditCycle, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, auditCycle *model.AuditCycle) (*model.AuditCycle, error) { return auditCycle, db.Model(&auditCycle).Where("id = ?", auditCycle.ID).Updates(&auditCycle).First(&auditCycle).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.AuditCycle, updatedFields ...string) (*model.AuditCycle, error) { auditCycle := model.AuditCycle{} return &auditCycle, db.Model(&auditCycle).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // ResetActionItem reset action_item high medium low to 0 in audit_cycle table func (s *store) ResetActionItem(db *gorm.DB) error { return db.Model(&model.AuditCycle{}).Where("deleted_at IS NULL").Updates(map[string]interface{}{"action_item_high": 0, "action_item_medium": 0, "action_item_low": 0}).Error }
```

# pkg/store/auditcycle/interface.go

```go
package auditcycle import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (auditCycle *model.AuditCycle, err error) All(db *gorm.DB) (auditCycles []*model.AuditCycle, err error) Delete(db *gorm.DB, id string) (err error) Create(db *gorm.DB, e *model.AuditCycle) (auditCycle *model.AuditCycle, err error) Update(db *gorm.DB, auditCycle *model.AuditCycle) (ac *model.AuditCycle, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, auditCycle model.AuditCycle, updatedFields ...string) (ac *model.AuditCycle, err error) ResetActionItem(db *gorm.DB) (err error) }
```

# pkg/store/audititem/audit_item.go

```go
package audititem import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get audit item by id func (s *store) One(db *gorm.DB, id string) (*model.AuditItem, error) { var auditItem *model.AuditItem return auditItem, db.Where("id = ?", id).First(&auditItem).Error } // All get all audit item func (s *store) All(db *gorm.DB) ([]*model.AuditItem, error) { var auditItems []*model.AuditItem return auditItems, db.Find(&auditItems).Error } // All get all audit item by audit id func (s *store) AllByAuditID(db *gorm.DB, auditID string) ([]*model.AuditItem, error) { var auditItems []*model.AuditItem return auditItems, db.Where("audit_id = ?", auditID).Find(&auditItems).Error } // Delete delete 1 audit item by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.AuditItem{}).Error } // DeleteByAuditID delete 1 audit item by audit id func (s *store) DeleteByAuditID(db *gorm.DB, auditID string) error { return db.Where("audit_id = ?", auditID).Delete(&model.AuditItem{}).Error } // Create creates a new audit item func (s *store) Create(db *gorm.DB, e *model.AuditItem) (auditItem *model.AuditItem, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, auditItem *model.AuditItem) (*model.AuditItem, error) { return auditItem, db.Model(&auditItem).Where("id = ?", auditItem.ID).Updates(&auditItem).First(&auditItem).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.AuditItem, updatedFields ...string) (*model.AuditItem, error) { auditItem := model.AuditItem{} return &auditItem, db.Model(&auditItem).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error }
```

# pkg/store/audititem/interface.go

```go
package audititem import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (auditItem *model.AuditItem, err error) All(db *gorm.DB) (auditItems []*model.AuditItem, err error) AllByAuditID(db *gorm.DB, auditID string) (auditItems []*model.AuditItem, err error) Delete(db *gorm.DB, id string) (err error) DeleteByAuditID(db *gorm.DB, auditID string) (err error) Create(db *gorm.DB, e *model.AuditItem) (auditItem *model.AuditItem, err error) Update(db *gorm.DB, auditItem *model.AuditItem) (ac *model.AuditItem, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, auditItem model.AuditItem, updatedFields ...string) (ac *model.AuditItem, err error) }
```

# pkg/store/auditparticipant/audit_participant.go

```go
package auditparticipant import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // All get all audit participant func (s *store) All(db *gorm.DB) ([]*model.AuditParticipant, error) { var auditParticipants []*model.AuditParticipant return auditParticipants, db.Find(&auditParticipants).Error } // All get all audit participant func (s *store) AllByAuditID(db *gorm.DB, auditID string) ([]*model.AuditParticipant, error) { var auditParticipants []*model.AuditParticipant return auditParticipants, db.Where("audit_id = ?", auditID).Find(&auditParticipants).Error } // Delete delete 1 audit participant by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.AuditParticipant{}).Error } // DeleteByAuditID delete 1 audit participant by audit id func (s *store) DeleteByAuditID(db *gorm.DB, auditID string) error { return db.Where("id = ?", auditID).Delete(&model.AuditParticipant{}).Error } // Create creates a new audit participant func (s *store) Create(db *gorm.DB, e *model.AuditParticipant) (auditParticipant *model.AuditParticipant, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, auditParticipant *model.AuditParticipant) (*model.AuditParticipant, error) { return auditParticipant, db.Model(&auditParticipant).Where("id = ?", auditParticipant.ID).Updates(&auditParticipant).First(&auditParticipant).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.AuditParticipant, updatedFields ...string) (*model.AuditParticipant, error) { auditParticipant := model.AuditParticipant{} return &auditParticipant, db.Model(&auditParticipant).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error }
```

# pkg/store/auditparticipant/interface.go

```go
package auditparticipant import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB) (auditParticipants []*model.AuditParticipant, err error) AllByAuditID(db *gorm.DB, auditID string) (auditParticipants []*model.AuditParticipant, err error) Delete(db *gorm.DB, id string) (err error) DeleteByAuditID(db *gorm.DB, auditID string) (err error) Create(db *gorm.DB, e *model.AuditParticipant) (auditParticipant *model.AuditParticipant, err error) Update(db *gorm.DB, auditParticipant *model.AuditParticipant) (ac *model.AuditParticipant, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, auditParticipant model.AuditParticipant, updatedFields ...string) (ac *model.AuditParticipant, err error) }
```

# pkg/store/bank/bank.go

```go
package bank import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get bank account by id func (s *store) One(db *gorm.DB, id string) (*model.Bank, error) { var bankAccount *model.Bank return bankAccount, db.Where("id = ?", id).First(&bankAccount).Error } type GetBanksInput struct { ID string Bin string SwiftCode string } // All get all bank account func (s *store) All(db *gorm.DB, in GetBanksInput) ([]*model.Bank, error) { var banks []*model.Bank query := db.Where("deleted_at IS NULL") if in.ID != "" { query = query.Where("id = ?", in.ID) } if in.Bin != "" { query = query.Where("bin = ?", in.Bin) } if in.SwiftCode != "" { query = query.Where("swift_code = ?", in.SwiftCode) } return banks, query.Find(&banks).Error } // IsExist check bank account existence func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM banks WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error } // OneByBin get bank account by bin func (s *store) OneByBin(db *gorm.DB, bin string) (bank *model.Bank, err error) { var bankAccount *model.Bank return bankAccount, db.Where("bin = ?", bin).First(&bankAccount).Error } // OneBySwiftCode get bank account by swift code func (s *store) OneBySwiftCode(db *gorm.DB, code string) (bank *model.Bank, err error) { var bankAccount *model.Bank return bankAccount, db.Where("swift_code = ?", code).First(&bankAccount).Error }
```

# pkg/store/bank/interface.go

```go
package bank import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (bank *model.Bank, err error) OneByBin(db *gorm.DB, bin string) (bank *model.Bank, err error) OneBySwiftCode(db *gorm.DB, code string) (bank *model.Bank, err error) All(db *gorm.DB, in GetBanksInput) ([]*model.Bank, error) IsExist(db *gorm.DB, id string) (exists bool, err error) }
```

# pkg/store/bankaccount/bank_account.go

```go
package bankaccount import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get bank account by id func (s *store) One(db *gorm.DB, id string) (*model.BankAccount, error) { var bankAccount *model.BankAccount return bankAccount, db.Where("id = ?", id). Preload("Currency"). First(&bankAccount).Error } // All get all bank account func (s *store) All(db *gorm.DB) ([]*model.BankAccount, error) { var bankAccounts []*model.BankAccount return bankAccounts, db.Preload("Currency").Find(&bankAccounts).Error } // IsExist check bank account existence func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM bank_accounts WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error }
```

# pkg/store/bankaccount/interface.go

```go
package bankaccount import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (bankAccount *model.BankAccount, err error) All(db *gorm.DB) (bankAccounts []*model.BankAccount, err error) IsExist(db *gorm.DB, id string) (exists bool, err error) }
```

# pkg/store/basesalary/base_salary.go

```go
package basesalary import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) One(db *gorm.DB, id string) (*model.BaseSalary, error) { var baseSalary *model.BaseSalary return baseSalary, db.Where("id = ?", id). Preload("Currency"). First(&baseSalary).Error } func (s *store) OneByEmployeeID(db *gorm.DB, employeeID string) (*model.BaseSalary, error) { var baseSalary *model.BaseSalary return baseSalary, db.Where("employee_id = ?", employeeID). Preload("Currency"). First(&baseSalary).Error } func (s *store) Save(db *gorm.DB, baseSalary *model.BaseSalary) (err error) { return db.Save(&baseSalary).Preload("Currency").Error }
```

# pkg/store/basesalary/interface.go

```go
package basesalary import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (baseSalary *model.BaseSalary, err error) OneByEmployeeID(db *gorm.DB, employeeID string) (baseSalary *model.BaseSalary, err error) Save(db *gorm.DB, baseSalary *model.BaseSalary) (err error) }
```

# pkg/store/brainerylog/brainery_log.go

```go
package brainerylog import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create creates a brainery log record in the database func (s *store) Create(db *gorm.DB, b []model.BraineryLog) (braineryLog []model.BraineryLog, err error) { return b, db.Create(b).Error } // GetLimitByTimeRange gets brainery logs in a specific time range, with limit func (s *store) GetLimitByTimeRange(db *gorm.DB, start, end *time.Time, limit int) ([]*model.BraineryLog, error) { var logs []*model.BraineryLog return logs, db.Where("published_at BETWEEN ? AND ?", start, end).Limit(limit).Order("published_at DESC").Find(&logs).Error } // GetNewContributorDiscordIDs gets list of discord IDs from new contributors in a specific time range func (s *store) GetNewContributorDiscordIDs(db *gorm.DB, start, end *time.Time) ([]string, error) { var discordIDs []string subQuery := db.Select("DISTINCT(discord_id)").Where("published_at <= ?", start).Table("brainery_logs") return discordIDs, db.Table("brainery_logs"). Where("published_at BETWEEN ? AND ? AND discord_id NOT IN (?)", start, end, subQuery). Distinct(). Pluck("discord_id", &discordIDs).Error }
```

# pkg/store/brainerylog/interface.go

```go
package brainerylog import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, b []model.BraineryLog) ([]model.BraineryLog, error) GetLimitByTimeRange(db *gorm.DB, start, end *time.Time, limit int) ([]*model.BraineryLog, error) GetNewContributorDiscordIDs(db *gorm.DB, start, end *time.Time) ([]string, error) }
```

# pkg/store/cachedpayroll/cached_payroll.go

```go
package cachedpayroll import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} // New create new pg service func New() IStore { return &store{} } func (s *store) Set(db *gorm.DB, cachedPayroll *model.CachedPayroll) error { return db.Save(cachedPayroll).Error } func (s *store) Get(db *gorm.DB, month, year, batch int) (*model.CachedPayroll, error) { p := model.CachedPayroll{} return &p, db.Where("month = ? AND year = ? AND batch = ?", month, year, batch).First(&p).Error }
```

# pkg/store/cachedpayroll/interface.go

```go
package cachedpayroll import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type IStore interface { Set(db *gorm.DB, cachedPayroll *model.CachedPayroll) error Get(db *gorm.DB, month, year, batch int) (*model.CachedPayroll, error) }
```

# pkg/store/chapter/chapter.go

```go
package chapter import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // All get all chapters func (s *store) All(db *gorm.DB) ([]*model.Chapter, error) { var chapters []*model.Chapter return chapters, db.Find(&chapters).Error } // IsExist check existence of a chapter func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM chapters WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error } func (s *store) UpdateChapterLead(db *gorm.DB, id string, lead *model.UUID) error { return db.Table("chapters").Where("id = ?", id).Update("lead_id", lead).Error } // GetAllByLeadID get all chapters by lead_id func (s *store) GetAllByLeadID(db *gorm.DB, leadID string) ([]*model.Chapter, error) { var chapters []*model.Chapter return chapters, db.Where("lead_id = ?", leadID).Find(&chapters).Error }
```

# pkg/store/chapter/interface.go

```go
package chapter import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB) (chapters []*model.Chapter, err error) IsExist(db *gorm.DB, id string) (isExist bool, err error) UpdateChapterLead(db *gorm.DB, id string, lead *model.UUID) (err error) GetAllByLeadID(db *gorm.DB, leadID string) (chapters []*model.Chapter, err error) }
```

# pkg/store/client/client.go

```go
package client import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get client by id func (s *store) One(db *gorm.DB, id string) (*model.Client, error) { var client *model.Client return client, db.Where("id = ?", id).Preload("Contacts", "deleted_at IS NULL").First(&client).Error } // IsExist check client existence func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM clients WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error } // All get all client func (s *store) All(db *gorm.DB, public bool, preload bool) ([]*model.Client, error) { var client []*model.Client query := db.Preload("Contacts", "deleted_at IS NULL") if preload { query = query. Preload("Projects"). Preload("Projects.ProjectStacks"). Preload("Projects.ProjectStacks.Stack") } if public { query = query.Where("is_public = ?", true) } return client, query.Find(&client).Error } // Delete delete 1 client by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.Client{}).Error } // Create creates a new client func (s *store) Create(db *gorm.DB, e *model.Client) (client *model.Client, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, client *model.Client) (*model.Client, error) { return client, db.Model(&client).Where("id = ?", client.ID).Updates(&client).First(&client).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Client, updatedFields ...string) (*model.Client, error) { client := model.Client{} return &client, db.Model(&client).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error }
```

# pkg/store/client/interface.go

```go
package client import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (client *model.Client, err error) IsExist(db *gorm.DB, id string) (exists bool, err error) All(db *gorm.DB, public bool, preload bool) ([]*model.Client, error) Delete(db *gorm.DB, id string) (err error) Create(db *gorm.DB, e *model.Client) (client *model.Client, err error) Update(db *gorm.DB, client *model.Client) (a *model.Client, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, client model.Client, updatedFields ...string) (a *model.Client, err error) }
```

# pkg/store/clientcontact/clientcontact.go

```go
package clientcontact import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get clientContact by id func (s *store) One(db *gorm.DB, id string) (*model.ClientContact, error) { var clientContact *model.ClientContact return clientContact, db.Where("id = ?", id).First(&clientContact).Error } // IsExist check client contact existence func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM client_contacts WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error } // All get all clientContact func (s *store) All(db *gorm.DB) ([]*model.ClientContact, error) { var clientContact []*model.ClientContact return clientContact, db.Find(&clientContact).Error } // Delete delete 1 clientContact by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.ClientContact{}).Error } // Delete delete 1 clientContact by id func (s *store) DeleteByClientID(db *gorm.DB, clientID string) error { return db.Where("client_id = ?", clientID).Delete(&model.ClientContact{}).Error } // Create creates a new clientContact func (s *store) Create(db *gorm.DB, e *model.ClientContact) (clientContact *model.ClientContact, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, clientContact *model.ClientContact) (*model.ClientContact, error) { return clientContact, db.Model(&clientContact).Where("id = ?", clientContact.ID).Updates(&clientContact).First(&clientContact).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ClientContact, updatedFields ...string) (*model.ClientContact, error) { clientContact := model.ClientContact{} return &clientContact, db.Model(&clientContact).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error }
```

# pkg/store/clientcontact/interface.go

```go
package clientcontact import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (clientContact *model.ClientContact, err error) IsExist(db *gorm.DB, id string) (exists bool, err error) All(db *gorm.DB) (clientContacts []*model.ClientContact, err error) Delete(db *gorm.DB, id string) (err error) DeleteByClientID(db *gorm.DB, clientID string) (err error) Create(db *gorm.DB, e *model.ClientContact) (clientContact *model.ClientContact, err error) Update(db *gorm.DB, clientContact *model.ClientContact) (a *model.ClientContact, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, clientContact model.ClientContact, updatedFields ...string) (a *model.ClientContact, err error) }
```

# pkg/store/companyinfo/companyinfo.go

```go
package companyinfo import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get companyInfo by id func (s *store) One(db *gorm.DB, id string) (*model.CompanyInfo, error) { var companyInfo *model.CompanyInfo return companyInfo, db.Where("id = ?", id).First(&companyInfo).Error } // IsExist check client contact existence func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM company_infos WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error } // All get all companyInfo func (s *store) All(db *gorm.DB) ([]*model.CompanyInfo, error) { var companyInfo []*model.CompanyInfo return companyInfo, db.Find(&companyInfo).Error }
```

# pkg/store/companyinfo/interface.go

```go
package companyinfo import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (companyInfo *model.CompanyInfo, err error) IsExist(db *gorm.DB, id string) (exists bool, err error) All(db *gorm.DB) (companyInfos []*model.CompanyInfo, err error) }
```

# pkg/store/config/config.go

```go
package config import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) One(db *gorm.DB, id string) (*model.Config, error) { var config *model.Config return config, db.Where("id = ?", id). First(&config).Error } func (s *store) OneByKey(db *gorm.DB, key string) (*model.Config, error) { var config *model.Config return config, db.Where("key = ?", key). First(&config).Error } func (s *store) Save(db *gorm.DB, config *model.Config) (err error) { return db.Save(&config).Error }
```

# pkg/store/config/interface.go

```go
package config import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (config *model.Config, err error) OneByKey(db *gorm.DB, key string) (config *model.Config, err error) Save(db *gorm.DB, salaryAdvance *model.Config) (err error) }
```

# pkg/store/content/content.go

```go
package content import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct { } func New() IStore { return &store{} } // Create a content record func (s *store) Create(tx *gorm.DB, content model.Content) (*model.Content, error) { return &content, tx.Create(&content).Error } // OneByPath get content by name func (s *store) OneByPath(tx *gorm.DB, path string) (*model.Content, error) { content := model.Content{} return &content, tx. Where("LOWER(path) = LOWER(?)", path).First(&content).Error }
```

# pkg/store/content/interface.go

```go
package content import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type IStore interface { Create(tx *gorm.DB, content model.Content) (*model.Content, error) OneByPath(tx *gorm.DB, path string) (*model.Content, error) }
```

# pkg/store/conversionrate/conversion_rate.go

```go
package conversionrate import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} // New create new pg service func New() IStore { return &store{} } func (c *store) GetByCurrencyID(db *gorm.DB, id string) (*model.ConversionRate, error) { rs := &model.ConversionRate{} return rs, db.Where("id = ?", id).Preload("Currency").First(rs).Error } func (c *store) GetList(db *gorm.DB) ([]model.ConversionRate, error) { var rs []model.ConversionRate return rs, db.Preload("Currency").Find(&rs).Error } func (s *store) Update(db *gorm.DB, cr *model.ConversionRate) error { return db.Model(&cr).Where("currency_id = ?", cr.CurrencyID).Updates(&cr).Error }
```

# pkg/store/conversionrate/interface.go

```go
package conversionrate import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { GetByCurrencyID(db *gorm.DB, id string) (*model.ConversionRate, error) GetList(db *gorm.DB) ([]model.ConversionRate, error) Update(db *gorm.DB, cr *model.ConversionRate) error }
```

# pkg/store/country/country.go

```go
package country import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // All get all countries func (s *store) All(db *gorm.DB) ([]*model.Country, error) { var countries []*model.Country return countries, db.Find(&countries).Error } // One get 1 country by id func (s *store) One(db *gorm.DB, id string) (*model.Country, error) { var country *model.Country return country, db.Where("id = ?", id).First(&country).Error } // OneByName get 1 country by name func (s *store) OneByName(db *gorm.DB, name string) (*model.Country, error) { var country *model.Country return country, db.Where("name = ?", name).First(&country).Error } // IsExist check country existence func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM countries WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error }
```

# pkg/store/country/interface.go

```go
package country import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB) (countries []*model.Country, err error) One(db *gorm.DB, id string) (countries *model.Country, err error) OneByName(db *gorm.DB, name string) (countries *model.Country, err error) IsExist(db *gorm.DB, id string) (bool, error) }
```

# pkg/store/currency/currency.go

```go
package currency import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type currencyService struct{} // New create new pg service func New() IStore { return &currencyService{} } func (c currencyService) GetByName(db *gorm.DB, name string) (*model.Currency, error) { currency := &model.Currency{} return currency, db.Where("name = ?", name).First(currency).Error } func (c currencyService) GetList(db *gorm.DB) ([]model.Currency, error) { var currencies []model.Currency return currencies, db.Find(&currencies).Error }
```

# pkg/store/currency/interface.go

```go
package currency import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { GetByName(db *gorm.DB, name string) (*model.Currency, error) GetList(db *gorm.DB) ([]model.Currency, error) }
```

# pkg/store/dashboard/dashboard.go

```go
package dashboard import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) GetProjectSizes(db *gorm.DB) ([]*model.ProjectSize, error) { var ru []*model.ProjectSize query := ` SELECT projects.id, projects.name, projects.code, projects.avatar, count(*) AS size FROM (projects JOIN project_members pm ON projects.id = pm.project_id JOIN organizations ON projects.organization_id = organizations.id) WHERE projects.function = 'development' AND organizations.code = 'dwarves-foundation' AND pm.status = 'active' AND (pm.status = 'active' OR pm.status='on-boarding') AND projects.deleted_at IS NULL GROUP BY projects.id ORDER BY size DESC ` return ru, db.Raw(query).Scan(&ru).Error } func (s *store) GetWorkSurveysByProjectID(db *gorm.DB, projectID string) ([]*model.WorkSurvey, error) { var rs []*model.WorkSurvey query := ` SELECT feedback_events.end_date, AVG( CASE WHEN "order" = 1 THEN CASE When length(answer) = 0 THEN null ELSE cast(answer AS integer) END END) as workload, AVG( CASE WHEN "order" = 2 THEN CASE When length(answer) = 0 THEN null ELSE cast(answer AS integer) END END) as deadline, AVG( CASE WHEN "order" = 3 THEN CASE When length(answer) = 0 THEN null ELSE cast(answer AS integer) END END) as learning FROM feedback_events JOIN employee_event_topics eet ON feedback_events.id = eet.event_id JOIN employee_event_questions eeq ON feedback_events.id = eeq.event_id WHERE eet.project_id = ? AND feedback_events.subtype='work' AND feedback_events.deleted_at IS NULL AND eet.deleted_at IS NULL AND eeq.deleted_at IS NULL GROUP BY feedback_events.end_date ORDER BY feedback_events.end_date LIMIT 6 ` return rs, db.Raw(query, projectID).Scan(&rs).Error } func (s *store) GetAllWorkSurveys(db *gorm.DB) ([]*model.WorkSurvey, error) { var rs []*model.WorkSurvey query := ` SELECT feedback_events.end_date, AVG( CASE WHEN "order" = 1 THEN CASE When length(answer) = 0 THEN null ELSE cast(answer AS integer) END END) as workload, AVG( CASE WHEN "order" = 2 THEN CASE When length(answer) = 0 THEN null ELSE cast(answer AS integer) END END) as deadline, AVG( CASE WHEN "order" = 3 THEN CASE When length(answer) = 0 THEN null ELSE cast(answer AS integer) END END) as learning FROM feedback_events JOIN employee_event_topics eet ON feedback_events.id = eet.event_id JOIN projects p ON eet.project_id = p.id JOIN organizations ON p.organization_id = organizations.id JOIN employee_event_questions eeq ON feedback_events.id = eeq.event_id WHERE p.function = 'development' AND organizations.code = 'dwarves-foundation' AND feedback_events.subtype='work' AND feedback_events.deleted_at IS NULL AND eet.deleted_at IS NULL AND eeq.deleted_at IS NULL GROUP BY feedback_events.end_date ORDER BY feedback_events.end_date LIMIT 6 ` return rs, db.Raw(query).Scan(&rs).Error } func (s *store) GetAllActionItemReports(db *gorm.DB) ([]*model.ActionItemReport, error) { var rs []*model.ActionItemReport query := ` SELECT sum(action_item_high) AS high, sum(action_item_medium) AS medium, sum(action_item_low) AS low, quarter AS quarter FROM audit_cycles WHERE audit_cycles.deleted_at IS NULL GROUP BY quarter ORDER BY quarter desc LIMIT 4 ` return rs, db.Raw(query).Scan(&rs).Error } func (s *store) GetActionItemReportsByProjectNotionID(db *gorm.DB, projectID string) ([]*model.ActionItemReport, error) { var rs []*model.ActionItemReport query := ` SELECT sum(audit_cycles.action_item_high) AS high, sum(audit_cycles.action_item_medium) AS medium, sum(audit_cycles.action_item_low) AS low, audit_cycles.quarter AS quarter FROM audit_cycles WHERE audit_cycles.project_id = ? AND audit_cycles.deleted_at IS NULL GROUP BY quarter ORDER BY quarter desc LIMIT 4 ` return rs, db.Raw(query, projectID).Scan(&rs).Error } func (s *store) AverageEngineeringHealth(db *gorm.DB) ([]*model.AverageEngineeringHealth, error) { var rs []*model.AverageEngineeringHealth query := ` SELECT audit_cycles.quarter, avg(CASE When a.score = 0 THEN NULL ELSE a.score END) as avg FROM audit_cycles LEFT JOIN audits AS a ON audit_cycles.health_audit_id = a.id WHERE audit_cycles.deleted_at IS NULL AND a.deleted_at IS NULL GROUP BY audit_cycles.quarter ORDER BY audit_cycles.quarter DESC LIMIT 4 ` return rs, db.Raw(query).Scan(&rs).Error } func (s *store) GroupEngineeringHealth(db *gorm.DB) ([]*model.GroupEngineeringHealth, error) { var rs []*model.GroupEngineeringHealth query := ` SELECT audit_cycles.quarter, ai.area, avg(CASE When ai.grade = 0 THEN NULL ELSE ai.grade END) as avg FROM audit_cycles LEFT JOIN audits AS a ON audit_cycles.health_audit_id = a.id LEFT JOIN audit_items AS ai ON a.id = ai.audit_id WHERE audit_cycles.deleted_at IS NULL AND a.deleted_at IS NULL AND ai.deleted_at IS NULL GROUP BY audit_cycles.quarter, ai.area ORDER BY audit_cycles.quarter DESC LIMIT 16 ` return rs, db.Raw(query).Scan(&rs).Error } func (s *store) AverageEngineeringHealthByProjectNotionID(db *gorm.DB, projectID string) ([]*model.AverageEngineeringHealth, error) { var rs []*model.AverageEngineeringHealth query := ` SELECT audit_cycles.quarter, avg(CASE When a.score = 0 THEN NULL ELSE a.score END) as avg FROM audit_cycles LEFT JOIN audits AS a ON audit_cycles.health_audit_id = a.id WHERE audit_cycles.project_id = ? AND audit_cycles.deleted_at IS NULL AND a.deleted_at IS NULL GROUP BY audit_cycles.quarter ORDER BY audit_cycles.quarter DESC LIMIT 4 ` return rs, db.Raw(query, projectID).Scan(&rs).Error } func (s *store) GroupEngineeringHealthByProjectNotionID(db *gorm.DB, projectID string) ([]*model.GroupEngineeringHealth, error) { var rs []*model.GroupEngineeringHealth query := ` SELECT audit_cycles.quarter, ai.area, avg(CASE When ai.grade = 0 THEN NULL ELSE ai.grade END) as avg FROM audit_cycles LEFT JOIN audits AS a ON audit_cycles.health_audit_id = a.id LEFT JOIN audit_items AS ai ON a.id = ai.audit_id WHERE audit_cycles.project_id = ? AND audit_cycles.deleted_at IS NULL AND a.deleted_at IS NULL AND ai.deleted_at IS NULL GROUP BY audit_cycles.quarter, ai.area ORDER BY audit_cycles.quarter DESC LIMIT 16 ` return rs, db.Raw(query, projectID).Scan(&rs).Error } func (s *store) GetAverageAudit(db *gorm.DB) ([]*model.AverageAudit, error) { var rs []*model.AverageAudit query := ` SELECT audit_cycles.quarter, avg(CASE When audit_cycles.average_score = 0 THEN null ELSE audit_cycles.average_score END) AS avg FROM audit_cycles WHERE audit_cycles.deleted_at IS NULL GROUP BY audit_cycles.quarter ORDER BY audit_cycles.quarter DESC LIMIT 4 ` return rs, db.Raw(query).Scan(&rs).Error } func (s *store) GetGroupAudit(db *gorm.DB) ([]*model.GroupAudit, error) { var rs []*model.GroupAudit query := ` SELECT audit_cycles.quarter, avg(CASE When asy.score = 0 THEN null ELSE asy.score END) as system, avg(CASE When afe.score = 0 THEN null ELSE afe.score END) as frontend, avg(CASE When abe.score = 0 THEN null ELSE abe.score END) as backend, avg(CASE When ap.score = 0 THEN null ELSE ap.score END) as process, avg(CASE When ab.score = 0 THEN null ELSE ab.score END) as blockchain, avg(CASE When am.score = 0 THEN null ELSE am.score END) as mobile FROM audit_cycles LEFT JOIN audits AS afe ON audit_cycles.frontend_audit_id = afe.id LEFT JOIN audits AS abe ON audit_cycles.backend_audit_id = abe.id LEFT JOIN audits AS ap ON audit_cycles.process_audit_id = ap.id LEFT JOIN audits AS asy ON audit_cycles.system_audit_id = asy.id LEFT JOIN audits AS ab ON audit_cycles.blockchain_audit_id = ab.id LEFT JOIN audits AS am ON audit_cycles.mobile_audit_id = am.id WHERE audit_cycles.deleted_at IS NULL AND afe.deleted_at IS NULL AND abe.deleted_at IS NULL AND ap.deleted_at IS NULL AND asy.deleted_at IS NULL AND ab.deleted_at IS NULL AND am.deleted_at IS NULL GROUP BY audit_cycles.quarter ORDER BY audit_cycles.quarter DESC LIMIT 4 ` return rs, db.Raw(query).Scan(&rs).Error } func (s *store) GetAverageAuditByProjectNotionID(db *gorm.DB, projectID string) ([]*model.AverageAudit, error) { var rs []*model.AverageAudit query := ` SELECT audit_cycles.quarter, avg(CASE When audit_cycles.average_score = 0 THEN null ELSE audit_cycles.average_score END) AS avg FROM audit_cycles WHERE audit_cycles.project_id = ? AND audit_cycles.deleted_at IS NULL GROUP BY audit_cycles.quarter ORDER BY audit_cycles.quarter DESC LIMIT 4 ` return rs, db.Raw(query, projectID).Scan(&rs).Error } func (s *store) GetGroupAuditByProjectNotionID(db *gorm.DB, projectID string) ([]*model.GroupAudit, error) { var rs []*model.GroupAudit query := ` SELECT audit_cycles.quarter, avg(CASE When asy.score = 0 THEN null ELSE asy.score END) as system, avg(CASE When afe.score = 0 THEN null ELSE afe.score END) as frontend, avg(CASE When abe.score = 0 THEN null ELSE abe.score END) as backend, avg(CASE When ap.score = 0 THEN null ELSE ap.score END) as process, avg(CASE When ab.score = 0 THEN null ELSE ab.score END) as blockchain, avg(CASE When am.score = 0 THEN null ELSE am.score END) as mobile FROM audit_cycles LEFT JOIN audits AS afe ON audit_cycles.frontend_audit_id = afe.id LEFT JOIN audits AS abe ON audit_cycles.backend_audit_id = abe.id LEFT JOIN audits AS ap ON audit_cycles.process_audit_id = ap.id LEFT JOIN audits AS asy ON audit_cycles.system_audit_id = asy.id LEFT JOIN audits AS ab ON audit_cycles.blockchain_audit_id = ab.id LEFT JOIN audits AS am ON audit_cycles.mobile_audit_id = am.id WHERE audit_cycles.project_id = ? AND audit_cycles.deleted_at IS NULL AND afe.deleted_at IS NULL AND abe.deleted_at IS NULL AND ap.deleted_at IS NULL AND asy.deleted_at IS NULL AND ab.deleted_at IS NULL AND am.deleted_at IS NULL GROUP BY audit_cycles.quarter ORDER BY audit_cycles.quarter DESC LIMIT 4 ` return rs, db.Raw(query, projectID).Scan(&rs).Error } func (s *store) GetAllActionItemSquashReports(db *gorm.DB) ([]*model.ActionItemSquashReport, error) { var rs []*model.ActionItemSquashReport query := ` WITH days AS (SELECT date_trunc('DAY', end_date) AS day FROM feedback_events WHERE subtype = 'work' GROUP BY date_trunc('DAY', end_date)) SELECT (sum(high) + sum(medium) + sum(low)) as all, sum(high) as high, sum(medium) as medium, sum(low) as low, date_trunc('DAY', action_item_snapshots.created_at) as snap_date FROM action_item_snapshots JOIN project_notions ON action_item_snapshots.project_id = project_notions.audit_notion_id JOIN projects ON project_notions.project_id = projects.id JOIN organizations ON projects.organization_id = organizations.id JOIN days ON date_trunc('DAY', action_item_snapshots.created_at) = date_trunc('DAY', days.day) WHERE projects.function = 'development' AND organizations.code = 'dwarves-foundation' AND action_item_snapshots.deleted_at IS NULL AND projects.deleted_at IS NULL GROUP BY snap_date ORDER BY snap_date desc LIMIT 12 ` return rs, db.Raw(query).Scan(&rs).Error } func (s *store) GetActionItemSquashReportsByProjectID(db *gorm.DB, projectID string) ([]*model.ActionItemSquashReport, error) { var rs []*model.ActionItemSquashReport query := ` WITH days AS (SELECT date_trunc('DAY', end_date) AS day FROM feedback_events WHERE subtype = 'work' GROUP BY date_trunc('DAY', end_date)) SELECT (sum(high) + sum(medium) + sum(low)) as all, sum(high) as high, sum(medium) as medium, sum(low) as low, date_trunc('DAY', action_item_snapshots.created_at ) as snap_date FROM action_item_snapshots LEFT JOIN project_notions ON action_item_snapshots.project_id = project_notions.audit_notion_id JOIN projects ON project_notions.project_id = projects.id JOIN organizations ON projects.organization_id = organizations.id JOIN days ON date_trunc('DAY', action_item_snapshots.created_at) = date_trunc('DAY', days.day) WHERE projects.function = 'development' AND organizations.code = 'dwarves-foundation' AND action_item_snapshots.deleted_at IS NULL AND projects.deleted_at IS NULL AND projects.id = ? GROUP BY snap_date ORDER BY snap_date desc LIMIT 12 ` return rs, db.Raw(query, projectID).Scan(&rs).Error } func (s *store) GetAuditSummaries(db *gorm.DB) ([]*model.AuditSummary, error) { var rs []*model.AuditSummary query := ` SELECT audit_cycles.quarter, p.id, p.name, p.code, p.avatar, SUM(audit_cycles.action_item_high) AS high, SUM(audit_cycles.action_item_medium) AS medium, SUM(audit_cycles.action_item_low) AS low, (SELECT count(*) FROM action_items WHERE status = 'done' AND audit_cycle_id = audit_cycles.id) as done, count(DISTINCT pm.id) as size, avg(CASE When a.score = 0 THEN NULL ELSE a.score END) as health, avg(CASE When audit_cycles.average_score = 0 THEN null ELSE audit_cycles.average_score END) AS audit FROM audit_cycles LEFT JOIN audits AS a ON audit_cycles.health_audit_id = a.id JOIN project_notions ON audit_cycles.project_id = project_notions.audit_notion_id JOIN projects AS p ON project_notions.project_id = p.id JOIN organizations ON p.organization_id = organizations.id JOIN project_members pm ON p.id = pm.project_id WHERE (pm.status = 'active' OR pm.status='on-boarding') AND audit_cycles.deleted_at IS NULL AND a.deleted_at IS NULL AND pm.deleted_at IS NULL AND p.deleted_at IS NULL AND organizations.code = 'dwarves-foundation' GROUP BY audit_cycles.id,audit_cycles.quarter, p.id ORDER BY audit_cycles.quarter DESC` return rs, db.Raw(query).Scan(&rs).Error } func (s *store) GetProjectSizesByStartTime(db *gorm.DB, curr time.Time) ([]*model.ProjectSize, error) { var ru []*model.ProjectSize query := ` SELECT projects.id, projects.name, projects.code, count(*) AS size FROM (projects JOIN project_members pm ON projects.id = pm.project_id JOIN organizations ON projects.organization_id = organizations.id) WHERE projects.function = 'development' AND organizations.code = 'dwarves-foundation' AND pm.status = 'active' AND projects.deleted_at IS NULL AND pm.deleted_at IS NULL AND (pm.status = 'active' OR pm.status='on-boarding') AND pm.start_date <= ? GROUP BY projects.id ` return ru, db.Raw(query, curr.UTC()).Scan(&ru).Error } func (s *store) GetPendingSlots(db *gorm.DB) ([]*model.ProjectSlot, error) { var slots []*model.ProjectSlot return slots, db. Where(`id NOT IN ( SELECT pm.project_slot_id FROM project_members pm WHERE (pm.end_date IS NULL OR pm.end_date > now()) AND pm.deleted_at IS NULL ) AND project_id NOT IN ( SELECT p.id FROM projects p WHERE p.status = ? AND p.deleted_at IS NULL ) AND status = ?`, model.ProjectStatusClosed, model.ProjectMemberStatusPending). Order("updated_at"). Preload("Seniority", "deleted_at IS NULL"). Preload("Project", "deleted_at IS NULL"). Preload("ProjectSlotPositions", "deleted_at IS NULL"). Preload("ProjectSlotPositions.Position", "deleted_at IS NULL"). Find(&slots).Error } func (s *store) GetAvailableEmployees(db *gorm.DB) ([]*model.Employee, error) { var employees []*model.Employee return employees, db. Where("working_status != ? ", model.WorkingStatusLeft). Where(`id IN ( SELECT eo.employee_id FROM employee_organizations eo JOIN organizations o ON eo.organization_id = o.id WHERE o.deleted_at IS NULL AND eo.deleted_at IS NULL AND o.code = ? )`, model.OrganizationCodeDwarves). Where(`id NOT IN ( SELECT pm.employee_id FROM project_members pm JOIN projects p ON pm.project_id = p.id WHERE p.type <> ? AND pm.deployment_type = ? AND p.status IN ? AND (pm.end_date IS NULL OR pm.end_date > now() + INTERVAL '2 months') AND p.deleted_at IS NULL AND pm.deleted_at IS NULL )`, model.ProjectTypeDwarves, model.MemberDeploymentTypeOfficial, []string{ model.ProjectStatusOnBoarding.String(), model.ProjectStatusActive.String(), }). Where(`id IN ( SELECT e2.id FROM employees e2 LEFT JOIN employee_chapters ec ON ec.employee_id = e2.id LEFT JOIN chapters c ON ec.chapter_id = c.id WHERE ec.deleted_at IS NULL AND c.deleted_at IS NULL AND e2.deleted_at IS NULL AND (c.code IS NULL OR (c.code <> 'sales' AND c.code <> 'operations')) )`). Order("created_at, display_name"). Preload("Seniority", "deleted_at IS NULL"). Preload("EmployeePositions", "deleted_at IS NULL"). Preload("EmployeePositions.Position", "deleted_at IS NULL"). Preload("EmployeeStacks", "deleted_at IS NULL"). Preload("EmployeeStacks.Stack", "deleted_at IS NULL"). Preload("ProjectMembers", func(db *gorm.DB) *gorm.DB { return db.Joins("JOIN projects ON projects.id = project_members.project_id"). Where("project_members.deleted_at IS NULL"). Where("project_members.start_date <= now()"). Where("(project_members.end_date IS NULL OR project_members.end_date > now())"). Where("projects.status IN ?", []string{ model.ProjectStatusOnBoarding.String(), model.ProjectStatusActive.String(), }). Order("projects.name") }). Preload("ProjectMembers.Project", "deleted_at IS NULL"). Find(&employees).Error } func (s *store) GetResourceUtilization(db *gorm.DB, currentDate time.Time) ([]*model.ResourceUtilization, error) { var ru []*model.ResourceUtilization query := ` WITH resource_utilization AS ( SELECT d.d AS "date", e.id AS employee_id, p.id AS project_id, p."type" AS "project_type", pm.deployment_type, pm.start_date, pm.end_date AS pm_end_date, p.end_date AS p_end_date, e.left_date FROM employees e LEFT JOIN project_members pm ON pm.employee_id = e.id LEFT JOIN projects p ON pm.project_id = p.id, generate_series( date_trunc('month', TO_DATE(?, 'YYYY-MM-DD')) - INTERVAL '3 month', date_trunc('month', TO_DATE(?, 'YYYY-MM-DD')) + INTERVAL '3 month', '1 month' ) d WHERE e.deleted_at IS NULL AND pm.deleted_at IS NULL AND p.deleted_at IS NULL AND e.id IN ( SELECT e2.id FROM employees e2 LEFT JOIN employee_chapters ec ON ec.employee_id = e2.id LEFT JOIN chapters c ON ec.chapter_id = c.id WHERE ec.deleted_at IS NULL AND c.deleted_at IS NULL AND e2.deleted_at IS NULL AND (c.code IS NULL OR (c.code <> 'sales' AND c.code <> 'operations')) ) AND e.id IN ( SELECT eo.employee_id FROM employee_organizations eo JOIN organizations o ON eo.organization_id = o.id WHERE o.code = ? AND eo.deleted_at IS NULL AND o.deleted_at IS NULL ) ORDER BY d.d ) SELECT "date" , COUNT(DISTINCT(employee_id)) FILTER ( WHERE deployment_type = 'official' AND "project_type" != 'dwarves' AND start_date <= "date" AND (pm_end_date IS NULL OR pm_end_date > "date") AND (p_end_date IS NULL OR p_end_date > "date") AND (left_date IS NULL OR left_date > "date") ) AS staffed, COUNT(DISTINCT(employee_id)) FILTER ( WHERE start_date <= "date" AND (pm_end_date IS NULL OR pm_end_date > "date") AND employee_id NOT IN ( SELECT ru2.employee_id FROM resource_utilization ru2 WHERE ru2.deployment_type = 'official' AND ru2."project_type" != 'dwarves' AND ru2.start_date <= ru."date" AND (ru2.pm_end_date IS NULL OR ru2.pm_end_date > ru."date") AND (ru2.p_end_date IS NULL OR ru2.p_end_date > ru."date") AND (ru2.left_date IS NULL OR ru2.left_date > ru."date") ) AND (left_date IS NULL OR left_date > "date") ) AS internal, COUNT(DISTINCT(employee_id)) FILTER ( WHERE (project_id IS NULL OR employee_id NOT IN ( SELECT ru3.employee_id FROM resource_utilization ru3 WHERE ru3.start_date <= ru."date" AND (ru3.pm_end_date IS NULL OR ru3.pm_end_date > ru."date") AND (ru3.p_end_date IS NULL OR ru3.p_end_date > ru."date") AND (ru3.left_date IS NULL OR ru3.left_date > ru."date") )) AND (left_date IS NULL OR left_date > "date") ) AS available FROM resource_utilization ru GROUP BY "date" ` return ru, db.Raw(query, currentDate, currentDate, model.OrganizationCodeDwarves).Scan(&ru).Error } func (s *store) TotalWorkUnitDistribution(db *gorm.DB) (*model.TotalWorkUnitDistribution, error) { var rs *model.TotalWorkUnitDistribution query := ` WITH employee_data AS ( SELECT e.id, e.full_name, e.display_name, e.username, e.avatar, e.line_manager_id, o.code as organization_code FROM employees e LEFT JOIN employee_organizations eo on e.id = eo.employee_id LEFT JOIN organizations o on eo.organization_id = o.id WHERE e.deleted_at IS NULL AND o.code = 'dwarves-foundation' ), work_unit_info AS ( SELECT wum.employee_id, wu.type, COUNT(*) AS work_unit_count FROM work_units wu JOIN work_unit_members wum ON wu.id = wum.work_unit_id WHERE wum.status = 'active' AND wu.status = 'active' AND wum.deleted_at IS NULL AND wu.deleted_at IS NULL GROUP BY wum.employee_id, wu.type), count_work_unit_distribution AS ( SELECT e.id, e.full_name, e.display_name, e.username, e.avatar, (SELECT COUNT(*) FROM employee_data WHERE line_manager_id = e.id) AS line_manager_count, (SELECT COUNT(*) FROM project_heads ph WHERE (ph.position = 'technical-lead' OR ph.position = 'delivery-manager' OR ph.position = 'account-manager') AND ph.employee_id = e.id AND ph.end_date IS NULL) AS project_head_count, COALESCE(wui_learning.work_unit_count, 0) AS learning, COALESCE(wui_development.work_unit_count, 0) AS development, COALESCE(wui_management.work_unit_count, 0) AS management, COALESCE(wui_training.work_unit_count, 0) AS training FROM employee_data e LEFT JOIN work_unit_info wui_learning ON e.id = wui_learning.employee_id AND wui_learning.type = 'learning' LEFT JOIN work_unit_info wui_development ON e.id = wui_development.employee_id AND wui_development.type = 'development' LEFT JOIN work_unit_info wui_management ON e.id = wui_management.employee_id AND wui_management.type = 'management' LEFT JOIN work_unit_info wui_training ON e.id = wui_training.employee_id AND wui_training.type = 'training') SELECT SUM(line_manager_count) AS total_line_manager, SUM(project_head_count) AS total_project_head, SUM(learning) AS total_learning, SUM(development) AS total_development, SUM(management) AS total_management, SUM(training) AS total_training FROM count_work_unit_distribution ` return rs, db.Raw(query).Scan(&rs).Error } func (s *store) GetAllWorkReviews(db *gorm.DB, keyword string, pagination model.Pagination) ([]*model.EmployeeEventReviewer, error) { var eer []*model.EmployeeEventReviewer query := db.Table("employee_event_reviewers"). Joins(`JOIN feedback_events fe ON employee_event_reviewers.event_id = fe.id AND fe.deleted_at IS NULL AND fe.subtype = ? AND fe.start_date > now() - INTERVAL '70 DAYS'`, model.EventSubtypeWork). // last 10 weeks Joins("JOIN employee_event_topics eet ON employee_event_reviewers.employee_event_topic_id = eet.id"). Joins("JOIN employees e ON employee_event_reviewers.reviewer_id = e.id AND e.deleted_at IS NULL") limit, offset := pagination.ToLimitOffset() if keyword != "" { query = query.Where("e.keyword_vector @@ plainto_tsquery('english_nostop', fn_remove_vietnamese_accents(LOWER(?)))", keyword) } query = query.Where("employee_event_reviewers.reviewer_status = ?", model.EventReviewerStatusDone) return eer, query.Order("fe.end_date, employee_event_reviewers.reviewer_id, eet.project_id"). Preload("Event", "deleted_at IS NULL"). Preload("Reviewer", "deleted_at IS NULL"). Preload("EmployeeEventQuestions", "deleted_at IS NULL"). Preload("EmployeeEventTopic", "deleted_at IS NULL"). Preload("EmployeeEventTopic.Project", "deleted_at IS NULL"). Limit(limit). Offset(offset). Find(&eer).Error } func (s *store) GetProjectHeadByEmployeeID(db *gorm.DB, employeeID string) ([]*model.ManagementInfo, error) { var rs []*model.ManagementInfo query := ` SELECT projects.id, projects.name, projects.code, projects.type, projects.status, projects.avatar, ph.position FROM projects JOIN project_heads AS ph ON projects.id = ph.project_id WHERE ph.employee_id = ? AND projects.status IN (?, ?) ` return rs, db.Raw(query, employeeID, model.ProjectStatusActive, model.ProjectStatusOnBoarding).Scan(&rs).Error } func (s *store) GetWorkUnitDistributionEmployees(db *gorm.DB, keyword string, workUnitType string) ([]*model.Employee, error) { var employees []*model.Employee query := db.Table("employees") if keyword != "" { query = query.Where("keyword_vector @@ plainto_tsquery('english_nostop', fn_remove_vietnamese_accents(LOWER(?)))", keyword) } query = query.Where("deleted_at IS NULL"). Where("working_status IN ?", []string{ model.WorkingStatusFullTime.String(), model.WorkingStatusContractor.String(), }). Order("display_name ASC") // preload mentees if workUnitType == "" || workUnitType == model.WorkUnitTypeTraining.String() { query = query.Preload("Mentees", "deleted_at IS NULL AND working_status IN ?", []string{ model.WorkingStatusFullTime.String(), model.WorkingStatusContractor.String(), }) } // preload project heads if workUnitType == "" || workUnitType == model.WorkUnitTypeManagement.String() { query = query.Preload("Heads", func(db *gorm.DB) *gorm.DB { return db.Joins("JOIN projects p ON project_heads.project_id = p.id"). Where("(project_heads.start_date IS NULL OR project_heads.start_date <= now())"). Where("(project_heads.end_date IS NULL OR project_heads.end_date > now())"). Where("p.status IN ?", []string{ model.ProjectStatusActive.String(), model.ProjectStatusOnBoarding.String(), }). Where("project_heads.deleted_at IS NULL"). Where("p.deleted_at IS NULL") }).Preload("Heads.Project", "deleted_at IS NULL") } // preload work units query = query.Preload("WorkUnitMembers", func(db *gorm.DB) *gorm.DB { db = db. Joins("JOIN work_units wu ON wu.id = work_unit_members.work_unit_id"). Joins("JOIN projects p ON p.id = wu.project_id"). Joins("JOIN project_members pm ON pm.project_id = work_unit_members.project_id AND pm.employee_id = work_unit_members.employee_id"). Where("wu.status = ?", model.WorkUnitStatusActive). Where("p.status IN ?", []string{ model.ProjectStatusActive.String(), model.ProjectStatusOnBoarding.String(), }). Where("pm.start_date <= now() AND (pm.end_date IS NULL OR pm.end_date > now())"). Where("p.deleted_at IS NULL"). Where("pm.deleted_at IS NULL"). Where("wu.deleted_at IS NULL"). Where("work_unit_members.deleted_at IS NULL") if workUnitType != "" { db = db.Where("wu.type = ?", workUnitType) } return db }). Preload("WorkUnitMembers.WorkUnit"). Preload("WorkUnitMembers.WorkUnit.Project") return employees, query.Find(&employees).Error }
```

# pkg/store/dashboard/interface.go

```go
package dashboard import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { GetProjectSizes(db *gorm.DB) (res []*model.ProjectSize, err error) GetWorkSurveysByProjectID(db *gorm.DB, projectID string) ([]*model.WorkSurvey, error) GetAllWorkSurveys(db *gorm.DB) ([]*model.WorkSurvey, error) GetActionItemReportsByProjectNotionID(db *gorm.DB, projectID string) ([]*model.ActionItemReport, error) GetAllActionItemReports(db *gorm.DB) ([]*model.ActionItemReport, error) AverageEngineeringHealth(db *gorm.DB) ([]*model.AverageEngineeringHealth, error) GroupEngineeringHealth(db *gorm.DB) ([]*model.GroupEngineeringHealth, error) AverageEngineeringHealthByProjectNotionID(db *gorm.DB, projectID string) ([]*model.AverageEngineeringHealth, error) GroupEngineeringHealthByProjectNotionID(db *gorm.DB, projectID string) ([]*model.GroupEngineeringHealth, error) GetAverageAudit(db *gorm.DB) ([]*model.AverageAudit, error) GetGroupAudit(db *gorm.DB) ([]*model.GroupAudit, error) GetActionItemSquashReportsByProjectID(db *gorm.DB, projectID string) ([]*model.ActionItemSquashReport, error) GetAllActionItemSquashReports(db *gorm.DB) ([]*model.ActionItemSquashReport, error) GetAverageAuditByProjectNotionID(db *gorm.DB, projectID string) ([]*model.AverageAudit, error) GetGroupAuditByProjectNotionID(db *gorm.DB, projectID string) ([]*model.GroupAudit, error) GetAuditSummaries(db *gorm.DB) ([]*model.AuditSummary, error) GetProjectSizesByStartTime(db *gorm.DB, curr time.Time) ([]*model.ProjectSize, error) GetPendingSlots(db *gorm.DB) ([]*model.ProjectSlot, error) GetAvailableEmployees(db *gorm.DB) ([]*model.Employee, error) GetResourceUtilization(db *gorm.DB, currentDate time.Time) ([]*model.ResourceUtilization, error) TotalWorkUnitDistribution(db *gorm.DB) (*model.TotalWorkUnitDistribution, error) GetAllWorkReviews(db *gorm.DB, keyword string, pagination model.Pagination) ([]*model.EmployeeEventReviewer, error) GetProjectHeadByEmployeeID(db *gorm.DB, employeeID string) ([]*model.ManagementInfo, error) GetWorkUnitDistributionEmployees(db *gorm.DB, keyword string, workUnitType string) ([]*model.Employee, error) }
```

# pkg/store/deliverymetric/delivery_metric.go

```go
package deliverymetric import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get delivery metrict by id func (s *store) One(db *gorm.DB, id string) (*model.DeliveryMetric, error) { var rs *model.DeliveryMetric return rs, db.Where("id = ?", id).First(&rs).Error } // Create creates a new delivery metric func (s *store) Create(db *gorm.DB, e []model.DeliveryMetric) (rs []model.DeliveryMetric, err error) { return e, db.Create(&e).Error } func (s *store) GetLatestWeek(db *gorm.DB) (*time.Time, error) { var rs *time.Time return rs, db.Model(&model.DeliveryMetric{}).Select("date").Order("date DESC").Limit(1).First(&rs).Error } func (s *store) GetLatestMonth(db *gorm.DB) (*time.Time, error) { var rs *time.Time return rs, db.Model(&model.DeliveryMetric{}).Select("DATE_TRUNC('month', date)").Order("date DESC").Limit(1).First(&rs).Error } func (s *store) GetTopWeighMetrics(db *gorm.DB, w *time.Time, limit int) ([]model.TopWeightMetric, error) { var rs []model.TopWeightMetric return rs, db.Raw(`SELECT employee_id, "date", SUM(weight) AS sum_weight, SUM(effort) AS sum_effort FROM delivery_metrics WHERE "date" = ? GROUP BY employee_id, "date" ORDER BY sum_weight DESC, sum_effort ASC LIMIT ?;`, w, limit).Find(&rs).Error } func (s *store) GetTopMonthlyWeighMetrics(db *gorm.DB, month *time.Time, limit int) ([]model.DeliveryMetric, error) { var rs []model.DeliveryMetric return rs, db.Raw(`SELECT DATE_TRUNC('month', m.date) AS "date", m.employee_id, SUM(m.weight) AS "weight", SUM(m.effort) AS "effort", AVG(m.effectiveness) AS "effectiveness" FROM delivery_metrics m WHERE DATE_TRUNC('month', m.date) = ? GROUP BY employee_id, DATE_TRUNC('month', m.date) ORDER BY "date" DESC, "weight" DESC, "effort" DESC LIMIT ?;`, month, limit).Find(&rs).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.DeliveryMetric, updatedFields ...string) (*model.DeliveryMetric, error) { rs := model.DeliveryMetric{} return &rs, db.Model(&rs).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // GetLatest get latest delivery metric by id func (s *store) GetLatest(db *gorm.DB) (*model.DeliveryMetric, error) { var rs *model.DeliveryMetric return rs, db.Order("ref DESC").Limit(1).First(&rs).Error }
```

# pkg/store/deliverymetric/interface.go

```go
package deliverymetric import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (client *model.DeliveryMetric, err error) GetLatest(db *gorm.DB) (*model.DeliveryMetric, error) GetLatestWeek(db *gorm.DB) (*time.Time, error) GetLatestMonth(db *gorm.DB) (*time.Time, error) GetTopWeighMetrics(db *gorm.DB, w *time.Time, limit int) ([]model.TopWeightMetric, error) GetTopMonthlyWeighMetrics(db *gorm.DB, m *time.Time, limit int) ([]model.DeliveryMetric, error) Create(db *gorm.DB, e []model.DeliveryMetric) (rs []model.DeliveryMetric, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, client model.DeliveryMetric, updatedFields ...string) (a *model.DeliveryMetric, err error) }
```

# pkg/store/deliverymetricmonthly/get.go

```go
package deliverymetricmonthly import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get delivery metrict by id func (s *store) One(db *gorm.DB, id string) (*model.DeliveryMetric, error) { var rs *model.DeliveryMetric return rs, db.Where("id = ?", id).First(&rs).Error } func (s *store) GetLast(db *gorm.DB, num int) ([]model.MonthlyDeliveryMetric, error) { var rs []model.MonthlyDeliveryMetric return rs, db.Table("vw_monthly_delivery_metrics").Order("month desc").Limit(num).Find(&rs).Error } func (s *store) AvgTo(db *gorm.DB, maxMonth *time.Time) (model.AvgMonthlyDeliveryMetric, error) { var rs model.AvgMonthlyDeliveryMetric return rs, db.Raw(`SELECT AVG(sum_weight) AS weight, AVG(sum_effort) AS effort FROM vw_monthly_delivery_metrics WHERE "month" <= ?;`, maxMonth).Scan(&rs).Error } // Create creates a new delivery metric func (s *store) Create(db *gorm.DB, e *model.DeliveryMetric) (rs *model.DeliveryMetric, err error) { return e, db.Create(e).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.DeliveryMetric, updatedFields ...string) (*model.DeliveryMetric, error) { rs := model.DeliveryMetric{} return &rs, db.Model(&rs).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error }
```

# pkg/store/deliverymetricmonthly/interface.go

```go
package deliverymetricmonthly import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { GetLast(db *gorm.DB, num int) ([]model.MonthlyDeliveryMetric, error) AvgTo(db *gorm.DB, maxMonth *time.Time) (model.AvgMonthlyDeliveryMetric, error) }
```

# pkg/store/deliverymetricweekly/get.go

```go
package deliverymetricweekly import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get delivery metrict by id func (s *store) One(db *gorm.DB, id string) (*model.DeliveryMetric, error) { var rs *model.DeliveryMetric return rs, db.Where("id = ?", id).First(&rs).Error } func (s *store) GetLast(db *gorm.DB, num int) ([]model.WeeklyDeliveryMetric, error) { var rs []model.WeeklyDeliveryMetric return rs, db.Table("vw_weekly_delivery_metrics").Order("date desc").Limit(num).Find(&rs).Error } func (s *store) Avg(db *gorm.DB) (model.AvgWeeklyDeliveryMetric, error) { var rs model.AvgWeeklyDeliveryMetric return rs, db.Raw(`SELECT AVG(sum_weight) AS weight, AVG(sum_effort) AS effort FROM vw_weekly_delivery_metrics;`).Scan(&rs).Error } func (s *store) AvgWithoutLatestWeek(db *gorm.DB) (model.AvgWeeklyDeliveryMetric, error) { var rs model.AvgWeeklyDeliveryMetric return rs, db.Raw(`SELECT AVG(sum_weight) AS weight, AVG(sum_effort) AS effort FROM vw_weekly_delivery_metrics WHERE date != (SELECT MAX(date) FROM delivery_metrics);`).Scan(&rs).Error } func (s *store) AvgByMonth(db *gorm.DB, month time.Time) ([]model.AvgMonthWeeklyDeliveryMetric, error) { var rs []model.AvgMonthWeeklyDeliveryMetric return rs, db.Raw(`SELECT DATE_TRUNC('month', date) AS "month", AVG(sum_weight) AS "weight", AVG(sum_effort) AS "effort" FROM vw_weekly_delivery_metrics GROUP BY DATE_TRUNC('month', date) HAVING DATE_TRUNC('month', date) = ? ORDER BY "month" DESC;`, month).Scan(&rs).Error } // Create creates a new delivery metric func (s *store) Create(db *gorm.DB, e *model.DeliveryMetric) (rs *model.DeliveryMetric, err error) { return e, db.Create(e).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.DeliveryMetric, updatedFields ...string) (*model.DeliveryMetric, error) { rs := model.DeliveryMetric{} return &rs, db.Model(&rs).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error }
```

# pkg/store/deliverymetricweekly/interface.go

```go
package deliverymetricweekly import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { GetLast(db *gorm.DB, num int) ([]model.WeeklyDeliveryMetric, error) Avg(db *gorm.DB) (model.AvgWeeklyDeliveryMetric, error) AvgWithoutLatestWeek(db *gorm.DB) (model.AvgWeeklyDeliveryMetric, error) AvgByMonth(db *gorm.DB, month time.Time) ([]model.AvgMonthWeeklyDeliveryMetric, error) }
```

# pkg/store/discordaccount/discord_account.go

```go
package discordaccount import ( "gorm.io/gorm" "gorm.io/gorm/clause" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct { } func New() IStore { return &store{} } func (r *store) Upsert(db *gorm.DB, da *model.DiscordAccount) (*model.DiscordAccount, error) { return da, db. Table("discord_accounts"). Clauses( clause.OnConflict{ Columns: []clause.Column{ {Name: "discord_id"}, }, DoUpdates: clause.Assignments( map[string]interface{}{ "discord_username": da.DiscordUsername, "roles": da.Roles, "github_username": da.GithubUsername, "personal_email": da.PersonalEmail, }, ), }, ). Create(da). Error } func (r *store) All(db *gorm.DB) ([]*model.DiscordAccount, error) { var res []*model.DiscordAccount return res, db.Find(&res).Error } func (r *store) One(db *gorm.DB, id string) (*model.DiscordAccount, error) { res := model.DiscordAccount{} return &res, db.Where("id = ?", id).First(&res).Error } func (r *store) OneByDiscordID(db *gorm.DB, discordID string) (*model.DiscordAccount, error) { res := model.DiscordAccount{} return &res, db.Where("discord_id = ?", discordID).First(&res).Error } func (r *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.DiscordAccount, updatedFields ...string) (a *model.DiscordAccount, err error) { discordAccount := model.DiscordAccount{} return &discordAccount, db.Model(&discordAccount).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // ListByMemoUsername gets a list of discord accounts by memo usernames, if memo username is not found, it will try to find by discord username func (r *store) ListByMemoUsername(db *gorm.DB, usernames []string) ([]model.DiscordAccount, error) { var cms []model.DiscordAccount err := db.Where("memo_username IN (?) OR discord_username IN (?)", usernames, usernames).Find(&cms).Error return cms, err }
```

# pkg/store/discordaccount/interface.go

```go
package discordaccount import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB) (discordAccounts []*model.DiscordAccount, err error) One(db *gorm.DB, id string) (*model.DiscordAccount, error) OneByDiscordID(db *gorm.DB, discordID string) (*model.DiscordAccount, error) Upsert(db *gorm.DB, da *model.DiscordAccount) (*model.DiscordAccount, error) UpdateSelectedFieldsByID(db *gorm.DB, id string, client model.DiscordAccount, updatedFields ...string) (a *model.DiscordAccount, err error) // ListByMemoUsername gets a list of discord accounts by memo usernames ListByMemoUsername(db *gorm.DB, usernames []string) ([]model.DiscordAccount, error) }
```

# pkg/store/discordevent/discord_event.go

```go
package discordevent import ( "gorm.io/gorm" "gorm.io/gorm/clause" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get client by id func (s *store) One(db *gorm.DB, query *Query) (*model.Event, error) { var e *model.Event if query.ID != "" { db = db.Where("id = ?", query.ID) } if query.DiscordEventID != "" { db = db.Where("discord_event_id = ?", query.DiscordEventID) } return e, db.Preload("EventSpeakers").First(&e).Error } // All get all client func (s *store) All(db *gorm.DB, q *Query, preload bool) ([]*model.Event, error) { var e []*model.Event if q.Limit == 0 { q.Limit = 10 } query := db.Order("date desc").Limit(q.Limit) if q.After != nil { query = query.Where("date > ?", q.After) } if len(q.DiscordEventIDs) > 0 { query = query.Where("discord_event_id IN (?)", q.DiscordEventIDs) } if !preload { return e, query.Find(&e).Error } return e, query.Preload("EventSpeakers").Find(&e).Order("date desc").Error } // Create creates a new e func (s *store) Create(db *gorm.DB, e *model.Event) (*model.Event, error) { return e, db.Create(e).Error } func (s *store) SetSpeakers(db *gorm.DB, e *model.Event) error { for _, es := range e.EventSpeakers { if es.DiscordAccountID.String() == "" { continue } // upsert speaker if err := db.Clauses( clause.OnConflict{ Columns: []clause.Column{ {Name: "discord_account_id"}, {Name: "event_id"}, }, DoUpdates: clause.Assignments( map[string]interface{}{ "topic": es.Topic, }, ), }, ).Create(es).Error; err != nil { return err } } return nil }
```

# pkg/store/discordevent/interface.go

```go
package discordevent import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, query *Query) (e *model.Event, err error) All(db *gorm.DB, query *Query, preload bool) ([]*model.Event, error) Create(db *gorm.DB, e *model.Event) (de *model.Event, err error) SetSpeakers(db *gorm.DB, e *model.Event) error } // Query present invoice query from user type Query struct { ID string DiscordEventID string // For querying by single ID DiscordEventIDs []string // For filter by multiple IDs EventTypes []model.EventType Limit int Offset int After *time.Time }
```

# pkg/store/discordtemplate/discord_template.go

```go
package discordtemplate import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct { } func New() IStore { return &store{} } func (s *store) GetTemplateByType(db *gorm.DB, templateType string) (*model.DiscordLogTemplate, error) { var template *model.DiscordLogTemplate return template, db.Where("type = ?", templateType).First(&template).Error }
```

# pkg/store/discordtemplate/interface.go

```go
package discordtemplate import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { GetTemplateByType(db *gorm.DB, templateType string) (*model.DiscordLogTemplate, error) }
```

# pkg/store/employee/employee.go

```go
package employee import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get 1 employee by id func (s *store) One(db *gorm.DB, id string, preload bool) (*model.Employee, error) { query := db if !model.IsUUIDFromString(id) { query = db.Where("username = ?", id) } else { query = db.Where("id = ?", id) } query = query.Preload("EmployeeRoles", func(db *gorm.DB) *gorm.DB { return db.Joins("employee_roles JOIN roles ON roles.id = employee_roles.role_id"). Where("employee_roles.deleted_at IS NULL"). Order("roles.level") }). Preload("EmployeeRoles.Role", "deleted_at IS NULL"). Preload("SocialAccounts", "deleted_at IS NULL"). Preload("DiscordAccount", "deleted_at IS NULL"). Preload("Referrer", "deleted_at IS NULL") if preload { query = query. Preload("ProjectMembers", "deleted_at IS NULL"). Preload("ProjectMembers.Project", "deleted_at IS NULL"). Preload("ProjectMembers.ProjectMemberPositions", "deleted_at IS NULL"). Preload("ProjectMembers.ProjectMemberPositions.Position", "deleted_at IS NULL"). Preload("EmployeePositions", "deleted_at IS NULL"). Preload("EmployeePositions.Position", "deleted_at IS NULL"). Preload("EmployeeStacks", "deleted_at IS NULL"). Preload("EmployeeStacks.Stack", "deleted_at IS NULL"). Preload("EmployeeChapters", "deleted_at IS NULL"). Preload("EmployeeChapters.Chapter", "deleted_at IS NULL"). Preload("EmployeeOrganizations", "deleted_at IS NULL"). Preload("EmployeeOrganizations.Organization", "deleted_at IS NULL"). Preload("Seniority"). Preload("LineManager"). Preload("BaseSalary"). Preload("BaseSalary.Currency") } var employee *model.Employee return employee, query.First(&employee).Error } // OneByEmail get 1 employee by team email or personal email func (s *store) OneByEmail(db *gorm.DB, email string) (*model.Employee, error) { var employee *model.Employee return employee, db.Where("NULLIF(TRIM(team_email), '') = ? OR NULLIF(TRIM(personal_email), '') = ?", email, email).First(&employee).Error } // OneByNotionID get 1 employee by notion id func (s *store) OneByNotionID(db *gorm.DB, notionID string) (*model.Employee, error) { var employee *model.Employee return employee, db.Where(`id IN ( SELECT sa.employee_id FROM social_accounts sa WHERE sa.account_id = ? AND sa.type = ? )`, notionID, model.SocialAccountTypeNotion).First(&employee).Error } // OneByBasecampID get 1 employee by basecampID func (s *store) OneByBasecampID(db *gorm.DB, basecampID int) (*model.Employee, error) { var employee *model.Employee return employee, db.Where("basecamp_id = ?", basecampID).First(&employee).Error } // All get employees by query and pagination func (s *store) All(db *gorm.DB, filter EmployeeFilter, pagination model.Pagination) ([]*model.Employee, int64, error) { var total int64 var employees []*model.Employee query := db.Table("employees").Distinct("ON(employees.id) employees.*") query = getByWhereConditions(query, filter) err := db.Raw("SELECT COUNT(*) FROM (?) res", query).Scan(&total).Error if err != nil { return nil, 0, err } query = getByFieldSort(db, query, "employees.joined_date", filter.JoinedDateSort). Preload("SocialAccounts", "deleted_at IS NULL"). Preload("DiscordAccount", "deleted_at IS NULL") if filter.Preload { query = query. Preload("LineManager", "deleted_at IS NULL"). Preload("Referrer", "deleted_at IS NULL"). Preload("Seniority", "deleted_at IS NULL"). Preload("ProjectMembers", func(db *gorm.DB) *gorm.DB { return db.Joins("JOIN projects ON projects.id = project_members.project_id"). Where("project_members.deleted_at IS NULL"). Where("project_members.start_date <= now()"). Where("(project_members.end_date IS NULL OR project_members.end_date > now())"). Where("projects.status IN ?", []string{ model.ProjectStatusOnBoarding.String(), model.ProjectStatusActive.String(), }). Order("projects.name") }). Preload("ProjectMembers.Project", "deleted_at IS NULL"). Preload("ProjectMembers.Project.Heads", "deleted_at IS NULL"). Preload("EmployeePositions", "deleted_at IS NULL"). Preload("EmployeePositions.Position", "deleted_at IS NULL"). Preload("EmployeeRoles", "deleted_at IS NULL"). Preload("EmployeeRoles.Role", "deleted_at IS NULL"). Preload("EmployeeChapters", "deleted_at IS NULL"). Preload("EmployeeChapters.Chapter", "deleted_at IS NULL"). Preload("EmployeeStacks", "deleted_at IS NULL"). Preload("EmployeeStacks.Stack", "deleted_at IS NULL"). Preload("EmployeeOrganizations", func(db *gorm.DB) *gorm.DB { return db.Joins("JOIN organizations ON organizations.id = employee_organizations.organization_id"). Where("employee_organizations.deleted_at IS NULL"). Order("organizations.code DESC") }). Preload("EmployeeOrganizations.Organization", "deleted_at IS NULL"). Preload("BaseSalary"). Preload("BaseSalary.Currency") } limit, offset := pagination.ToLimitOffset() if pagination.Page > 0 { query = query.Limit(limit) } return employees, total, query. Limit(limit). Offset(offset). Find(&employees).Error } func (s *store) Create(db *gorm.DB, e *model.Employee) (employee *model.Employee, err error) { return e, db.Create(e).Error } // IsExist check the existence of employee func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM employees WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, employee *model.Employee) (*model.Employee, error) { return employee, db.Model(&employee).Where("id = ?", employee.ID).Updates(&employee).First(&employee).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Employee, updatedFields ...string) (*model.Employee, error) { employee := model.Employee{} return &employee, db.Model(&employee).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // GetByIDs return list employee by IDs func (s *store) GetByIDs(db *gorm.DB, ids []model.UUID) ([]*model.Employee, error) { var employees []*model.Employee return employees, db.Where("id IN ?", ids).Order("created_at").Find(&employees).Error } // GetByWorkingStatus return list employee by working status func (s *store) GetByWorkingStatus(db *gorm.DB, workingStatus model.WorkingStatus) ([]*model.Employee, error) { var employees []*model.Employee return employees, db.Where("working_status = ?", workingStatus). Preload("Organizations", "deleted_at IS NULL"). Find(&employees).Error } func (s *store) GetLineManagers(db *gorm.DB) ([]*model.Employee, error) { var employees []*model.Employee return employees, db.Where(`id IN ( SELECT e.line_manager_id FROM employees e WHERE e.deleted_at IS NULL AND e.working_status != ? AND (e.left_date IS NULL OR e.left_date >= now()) )`, model.WorkingStatusLeft).Find(&employees).Error } func (s *store) GetLineManagersOfPeers(db *gorm.DB, employeeID string) ([]*model.Employee, error) { var employees []*model.Employee return employees, db.Where(`id IN ( SELECT e.line_manager_id FROM employees e JOIN project_members pm ON pm.employee_id = e.id WHERE e.deleted_at IS NULL AND e.working_status != ? AND (e.left_date IS NULL OR e.left_date >= now()) AND pm.project_id IN ( SELECT pm2.project_id FROM project_members pm2 WHERE pm2.employee_id = employees.id ) )`, model.WorkingStatusLeft).Find(&employees).Error } func (s *store) GetMenteesByID(db *gorm.DB, employeeID string) ([]*model.Employee, error) { var employees []*model.Employee return employees, db.Where(`id IN ( SELECT e.id FROM employees e WHERE e.deleted_at IS NULL AND e.line_manager_id = ? AND e.working_status <> ? AND (e.left_date IS NULL OR e.left_date >= now()) )`, employeeID, model.WorkingStatusLeft). Preload("EmployeePositions", "deleted_at IS NULL"). Preload("EmployeePositions.Position", "deleted_at IS NULL"). Preload("Seniority"). Find(&employees).Error } func (s *store) GetByEmails(db *gorm.DB, emails []string) ([]*model.Employee, error) { var employees []*model.Employee return employees, db.Where("NULLIF(TRIM(team_email), '') IN ? OR NULLIF(TRIM(personal_email), '') IN ?", emails, emails).Find(&employees).Error } func (s *store) GetByBasecampIDs(db *gorm.DB, basecampIDs []int) ([]*model.Employee, error) { var employees []*model.Employee return employees, db.Where("basecamp_id IN ?", basecampIDs).Find(&employees).Error } func (s *store) GetByDiscordID(db *gorm.DB, discordID string, preload bool) (*model.Employee, error) { var employee *model.Employee query := db.Joins("JOIN discord_accounts ON discord_accounts.id = employees.discord_account_id AND discord_accounts.discord_id = ?", discordID). Where("employees.deleted_at IS NULL AND employees.working_status <> ?", model.WorkingStatusLeft) if preload { query = query. Preload("Roles"). Preload("SocialAccounts", "deleted_at IS NULL"). Preload("DiscordAccount", "deleted_at IS NULL"). Preload("ProjectMembers", "deleted_at IS NULL"). Preload("ProjectMembers.Project", "deleted_at IS NULL"). Preload("EmployeePositions", "deleted_at IS NULL"). Preload("EmployeePositions.Position", "deleted_at IS NULL"). Preload("EmployeeStacks", "deleted_at IS NULL"). Preload("EmployeeStacks.Stack", "deleted_at IS NULL"). Preload("EmployeeMMAScores", func(db *gorm.DB) *gorm.DB { return db.Order("rated_at DESC").Limit(1) }). Preload("Seniority") } return employee, query.First(&employee).Error } func (s *store) GetByDiscordUsername(db *gorm.DB, discordUsername string) (*model.Employee, error) { var employee *model.Employee query := db.Joins("JOIN discord_accounts ON discord_accounts.id = employees.discord_account_id AND discord_accounts.username = ?", discordUsername). Where("employees.deleted_at IS NULL AND employees.working_status <> ?", model.WorkingStatusLeft). Preload("SocialAccounts", "deleted_at IS NULL"). Preload("DiscordAccount", "deleted_at IS NULL") err := query.First(&employee).Error if err != nil { return nil, err } return employee, nil } func (s *store) ListByDiscordRequest(db *gorm.DB, in DiscordRequestFilter, preload bool) ([]model.Employee, error) { var employee []model.Employee query := db.Where("employees.deleted_at IS NULL AND employees.working_status <> ?", model.WorkingStatusLeft).Order("employees.joined_date DESC") if len(in.DiscordID) > 0 { query = query.Joins("JOIN discord_accounts ON discord_accounts.id = employees.discord_account_id AND discord_accounts.discord_id IN (?)", in.DiscordID) } if in.Email != "" { query = query.Where("employees.team_email = ? OR employees.personal_email = ?", in.Email, in.Email) } if in.Keyword != "" { query = query.Where(`employees.keyword_vector @@ plainto_tsquery('english_nostop', fn_remove_vietnamese_accents(LOWER(?))) OR employees.id IN ( SELECT sa.employee_id FROM social_accounts sa WHERE sa.account_id = ? AND sa.type = ?) `, in.Keyword, in.Keyword, model.SocialAccountTypeGitHub) } if preload { query = query. Preload("SocialAccounts", "deleted_at IS NULL"). Preload("DiscordAccount", "deleted_at IS NULL"). Preload("ProjectMembers", "deleted_at IS NULL"). Preload("ProjectMembers.Project", "deleted_at IS NULL"). Preload("EmployeePositions", "deleted_at IS NULL"). Preload("EmployeePositions.Position", "deleted_at IS NULL"). Preload("EmployeeStacks", "deleted_at IS NULL"). Preload("EmployeeStacks.Stack", "deleted_at IS NULL"). Preload("EmployeeMMAScores", func(db *gorm.DB) *gorm.DB { return db.Order("rated_at DESC").Limit(1) }). Preload("Seniority") } return employee, query.Find(&employee).Error } // SimpleList get employees by query and pagination func (s *store) SimpleList(db *gorm.DB) ([]*model.Employee, error) { var employees []*model.Employee query := db.Where("deleted_at IS NULL AND working_status <> ?", model.WorkingStatusLeft). Order("created_at"). Preload("DiscordAccount", "deleted_at IS NULL"). Preload("EmployeeChapters", "deleted_at IS NULL"). Preload("EmployeeChapters.Chapter", "deleted_at IS NULL") return employees, query.Find(&employees).Error } func (s *store) GetRawList(db *gorm.DB, filter EmployeeFilter) ([]model.Employee, error) { var employees []model.Employee query := db if filter.WorkingStatuses != nil { query = query.Where("working_status IN ?", filter.WorkingStatuses) } return employees, query.Find(&employees).Error } // ListWithMMAScore get employees with latest mma score func (s *store) ListWithMMAScore(db *gorm.DB) ([]model.EmployeeMMAScoreData, error) { var employees []model.EmployeeMMAScoreData query := ` SELECT e.id AS employee_id, e.full_name, m.id AS mma_id, m.mastery_score, m.autonomy_score, m.meaning_score, m.rated_at FROM employees e LEFT JOIN ( SELECT id, employee_id, mastery_score, autonomy_score, meaning_score, rated_at FROM employee_mma_scores WHERE (employee_id, rated_at) IN ( SELECT employee_id, MAX(rated_at) AS rated_at FROM employee_mma_scores GROUP BY employee_id ) ) m ON e.id = m.employee_id WHERE e.deleted_at IS NULL AND e.working_status <> ? ORDER BY e.joined_date DESC ` return employees, db.Raw(query, model.WorkingStatusLeft).Scan(&employees).Error }
```

# pkg/store/employee/interface.go

```go
package employee import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB, input EmployeeFilter, pagination model.Pagination) (employees []*model.Employee, total int64, err error) Create(db *gorm.DB, e *model.Employee) (employee *model.Employee, err error) One(db *gorm.DB, id string, preload bool) (employee *model.Employee, err error) OneByEmail(db *gorm.DB, email string) (*model.Employee, error) OneByNotionID(db *gorm.DB, notionID string) (employee *model.Employee, err error) OneByBasecampID(db *gorm.DB, basecampID int) (employee *model.Employee, err error) GetByIDs(db *gorm.DB, ids []model.UUID) (employees []*model.Employee, err error) GetByEmails(db *gorm.DB, emails []string) (employees []*model.Employee, err error) GetByBasecampIDs(db *gorm.DB, basecampIDs []int) (employees []*model.Employee, err error) GetByWorkingStatus(db *gorm.DB, workingStatus model.WorkingStatus) ([]*model.Employee, error) GetLineManagers(db *gorm.DB) ([]*model.Employee, error) GetLineManagersOfPeers(db *gorm.DB, employeeID string) ([]*model.Employee, error) GetMenteesByID(db *gorm.DB, employeeID string) ([]*model.Employee, error) GetByDiscordID(db *gorm.DB, discordID string, preload bool) (*model.Employee, error) GetByDiscordUsername(db *gorm.DB, discordUsername string) (*model.Employee, error) ListByDiscordRequest(db *gorm.DB, in DiscordRequestFilter, preload bool) ([]model.Employee, error) ListWithMMAScore(db *gorm.DB) ([]model.EmployeeMMAScoreData, error) SimpleList(db *gorm.DB) ([]*model.Employee, error) GetRawList(db *gorm.DB, filter EmployeeFilter) ([]model.Employee, error) IsExist(db *gorm.DB, id string) (bool, error) Update(db *gorm.DB, employee *model.Employee) (*model.Employee, error) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Employee, updatedFields ...string) (*model.Employee, error) }
```

# pkg/store/employee/request.go

```go
package employee import ( "time" "github.com/dwarvesf/fortress-api/pkg/model" ) type EmployeeFilter struct { WorkingStatuses []string Preload bool Positions []string Stacks []string Projects []string Chapters []string Seniorities []string Organizations []string LineManagers []string Keyword string IsLeft *bool BatchDate *time.Time //field sort JoinedDateSort model.SortOrder } type DiscordRequestFilter struct { DiscordID []string Email string Keyword string }
```

# pkg/store/employee/util.go

```go
package employee import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) func getByWhereConditions(query *gorm.DB, filter EmployeeFilter) *gorm.DB { if len(filter.WorkingStatuses) > 0 { query = query.Where("working_status IN ?", filter.WorkingStatuses) } if len(filter.Positions) > 0 { if len(filter.Positions) == 1 { if filter.Positions[0] == "-" { query = query.Joins(`LEFT JOIN employee_positions ep ON employees.id = ep.employee_id`).Where("ep.id IS NULL") } else { query = query.Joins(`JOIN employee_positions ep ON employees.id = ep.employee_id`).Joins(`JOIN positions po ON ep.position_id = po.id`). Where("po.code = ? AND ep.deleted_at IS NULL", filter.Positions[0]) } } if len(filter.Positions) > 1 { if filter.Positions[0] == "-" { query = query.Joins(`LEFT JOIN employee_positions ep ON employees.id = ep.employee_id`). Joins(`LEFT JOIN positions po ON ep.position_id = po.id`). Where(`ep.id IS NULL OR (po.code IN ? AND ep.deleted_at IS NULL)`, filter.Positions[1:]) } else { query = query.Joins(`JOIN employee_positions ep ON employees.id = ep.employee_id`). Joins(`JOIN positions po ON ep.position_id = po.id`). Where(`po.code IN ? AND ep.deleted_at IS NULL`, filter.Positions) } } } if len(filter.Stacks) > 0 { if len(filter.Stacks) == 1 { if filter.Stacks[0] == "-" { query = query.Joins(`LEFT JOIN employee_stacks es ON employees.id = es.employee_id`).Where("es.id IS NULL") } else { query = query.Joins(`JOIN employee_stacks es ON employees.id = es.employee_id`).Joins(`JOIN stacks s ON es.stack_id = s.id`). Where("s.code = ? AND es.deleted_at IS NULL", filter.Stacks[0]) } } if len(filter.Stacks) > 1 { if filter.Stacks[0] == "-" { query = query.Joins(`LEFT JOIN employee_stacks es ON employees.id = es.employee_id`). Joins(`LEFT JOIN stacks s ON es.project_id = s.id`). Where(`es.id IS NULL OR (s.code IN ? AND es.deleted_at IS NULL)`, filter.Stacks[1:]) } else { query = query.Joins(`JOIN employee_stacks es ON employees.id = es.employee_id`). Joins(`JOIN stacks s ON es.stack_id = s.id`). Where(`s.code IN ? AND es.deleted_at IS NULL`, filter.Stacks) } } } if len(filter.Projects) > 0 { if len(filter.Projects) == 1 { if filter.Projects[0] == "-" { query = query.Where(`employees.id NOT IN (SELECT DISTINCT employee_id FROM project_members WHERE deleted_at IS NULL AND start_date <= now() AND (end_date IS NULL OR end_date > now()))`) } else { query = query.Joins(`JOIN project_members pm ON employees.id = pm.employee_id`).Joins(`JOIN projects p ON pm.project_id = p.id`). Where("p.code = ? AND pm.deleted_at IS NULL AND pm.start_date <= now() AND (pm.end_date IS NULL OR pm.end_date > now())", filter.Projects[0]) } } if len(filter.Projects) > 1 { if filter.Projects[0] == "-" { query = query.Joins(`LEFT JOIN project_members pm ON employees.id = pm.employee_id`). Joins(`LEFT JOIN projects p ON pm.project_id = p.id`). Where(`(p.code IN ? AND pm.deleted_at IS NULL AND pm.start_date <= now() AND (pm.end_date IS NULL OR pm.end_date > now())) OR (employees.id NOT IN (SELECT DISTINCT employee_id FROM project_members WHERE deleted_at IS NULL AND start_date <= now() AND (end_date IS NULL OR end_date > now())))`, filter.Projects[1:]) } else { query = query.Joins(`JOIN project_members pm ON employees.id = pm.employee_id`). Joins(`JOIN projects p ON pm.project_id = p.id`). Where(`p.code IN ? AND pm.deleted_at IS NULL AND pm.start_date <= now() AND (pm.end_date IS NULL OR pm.end_date > now())`, filter.Projects) } } } if len(filter.LineManagers) > 0 { if len(filter.LineManagers) == 1 { if filter.LineManagers[0] == "-" { query = query.Where("employees.line_manager_id IS NULL") } else { query = query.Where("employees.line_manager_id = ?", filter.LineManagers[0]) } } else { if filter.LineManagers[0] == "-" { query = query.Where(`employees.line_manager_id IS NULL AND employees.line_manager_id IN ?`, filter.LineManagers[1:]) } else { query = query.Where("employees.line_manager_id IN ?", filter.LineManagers) } } } if len(filter.Chapters) > 0 { if len(filter.Chapters) == 1 { if filter.Chapters[0] == "-" { query = query.Joins(`LEFT JOIN employee_chapters ec ON employees.id = ec.employee_id`).Where("ec.id IS NULL") } else { query = query.Joins(`JOIN employee_chapters ec ON employees.id = ec.employee_id`).Joins(`JOIN chapters c ON ec.chapter_id = c.id`). Where("c.code = ? AND ec.deleted_at IS NULL", filter.Chapters[0]) } } if len(filter.Chapters) > 1 { if filter.Chapters[0] == "-" { query = query.Joins(`LEFT JOIN employee_chapters ec ON employees.id = ec.employee_id`). Joins(`LEFT JOIN chapters c ON ec.chapter_id = c.id`). Where(`ec.id IS NULL OR (c.code IN ? AND ec.deleted_at IS NULL)`, filter.Chapters[1:]) } else { query = query.Joins(`JOIN employee_chapters ec ON employees.id = ec.employee_id`). Joins(`JOIN chapters c ON ec.chapter_id = c.id`). Where(`c.code IN ? AND ec.deleted_at IS NULL`, filter.Chapters) } } } if len(filter.Seniorities) > 0 { query = query.Joins("JOIN seniorities ON employees.seniority_id = seniorities.id AND seniorities.code IN ?", filter.Seniorities) } if len(filter.Organizations) > 0 { if filter.Organizations[0] == "-" { query = query.Where(`employees.id NOT IN (SELECT DISTINCT employee_id FROM employee_organizations)`) } else { query = query.Joins(`JOIN employee_organizations ON employees.id = employee_organizations.employee_id JOIN organizations ON employee_organizations.organization_id = organizations.id AND organizations.code IN ?`, filter.Organizations) } } if filter.IsLeft != nil { if *filter.IsLeft { query = query.Where("employees.left_date IS NOT NULL") } else { from := time.Now() if filter.BatchDate != nil { from = *filter.BatchDate } query = query.Where("(employees.left_date IS NULL OR employees.left_date > ?)", from) } } if filter.Keyword != "" { query = query.Where("employees.keyword_vector @@ plainto_tsquery('english_nostop', fn_remove_vietnamese_accents(LOWER(?)))", filter.Keyword) } return query } func getByFieldSort(db *gorm.DB, query *gorm.DB, field string, sortOrder model.SortOrder) *gorm.DB { if len(sortOrder) > 0 { if sortOrder == model.SortOrderASC { return db.Table("(?) as employees", query).Order(field + " asc") } else { return db.Table("(?) as employees", query).Order(field + " desc") } } return query }
```

# pkg/store/employeebonus/employee_bonus.go

```go
package employeebonus import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} // New initialize new store for bonus func New() IStore { return &store{} } func (s *store) GetByUserID(db *gorm.DB, id model.UUID) ([]model.EmployeeBonus, error) { var res []model.EmployeeBonus return res, db.Where("is_active = true AND employee_id = ?", id).Find(&res).Error }
```

# pkg/store/employeebonus/interface.go

```go
package employeebonus import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) // IStore is an interface that abstract database method for bonus type IStore interface { GetByUserID(db *gorm.DB, id model.UUID) ([]model.EmployeeBonus, error) }
```

# pkg/store/employeechapter/employee_chapter.go

```go
package employeechapter import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create make new one by id func (s *store) Create(db *gorm.DB, employeeChapter *model.EmployeeChapter) (*model.EmployeeChapter, error) { return employeeChapter, db.Create(&employeeChapter).Error } // DeleteByEmployeeID delete many EmployeeChapters by employeeID func (s *store) DeleteByEmployeeID(db *gorm.DB, employeeID string) error { return db.Unscoped().Where("employee_id = ?", employeeID).Delete(&model.EmployeeChapter{}).Error }
```

# pkg/store/employeechapter/interface.go

```go
package employeechapter import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, employeeChapter *model.EmployeeChapter) (*model.EmployeeChapter, error) DeleteByEmployeeID(db *gorm.DB, employeeID string) error }
```

# pkg/store/employeecommission/employee_commission.go

```go
package employeecommission import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} // New initialize new store for commission func New() IStore { return &store{} } func (s *store) Create(db *gorm.DB, employeeCommissions []model.EmployeeCommission) ([]model.EmployeeCommission, error) { return employeeCommissions, db.Create(&employeeCommissions).Error } func (s *store) Get(db *gorm.DB, q Query) ([]model.EmployeeCommission, error) { var res []model.EmployeeCommission if q.EmployeeID != "" { db = db.Where("employee_id = ?", q.EmployeeID) } if q.FromDate != nil { db = db.Where("created_at > ?", q.FromDate) } if q.ToDate != nil { db = db.Where("created_at < ?", q.ToDate) } return res, db.Preload("Invoice").Where("is_paid = ?", q.IsPaid).Find(&res).Error } func (s *store) MarkPaid(db *gorm.DB, id model.UUID) error { var cms model.EmployeeCommission err := db.Where("id = ?", id).Find(&cms).Error if err != nil { return err } return db.Model(&cms).Updates(map[string]interface{}{"is_paid": true, "paid_at": time.Now()}).Error }
```

# pkg/store/employeecommission/interface.go

```go
package employeecommission import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) // IStore is an interface that abstract database method for commission type IStore interface { // Create new row for table user_commissions, save the commission // for an user for specific invoice Create(db *gorm.DB, employeeCommissions []model.EmployeeCommission) ([]model.EmployeeCommission, error) Get(db *gorm.DB, q Query) ([]model.EmployeeCommission, error) MarkPaid(db *gorm.DB, ids model.UUID) error } type Query struct { EmployeeID string FromDate *time.Time ToDate *time.Time IsPaid bool }
```

# pkg/store/employeeeventquestion/employee_event_question.go

```go
package employeeeventquestion import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // GetByEventReviewerID return list EmployeeEventQuestion by eventReviewerID func (s *store) GetByEventReviewerID(db *gorm.DB, reviewID string) ([]*model.EmployeeEventQuestion, error) { var eventQuestions []*model.EmployeeEventQuestion return eventQuestions, db.Where("employee_event_reviewer_id = ?", reviewID).Order("\"order\"").Find(&eventQuestions).Error } // UpdateAnswers update answer and note by table id func (s *store) UpdateAnswers(db *gorm.DB, data BasicEventQuestion) error { return db.Table("employee_event_questions"). Where("id = ?", data.EventQuestionID). Updates(map[string]interface{}{"answer": data.Answer, "note": data.Note}).Error } // Create create new one func (s *store) BatchCreate(db *gorm.DB, employeeEventQuestions []model.EmployeeEventQuestion) ([]model.EmployeeEventQuestion, error) { return employeeEventQuestions, db.Create(&employeeEventQuestions).Error } // Create a employee event question func (s *store) Create(tx *gorm.DB, eventQuestion *model.EmployeeEventQuestion) (*model.EmployeeEventQuestion, error) { return eventQuestion, tx.Create(&eventQuestion).Error } // DeleteByEventID delete EmployeeEventQuestion by eventID func (s *store) DeleteByEventID(db *gorm.DB, eventID string) error { return db.Where("event_id = ?", eventID).Delete(&model.EmployeeEventQuestion{}).Error } // DeleteByEventReviewerIDList delete EmployeeEventQuestion by reviewerID list func (s *store) DeleteByEventReviewerIDList(db *gorm.DB, reviewerIDList []string) error { return db.Where("employee_event_reviewer_id IN ?", reviewerIDList).Delete(&model.EmployeeEventQuestion{}).Error } // DeleteByEventReviewerID delete EmployeeEventQuestion by eventReviewerID func (s *store) DeleteByEventReviewerID(db *gorm.DB, eventReviewerID string) error { return db.Where("employee_event_reviewer_id = ?", eventReviewerID).Delete(&model.EmployeeEventQuestion{}).Error } // CountLikertScaleByEventIDAndDomain return LikertScaleCount by eventID and domain func (s *store) CountLikertScaleByEventIDAndDomain(db *gorm.DB, eventID string, domain string) (*model.LikertScaleCount, error) { var count *model.LikertScaleCount query := db.Raw(` WITH q0 AS ( SELECT * FROM employee_event_questions WHERE event_id = ? AND domain = ? AND deleted_at IS NULL ), q1 AS ( SELECT COUNT(*) AS "strongly_disagree" FROM q0 WHERE q0.answer = ? ), q2 AS ( SELECT COUNT(*) AS disagree FROM q0 WHERE q0.answer = ? ), q3 AS ( SELECT COUNT(*) AS mixed FROM q0 WHERE q0.answer = ? ), q4 AS ( SELECT COUNT(*) AS agree FROM q0 WHERE q0.answer = ? ), q5 AS ( SELECT COUNT(*) AS "strongly_agree" FROM q0 WHERE q0.answer = ? ) SELECT * FROM q1, q2, q3, q4, q5 `, eventID, domain, model.AgreementLevelMap[model.AgreementLevelStronglyDisagree], model.AgreementLevelMap[model.AgreementLevelDisagree], model.AgreementLevelMap[model.AgreementLevelMixed], model.AgreementLevelMap[model.AgreementLevelAgree], model.AgreementLevelMap[model.AgreementLevelStronglyAgree]) return count, query.Scan(&count).Error } // GetAverageAnswerEngagementByTime return average answer of engagement dashboard by time func (s *store) GetAverageAnswerEngagementByTime(db *gorm.DB, times []time.Time) ([]*model.StatisticEngagementDashboard, error) { var result []*model.StatisticEngagementDashboard query := db.Table("feedback_events fe"). Select("DISTINCT q.content, eq.question_id, fe.title, fe.start_date, avg( CASE WHEN answer = '' THEN 0 ELSE cast(answer AS DECIMAL) END) AS point"). Joins("JOIN employee_event_questions eq ON fe.id = eq.event_id"). Joins("JOIN employee_event_reviewers er ON eq.employee_event_reviewer_id = er.id"). Joins("JOIN questions q ON eq.question_id = q.id"). Where("eq.domain = 'engagement'"). Where("er.reviewer_status = 'done' AND is_forced_done = FALSE"). Where("fe.start_date IN ?", times). Group("q.content, eq.question_id, fe.title, fe.start_date"). Order("q.content asc") return result, query.Find(&result).Error } // GetAverageAnswerEngagementByFilter return average answer of engagement dashboard by filter func (s *store) GetAverageAnswerEngagementByFilter(db *gorm.DB, filter model.EngagementDashboardFilter, time *time.Time) ([]*model.StatisticEngagementDashboard, error) { var result []*model.StatisticEngagementDashboard query := db.Table("feedback_events fe"). Select("DISTINCT f.name, eq.question_id, fe.title, fe.start_date, avg( CASE WHEN answer = '' THEN 0 ELSE cast(answer AS DECIMAL) END) AS point"). Joins("JOIN employee_event_questions eq ON fe.id = eq.event_id"). Joins("JOIN employee_event_reviewers er ON eq.employee_event_reviewer_id = er.id"). Where("eq.domain = 'engagement'"). Where("er.reviewer_status = 'done' AND is_forced_done = FALSE"). Where("fe.start_date = ?", time). Group("eq.question_id, fe.title, fe.start_date") if filter == model.EngagementDashboardFilterChapter { query = query. Joins("JOIN employee_chapters ec ON er.reviewer_id = ec.employee_id"). Joins("JOIN chapters f ON ec.chapter_id = f.id"). Group("f.name") } if filter == model.EngagementDashboardFilterSeniority { query = query. Joins("JOIN employees e ON er.reviewer_id = e.id"). Joins("JOIN seniorities f ON e.seniority_id = f.id"). Group("f.name") } if filter == model.EngagementDashboardFilterProject { query = query. Joins("JOIN project_members pm ON er.reviewer_id = pm.employee_id"). Joins("JOIN projects f ON pm.project_id = f.id"). Where("f.status = ?", model.ProjectStatusActive). Group("f.name") } return result, query.Find(&result).Error }
```

# pkg/store/employeeeventquestion/interface.go

```go
package employeeeventquestion import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { GetByEventReviewerID(db *gorm.DB, reviewID string) (eventQuestions []*model.EmployeeEventQuestion, err error) UpdateAnswers(db *gorm.DB, data BasicEventQuestion) (err error) BatchCreate(db *gorm.DB, employeeEventQuestions []model.EmployeeEventQuestion) ([]model.EmployeeEventQuestion, error) Create(tx *gorm.DB, eventQuestion *model.EmployeeEventQuestion) (employeeEventQuestion *model.EmployeeEventQuestion, err error) DeleteByEventID(db *gorm.DB, eventID string) error DeleteByEventReviewerIDList(db *gorm.DB, reviewerIDList []string) error DeleteByEventReviewerID(db *gorm.DB, eventReviewerID string) error CountLikertScaleByEventIDAndDomain(db *gorm.DB, eventID string, domain string) (*model.LikertScaleCount, error) GetAverageAnswerEngagementByTime(db *gorm.DB, times []time.Time) ([]*model.StatisticEngagementDashboard, error) GetAverageAnswerEngagementByFilter(db *gorm.DB, filter model.EngagementDashboardFilter, time *time.Time) ([]*model.StatisticEngagementDashboard, error) }
```

# pkg/store/employeeeventquestion/request.go

```go
package employeeeventquestion type BasicEventQuestion struct { EventQuestionID string Answer string Note string }
```

# pkg/store/employeeeventreviewer/employee_event_reviewer.go

```go
package employeeeventreviewer import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get one record by ID func (s *store) One(db *gorm.DB, id string) (*model.EmployeeEventReviewer, error) { var eer *model.EmployeeEventReviewer return eer, db.Where("id = ?", id). Preload("Reviewer", "deleted_at IS NULL"). First(&eer).Error } // OneByReviewerID get one record by reviewerID and topicID func (s *store) OneByReviewerID(db *gorm.DB, reviewerID string, topicID string) (*model.EmployeeEventReviewer, error) { var eer *model.EmployeeEventReviewer return eer, db.Where("reviewer_id = ? AND employee_event_topic_id = ? ", reviewerID, topicID).First(&eer).Error } // GetByTopicID get record by topicID func (s *store) GetByTopicID(db *gorm.DB, topicID string) ([]*model.EmployeeEventReviewer, error) { var employeeeventreviewer []*model.EmployeeEventReviewer return employeeeventreviewer, db.Where("employee_event_topic_id = ? ", topicID).Find(&employeeeventreviewer).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.EmployeeEventReviewer, updatedFields ...string) (*model.EmployeeEventReviewer, error) { eventReviewer := model.EmployeeEventReviewer{} return &eventReviewer, db.Model(&eventReviewer).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // BatchCreate create a list of event reviewer func (s *store) BatchCreate(db *gorm.DB, eers []model.EmployeeEventReviewer) ([]model.EmployeeEventReviewer, error) { return eers, db.Create(&eers).Error } // Create a employee event reviewer func (s *store) Create(tx *gorm.DB, eer *model.EmployeeEventReviewer) (*model.EmployeeEventReviewer, error) { return eer, tx.Create(&eer).Error } // DeleteByEventID delete EmployeeEventReviewer by eventID func (s *store) DeleteByEventID(db *gorm.DB, eventID string) error { return db.Where("event_id = ?", eventID).Delete(&model.EmployeeEventReviewer{}).Error } // DeleteByTopicID delete EmployeeEventReviewer by topicID func (s *store) DeleteByTopicID(db *gorm.DB, topicID string) error { return db.Where("employee_event_topic_id = ?", topicID).Delete(&model.EmployeeEventReviewer{}).Error } // DeleteByID delete EmployeeEventReviewer by id func (s *store) DeleteByID(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.EmployeeEventReviewer{}).Error }
```

# pkg/store/employeeeventreviewer/interface.go

```go
package employeeeventreviewer import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (employeeeventreviewer *model.EmployeeEventReviewer, err error) OneByReviewerID(db *gorm.DB, reviewerID string, topicID string) (*model.EmployeeEventReviewer, error) GetByTopicID(db *gorm.DB, topicID string) ([]*model.EmployeeEventReviewer, error) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.EmployeeEventReviewer, updatedFields ...string) (employeeEventReviewer *model.EmployeeEventReviewer, err error) BatchCreate(db *gorm.DB, employeeEventReviewers []model.EmployeeEventReviewer) ([]model.EmployeeEventReviewer, error) Create(tx *gorm.DB, eventReviewer *model.EmployeeEventReviewer) (employeeEventReviewer *model.EmployeeEventReviewer, err error) DeleteByEventID(db *gorm.DB, eventID string) (err error) DeleteByTopicID(db *gorm.DB, topicID string) (err error) DeleteByID(db *gorm.DB, id string) (err error) }
```

# pkg/store/employeeeventtopic/employee_event_topic.go

```go
package employeeeventtopic import ( "fmt" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One get topic by id func (s *store) One(db *gorm.DB, id string, eventID string, preload bool) (*model.EmployeeEventTopic, error) { query := db.Where("id = ? AND event_id = ?", id, eventID) if preload { query = query. Preload("Employee", "deleted_at IS NULL"). Preload("Event", "deleted_at IS NULL"). Preload("EmployeeEventReviewers", "deleted_at IS NULL"). Preload("EmployeeEventReviewers.Reviewer", "deleted_at IS NULL") } var topic *model.EmployeeEventTopic return topic, query.First(&topic).Error } // GetByEmployeeID return list of EmployeeEventTopic by employeeID and pagination func (s *store) GetByEmployeeID(db *gorm.DB, employeeID string, input GetByEmployeeIDInput, pagination model.Pagination) ([]*model.EmployeeEventTopic, int64, error) { var eTopics []*model.EmployeeEventTopic var total int64 query := db. Table("employee_event_topics"). Joins("JOIN employee_event_reviewers eer ON employee_event_topics.id = eer.employee_event_topic_id AND eer.deleted_at IS NULL"). Joins("JOIN feedback_events fe ON employee_event_topics.event_id = fe.id"). Where("((eer.reviewer_id = ? AND fe.type = ?) OR (employee_event_topics.employee_id = ? AND fe.type = ?)) AND eer.author_status <> ? AND eer.reviewer_status <> ?", employeeID, model.EventTypeSurvey, employeeID, model.EventTypeFeedback, model.EventAuthorStatusDraft, model.EventReviewerStatusNone, ) if input.Status != "" { query = query.Where("eer.reviewer_status = ?", input.Status) } query = query.Count(&total) if pagination.Sort != "" { query = query.Order(pagination.Sort) } else { query = query.Order("created_at DESC") } limit, offset := pagination.ToLimitOffset() if pagination.Page > 0 { query = query.Limit(limit) } query = query.Offset(offset) return eTopics, total, query. Preload("Event", "deleted_at IS NULL"). Preload("Event.Employee", "deleted_at IS NULL"). Preload("EmployeeEventReviewers", func(db *gorm.DB) *gorm.DB { return db.Joins("JOIN employee_event_topics ON employee_event_topics.id = employee_event_reviewers.employee_event_topic_id"). Joins("JOIN feedback_events fe ON employee_event_topics.event_id = fe.id"). Where("((employee_event_reviewers.reviewer_id = ? AND fe.type = ?) OR (employee_event_topics.employee_id = ? AND fe.type = ?)) AND employee_event_reviewers.reviewer_status <> ?", employeeID, model.EventTypeSurvey, employeeID, model.EventTypeFeedback, model.EventReviewerStatusNone, ) }). Preload("EmployeeEventReviewers.Reviewer", "deleted_at IS NULL"). Find(&eTopics).Error } // CountUnreadFeedbackByEmployeeID return total of unread inbox of the employee func (s *store) CountUnreadFeedbackByEmployeeID(db *gorm.DB, employeeID string) (int64, error) { var total int64 query := db. Table("employee_event_topics"). Joins("JOIN employee_event_reviewers eer ON employee_event_topics.id = eer.employee_event_topic_id AND eer.deleted_at IS NULL"). Joins("JOIN feedback_events fe ON employee_event_topics.event_id = fe.id"). Where("((eer.reviewer_id = ? AND fe.type = ?) OR (employee_event_topics.employee_id = ? AND fe.type = ?)) AND eer.author_status <> ? AND eer.reviewer_status <> ? AND eer.is_read = false", employeeID, model.EventTypeSurvey, employeeID, model.EventTypeFeedback, model.EventAuthorStatusDraft, model.EventReviewerStatusNone, ) return total, query.Count(&total).Error } // All return list of EmployeeEventTopic by input and pagination func (s *store) All(db *gorm.DB, input GetByEventIDInput, pagination *model.Pagination) ([]*model.EmployeeEventTopic, int64, error) { var topics []*model.EmployeeEventTopic var total int64 query := db.Table("employee_event_topics") if input.Keyword != "" { query = query.Where("title ILIKE ?", fmt.Sprintf("%%%s%%", input.Keyword)) } if input.Status != "" { query = query.Where(`employee_event_topics.id IN ( SELECT eer.employee_event_topic_id FROM employee_event_reviewers eer WHERE eer.event_id = ? AND eer.author_status = ? )`, input.EventID, input.Status) } if len(input.Projects) > 0 { query = query.Where(`project_id IN ( SELECT p.id FROM projects p WHERE p.code IN ? AND p.deleted_at IS NULL )`, input.Projects) } query = query.Where("event_id = ? AND deleted_at IS NULL", input.EventID).Count(&total) // sort by comments query = query.Joins(`JOIN ( SELECT eet.id, COUNT(*) AS comments FROM employee_event_topics eet LEFT JOIN employee_event_reviewers eer ON eet.id = eer.employee_event_topic_id AND eer.reviewer_status = ? LEFT JOIN employee_event_questions eeq ON eer.id = eeq.employee_event_reviewer_id WHERE eet.deleted_at IS NULL AND eer.deleted_at IS NULL AND eeq.deleted_at IS NULL GROUP BY eet.id ) as eet_comments ON employee_event_topics.id = eet_comments.id `, model.EventReviewerStatusDone) if pagination != nil && pagination.Sort != "" { query = query.Order(pagination.Sort) } else { query = query.Order("eet_comments.comments") } if input.Paging { limit, offset := pagination.ToLimitOffset() if pagination.Page > 0 { query = query.Limit(limit) } query = query.Offset(offset) } if input.Preload { query = query. Preload("Event", "deleted_at IS NULL"). Preload("Employee", "deleted_at IS NULL"). Preload("Project", "deleted_at IS NULL"). Preload("EmployeeEventReviewers", "deleted_at IS NULL"). Preload("EmployeeEventReviewers.Reviewer", "deleted_at IS NULL"). Preload("EmployeeEventReviewers.EmployeeEventQuestions", "deleted_at IS NULL") } return topics, total, query.Find(&topics).Error } // BatchCreate create new one func (s *store) BatchCreate(db *gorm.DB, employeeEventTopics []model.EmployeeEventTopic) ([]model.EmployeeEventTopic, error) { return employeeEventTopics, db.Create(&employeeEventTopics).Error } // DeleteByEventID delete by Event ID func (s *store) DeleteByEventID(db *gorm.DB, eventID string) error { return db.Where("event_id = ?", eventID).Delete(&model.EmployeeEventTopic{}).Error } // DeleteByID delete by topic ID func (s *store) DeleteByID(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.EmployeeEventTopic{}).Error }
```

# pkg/store/employeeeventtopic/interface.go

```go
package employeeeventtopic import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string, eventID string, preload bool) (topic *model.EmployeeEventTopic, err error) All(db *gorm.DB, input GetByEventIDInput, pagination *model.Pagination) (topics []*model.EmployeeEventTopic, total int64, err error) GetByEmployeeID(db *gorm.DB, employeeID string, input GetByEmployeeIDInput, pagination model.Pagination) (eTopics []*model.EmployeeEventTopic, total int64, err error) BatchCreate(db *gorm.DB, employeeEventTopics []model.EmployeeEventTopic) ([]model.EmployeeEventTopic, error) DeleteByEventID(db *gorm.DB, eventID string) error DeleteByID(db *gorm.DB, ID string) error CountUnreadFeedbackByEmployeeID(db *gorm.DB, employeeID string) (count int64, err error) }
```

# pkg/store/employeeeventtopic/request.go

```go
package employeeeventtopic type GetByEmployeeIDInput struct { Status string } type GetByEventIDInput struct { EventID string Keyword string Status string Projects []string Preload bool Paging bool }
```

# pkg/store/employeeinvitation/employee_invitation.go

```go
package employeeinvitation import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create generate new one func (s *store) Create(db *gorm.DB, employeeInvitation *model.EmployeeInvitation) (*model.EmployeeInvitation, error) { return employeeInvitation, db.Create(&employeeInvitation).Error } // OneByEmployeeID get one by employeeID func (s *store) OneByEmployeeID(db *gorm.DB, employeeID string) (*model.EmployeeInvitation, error) { var rs *model.EmployeeInvitation return rs, db.Preload("Employee"). Where("employee_id = ?", employeeID).First(&rs).Error } func (s *store) Save(db *gorm.DB, employeeInvitation *model.EmployeeInvitation) error { return db.Save(&employeeInvitation).Error }
```

# pkg/store/employeeinvitation/interface.go

```go
package employeeinvitation import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, employeeOrganization *model.EmployeeInvitation) (*model.EmployeeInvitation, error) OneByEmployeeID(db *gorm.DB, employeeID string) (*model.EmployeeInvitation, error) Save(db *gorm.DB, employeeInvitation *model.EmployeeInvitation) error }
```

# pkg/store/employeeorganization/employee_organization.go

```go
package employeeorganization import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create create new one by id func (s *store) Create(db *gorm.DB, employeeOrganization *model.EmployeeOrganization) (*model.EmployeeOrganization, error) { return employeeOrganization, db.Create(&employeeOrganization).Error } // Delete delete many EmployeePositions by employeeID func (s *store) DeleteByEmployeeID(db *gorm.DB, employeeID string) error { return db.Unscoped().Where("employee_id = ?", employeeID).Delete(&model.EmployeeOrganization{}).Error }
```

# pkg/store/employeeorganization/interface.go

```go
package employeeorganization import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, employeeOrganization *model.EmployeeOrganization) (*model.EmployeeOrganization, error) DeleteByEmployeeID(db *gorm.DB, employeeID string) (err error) }
```

# pkg/store/employeeposition/employee_position.go

```go
package employeeposition import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create create new one by id func (s *store) Create(db *gorm.DB, employeePosition *model.EmployeePosition) (*model.EmployeePosition, error) { return employeePosition, db.Create(&employeePosition).Error } // Delete delete many EmployeePositions by employeeID func (s *store) DeleteByEmployeeID(db *gorm.DB, employeeID string) error { return db.Unscoped().Where("employee_id = ?", employeeID).Delete(&model.EmployeePosition{}).Error }
```

# pkg/store/employeeposition/interface.go

```go
package employeeposition import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, employeePosition *model.EmployeePosition) (*model.EmployeePosition, error) DeleteByEmployeeID(db *gorm.DB, employeeID string) (err error) }
```

# pkg/store/employeerole/employee_role.go

```go
package employeerole import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct { } func New() IStore { return &store{} } // Create using fore create new Employee role func (s *store) Create(db *gorm.DB, er *model.EmployeeRole) (*model.EmployeeRole, error) { return er, db.Create(&er).Error } // HardDeleteByEmployeeID hard delete employeeRole by employeeID func (s *store) HardDeleteByEmployeeID(db *gorm.DB, employeeID string) error { return db.Unscoped().Where("employee_id = ?", employeeID).Delete(&model.EmployeeRole{}).Error }
```

# pkg/store/employeerole/interface.go

```go
package employeerole import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, er *model.EmployeeRole) (employeeRole *model.EmployeeRole, err error) HardDeleteByEmployeeID(db *gorm.DB, employeeID string) (err error) }
```

# pkg/store/employeestack/employee_stack.go

```go
package employeestack import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create create new one by id func (s *store) Create(db *gorm.DB, employeeStack *model.EmployeeStack) (*model.EmployeeStack, error) { return employeeStack, db.Create(&employeeStack).Error } // DeleteByEmployeeID delete many EmployeeStaks by employeeID func (s *store) DeleteByEmployeeID(db *gorm.DB, employeeID string) error { return db.Unscoped().Where("employee_id = ?", employeeID).Delete(&model.EmployeeStack{}).Error }
```

# pkg/store/employeestack/interface.go

```go
package employeestack import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, employeeStack *model.EmployeeStack) (*model.EmployeeStack, error) DeleteByEmployeeID(db *gorm.DB, employeeID string) error }
```

# pkg/store/engagementsrollup/engagements_rollup.go

```go
package engagementsrollup import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" "gorm.io/gorm/clause" ) type store struct{} func New() IStore { return &store{} } func (s *store) Upsert(db *gorm.DB, record *model.EngagementsRollup) (*model.EngagementsRollup, error) { return record, db. Table("engagements_rollup"). Clauses( clause.OnConflict{ Columns: []clause.Column{ {Name: "discord_user_id"}, {Name: "channel_id"}, }, DoUpdates: clause.Assignments( map[string]interface{}{ // COALESCE is needed since anything can be null "message_count": gorm.Expr("engagements_rollup.message_count + excluded.message_count"), "reaction_count": gorm.Expr("engagements_rollup.reaction_count + excluded.reaction_count"), "last_message_id": gorm.Expr("GREATEST(engagements_rollup.last_message_id, excluded.last_message_id)"), }, ), }, ). Create(record). Error } func (s *store) GetLastMessageID(db *gorm.DB, channelID string) (string, error) { lastMessageID := "" err := db. Raw( "SELECT COALESCE(MAX(last_message_id), 0) FROM engagements_rollup WHERE channel_id = ?", channelID, ). Scan(&lastMessageID). Error return lastMessageID, err }
```

# pkg/store/engagementsrollup/interface.go

```go
package engagementsrollup import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type IStore interface { Upsert(db *gorm.DB, record *model.EngagementsRollup) (*model.EngagementsRollup, error) GetLastMessageID(db *gorm.DB, channelID string) (string, error) }
```

# pkg/store/eventspeaker/event_speaker.go

```go
package eventspeaker import ( "time" "gorm.io/gorm" "gorm.io/gorm/clause" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create creates a new e func (s *store) Create(db *gorm.DB, e *model.EventSpeaker) (*model.EventSpeaker, error) { return e, db.Clauses( clause.OnConflict{ Columns: []clause.Column{{Name: "topic"}}, DoNothing: true, }, ).Create(e).Error } // DeleteAllByEventID deletes all event speakers by event id func (s *store) DeleteAllByEventID(db *gorm.DB, eventID string) error { return db.Table("event_speakers").Where("event_id = ?", eventID).Delete(&model.EventSpeaker{}).Error } // List returns a lit of event speaker with loaded event info func (s *store) List(db *gorm.DB, discordID string, after *time.Time, topic string) ([]model.EventSpeaker, error) { var eventSpeakers []model.EventSpeaker query := db.Table("event_speakers"). Joins("JOIN discord_accounts ON event_speakers.discord_account_id = discord_accounts.id"). Joins("JOIN events ON events.id = event_speakers.event_id"). Order("events.date DESC") if after != nil { query = query.Where("events.date > ?", after) } if topic != "" { query = query.Where("LOWER(event_speakers.topic) LIKE LOWER(?)", "%"+topic+"%") } if discordID != "" { query = query.Where("discord_accounts.discord_id = ?", discordID) } err := query.Preload("Event"). Find(&eventSpeakers).Error if err != nil { return nil, err } return eventSpeakers, nil } // Count returns the total count of event speakers with the same filtering criteria as List func (s *store) Count(db *gorm.DB, discordID string, after *time.Time, topic string) (int64, error) { var count int64 query := db.Table("event_speakers"). Joins("JOIN discord_accounts ON event_speakers.discord_account_id = discord_accounts.id"). Joins("JOIN events ON events.id = event_speakers.event_id") if after != nil { query = query.Where("events.date > ?", after) } if topic != "" { query = query.Where("LOWER(event_speakers.topic) LIKE LOWER(?)", "%"+topic+"%") } if discordID != "" { query = query.Where("discord_accounts.discord_id = ?", discordID) } err := query.Count(&count).Error if err != nil { return 0, err } return count, nil } // SpeakerStats type SpeakerStats struct { TotalSpeakCount int64 `gorm:"column:total_speak_count"` SpeakRank int64 `gorm:"column:speak_rank"` } // GetSpeakerStats returns the total speak count and rank for a given discord_id func (s *store) GetSpeakerStats(db *gorm.DB, discordID string, after *time.Time, topic string) (SpeakerStats, error) { var stats SpeakerStats query := db.Table("event_speakers"). Select("discord_accounts.discord_id, COUNT(event_speakers.topic) as total_speak_count, RANK() OVER (ORDER BY COUNT(event_speakers.topic) DESC) as speak_rank"). Joins("JOIN discord_accounts ON event_speakers.discord_account_id = discord_accounts.id"). Joins("JOIN events ON events.id = event_speakers.event_id") if after != nil { query = query.Where("events.date > ?", after) } if topic != "" { query = query.Where("LOWER(event_speakers.topic) LIKE LOWER(?)", "%"+topic+"%") } query = query.Group("discord_accounts.discord_id") err := db.Table("(?) as speaker_counts", query). Select("total_speak_count, speak_rank"). Where("discord_id = ?", discordID). Scan(&stats).Error if err != nil { return SpeakerStats{}, err } return stats, nil } // GetLeaderboard returns the top speakers ordered by the count of events with a topic containing 'ogif' (case insensitive) func (s *store) GetLeaderboard(db *gorm.DB, after *time.Time, limit int, topic string) ([]model.OgifLeaderboardRecord, error) { leaderboard := make([]model.OgifLeaderboardRecord, 0) query := db.Table("event_speakers"). Select("discord_accounts.discord_id, COUNT(DISTINCT event_speakers.event_id) as speak_count"). Joins("JOIN discord_accounts ON event_speakers.discord_account_id = discord_accounts.id"). Joins("JOIN events ON events.id = event_speakers.event_id"). Joins("LEFT JOIN employees ON employees.discord_account_id = discord_accounts.id"). Where("LOWER(event_speakers.topic) LIKE LOWER(?)", "%"+topic+"%") if after != nil { query = query.Where("events.date > ?", after) } err := query.Group("discord_accounts.discord_id"). Order("speak_count DESC"). Limit(limit). Scan(&leaderboard).Error if err != nil { return nil, err } return leaderboard, nil }
```

# pkg/store/eventspeaker/interface.go

```go
package eventspeaker import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, s *model.EventSpeaker) (ep *model.EventSpeaker, err error) DeleteAllByEventID(db *gorm.DB, eventID string) error List(db *gorm.DB, discordID string, after *time.Time, topic string) ([]model.EventSpeaker, error) GetSpeakerStats(db *gorm.DB, discordID string, after *time.Time, topic string) (SpeakerStats, error) Count(db *gorm.DB, discordID string, after *time.Time, topic string) (int64, error) GetLeaderboard(db *gorm.DB, after *time.Time, limit int, topic string) ([]model.OgifLeaderboardRecord, error) }
```

# pkg/store/expense/expense.go

```go
package expense import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct { } func New() IStore { return &store{} } func (s *store) Create(db *gorm.DB, e *model.Expense) (*model.Expense, error) { return e, db.Create(&e).Error } func (s *store) Delete(db *gorm.DB, e *model.Expense) (*model.Expense, error) { return e, db.Delete(&e).Error } func (s *store) Update(db *gorm.DB, e *model.Expense) (*model.Expense, error) { return e, db.Model(&model.Expense{}).Where("id = ?", e.ID).Updates(&e).First(&e).Error } func (s *store) GetValuation(db *gorm.DB, y int) (*model.CurrencyView, error) { res := &model.CurrencyView{} return res, db.Raw("select * from vw_expense where year = ?", y).Find(&res).Error } func (s *store) GetByQuery(db *gorm.DB, q *ExpenseQuery) (*model.Expense, error) { e := &model.Expense{} if q.BasecampID != 0 { db = db.Where("basecamp_id = ?", q.BasecampID) } return e, db.First(e).Error }
```

# pkg/store/expense/interface.go

```go
package expense import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, e *model.Expense) (*model.Expense, error) Delete(db *gorm.DB, e *model.Expense) (*model.Expense, error) Update(db *gorm.DB, e *model.Expense) (*model.Expense, error) GetValuation(db *gorm.DB, y int) (*model.CurrencyView, error) GetByQuery(db *gorm.DB, q *ExpenseQuery) (*model.Expense, error) } type ExpenseQuery struct { BasecampID int }
```

# pkg/store/feedbackevent/feedback_event.go

```go
package feedbackevent import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // IsExist check the existence of FeedbackEvent func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM feedback_events WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error } // GetBySubtype return list of FeedbackEvent by subtype func (s *store) GetBySubtype(db *gorm.DB, subtype string, pagination model.Pagination) ([]*model.FeedbackEvent, int64, error) { var events []*model.FeedbackEvent var total int64 // query for total query := db.Table("feedback_events"). Where("subtype = ? AND deleted_at IS NULL", subtype). Count(&total). Order(pagination.Sort) // add pagination if pagination.Sort == "" { query = query.Order("created_at DESC") } limit, offset := pagination.ToLimitOffset() if pagination.Page > 0 { query = query.Limit(limit) } query = query.Offset(offset) return events, total, query. Preload("Employee", "deleted_at IS NULL"). Preload("Topics", "deleted_at IS NULL"). Preload("Topics.EmployeeEventReviewers", "deleted_at IS NULL"). Find(&events).Error } // Create create new one func (s *store) Create(db *gorm.DB, feedbackEvent *model.FeedbackEvent) (*model.FeedbackEvent, error) { return feedbackEvent, db.Create(&feedbackEvent).Error } // One get 1 by id func (s *store) One(db *gorm.DB, id string, preload bool) (*model.FeedbackEvent, error) { var event *model.FeedbackEvent query := db.Where("id = ?", id) if preload { query = query.Preload("Employee", "deleted_at IS NULL").Preload("Topics", "deleted_at IS NULL") } return event, query.First(&event).Error } // OneByTypeInTimeRange get 1 by type in time range func (s *store) OneByTypeInTimeRange(db *gorm.DB, eventType model.EventType, eventSubtype model.EventSubtype, from, to *time.Time) (*model.FeedbackEvent, error) { var event *model.FeedbackEvent return event, db.Where("type = ?", eventType). Where("subtype = ?", eventSubtype). Where("start_date <= ? AND end_date >= ?", to, from). First(&event).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.FeedbackEvent, updatedFields ...string) (*model.FeedbackEvent, error) { feedbackEvent := model.FeedbackEvent{} return &feedbackEvent, db.Model(&feedbackEvent).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // DeleteByID delete FeedbackEvent by id func (s *store) DeleteByID(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.FeedbackEvent{}).Error } // GetLatestEventByType get FeedbackEvent by type with limit func (s *store) GetLatestEventByType(db *gorm.DB, eventType model.EventType, eventSubtype model.EventSubtype, num int) ([]*model.FeedbackEvent, error) { var feedbackEvents []*model.FeedbackEvent return feedbackEvents, db.Where("type = ? AND subtype = ?", eventType, eventSubtype).Order("start_date DESC").Limit(num).Find(&feedbackEvents).Error }
```

# pkg/store/feedbackevent/interface.go

```go
package feedbackevent import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { IsExist(db *gorm.DB, id string) (bool, error) One(db *gorm.DB, id string, preload bool) (event *model.FeedbackEvent, err error) OneByTypeInTimeRange(db *gorm.DB, eventType model.EventType, eventSubtype model.EventSubtype, from, to *time.Time) (*model.FeedbackEvent, error) GetBySubtype(db *gorm.DB, subtype string, pagination model.Pagination) (events []*model.FeedbackEvent, total int64, err error) Create(db *gorm.DB, feedbackEvent *model.FeedbackEvent) (*model.FeedbackEvent, error) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.FeedbackEvent, updatedFields ...string) (event *model.FeedbackEvent, err error) DeleteByID(db *gorm.DB, id string) error GetLatestEventByType(db *gorm.DB, eventType model.EventType, eventSubtype model.EventSubtype, num int) ([]*model.FeedbackEvent, error) }
```

# pkg/store/icydistribution/icy_distribution.go

```go
package icydistribution import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} // New implements IStore. func New() IStore { return &store{} } // GetWeekly implements IStore. func (*store) GetWeekly(db *gorm.DB) ([]model.IcyDistribution, error) { res := []model.IcyDistribution{} return res, db.Raw(`SELECT Team, SUM(Amount) AS Total_Amount FROM vw_icy_earning_by_team_weekly WHERE Period >= to_char(date_trunc('week', CURRENT_DATE), 'yyyy-mm-dd') AND Period <= to_char(date_trunc('week', CURRENT_DATE) + '6 days'::interval, 'yyyy-mm-dd') GROUP BY Team ORDER BY Total_Amount DESC;`).Find(&res).Error }
```

# pkg/store/icydistribution/interface.go

```go
package icydistribution import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) // IStore is an interface for icydistribution store type IStore interface { GetWeekly(db *gorm.DB) ([]model.IcyDistribution, error) }
```

# pkg/store/icytransaction/icy_transaction.go

```go
package icytransaction import ( "gorm.io/gorm" "gorm.io/gorm/clause" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) Create(db *gorm.DB, model []model.IcyTransaction) error { return db.Clauses(clause.OnConflict{ Columns: []clause.Column{ {Name: "sender"}, {Name: "target"}, {Name: "category"}, {Name: "amount"}, {Name: "txn_time"}, }, UpdateAll: true, }).Create(&model).Error }
```

# pkg/store/icytransaction/interface.go

```go
package icytransaction import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, model []model.IcyTransaction) error }
```

# pkg/store/invoice/interface.go

```go
package invoice import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB, filter GetInvoicesFilter, pagination model.Pagination) (invoices []*model.Invoice, total int64, err error) Create(db *gorm.DB, e *model.Invoice) (invoice *model.Invoice, err error) Delete(db *gorm.DB, id string) (err error) GetLatestInvoiceByProject(db *gorm.DB, projectID string) (invoice *model.Invoice, err error) GetNextInvoiceNumber(db *gorm.DB, year int, projectCode string) (*string, error) IsExist(db *gorm.DB, id string) (exists bool, err error) One(db *gorm.DB, query *Query) (invoice *model.Invoice, err error) Save(db *gorm.DB, e *model.Invoice) (invoice *model.Invoice, err error) Update(db *gorm.DB, invoice *model.Invoice) (a *model.Invoice, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, invoice model.Invoice, updatedFields ...string) (a *model.Invoice, err error) } // Query present invoice query from user type Query struct { ID string Alias string Month int64 Year int64 ProjectName string Statuses []model.InvoiceStatus Number string } type GetInvoicesFilter struct { Preload bool ProjectIDs []string Statuses []string }
```

# pkg/store/invoice/invoice.go

```go
package invoice import ( "fmt" "strings" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One getNext invoice by id func (s *store) One(db *gorm.DB, query *Query) (*model.Invoice, error) { var invoice *model.Invoice if query.ID != "" { db = db.Where("id = ?", query.ID) } if query.Number != "" { db = db.Where("number = ?", query.Number) } return invoice, db. Preload("Project"). Preload("Project.Heads", "deleted_at IS NULL AND (end_date IS NULL OR end_date > now())"). Preload("Project.Heads.Employee", "deleted_at IS NULL"). Preload("Project.BankAccount", "deleted_at IS NULL"). Preload("Project.BankAccount.Currency", "deleted_at IS NULL"). Preload("Project.Organization", "deleted_at IS NULL"). First(&invoice).Error } // IsExist check the existence of invoice func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM invoices WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error } func (s *store) GetLatestInvoiceByProject(db *gorm.DB, projectID string) (*model.Invoice, error) { iv := model.Invoice{} return &iv, db.Where("project_id = ? AND status != ? AND status != ?", projectID, model.InvoiceStatusDraft, model.InvoiceStatusError).Order("created_at DESC").First(&iv).Error } // All getNext all invoice func (s *store) All(db *gorm.DB, filter GetInvoicesFilter, pagination model.Pagination) ([]*model.Invoice, int64, error) { var total int64 var invoices []*model.Invoice query := db.Table("invoices") if len(filter.ProjectIDs) > 0 { query = query.Where("project_id IN (?)", filter.ProjectIDs) } if len(filter.Statuses) > 0 { query = query.Where("status IN (?)", filter.Statuses) } err := db.Raw("SELECT COUNT(*) FROM (?) res", query).Scan(&total).Error if err != nil { return nil, 0, err } if filter.Preload { query = query. Preload("Bank"). Preload("Bank.Currency"). Preload("Project"). Preload("Project.Client", "deleted_at IS NULL"). Preload("Project.Client.Contacts", "deleted_at IS NULL"). Preload("Project.CompanyInfo", "deleted_at IS NULL") } limit, offset := pagination.ToLimitOffset() if pagination.Page > 0 { query = query.Limit(limit) } return invoices, total, query. Limit(limit). Offset(offset). Find(&invoices).Error } // Delete delete 1 invoice by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.Invoice{}).Error } // Create creates a new invoice func (s *store) Create(db *gorm.DB, e *model.Invoice) (invoice *model.Invoice, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, invoice *model.Invoice) (*model.Invoice, error) { return invoice, db.Model(&invoice).Where("id = ?", invoice.ID).Updates(&invoice).First(&invoice).Error } func (s *store) Save(db *gorm.DB, invoice *model.Invoice) (*model.Invoice, error) { return invoice, db.Save(&invoice).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Invoice, updatedFields ...string) (*model.Invoice, error) { invoice := model.Invoice{} return &invoice, db.Model(&invoice).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } func (s *store) GetNextInvoiceNumber(db *gorm.DB, year int, projectCode string) (*string, error) { yearComInvoiceKey := fmt.Sprintf("%s_%d", model.InvoiceCachingKey.YearInvoiceNumberPrefix, year) nextCompIvn, err := s.getNext(db, yearComInvoiceKey) if err != nil { return nil, err } key := fmt.Sprintf("%s_%s_%d", model.InvoiceCachingKey.ProjectInvoiceNumberPrefix, strings.ToUpper(projectCode), time.Now().Year()) nextProjectIvn, err := s.getNext(db, key) if err != nil { return nil, err } invoiceNumberText := fmt.Sprintf("%d%d-%s-%03d", year, nextCompIvn, strings.ToUpper(projectCode), nextProjectIvn) return &invoiceNumberText, err } func (s *store) getNext(db *gorm.DB, key string) (next int, err error) { var maxNumber model.InvoiceNumberCaching err = db.Where(&model.InvoiceNumberCaching{Key: key}).Find(&maxNumber).Error if err != nil { if err == gorm.ErrRecordNotFound { return 0, nil } return 0, err } return maxNumber.Number + 1, nil }
```

# pkg/store/invoicenumbercaching/interface.go

```go
package invoicenumbercaching import ( "time" "gorm.io/gorm" ) type IStore interface { Set(db *gorm.DB, key string) error Decrease(db *gorm.DB, key string) error GetNext(db *gorm.DB, key string) (int, error) // NextProjectTemplateNumber TODO: (hnh), might be we just need GetNext(key) fn to get these things ? NextProjectTemplateNumber(db *gorm.DB, pid string) (int, error) UpdateInvoiceCachingNumber(db *gorm.DB, issuedAt time.Time, projectAlias string) error UnCountErrorInvoice(db *gorm.DB, issuedAt time.Time) error }
```

# pkg/store/invoicenumbercaching/invoice_number_caching.go

```go
package invoicenumbercaching import ( "fmt" "strings" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) get(db *gorm.DB, key string) (next int, err error) { var maxNumber model.InvoiceNumberCaching err = db.Where(&model.InvoiceNumberCaching{Key: key}).Find(&maxNumber).Error if err != nil { if err == gorm.ErrRecordNotFound { return 0, nil } return 0, err } return maxNumber.Number + 1, nil } func (s *store) GetNext(db *gorm.DB, key string) (int, error) { return s.get(db, key) } func (s *store) Set(db *gorm.DB, key string) error { var maxNumber model.InvoiceNumberCaching err := db.Where(&model.InvoiceNumberCaching{Key: key}).FirstOrCreate(&maxNumber).Error if err != nil { return err } maxNumber.Number++ return db.Model(&maxNumber).Update("number", maxNumber.Number).Error } func (s *store) NextProjectTemplateNumber(db *gorm.DB, pid string) (next int, err error) { key := fmt.Sprintf("%s%s", model.InvoiceCachingKey.ProjectTemplateNumberPrefix, pid) return s.GetNext(db, key) } func (s *store) Decrease(db *gorm.DB, key string) error { var maxNumber model.InvoiceNumberCaching err := db.Where(&model.InvoiceNumberCaching{Key: key}).FirstOrCreate(&maxNumber).Error if err != nil { return err } maxNumber.Number-- return db.Model(&maxNumber).Update("number", maxNumber.Number).Error } func (s *store) UpdateInvoiceCachingNumber(db *gorm.DB, issuedAt time.Time, alias string) error { year := issuedAt.Year() err := s.Set(db, fmt.Sprintf("%s_%d", model.InvoiceCachingKey.YearInvoiceNumberPrefix, year)) if err != nil { return err } err = s.Set(db, fmt.Sprintf("%s_%s_%d", model.InvoiceCachingKey.ProjectInvoiceNumberPrefix, strings.ToUpper(alias), year)) if err != nil { return err } return nil } func (s *store) UnCountErrorInvoice(db *gorm.DB, issuedAt time.Time) error { year := issuedAt.Year() return s.Decrease(db, fmt.Sprint(model.InvoiceCachingKey.YearInvoiceNumberPrefix, year)) }
```

# pkg/store/memolog/interface.go

```go
package memolog import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, b []model.MemoLog) ([]model.MemoLog, error) GetLimitByTimeRange(db *gorm.DB, start, end *time.Time, limit int) ([]model.MemoLog, error) List(db *gorm.DB, filter ListFilter) ([]model.MemoLog, error) GetRankByDiscordID(db *gorm.DB, discordID string) (*model.DiscordAccountMemoRank, error) ListNonAuthor(db *gorm.DB) ([]model.MemoLog, error) CreateMemoAuthor(db *gorm.DB, memoAuthor *model.MemoAuthor) error GetTopAuthors(db *gorm.DB, limit int) ([]model.DiscordAccountMemoRank, error) }
```

# pkg/store/memolog/memo_log.go

```go
package memolog import ( "fmt" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create creates a memo log record in the database func (s *store) Create(db *gorm.DB, b []model.MemoLog) ([]model.MemoLog, error) { return b, db.Table("memo_logs").Create(b).Error } // GetLimitByTimeRange gets memo logs in a specific time range, with limit func (s *store) GetLimitByTimeRange(db *gorm.DB, start, end *time.Time, limit int) ([]model.MemoLog, error) { var logs []model.MemoLog return logs, db.Preload("Authors").Preload("Authors.Employee").Where("published_at BETWEEN ? AND ?", start, end).Limit(limit).Order("published_at DESC").Find(&logs).Error } // ListFilter is a filter for List function type ListFilter struct { From *time.Time To *time.Time DiscordID string } // List gets all memo logs func (s *store) List(db *gorm.DB, filter ListFilter) ([]model.MemoLog, error) { var logs []model.MemoLog query := db.Preload("Authors").Preload("Authors.Employee").Order("published_at DESC") if filter.From != nil { query = query.Where("published_at >= ?", *filter.From) } if filter.To != nil { query = query.Where("published_at <= ?", *filter.To) } if filter.DiscordID != "" { query = query.Joins("JOIN memo_authors ma ON ma.memo_log_id = memo_logs.id"). Joins("JOIN discord_accounts da ON da.id = ma.discord_account_id AND da.discord_id = ?", filter.DiscordID) } return logs, query.Find(&logs).Error } // ListNonAuthor gets all memo logs that have no author info func (s *store) ListNonAuthor(db *gorm.DB) ([]model.MemoLog, error) { var logs []model.MemoLog query := ` SELECT memo_logs.* FROM memo_logs LEFT JOIN memo_authors ON memo_authors.memo_log_id = memo_logs.id GROUP BY memo_logs.id HAVING STRING_AGG(memo_authors.discord_account_id::text, ', ') IS NULL OR STRING_AGG(memo_authors.discord_account_id::text, ', ') = '' ` return logs, db.Raw(query).Scan(&logs).Error } func (s *store) GetRankByDiscordID(db *gorm.DB, discordID string) (*model.DiscordAccountMemoRank, error) { query := ` WITH memo_count AS ( SELECT da.discord_id, COUNT(ml.id) AS total_memos FROM public.memo_authors ma JOIN public.memo_logs ml ON ma.memo_log_id = ml.id JOIN public.discord_accounts da ON ma.discord_account_id = da.id WHERE ml.deleted_at IS NULL GROUP BY da.discord_id ), ranked_memos AS ( SELECT discord_id, total_memos, RANK() OVER (ORDER BY total_memos DESC) AS rank FROM memo_count ) SELECT rm.discord_id, rm.total_memos, rm.rank FROM ranked_memos rm WHERE rm.discord_id = ? ` var memoRank model.DiscordAccountMemoRank result := db.Raw(query, discordID).Scan(&memoRank) if result.Error != nil { return nil, result.Error } if result.RowsAffected == 0 { return nil, fmt.Errorf("no records found for discord_id: %s", discordID) } return &memoRank, nil } // CreateMemoAuthor creates a memo author record in the database func (s *store) CreateMemoAuthor(db *gorm.DB, memoAuthor *model.MemoAuthor) error { return db.Create(memoAuthor).Error } // GetTopAuthors gets the top authors by memo count func (s *store) GetTopAuthors(db *gorm.DB, limit int) ([]model.DiscordAccountMemoRank, error) { query := ` WITH memo_count AS ( SELECT da.discord_id, da.discord_username, da.memo_username, COUNT(ml.id) AS total_memos FROM public.memo_authors ma JOIN public.memo_logs ml ON ma.memo_log_id = ml.id JOIN public.discord_accounts da ON ma.discord_account_id = da.id WHERE ml.deleted_at IS NULL -- Exclude deleted memos if necessary GROUP BY da.discord_id, da.discord_username, da.memo_username ) SELECT discord_id, discord_username, memo_username, total_memos, RANK() OVER (ORDER BY total_memos DESC) AS rank FROM memo_count ORDER BY total_memos DESC LIMIT ?; ` var topAuthors []model.DiscordAccountMemoRank return topAuthors, db.Raw(query, limit).Scan(&topAuthors).Error }
```

# pkg/store/onleaverequest/interface.go

```go
package onleaverequest import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, r *model.OnLeaveRequest) (request *model.OnLeaveRequest, err error) All(db *gorm.DB, input GetOnLeaveInput) ([]*model.OnLeaveRequest, error) }
```

# pkg/store/onleaverequest/onleave_request.go

```go
package onleaverequest import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } type GetOnLeaveInput struct { Date string } // Create creates an on-leave request record in the database func (s *store) Create(db *gorm.DB, r *model.OnLeaveRequest) (request *model.OnLeaveRequest, err error) { return r, db.Create(r).Error } func (s *store) All(db *gorm.DB, input GetOnLeaveInput) ([]*model.OnLeaveRequest, error) { var chapters []*model.OnLeaveRequest query := db. Preload("Creator"). Preload("Creator.DiscordAccount"). Preload("Approver"). Preload("Approver.DiscordAccount") if input.Date != "" { query = query.Where("start_date <= ? AND ? <= end_date", input.Date, input.Date) } return chapters, query.Find(&chapters).Error }
```

# pkg/store/operationalservice/interface.go

```go
package operationalservice import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { FindOperationByMonth(db *gorm.DB, month time.Month) ([]*model.OperationalService, error) }
```

# pkg/store/operationalservice/operational_service.go

```go
package operationalservice import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s store) FindOperationByMonth(db *gorm.DB, month time.Month) ([]*model.OperationalService, error) { var res []*model.OperationalService query := db.Table("operational_services"). Preload("Currency"). Where("is_active is true and type = 'monthly'") err := query.Find(&res).Error if err != nil && err != gorm.ErrRecordNotFound { return nil, err } return res, nil }
```

# pkg/store/organization/interface.go

```go
package organization import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (organization *model.Organization, err error) OneByCode(db *gorm.DB, code string) (organization *model.Organization, err error) All(db *gorm.DB) ([]*model.Organization, error) IsExist(db *gorm.DB, id string) (exists bool, err error) }
```

# pkg/store/organization/organization.go

```go
package organization import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type store struct{} func New() IStore { return &store{} } func (s *store) One(db *gorm.DB, id string) (*model.Organization, error) { var organization *model.Organization return organization, db.Where("id = ?", id).First(&organization).Error } func (s *store) All(db *gorm.DB) ([]*model.Organization, error) { var organizations []*model.Organization return organizations, db.Find(&organizations).Error } func (s *store) OneByCode(db *gorm.DB, code string) (*model.Organization, error) { var organization *model.Organization return organization, db.Where("code = ?", code).First(&organization).Error } // IsExist check organization existence func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM organizations WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error }
```

# pkg/store/payroll/input.go

```go
package payroll type GetListPayrollInput struct { ID string UserID string Day int Month int Year int }
```

# pkg/store/payroll/interface.go

```go
package payroll import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) // IStore implement operation method type IStore interface { // GetSalary TODO: rename to GetList GetSalary(db *gorm.DB, year int, month int) ([]model.Employee, error) Get(db *gorm.DB, userId string, year, month int) (*model.Payroll, error) Create(db *gorm.DB, p *model.Payroll) error InsertList(db *gorm.DB, payrolls []model.Payroll) error // GetList payroll row, the result included: User, // Role, Rank, Base Salary and Commission GetList(db *gorm.DB, q GetListPayrollInput) ([]model.Payroll, error) // UpdateSpecificFields for a payroll row // fields that will be update will be declared // as string match with column name in table payroll UpdateSpecificFields(db *gorm.DB, id string, fields map[string]interface{}) error GetLatestCommitTime(db *gorm.DB) (time.Time, error) }
```

# pkg/store/payroll/payroll.go

```go
package payroll import ( "fmt" "strings" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} // New create new pg service func New() IStore { return &store{} } func (s *store) GetSalary(db *gorm.DB, year int, month int) ([]model.Employee, error) { var employees []model.Employee return employees, db.Table("employee"). Where("status = <> ?", model.WorkingStatusLeft). Preload("Expense", func(db *gorm.DB) *gorm.DB { return db.Where("date_part('year', issued_date) = ? AND date_part('month', issued_date) = ?", year, month) }). Group("employee.id"). Find(&employees). Error } func (s *store) Create(db *gorm.DB, p *model.Payroll) error { return db.Create(p).Error } func (s *store) Get(db *gorm.DB, employeeId string, month, year int) (*model.Payroll, error) { res := &model.Payroll{} return res, db.Where("employee_id = ? AND year = ? AND month = ?", employeeId, year, month).First(&res).Error } func (s *store) GetList(db *gorm.DB, q GetListPayrollInput) ([]model.Payroll, error) { var res []model.Payroll payrollQuery := db. Preload("Employee", func(db *gorm.DB) *gorm.DB { return db.Order("display_name asc") }). Preload("Employee.BaseSalary.Currency") if q.ID != "" { payrollQuery = payrollQuery.Where("payrolls.id = ?", q.ID) } if q.UserID != "" { payrollQuery = payrollQuery.Where("payrolls.employee_id = ?", q.UserID) } if q.Month != 0 { payrollQuery = payrollQuery.Where("payrolls.month = ?", q.Month) } if q.Year != 0 { payrollQuery = payrollQuery.Where("payrolls.year = ?", q.Year) } if q.Day != 0 { payrollQuery = payrollQuery.Where("date_part('day', due_date) = ?", q.Day) } err := payrollQuery. Order(` year desc, month desc`). Find(&res). Error if err != nil { return nil, err } for i, v := range res { var baseSalary model.BaseSalary if err := db. Preload("Currency"). Where("employee_id = ?", v.EmployeeID). Order("effective_date desc"). First(&baseSalary).Error; err != nil { if err == gorm.ErrRecordNotFound { continue } return nil, err } res[i].Employee.BaseSalary = baseSalary } return res, nil } func (s *store) UpdateSpecificFields(db *gorm.DB, id string, fields map[string]interface{}) error { return db.Model(&model.Payroll{}). Where("id = ?", id). Updates(fields).Error } func (s *store) GetLatestCommitTime(db *gorm.DB) (time.Time, error) { var DueDate time.Time return DueDate, db.Table("payrolls").Select("max(due_date) as due_date").Row().Scan(&DueDate) } func (s *store) InsertList(db *gorm.DB, payrolls []model.Payroll) error { if len(payrolls) <= 0 { return fmt.Errorf("payrolls cannot be empty") } var valueStrings []string var valueArgs []interface{} for _, payroll := range payrolls { valueStrings = append(valueStrings, "(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)") valueArgs = append(valueArgs, model.NewUUID()) valueArgs = append(valueArgs, payroll.EmployeeID) valueArgs = append(valueArgs, payroll.Total) valueArgs = append(valueArgs, payroll.Month) valueArgs = append(valueArgs, payroll.Year) valueArgs = append(valueArgs, payroll.CommissionAmount) valueArgs = append(valueArgs, payroll.CommissionExplain) valueArgs = append(valueArgs, payroll.UserRankSnapshot) valueArgs = append(valueArgs, payroll.TotalExplain) valueArgs = append(valueArgs, payroll.ProjectBonusAmount) valueArgs = append(valueArgs, payroll.DueDate) valueArgs = append(valueArgs, payroll.ProjectBonusExplain) valueArgs = append(valueArgs, payroll.IsPaid) valueArgs = append(valueArgs, payroll.ConversionAmount) valueArgs = append(valueArgs, payroll.BaseSalaryAmount) valueArgs = append(valueArgs, payroll.ContractAmount) valueArgs = append(valueArgs, payroll.SalaryAdvanceAmount) } smt := `INSERT INTO payrolls(id, employee_id, total, month, year, commission_amount, commission_explain, employee_rank_snapshot, total_explain, project_bonus_amount, due_date, project_bonus_explain, is_paid, conversion_amount, base_salary_amount, contract_amount, salary_advance_amount) VALUES %s` smt = fmt.Sprintf(smt, strings.Join(valueStrings, ",")) tx := db.Begin() err := tx.Exec(smt, valueArgs...).Error if err != nil { tx.Rollback() return err } tx.Commit() return nil }
```

# pkg/store/permission/interface.go

```go
package permission import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { GetByEmployeeID(db *gorm.DB, employeeID string) (permissions []*model.Permission, err error) GetByApiKeyID(db *gorm.DB, apiKeyID string) ([]*model.Permission, error) HasPermission(db *gorm.DB, employeeID string, perm string) (bool, error) }
```

# pkg/store/permission/permission.go

```go
package permission import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // GetByEmployeeID get list of permissions by employee id func (s *store) GetByEmployeeID(db *gorm.DB, employeeID string) ([]*model.Permission, error) { var permissions []*model.Permission return permissions, db. Select("DISTINCT permissions.*"). Joins("JOIN role_permissions rp ON permissions.id = rp.permission_id"). Joins("JOIN employee_roles er ON er.role_id = rp.role_id"). Where("er.employee_id = ?", employeeID). Order("permissions.code"). Find(&permissions).Error } func (s *store) HasPermission(db *gorm.DB, employeeID string, permCode string) (bool, error) { var res struct { Result bool } query := db.Raw(` SELECT EXISTS ( SELECT * FROM permissions p JOIN role_permissions rp ON p.id = rp.permission_id JOIN employee_roles er ON rp.role_id = er.role_id JOIN employees e ON er.employee_id = e.id AND e.id = ? WHERE p.code = ? ) as result`, employeeID, permCode) return res.Result, query.Scan(&res).Error } func (s *store) GetByApiKeyID(db *gorm.DB, apiKeyID string) ([]*model.Permission, error) { var permissions []*model.Permission return permissions, db. Select("DISTINCT permissions.*"). Joins("JOIN role_permissions rp ON permissions.id = rp.permission_id"). Joins("JOIN api_key_roles ar ON ar.role_id = rp.role_id"). Where("ar.api_key_id = ?", apiKeyID). Order("permissions.code"). Find(&permissions).Error }
```

# pkg/store/physicalcheckin/interface.go

```go
package physicalcheckin import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id int) (pc *model.PhysicalCheckinTransaction, err error) Save(db *gorm.DB, pc *model.PhysicalCheckinTransaction) (err error) GetByEmployeeIDAndDate(db *gorm.DB, employeeID string, date string) (*model.PhysicalCheckinTransaction, error) }
```

# pkg/store/physicalcheckin/physical_checkin.go

```go
package physicalcheckin import ( "gorm.io/gorm" "gorm.io/gorm/clause" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) Save(db *gorm.DB, tx *model.PhysicalCheckinTransaction) error { return db.Clauses(clause.OnConflict{ Columns: []clause.Column{{Name: "employee_id"}, {Name: "date"}}, DoUpdates: clause.Assignments(map[string]interface{}{ "icy_amount": tx.IcyAmount, "mochi_tx_id": tx.MochiTxID, }), }).Create(tx).Error } func (s *store) One(db *gorm.DB, id int) (*model.PhysicalCheckinTransaction, error) { var tx model.PhysicalCheckinTransaction err := db.Where("id = ?", id).First(&tx).Error return &tx, err } func (s *store) GetByEmployeeIDAndDate(db *gorm.DB, employeeID string, date string) (*model.PhysicalCheckinTransaction, error) { var tx model.PhysicalCheckinTransaction err := db.Where("employee_id = ? AND date = ?", employeeID, date).First(&tx).Error return &tx, err }
```

# pkg/store/position/interface.go

```go
package position import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB) (positions []*model.Position, err error) One(db *gorm.DB, id model.UUID) (position *model.Position, err error) Update(db *gorm.DB, position *model.Position) (p *model.Position, err error) Create(db *gorm.DB, position *model.Position) (p *model.Position, err error) Delete(db *gorm.DB, id string) (err error) }
```

# pkg/store/position/position.go

```go
package position import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // All get all positions func (s *store) All(db *gorm.DB) ([]*model.Position, error) { var positions []*model.Position return positions, db.Find(&positions).Error } // One get 1 one by id func (s *store) One(db *gorm.DB, id model.UUID) (*model.Position, error) { var pos *model.Position return pos, db.Where("id = ?", id).First(&pos).Error } // Update update the position func (s *store) Update(db *gorm.DB, position *model.Position) (*model.Position, error) { return position, db.Model(&model.Position{}).Where("id = ?", position.ID).Updates(&position).First(&position).Error } // Delete delete ProjectMember by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.Position{}).Error } // Create create new position func (s *store) Create(db *gorm.DB, position *model.Position) (*model.Position, error) { return position, db.Create(position).Error }
```

# pkg/store/project/interface.go

```go
package project import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB, input GetListProjectInput, pagination model.Pagination) ([]*model.Project, int64, error) Create(db *gorm.DB, project *model.Project) error IsExist(db *gorm.DB, id string) (bool, error) IsExistByCode(db *gorm.DB, code string) (bool, error) One(db *gorm.DB, id string, preload bool) (*model.Project, error) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Project, updatedFields ...string) (*model.Project, error) GetByEmployeeID(db *gorm.DB, employeeID string) ([]*model.Project, error) GetProjectByAlias(db *gorm.DB, alias string) (*model.Project, error) GetRawList(db *gorm.DB) ([]model.Project, error) }
```

# pkg/store/project/project.go

```go
package project import ( "fmt" "strings" "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // All get all projects by query and pagination func (s *store) All(db *gorm.DB, input GetListProjectInput, pagination model.Pagination) ([]*model.Project, int64, error) { var projects []*model.Project query := db.Table("projects"). Where("projects.deleted_at IS NULL") var total int64 if input.Name != "" { query = query.Where("projects.name ILIKE ?", fmt.Sprintf("%%%s%%", input.Name)) } if len(input.Statuses) > 0 { query = query.Where("projects.status IN ?", input.Statuses) } if len(input.Types) > 0 { query = query.Where("projects.type IN ?", input.Types) } if input.AllowsSendingSurvey { query = query.Where("projects.allows_sending_survey = ?", input.AllowsSendingSurvey) } query = query.Count(&total) query = query. Select("projects.*, COALESCE(SUM(project_members.rate)/currency_exchanges.exchange_rate, 0) as converted_monthly_revenue"). Joins(`LEFT JOIN project_members ON project_members.project_id = projects.id AND project_members.deleted_at IS NULL AND project_members.status = 'active' AND project_members.deployment_type = 'official' `). Joins("LEFT JOIN bank_accounts on projects.bank_account_id = bank_accounts.id"). Joins("LEFT JOIN currencies on bank_accounts.currency_id = currencies.id"). Joins(` LEFT JOIN ( SELECT * FROM ( VALUES ('USD', 'USD', 1), ('USD', 'CAD', 1.33420), ('USD', 'GBP', 0.79488), ('USD', 'EUR', 0.93030), ('USD', 'VND', 23480), ('USD', 'SGD', 1.34325)) AS rates(src_cur, dest_cur, exchange_rate) ) as currency_exchanges ON currencies.name = currency_exchanges.dest_cur`). Group(` projects.id, projects.deleted_at, projects.created_at, projects.updated_at, projects.name, projects.type, projects.start_date, projects.end_date, projects.status, projects.country_id, projects.client_email, projects.project_email, projects.allows_sending_survey, projects.avatar, projects.code, projects.bank_account_id, projects.client_id, projects.company_info_id, projects.organization_id, account_rating, delivery_rating, lead_rating, important_level, currencies.name, currency_exchanges.exchange_rate `) if pagination.Sort != "" { query = query.Order(s.sortFieldMapping(pagination.Sort)) } else { query = query.Order("converted_monthly_revenue DESC") } limit, offset := pagination.ToLimitOffset() if pagination.Page > 0 { query = query.Limit(limit) } query = query.Preload("ProjectMembers", func(db *gorm.DB) *gorm.DB { return db.Joins("JOIN projects ON project_members.project_id = projects.id"). Where("project_members.deleted_at IS NULL AND (projects.status = ? OR project_members.status = ?)", model.ProjectStatusClosed, model.ProjectMemberStatusActive) }). Preload("ProjectMembers.Employee"). Preload("ProjectNotion", "deleted_at IS NULL"). Preload("Organization", "deleted_at IS NULL"). Preload("Heads", `deleted_at IS NULL AND (end_date IS NULL OR end_date > now())`). Preload("Heads.Employee"). Preload("BankAccount", "deleted_at IS NULL"). Preload("BankAccount.Currency", "deleted_at IS NULL"). Preload("CommissionConfigs", "deleted_at IS NULL"). Offset(offset) return projects, total, query.Find(&projects).Error } // Create use to create new project to database func (s *store) Create(db *gorm.DB, project *model.Project) error { return db.Create(&project).Preload("Country").Error } // IsExist check project existence func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM projects WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error } // IsExistByCode check project existence by code func (s *store) IsExistByCode(db *gorm.DB, code string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM projects WHERE code = ?) as result", code) return result.Result, query.Scan(&result).Error } // One get 1 project by id func (s *store) One(db *gorm.DB, id string, preload bool) (*model.Project, error) { query := db if !model.IsUUIDFromString(id) { query = db.Where("code = ?", id) } else { query = db.Where("id = ?", id) } query = query. Preload("BankAccount", "deleted_at IS NULL"). Preload("BankAccount.Currency", "deleted_at IS NULL") if preload { query = query. Preload("Heads", "deleted_at IS NULL AND (end_date IS NULL OR end_date > now())"). Preload("Heads.Employee", "deleted_at IS NULL"). Preload("ProjectStacks", "deleted_at IS NULL"). Preload("ProjectStacks.Stack", "deleted_at IS NULL"). Preload("Country", "deleted_at IS NULL"). Preload("Client", "deleted_at IS NULL"). Preload("Client.Contacts", "deleted_at IS NULL"). Preload("CompanyInfo", "deleted_at IS NULL"). Preload("ProjectNotion", "deleted_at IS NULL"). Preload("Organization", "deleted_at IS NULL"). Preload("ProjectMembers", func(db *gorm.DB) *gorm.DB { return db.Joins("JOIN seniorities s ON s.id = project_members.seniority_id"). Joins(`LEFT JOIN project_heads ph ON ph.project_id = project_members.project_id AND ph.employee_id = project_members.employee_id AND ph.position = ? AND (ph.end_date IS NULL OR ph.end_date > now())`, model.HeadPositionTechnicalLead, ). Where("project_members.deleted_at IS NULL"). Where("project_members.start_date <= now()"). Where("(project_members.end_date IS NULL OR project_members.end_date > now())"). Order("CASE ph.position WHEN 'technical-lead' THEN 1 ELSE 2 END"). Order("s.level DESC") }). Preload("ProjectMembers.Employee", "deleted_at IS NULL"). Preload("ProjectMembers.ProjectMemberPositions", "deleted_at IS NULL"). Preload("ProjectMembers.ProjectMemberPositions.Position", "deleted_at IS NULL"). Preload("ProjectMembers.Seniority", "deleted_at IS NULL"). Preload("ProjectMembers.UpsellPerson", "deleted_at IS NULL"). Preload("CommissionConfigs", "deleted_at IS NULL") } var project *model.Project return project, query.First(&project).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.Project, updatedFields ...string) (*model.Project, error) { project := model.Project{} return &project, db.Model(&project).Where("id = ?", id).Select(updatedFields).Updates(&updateModel).Error } // GetByEmployeeID get project list by employee id func (s *store) GetByEmployeeID(db *gorm.DB, employeeID string) ([]*model.Project, error) { var projects []*model.Project query := db.Table("projects"). Joins("JOIN project_members pm ON pm.project_id = projects.id"). Where("pm.start_date <= now() AND (pm.end_date IS NULL OR pm.end_date > now())"). Where("projects.status = ?", model.ProjectStatusActive). Where("projects.deleted_at IS NULL AND pm.employee_id = ?", employeeID). Preload("Heads", func(db *gorm.DB) *gorm.DB { return db.Joins("JOIN projects p ON project_heads.project_id = p.id"). Where("(project_heads.end_date IS NULL OR project_heads.end_date > ?) AND project_heads.employee_id = ? AND project_heads.position = ?", time.Now(), employeeID, model.HeadPositionTechnicalLead) }). Preload("Heads.Employee") return projects, query.Find(&projects).Error } func (s *store) GetProjectByAlias(db *gorm.DB, alias string) (*model.Project, error) { res := model.Project{} return &res, db.Where("alias = ?", alias).Preload("ProjectInfo").Find(&res).Error } func (s *store) sortFieldMapping(fields string) string { sortFields := strings.Split(fields, ",") sortString := "" for _, field := range sortFields { sortField := strings.Split(field, " ") switch sortField[0] { case "monthlyChargeRate": sortString += fmt.Sprintf("%v %v, ", "converted_monthly_revenue", sortField[1]) case "importantLevel": sortString += fmt.Sprintf("%v %v, ", "projects.important_level", sortField[1]) case "updatedAt": sortString += fmt.Sprintf("%v %v, ", "projects.updated_at", sortField[1]) } } if sortString == "" { return fmt.Sprintf("%v %v", "converted_monthly_revenue", "DESC") } return strings.TrimSuffix(sortString, ", ") } func (s *store) GetRawList(db *gorm.DB) ([]model.Project, error) { var projects []model.Project return projects, db.Find(&projects).Error }
```

# pkg/store/project/request.go

```go
package project type GetListProjectInput struct { Statuses []string `json:"statuses"` Name string `json:"name"` Types []string `json:"type"` AllowsSendingSurvey bool `json:"allowsSendingSurvey"` }
```

# pkg/store/projectcommissionconfig/interface.go

```go
package projectcommissionconfig import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type IStore interface { GetByProjectID(db *gorm.DB, projectID string) (heads model.ProjectCommissionConfigs, err error) }
```

# pkg/store/projectcommissionconfig/project_commission_config.go

```go
package projectcommissionconfig import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type store struct{} func New() IStore { return &store{} } func (s *store) GetByProjectID(db *gorm.DB, projectID string) (model.ProjectCommissionConfigs, error) { var heads model.ProjectCommissionConfigs return heads, db.Where("project_id = ?", projectID).Find(&heads).Error }
```

# pkg/store/projecthead/interface.go

```go
package projecthead import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, head *model.ProjectHead) error BatchCreate(db *gorm.DB, heads []*model.ProjectHead) ([]*model.ProjectHead, error) GetActiveLeadsByProjectID(db *gorm.DB, projectID string) (projectHeads []*model.ProjectHead, err error) DeleteByPositionInProject(db *gorm.DB, projectID string, employeeID string, position string) (err error) DeleteByID(db *gorm.DB, id string) (err error) One(db *gorm.DB, projectID string, employeeID string, position model.HeadPosition) (projectHead *model.ProjectHead, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectHead, updatedFields ...string) (*model.ProjectHead, error) UpdateDateOfEmployee(db *gorm.DB, employeeID string, projectID string, position string, startDate *time.Time, endDate *time.Time) (*model.ProjectHead, error) GetByProjectIDAndPosition(db *gorm.DB, projectID string, position model.HeadPosition) (heads []*model.ProjectHead, err error) }
```

# pkg/store/projecthead/project_head.go

```go
package projecthead import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create using for insert new data to project head func (s *store) Create(db *gorm.DB, projectHead *model.ProjectHead) error { return db.Create(projectHead).Preload("Employee").First(projectHead).Error } // BatchCreate create multiple project heads in one transaction func (s *store) BatchCreate(db *gorm.DB, heads []*model.ProjectHead) ([]*model.ProjectHead, error) { return heads, db.Create(&heads).Error } // GetActiveLeadsByProjectID get active project heads by projectID func (s *store) GetActiveLeadsByProjectID(db *gorm.DB, projectID string) ([]*model.ProjectHead, error) { var projectHeads []*model.ProjectHead now := time.Now() return projectHeads, db.Where("project_id = ? AND (end_date IS NULL OR end_date > ?)", projectID, now). Order("position"). Preload("Employee"). Find(&projectHeads).Error } func (s *store) DeleteByPositionInProject(db *gorm.DB, projectID string, employeeID string, position string) error { return db.Unscoped().Where("project_id = ? AND employee_id = ? AND position = ?", projectID, employeeID, position).Delete(&model.ProjectHead{}).Error } func (s *store) DeleteByID(db *gorm.DB, id string) error { return db.Unscoped().Where("id = ?", id).Delete(&model.ProjectHead{}).Error } func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectHead, updatedFields ...string) (*model.ProjectHead, error) { head := model.ProjectHead{} return &head, db.Model(&head).Where("id = ?", id).Select(updatedFields).Updates(&updateModel).Error } // One Get one head by project id and position func (s *store) One(db *gorm.DB, projectID string, employeeID string, position model.HeadPosition) (*model.ProjectHead, error) { var projectHead *model.ProjectHead return projectHead, db. Where("project_id = ?", projectID). Where("employee_id = ?", employeeID). Where("position = ?", position). First(&projectHead).Error } func (s *store) UpdateDateOfEmployee(db *gorm.DB, employeeID string, projectID string, position string, startDate *time.Time, endDate *time.Time) (*model.ProjectHead, error) { head := model.ProjectHead{} return &head, db. Model(&head). Where("employee_id = ? AND project_id = ? AND position = ?", employeeID, projectID, position). Updates(map[string]interface{}{ "start_date": startDate, "end_date": endDate, }).Error } func (s *store) GetByProjectIDAndPosition(db *gorm.DB, projectID string, position model.HeadPosition) ([]*model.ProjectHead, error) { var heads []*model.ProjectHead return heads, db.Where("project_id = ? AND position = ?", projectID, position).Find(&heads).Error }
```

# pkg/store/projectmember/interface.go

```go
package projectmember import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, member *model.ProjectMember) error Delete(db *gorm.DB, id string) (err error) GetActiveByProjectIDs(db *gorm.DB, projectIDs []string) ([]*model.ProjectMember, error) GetActiveMemberInProject(db *gorm.DB, projectID string, employeeID string) (*model.ProjectMember, error) GetActiveMembersBySlotID(db *gorm.DB, slotID string) ([]*model.ProjectMember, error) GetAssignedMembers(db *gorm.DB, projectID string, status string, preload bool) ([]*model.ProjectMember, error) IsExist(db *gorm.DB, id string) (bool, error) IsExistsByEmployeeID(db *gorm.DB, projectID string, employeeID string) (bool, error) OneByID(db *gorm.DB, id string) (*model.ProjectMember, error) OneBySlotID(db *gorm.DB, slotID string) (*model.ProjectMember, error) UpdateEndDateByProjectID(db *gorm.DB, projectID string) error UpdateEndDateOverdueMemberToInActive(db *gorm.DB) error UpdateLeftMemberToInActive(db *gorm.DB) error UpdateMemberInClosedProjectToInActive(db *gorm.DB) error UpdateMemberToInActiveByID(db *gorm.DB, id string, endDate *time.Time) error UpdateSelectedFieldByProjectID(db *gorm.DB, projectID string, updateModel model.ProjectMember, updatedField string) error UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectMember, updatedFields ...string) (*model.ProjectMember, error) }
```

# pkg/store/projectmember/project_member.go

```go
package projectmember import ( "time" "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type store struct{} func New() IStore { return &store{} } // Delete delete ProjectMember by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Unscoped().Where("id = ?", id).Delete(&model.ProjectMember{}).Error } // IsExist check ProjectMember existence func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { var record struct { Result bool } query := db.Raw("SELECT EXISTS (SELECT * FROM project_members WHERE id = ?) as result", id) return record.Result, query.Scan(&record).Error } // OneByID return a project member by id func (s *store) OneByID(db *gorm.DB, id string) (*model.ProjectMember, error) { var member *model.ProjectMember return member, db.Where("id = ?", id).First(&member).Error } // OneBySlotID return a project member by slotID func (s *store) OneBySlotID(db *gorm.DB, slotID string) (*model.ProjectMember, error) { var member *model.ProjectMember return member, db.Where("project_slot_id = ? AND status = ?", slotID, model.ProjectMemberStatusActive). Preload("Employee"). First(&member).Error } // Create using for create new member func (s *store) Create(db *gorm.DB, member *model.ProjectMember) error { return db.Create(&member).Preload("Employee").First(&member).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectMember, updatedFields ...string) (*model.ProjectMember, error) { member := model.ProjectMember{} return &member, db.Model(&member).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // UpdateSelectedFieldByProjectID just update selected field by projectID func (s *store) UpdateSelectedFieldByProjectID(db *gorm.DB, projectID string, updateModel model.ProjectMember, updatedField string) error { return db.Model(&model.ProjectMember{}). Where("project_id = ?", projectID). Select(updatedField). Updates(updateModel).Error } // UpdateEndDateByProjectID just update end_date by projectID func (s *store) UpdateEndDateByProjectID(db *gorm.DB, projectID string) error { now := time.Now() return db.Model(&model.ProjectMember{}). Where("project_id = ? AND (end_date IS NULL OR end_date > ?)", projectID, now). Select("end_date"). Updates(model.ProjectMember{EndDate: &now}).Error } // IsExistsByEmployeeID check ProjectMember existence by project id and employee id func (s *store) IsExistsByEmployeeID(db *gorm.DB, projectID string, employeeID string) (bool, error) { var record struct { Result bool } query := db.Raw("SELECT EXISTS (SELECT * FROM project_members WHERE project_id = ? and employee_id = ?) as result", projectID, employeeID) return record.Result, query.Scan(&record).Error } // GetActiveByProjectIDs get project member by projectID list func (s *store) GetActiveByProjectIDs(db *gorm.DB, projectIDs []string) ([]*model.ProjectMember, error) { var members []*model.ProjectMember return members, db.Joins("JOIN employees ON project_members.employee_id = employees.id").Where("(project_members.end_date IS NULL OR project_members.end_date > ?) AND project_members.status = 'active' AND employees.working_status = 'full-time' AND project_members.project_id IN ?", time.Now(), projectIDs).Preload("Employee").Find(&members).Error } func (s *store) GetActiveMemberInProject(db *gorm.DB, projectID string, employeeID string) (*model.ProjectMember, error) { var member *model.ProjectMember return member, db. Where("project_id = ?", projectID). Where("employee_id = ?", employeeID). Where("(end_date IS NULL OR end_date > now())"). Preload("Employee"). First(&member).Error } func (s *store) GetActiveMembersBySlotID(db *gorm.DB, slotID string) ([]*model.ProjectMember, error) { var members []*model.ProjectMember return members, db.Where("project_slot_id = ? AND status = ?", slotID, model.ProjectMemberStatusActive).Find(&members).Error } func (s *store) GetAssignedMembers(db *gorm.DB, projectID string, status string, preload bool) ([]*model.ProjectMember, error) { timeNow := time.Now() query := db.Table("project_members"). Joins("LEFT JOIN seniorities s ON project_members.seniority_id = s.id"). Joins(`LEFT JOIN project_heads ph ON (project_members.end_date IS NULL OR project_members.end_date > ?) AND project_members.project_id = ph.project_id AND project_members.employee_id = ph.employee_id AND ph.deleted_at IS NULL AND (ph.end_date IS NULL OR ph.end_date > ?) AND ph.position = ? `, timeNow, timeNow, model.HeadPositionTechnicalLead). Where("project_members.deleted_at IS NULL AND project_members.project_id = ?", projectID). Order("project_members.end_date DESC, ph.created_at, s.level DESC"). Preload("Employee", "deleted_at IS NULL"). Preload("Employee.Referrer", "deleted_at IS NULL") switch status { case model.ProjectMemberStatusOnBoarding.String(): query = query.Where("project_members.start_date > ?", timeNow) case model.ProjectMemberStatusActive.String(): query = query.Where("project_members.start_date <= ?", timeNow). Where("(project_members.end_date IS NULL OR project_members.end_date > ?)", timeNow) case model.ProjectMemberStatusInactive.String(): query = query.Where("project_members.end_date <= ?", timeNow) } if preload { query = query.Preload("Seniority", "deleted_at IS NULL"). Preload("UpsellPerson", "deleted_at IS NULL"). Preload("ProjectMemberPositions", "deleted_at IS NULL"). Preload("ProjectMemberPositions.Position", "deleted_at IS NULL") } var members []*model.ProjectMember return members, query.Find(&members).Error } // UpdateEndDateOverdueMemberToInActive just update end_date by projectID func (s *store) UpdateEndDateOverdueMemberToInActive(db *gorm.DB) error { sql := ` UPDATE project_members SET status = 'inactive' WHERE status = 'active' AND end_date >= (NOW() AT TIME ZONE 'ICT')::DATE; ` return db.Exec(sql).Error } // UpdateMemberInClosedProjectToInActive just update if project is closed or paused func (s *store) UpdateMemberInClosedProjectToInActive(db *gorm.DB) error { sql := ` UPDATE project_members pm SET status = 'inactive', end_date = p.end_date FROM projects p WHERE pm.project_id = p.id AND pm.status <> 'inactive' AND p.status IN ('closed', 'paused'); ` return db.Exec(sql).Error } // UpdateLeftMemberToInActive just update if employee is left func (s *store) UpdateLeftMemberToInActive(db *gorm.DB) error { sql := ` UPDATE project_members pm SET status = 'inactive', end_date = e.left_date FROM employees e WHERE pm.employee_id = e.id and pm.status <> 'inactive' AND e.working_status IN ('left'); ` return db.Exec(sql).Error } func (s *store) UpdateMemberToInActiveByID(db *gorm.DB, id string, endDate *time.Time) error { sql := ` UPDATE project_members pm SET status = 'inactive', end_date = ? WHERE employee_id = ? AND (status <> 'inactive' OR end_date IS NULL OR end_date > NOW()) ` return db.Exec(sql, endDate, id).Error }
```

# pkg/store/projectmemberposition/interface.go

```go
package projectmemberposition import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type IStore interface { Create(db *gorm.DB, pos ...model.ProjectMemberPosition) error DeleteByProjectMemberID(db *gorm.DB, memberID string) error }
```

# pkg/store/projectmemberposition/project_member_position.go

```go
package projectmemberposition import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create create new project member position func (s *store) Create(db *gorm.DB, pos ...model.ProjectMemberPosition) error { return db.Create(&pos).Error } // DeleteByProjectMemberID delete project_member_positions by project_member_id func (s *store) DeleteByProjectMemberID(db *gorm.DB, memberID string) error { return db.Unscoped().Where("project_member_id = ?", memberID).Delete(&model.ProjectMemberPosition{}).Error }
```

# pkg/store/projectnotion/interface.go

```go
package projectnotion import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { OneByProjectID(db *gorm.DB, projectID string) (projectNotion *model.ProjectNotion, err error) OneByAuditNotionID(db *gorm.DB, projectID string) (projectNotion *model.ProjectNotion, err error) Create(db *gorm.DB, e *model.ProjectNotion) (projectNotion *model.ProjectNotion, err error) Update(db *gorm.DB, projectNotion *model.ProjectNotion) (a *model.ProjectNotion, err error) IsExistByAuditNotionID(db *gorm.DB, id string) (exists bool, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectNotion, updatedFields ...string) (projectNotion *model.ProjectNotion, err error) }
```

# pkg/store/projectnotion/project_notion.go

```go
package projectnotion import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // OneByProjectID get projectNotion by project id func (s *store) OneByProjectID(db *gorm.DB, projectID string) (*model.ProjectNotion, error) { var projectNotion *model.ProjectNotion return projectNotion, db.Where("project_id = ?", projectID).Preload("Project", "deleted_at IS NULL").First(&projectNotion).Error } // OneByAuditNotionID get projectNotion by audit notion id func (s *store) OneByAuditNotionID(db *gorm.DB, auditNotionID string) (*model.ProjectNotion, error) { var projectNotion *model.ProjectNotion return projectNotion, db.Where("audit_notion_id = ?", auditNotionID).Preload("Project", "deleted_at IS NULL").First(&projectNotion).Error } // Create creates a new projectNotion func (s *store) Create(db *gorm.DB, e *model.ProjectNotion) (projectNotion *model.ProjectNotion, err error) { return e, db.Create(e).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, projectNotion *model.ProjectNotion) (*model.ProjectNotion, error) { return projectNotion, db.Model(&projectNotion).Where("id = ?", projectNotion.ID).Updates(&projectNotion).First(&projectNotion).Error } // IsExistByAuditNotionID check project notion existence by audit notion id func (s *store) IsExistByAuditNotionID(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM project_notions WHERE audit_notion_id = ?) as result", id) return result.Result, query.Scan(&result).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectNotion, updatedFields ...string) (*model.ProjectNotion, error) { projectNotion := model.ProjectNotion{} return &projectNotion, db.Model(&projectNotion).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error }
```

# pkg/store/projectslot/interface.go

```go
package projectslot import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { GetPendingSlots(db *gorm.DB, projectID string, preload bool) ([]*model.ProjectSlot, error) One(db *gorm.DB, id string) (*model.ProjectSlot, error) Create(db *gorm.DB, slot *model.ProjectSlot) error Delete(db *gorm.DB, id string) (err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectSlot, updatedFields ...string) (*model.ProjectSlot, error) UpdateSelectedFieldByProjectID(db *gorm.DB, projectID string, updateModel model.ProjectSlot, updatedField string) error }
```

# pkg/store/projectslot/project_slot.go

```go
package projectslot import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Delete delete ProjectSlot by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Unscoped().Where("id = ?", id).Delete(&model.ProjectSlot{}).Error } // One get 1 one by id func (s *store) One(db *gorm.DB, id string) (*model.ProjectSlot, error) { var slot *model.ProjectSlot return slot, db.Where("id = ?", id).Preload("Seniority", "deleted_at IS NULL").First(&slot).Error } // Create create new project slot func (s *store) Create(db *gorm.DB, slot *model.ProjectSlot) error { return db.Create(&slot).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.ProjectSlot, updatedFields ...string) (*model.ProjectSlot, error) { slot := model.ProjectSlot{} return &slot, db.Model(&slot).Where("id = ?", id).Select(updatedFields).Updates(&updateModel).Error } // UpdateSelectedFieldByProjectID just update selected field by projectID func (s *store) UpdateSelectedFieldByProjectID(db *gorm.DB, projectID string, updateModel model.ProjectSlot, updatedField string) error { return db.Model(&model.ProjectSlot{}). Where("project_id = ?", projectID). Select(updatedField). Updates(updateModel).Error } func (s *store) GetPendingSlots(db *gorm.DB, projectID string, preload bool) ([]*model.ProjectSlot, error) { query := db.Where("project_id = ? AND status = ?", projectID, model.ProjectMemberStatusPending).Order("created_at DESC") if preload { query = query.Preload("Seniority", "deleted_at IS NULL"). Preload("ProjectSlotPositions", "deleted_at IS NULL"). Preload("ProjectSlotPositions.Position", "deleted_at IS NULL") } var slots []*model.ProjectSlot return slots, query.Find(&slots).Error }
```

# pkg/store/projectslotposition/interface.go

```go
package projectslotposition import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type IStore interface { Create(db *gorm.DB, pos ...model.ProjectSlotPosition) error DeleteByProjectSlotID(db *gorm.DB, slotID string) error }
```

# pkg/store/projectslotposition/project_slot_position.go

```go
package projectslotposition import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) GetByProjectSlotID(db *gorm.DB, memberID string) ([]*model.ProjectSlotPosition, error) { var pos []*model.ProjectSlotPosition return pos, db.Where("project_slot_id = ?", memberID).Preload("Position").Find(&pos).Error } func (s *store) Create(db *gorm.DB, pos ...model.ProjectSlotPosition) error { return db.Create(&pos).Error } func (s *store) DeleteByProjectSlotID(db *gorm.DB, slotID string) error { return db.Unscoped().Where("project_slot_id = ?", slotID).Delete(&model.ProjectSlotPosition{}).Error }
```

# pkg/store/projectstack/interface.go

```go
package projectstack import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, projectStack *model.ProjectStack) (*model.ProjectStack, error) DeleteByProjectID(db *gorm.DB, projectID string) (err error) }
```

# pkg/store/projectstack/project_stack.go

```go
package projectstack import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create create new one by id func (s *store) Create(db *gorm.DB, projectStack *model.ProjectStack) (*model.ProjectStack, error) { return projectStack, db.Create(&projectStack).Error } // DeleteByProjectID delete many ProjectStacks by projectID func (s *store) DeleteByProjectID(db *gorm.DB, projectID string) error { return db.Unscoped().Where("project_id = ?", projectID).Delete(&model.ProjectStack{}).Error }
```

# pkg/store/question/interface.go

```go
package question import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { AllByCategory(db *gorm.DB, category model.EventType, subcategory model.EventSubtype) (questions []*model.Question, err error) }
```

# pkg/store/question/question.go

```go
package question import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // AllByCategory get all by category and subcategory func (s *store) AllByCategory(db *gorm.DB, category model.EventType, subcategory model.EventSubtype) ([]*model.Question, error) { var questions []*model.Question return questions, db.Where("category = ? AND subcategory = ?", category, subcategory).Order("\"order\"").Find(&questions).Error }
```

# pkg/store/recruitment/interface.go

```go
package recruitment import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) // IStore -- type IStore interface { Save(db *gorm.DB, cv *model.Candidate) error Update(db *gorm.DB, cv *model.Candidate) error GetByBasecampID(db *gorm.DB, bcID int) (*model.Candidate, error) GetApproachCandidateByBasecampID(db *gorm.DB, bcID int) (*model.Candidate, error) GetByDuration(db *gorm.DB, from, to time.Time) ([]model.Candidate, error) GetAll(db *gorm.DB) ([]model.Candidate, error) GetOffered(db *gorm.DB, batchDate, dueDate time.Time) ([]model.Candidate, error) }
```

# pkg/store/recruitment/recruitment.go

```go
package recruitment import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct { } // New create new pg service func New() IStore { return &store{} } func (s *store) Save(db *gorm.DB, cv *model.Candidate) error { return db.Save(&cv).Error } func (s *store) GetByBasecampID(db *gorm.DB, bcID int) (*model.Candidate, error) { var c model.Candidate return &c, db.Where("basecamp_todo_id = ?", bcID).First(&c).Error } func (s *store) GetApproachCandidateByBasecampID(db *gorm.DB, bcID int) (*model.Candidate, error) { var c model.Candidate return &c, db.Where("basecamp_todo_id = ? and status = ?", bcID, model.ApproachCandidateStatus).First(&c).Error } func (s *store) Update(db *gorm.DB, candidate *model.Candidate) error { return db.Save(&candidate).Error } func (s *store) GetByDuration(db *gorm.DB, from, to time.Time) ([]model.Candidate, error) { var c []model.Candidate return c, db.Where("created_at > ? AND created_at < ?", from, to).Find(&c).Error } func (s *store) GetAll(db *gorm.DB) ([]model.Candidate, error) { var c []model.Candidate return c, db.Find(&c).Error } func (s *store) GetOffered(db *gorm.DB, batchDate, dueDate time.Time) ([]model.Candidate, error) { var c []model.Candidate return c, db.Where("offer_start_date > ? AND offer_start_date < ? AND status = ?", batchDate, dueDate, model.HiredCandidateStatus).Find(&c).Error }
```

# pkg/store/repo.go

```go
package store import ( "errors" "gorm.io/gorm" ) // FinallyFunc function to finish a transaction type FinallyFunc = func(error) error // DBRepo .. type DBRepo interface { DB() *gorm.DB NewTransaction() (DBRepo, FinallyFunc) SetNewDB(*gorm.DB) } // repo is implementation of repository type repo struct { Database *gorm.DB } // DB database connection func (s *repo) DB() *gorm.DB { return s.Database } func NewRepo(db *gorm.DB) DBRepo { return &repo{Database: db} } // NewTransaction for database connection func (s *repo) NewTransaction() (newRepo DBRepo, finallyFn FinallyFunc) { newDB := s.Database.Begin() finallyFn = func(err error) error { if err != nil { nErr := newDB.Rollback().Error if nErr != nil { return errors.New(nErr.Error()) } return err } cErr := newDB.Commit().Error if cErr != nil { return errors.New(cErr.Error()) } return nil } return &repo{Database: newDB}, finallyFn } func (s *repo) SetNewDB(db *gorm.DB) { s.Database = db }
```

# pkg/store/role/interface.go

```go
package role import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB) (roles []*model.Role, err error) One(db *gorm.DB, id model.UUID) (role *model.Role, err error) GetByLevel(db *gorm.DB, level int64) ([]*model.Role, error) GetByCode(db *gorm.DB, code string) (*model.Role, error) GetByIDs(db *gorm.DB, ids []model.UUID) ([]*model.Role, error) IsExist(db *gorm.DB, id string) (exists bool, err error) }
```

# pkg/store/role/role.go

```go
package role import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // All get all positions func (s *store) All(db *gorm.DB) ([]*model.Role, error) { var roles []*model.Role return roles, db.Where("is_show IS TRUE").Order("level").Find(&roles).Error } // GetByLevel get by input level func (s *store) GetByLevel(db *gorm.DB, level int64) ([]*model.Role, error) { var roles []*model.Role return roles, db.Where("level >= ? AND is_show IS TRUE", level).Find(&roles).Error } func (s *store) GetByCode(db *gorm.DB, code string) (*model.Role, error) { var role *model.Role return role, db.Where("code = ?", code).First(&role).Error } func (s *store) GetByIDs(db *gorm.DB, ids []model.UUID) ([]*model.Role, error) { var roles []*model.Role return roles, db.Where("id IN ?", ids).Find(&roles).Error } // One get 1 one by id func (s *store) One(db *gorm.DB, id model.UUID) (*model.Role, error) { var role *model.Role return role, db.Where("id = ?", id).First(&role).Error } // IsExist check the existence of employee func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM roles WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error }
```

# pkg/store/salaryadvance/interface.go

```go
package salaryadvance import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { One(db *gorm.DB, id string) (salaryAdvance *model.SalaryAdvance, err error) ListNotPayBackByEmployeeID(db *gorm.DB, employeeID string) (salaryAdvance []model.SalaryAdvance, err error) Save(db *gorm.DB, salaryAdvance *model.SalaryAdvance) (err error) ListAggregatedSalaryAdvance(db *gorm.DB, idPaid *bool, paging model.Pagination, order model.SortOrder) (report []model.AggregatedSalaryAdvance, err error) TotalAggregatedSalaryAdvance(db *gorm.DB, idPaid *bool) (count, totalIcy int64, totalUSD float64, err error) }
```

# pkg/store/salaryadvance/salary_advance.go

```go
package salaryadvance import ( "database/sql" "fmt" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) One(db *gorm.DB, id string) (*model.SalaryAdvance, error) { var salaryAdvance *model.SalaryAdvance return salaryAdvance, db.Where("id = ?", id). First(&salaryAdvance).Error } func (s *store) ListNotPayBackByEmployeeID(db *gorm.DB, employeeID string) ([]model.SalaryAdvance, error) { var advanceSalaries []model.SalaryAdvance return advanceSalaries, db.Where("employee_id = ?", employeeID).Where("is_paid_back = ?", false).Find(&advanceSalaries).Error } func (s *store) Save(db *gorm.DB, salaryAdvance *model.SalaryAdvance) (err error) { return db.Save(&salaryAdvance).Error } func (s *store) ListAggregatedSalaryAdvance(db *gorm.DB, idPaid *bool, paging model.Pagination, order model.SortOrder) (report []model.AggregatedSalaryAdvance, err error) { query := db. Table("salary_advance_histories"). Select("employee_id, sum(amount_icy) as amount_icy, sum(amount_usd) as amount_usd") if idPaid != nil { query = query.Where("is_paid_back = ?", idPaid) } if paging.Sort != "" { query = query.Order(fmt.Sprintf("%s %s", paging.Sort, order)) } limit, offset := paging.ToLimitOffset() if limit != 0 { query = query.Limit(limit).Offset(offset) } return report, query.Group("employee_id").Find(&report).Error } func (s *store) TotalAggregatedSalaryAdvance(db *gorm.DB, idPaid *bool) (int64, int64, float64, error) { queryCurrency := db. Table("salary_advance_histories"). Select("sum(amount_icy) as total_icy, sum(amount_usd) as total_usd") queryCount := db. Table("salary_advance_histories") if idPaid != nil { queryCurrency = queryCurrency.Where("is_paid_back = ?", idPaid) queryCount = queryCount.Where("is_paid_back = ?", idPaid) } var ( count int64 nullIcy sql.NullInt64 nullUsd sql.NullFloat64 ) if err := queryCurrency.Row().Scan(&nullIcy, &nullUsd); err != nil { return 0, 0, 0, err } if err := queryCount.Group("employee_id").Count(&count).Error; err != nil { return 0, 0, 0, err } return count, nullIcy.Int64, nullUsd.Float64, nil }
```

# pkg/store/schedule/interface.go

```go
package schedule import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, schedule *model.Schedule) (*model.Schedule, error) CreateDiscord(db *gorm.DB, schedule *model.ScheduleDiscordEvent) (*model.ScheduleDiscordEvent, error) GetOneByGcalID(db *gorm.DB, gcalID string) (*model.Schedule, error) Update(db *gorm.DB, schedule *model.Schedule) (*model.Schedule, error) }
```

# pkg/store/schedule/schedule.go

```go
package schedule import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type store struct{} func New() IStore { return &store{} } func (s *store) GetOneByGcalID(db *gorm.DB, gcalID string) (*model.Schedule, error) { var sch *model.Schedule return sch, db. Table("schedules"). Joins("JOIN schedule_google_calendars sgc ON schedules.id = sgc.schedule_id").Where("sgc.google_calendar_id = ?", gcalID).First(&sch).Error } func (s *store) Create(db *gorm.DB, schedule *model.Schedule) (*model.Schedule, error) { return schedule, db.Create(schedule).Error } func (s *store) CreateDiscord(db *gorm.DB, schedule *model.ScheduleDiscordEvent) (*model.ScheduleDiscordEvent, error) { return schedule, db.Create(schedule).Error } func (s *store) Upsert(db *gorm.DB, schedule *model.Schedule) (*model.Schedule, error) { return schedule, db.Save(schedule).Error } func (s *store) Update(db *gorm.DB, schedule *model.Schedule) (*model.Schedule, error) { return schedule, db.Updates(schedule).Error }
```

# pkg/store/seniority/interface.go

```go
package seniority import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB) ([]*model.Seniority, error) One(db *gorm.DB, id model.UUID) (seniorities *model.Seniority, err error) IsExist(db *gorm.DB, id string) (bool, error) }
```

# pkg/store/seniority/seniority.go

```go
package seniority import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // All get all Seniorities func (s *store) All(db *gorm.DB) ([]*model.Seniority, error) { var seniories []*model.Seniority return seniories, db.Order("level").Find(&seniories).Error } // One get 1 one by id func (s *store) One(db *gorm.DB, id model.UUID) (*model.Seniority, error) { var sen *model.Seniority return sen, db.Where("id = ?", id).First(&sen).Error } // IsExist check existence of a seniority func (s *store) IsExist(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM seniorities WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error }
```

# pkg/store/socialaccount/interface.go

```go
package socialaccount import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, sa *model.SocialAccount) (account *model.SocialAccount, err error) Update(db *gorm.DB, sa *model.SocialAccount) (account *model.SocialAccount, err error) GetByEmployeeID(db *gorm.DB, employeeID string) (accounts []*model.SocialAccount, err error) GetByType(db *gorm.DB, saType string) (accounts []model.SocialAccount, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.SocialAccount, updatedFields ...string) (*model.SocialAccount, error) }
```

# pkg/store/socialaccount/social_account.go

```go
package socialaccount import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create create new SocialAccount func (s *store) Create(db *gorm.DB, sa *model.SocialAccount) (*model.SocialAccount, error) { return sa, db.Create(sa).Error } // Update update all value (including nested model) func (s *store) Update(db *gorm.DB, sa *model.SocialAccount) (*model.SocialAccount, error) { return sa, db.Model(&sa).Where("id = ?", sa.ID).Updates(&sa).Error } // GetByEmployeeID get social account by employee id func (s *store) GetByEmployeeID(db *gorm.DB, employeeID string) ([]*model.SocialAccount, error) { var accounts []*model.SocialAccount return accounts, db.Where("employee_id = ?", employeeID).Find(&accounts).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.SocialAccount, updatedFields ...string) (*model.SocialAccount, error) { sa := model.SocialAccount{} return &sa, db.Model(&sa).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // GetByType get social account by type func (s *store) GetByType(db *gorm.DB, saType string) ([]model.SocialAccount, error) { var accounts []model.SocialAccount return accounts, db.Where("type = ?", saType).Find(&accounts).Error }
```

# pkg/store/stack/interface.go

```go
package stack import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { All(db *gorm.DB, keyword string, pagination *model.Pagination) (int64, []*model.Stack, error) One(db *gorm.DB, id string) (*model.Stack, error) GetByIDs(db *gorm.DB, ids []model.UUID) (stacks []*model.Stack, err error) Update(db *gorm.DB, stack *model.Stack) (s *model.Stack, err error) Create(db *gorm.DB, stack *model.Stack) (s *model.Stack, err error) Delete(db *gorm.DB, id string) (err error) }
```

# pkg/store/stack/stack.go

```go
package stack import ( "fmt" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // All get all Senitorities func (s *store) All(db *gorm.DB, keyword string, pagination *model.Pagination) (int64, []*model.Stack, error) { var stacks []*model.Stack var total int64 query := db.Table("stacks") if keyword != "" { query = query.Where("name ILIKE ?", fmt.Sprintf("%%%s%%", keyword)). Where("code ILIKE ?", fmt.Sprintf("%%%s%%", keyword)) } query = query.Count(&total).Order("code") if pagination != nil { limit, offset := pagination.ToLimitOffset() if pagination.Page > 0 { query = query.Limit(limit) } query = query.Offset(offset) } return total, stacks, query.Find(&stacks).Error } // One get 1 stack by id func (s *store) One(db *gorm.DB, id string) (*model.Stack, error) { var stack *model.Stack return stack, db.Where("id = ?", id).First(&stack).Error } // GetByIDs return list stack by IDs func (s *store) GetByIDs(db *gorm.DB, ids []model.UUID) ([]*model.Stack, error) { var stacks []*model.Stack return stacks, db.Where("id IN ?", ids).Find(&stacks).Error } // Update update the stack func (s *store) Update(db *gorm.DB, stack *model.Stack) (*model.Stack, error) { return stack, db.Model(&model.Stack{}).Where("id = ?", stack.ID).Updates(&stack).First(&stack).Error } // Delete delete ProjectMember by id func (s *store) Delete(db *gorm.DB, id string) error { return db.Where("id = ?", id).Delete(&model.Stack{}).Error } // Create create new stack func (s *store) Create(db *gorm.DB, stack *model.Stack) (*model.Stack, error) { return stack, db.Create(stack).Error }
```

# pkg/store/store_util.go

```go
package store import ( "database/sql" "fmt" "gorm.io/driver/postgres" "gorm.io/gorm" "gorm.io/gorm/schema" "github.com/dwarvesf/fortress-api/pkg/config" "github.com/dwarvesf/fortress-api/pkg/logger" gormlogger "gorm.io/gorm/logger" ) // NewPostgresStore postgres init by gorm func NewPostgresStore(cfg *config.Config) DBRepo { ds := fmt.Sprintf( "postgres://%s:%s@%s:%s/%s?sslmode=disable", cfg.Postgres.User, cfg.Postgres.Pass, cfg.Postgres.Host, cfg.Postgres.Port, cfg.Postgres.Name, ) conn, err := sql.Open("postgres", ds) if err != nil { logger.L.Fatalf(err, "failed to open database connection") } db, err := gorm.Open(postgres.New( postgres.Config{Conn: conn}), &gorm.Config{ NamingStrategy: schema.NamingStrategy{ SingularTable: false, }, }) if err != nil { logger.L.Fatalf(err, "failed to open database connection") } logger.L.Info("database connected") if cfg.Debug { db.Logger = gormlogger.Default.LogMode(gormlogger.Info) } return &repo{Database: db} }
```

# pkg/store/store.go

```go
package store import ( "github.com/dwarvesf/fortress-api/pkg/store/accounting" "github.com/dwarvesf/fortress-api/pkg/store/actionitem" "github.com/dwarvesf/fortress-api/pkg/store/actionitemsnapshot" "github.com/dwarvesf/fortress-api/pkg/store/apikey" "github.com/dwarvesf/fortress-api/pkg/store/apikeyrole" "github.com/dwarvesf/fortress-api/pkg/store/audit" "github.com/dwarvesf/fortress-api/pkg/store/auditactionitem" "github.com/dwarvesf/fortress-api/pkg/store/auditcycle" "github.com/dwarvesf/fortress-api/pkg/store/audititem" "github.com/dwarvesf/fortress-api/pkg/store/auditparticipant" "github.com/dwarvesf/fortress-api/pkg/store/bank" "github.com/dwarvesf/fortress-api/pkg/store/bankaccount" "github.com/dwarvesf/fortress-api/pkg/store/basesalary" "github.com/dwarvesf/fortress-api/pkg/store/brainerylog" "github.com/dwarvesf/fortress-api/pkg/store/cachedpayroll" "github.com/dwarvesf/fortress-api/pkg/store/chapter" "github.com/dwarvesf/fortress-api/pkg/store/client" "github.com/dwarvesf/fortress-api/pkg/store/clientcontact" "github.com/dwarvesf/fortress-api/pkg/store/companyinfo" "github.com/dwarvesf/fortress-api/pkg/store/config" "github.com/dwarvesf/fortress-api/pkg/store/content" "github.com/dwarvesf/fortress-api/pkg/store/conversionrate" "github.com/dwarvesf/fortress-api/pkg/store/country" "github.com/dwarvesf/fortress-api/pkg/store/currency" "github.com/dwarvesf/fortress-api/pkg/store/dashboard" "github.com/dwarvesf/fortress-api/pkg/store/deliverymetric" "github.com/dwarvesf/fortress-api/pkg/store/deliverymetricmonthly" "github.com/dwarvesf/fortress-api/pkg/store/deliverymetricweekly" "github.com/dwarvesf/fortress-api/pkg/store/discordaccount" "github.com/dwarvesf/fortress-api/pkg/store/discordevent" "github.com/dwarvesf/fortress-api/pkg/store/discordtemplate" "github.com/dwarvesf/fortress-api/pkg/store/employee" "github.com/dwarvesf/fortress-api/pkg/store/employeebonus" "github.com/dwarvesf/fortress-api/pkg/store/employeechapter" "github.com/dwarvesf/fortress-api/pkg/store/employeecommission" "github.com/dwarvesf/fortress-api/pkg/store/employeeeventquestion" "github.com/dwarvesf/fortress-api/pkg/store/employeeeventreviewer" "github.com/dwarvesf/fortress-api/pkg/store/employeeeventtopic" "github.com/dwarvesf/fortress-api/pkg/store/employeeinvitation" "github.com/dwarvesf/fortress-api/pkg/store/employeeorganization" "github.com/dwarvesf/fortress-api/pkg/store/employeeposition" "github.com/dwarvesf/fortress-api/pkg/store/employeerole" "github.com/dwarvesf/fortress-api/pkg/store/employeestack" "github.com/dwarvesf/fortress-api/pkg/store/engagementsrollup" "github.com/dwarvesf/fortress-api/pkg/store/eventspeaker" "github.com/dwarvesf/fortress-api/pkg/store/expense" "github.com/dwarvesf/fortress-api/pkg/store/feedbackevent" "github.com/dwarvesf/fortress-api/pkg/store/icydistribution" "github.com/dwarvesf/fortress-api/pkg/store/icytransaction" "github.com/dwarvesf/fortress-api/pkg/store/invoice" "github.com/dwarvesf/fortress-api/pkg/store/invoicenumbercaching" "github.com/dwarvesf/fortress-api/pkg/store/memolog" "github.com/dwarvesf/fortress-api/pkg/store/onleaverequest" "github.com/dwarvesf/fortress-api/pkg/store/operationalservice" "github.com/dwarvesf/fortress-api/pkg/store/organization" "github.com/dwarvesf/fortress-api/pkg/store/payroll" "github.com/dwarvesf/fortress-api/pkg/store/permission" "github.com/dwarvesf/fortress-api/pkg/store/physicalcheckin" "github.com/dwarvesf/fortress-api/pkg/store/position" "github.com/dwarvesf/fortress-api/pkg/store/project" "github.com/dwarvesf/fortress-api/pkg/store/projectcommissionconfig" "github.com/dwarvesf/fortress-api/pkg/store/projecthead" "github.com/dwarvesf/fortress-api/pkg/store/projectmember" "github.com/dwarvesf/fortress-api/pkg/store/projectmemberposition" "github.com/dwarvesf/fortress-api/pkg/store/projectnotion" "github.com/dwarvesf/fortress-api/pkg/store/projectslot" "github.com/dwarvesf/fortress-api/pkg/store/projectslotposition" "github.com/dwarvesf/fortress-api/pkg/store/projectstack" "github.com/dwarvesf/fortress-api/pkg/store/question" "github.com/dwarvesf/fortress-api/pkg/store/recruitment" "github.com/dwarvesf/fortress-api/pkg/store/role" "github.com/dwarvesf/fortress-api/pkg/store/salaryadvance" "github.com/dwarvesf/fortress-api/pkg/store/schedule" "github.com/dwarvesf/fortress-api/pkg/store/seniority" "github.com/dwarvesf/fortress-api/pkg/store/socialaccount" "github.com/dwarvesf/fortress-api/pkg/store/stack" "github.com/dwarvesf/fortress-api/pkg/store/valuation" "github.com/dwarvesf/fortress-api/pkg/store/workunit" "github.com/dwarvesf/fortress-api/pkg/store/workunitmember" "github.com/dwarvesf/fortress-api/pkg/store/workunitstack" ) type Store struct { Accounting accounting.IStore ActionItem actionitem.IStore ActionItemSnapshot actionitemsnapshot.IStore APIKey apikey.IStore APIKeyRole apikeyrole.IStore Audit audit.IStore AuditActionItem auditactionitem.IStore AuditCycle auditcycle.IStore AuditItem audititem.IStore AuditParticipant auditparticipant.IStore SalaryAdvance salaryadvance.IStore Bank bank.IStore BankAccount bankaccount.IStore BaseSalary basesalary.IStore Bonus employeebonus.IStore BraineryLog brainerylog.IStore CachedPayroll cachedpayroll.IStore Chapter chapter.IStore Client client.IStore ClientContact clientcontact.IStore CompanyInfo companyinfo.IStore Content content.IStore ConversionRate conversionrate.IStore Country country.IStore Currency currency.IStore Config config.IStore Dashboard dashboard.IStore DeliveryMetric deliverymetric.IStore DiscordAccount discordaccount.IStore DiscordEvent discordevent.IStore DiscordLogTemplate discordtemplate.IStore Employee employee.IStore EmployeeChapter employeechapter.IStore EmployeeCommission employeecommission.IStore EmployeeEventQuestion employeeeventquestion.IStore EmployeeEventReviewer employeeeventreviewer.IStore EmployeeEventTopic employeeeventtopic.IStore EmployeeInvitation employeeinvitation.IStore EmployeeOrganization employeeorganization.IStore EmployeePosition employeeposition.IStore EmployeeRole employeerole.IStore EmployeeStack employeestack.IStore EventSpeaker eventspeaker.IStore EngagementsRollup engagementsrollup.IStore Expense expense.IStore FeedbackEvent feedbackevent.IStore IcyDistribution icydistribution.IStore IcyTransaction icytransaction.IStore Invoice invoice.IStore InvoiceNumberCaching invoicenumbercaching.IStore MemoLog memolog.IStore MonthlyDeliveryMetric deliverymetricmonthly.IStore OnLeaveRequest onleaverequest.IStore OperationalService operationalservice.IStore Organization organization.IStore Payroll payroll.IStore Permission permission.IStore Position position.IStore Project project.IStore ProjectCommissionConfig projectcommissionconfig.IStore ProjectHead projecthead.IStore ProjectMember projectmember.IStore ProjectMemberPosition projectmemberposition.IStore ProjectNotion projectnotion.IStore ProjectSlot projectslot.IStore ProjectSlotPosition projectslotposition.IStore ProjectStack projectstack.IStore PhysicalCheckin physicalcheckin.IStore Question question.IStore Recruitment recruitment.IStore Role role.IStore Schedule schedule.IStore Seniority seniority.IStore SocialAccount socialaccount.IStore Stack stack.IStore Valuation valuation.IStore WeeklyDeliveryMetric deliverymetricweekly.IStore WorkUnit workunit.IStore WorkUnitMember workunitmember.IStore WorkUnitStack workunitstack.IStore } func New() *Store { return &Store{ Accounting: accounting.New(), ActionItem: actionitem.New(), ActionItemSnapshot: actionitemsnapshot.New(), APIKey: apikey.New(), APIKeyRole: apikeyrole.New(), Audit: audit.New(), AuditActionItem: auditactionitem.New(), AuditCycle: auditcycle.New(), AuditItem: audititem.New(), AuditParticipant: auditparticipant.New(), SalaryAdvance: salaryadvance.New(), Bank: bank.New(), BankAccount: bankaccount.New(), BaseSalary: basesalary.New(), Bonus: employeebonus.New(), BraineryLog: brainerylog.New(), CachedPayroll: cachedpayroll.New(), Chapter: chapter.New(), Client: client.New(), ClientContact: clientcontact.New(), CompanyInfo: companyinfo.New(), Content: content.New(), ConversionRate: conversionrate.New(), Country: country.New(), Currency: currency.New(), Config: config.New(), Dashboard: dashboard.New(), DeliveryMetric: deliverymetric.New(), DiscordAccount: discordaccount.New(), DiscordEvent: discordevent.New(), DiscordLogTemplate: discordtemplate.New(), Employee: employee.New(), EmployeeChapter: employeechapter.New(), EmployeeCommission: employeecommission.New(), EmployeeEventQuestion: employeeeventquestion.New(), EmployeeEventReviewer: employeeeventreviewer.New(), EmployeeEventTopic: employeeeventtopic.New(), EmployeeInvitation: employeeinvitation.New(), EmployeeOrganization: employeeorganization.New(), EmployeePosition: employeeposition.New(), EmployeeRole: employeerole.New(), EmployeeStack: employeestack.New(), EngagementsRollup: engagementsrollup.New(), EventSpeaker: eventspeaker.New(), Expense: expense.New(), FeedbackEvent: feedbackevent.New(), IcyDistribution: icydistribution.New(), IcyTransaction: icytransaction.New(), Invoice: invoice.New(), InvoiceNumberCaching: invoicenumbercaching.New(), MemoLog: memolog.New(), MonthlyDeliveryMetric: deliverymetricmonthly.New(), OnLeaveRequest: onleaverequest.New(), OperationalService: operationalservice.New(), Organization: organization.New(), Payroll: payroll.New(), Permission: permission.New(), Position: position.New(), Project: project.New(), ProjectCommissionConfig: projectcommissionconfig.New(), ProjectHead: projecthead.New(), ProjectMember: projectmember.New(), ProjectMemberPosition: projectmemberposition.New(), ProjectNotion: projectnotion.New(), ProjectSlot: projectslot.New(), ProjectSlotPosition: projectslotposition.New(), ProjectStack: projectstack.New(), PhysicalCheckin: physicalcheckin.New(), Question: question.New(), Recruitment: recruitment.New(), Role: role.New(), Schedule: schedule.New(), Seniority: seniority.New(), SocialAccount: socialaccount.New(), Stack: stack.New(), Valuation: valuation.New(), WeeklyDeliveryMetric: deliverymetricweekly.New(), WorkUnit: workunit.New(), WorkUnitMember: workunitmember.New(), WorkUnitStack: workunitstack.New(), } }
```

# pkg/store/test_repo.go

```go
package store import ( "gorm.io/gorm" ) // testRepo is implementation of repository type testRepo struct { Database *gorm.DB } // DB database connection func (s *testRepo) DB() *gorm.DB { return s.Database } func NewTestRepo(db *gorm.DB) DBRepo { return &testRepo{Database: db} } // NewTransaction for database connection func (s *testRepo) NewTransaction() (newRepo DBRepo, finallyFn FinallyFunc) { finallyFn = func(err error) error { return err } return &testRepo{Database: s.DB()}, finallyFn } func (s *testRepo) SetNewDB(db *gorm.DB) { s.Database = db }
```

# pkg/store/valuation/interface.go

```go
package valuation import ( "github.com/dwarvesf/fortress-api/pkg/model" "gorm.io/gorm" ) type IStore interface { GetAccountReceivable(db *gorm.DB, year string) (total *model.CurrencyView, err error) GetLiabilities(db *gorm.DB, year string) (res []model.Liability, total *model.CurrencyView, err error) GetRevenue(db *gorm.DB, year string) (total *model.CurrencyView, err error) GetInvestment(db *gorm.DB, year string) (total *model.CurrencyView, err error) // GetAssetAmount return total amount of current holding assets GetAssetAmount(db *gorm.DB, year string) (total float64, err error) GetExpense(db *gorm.DB, year string) (total *model.CurrencyView, err error) GetPayroll(db *gorm.DB, year string) (total *model.CurrencyView, err error) }
```

# pkg/store/valuation/valuation.go

```go
// please edit this file only with approval from hnh package valuation import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) GetAccountReceivable(db *gorm.DB, year string) (*model.CurrencyView, error) { res := &model.CurrencyView{} return res, db.Raw("select * from vw_account_receivables where year = ?", year).Find(&res).Error } func (s *store) GetRevenue(db *gorm.DB, year string) (*model.CurrencyView, error) { res := &model.CurrencyView{} return res, db.Raw(`SELECT sum(vnd) AS vnd, sum(usd) AS usd, sum(gbp) AS gbp, sum(eur) AS eur, sum(sgd) as sgd FROM vw_incomes WHERE year = ?`, year). Find(&res).Error } func (s *store) GetInvestment(db *gorm.DB, year string) (*model.CurrencyView, error) { res := &model.CurrencyView{} return res, db.Raw(`SELECT * FROM vw_investments WHERE year = ?`, year). Find(&res).Error } func (s *store) GetLiabilities(db *gorm.DB, year string) (res []model.Liability, total *model.CurrencyView, err error) { err = db.Find(&res, "date_part('year', created_at) = ?", year).Error if err != nil { return nil, nil, err } return res, total, db.Raw(`SELECT sum(vnd) AS vnd, sum(usd) AS usd, sum(gbp) AS gbp, sum(eur) AS eur, sum(sgd) as sgd FROM vw_liabilities WHERE year = ?`, year). Find(&total).Error } func (s *store) GetAssetAmount(db *gorm.DB, year string) (float64, error) { return 0, nil } func (s *store) GetExpense(db *gorm.DB, year string) (*model.CurrencyView, error) { res := &model.CurrencyView{} return res, db.Raw("select * from vw_expenses where year = ?", year).Find(&res).Error } func (s *store) GetPayroll(db *gorm.DB, year string) (*model.CurrencyView, error) { res := &model.CurrencyView{} return res, db.Raw("select total as vnd from vw_payrolls where year = ?", year).Scan(&res).Error }
```

# pkg/store/workunit/interface.go

```go
package workunit import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, workUnit *model.WorkUnit) error GetByProjectID(db *gorm.DB, projectID string, status model.WorkUnitStatus) (workUnits []*model.WorkUnit, err error) One(db *gorm.DB, id string) (*model.WorkUnit, error) IsExists(db *gorm.DB, id string) (bool, error) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.WorkUnit, updatedFields ...string) (workUnit *model.WorkUnit, err error) GetAllWorkUnitByEmployeeID(db *gorm.DB, employeeID string) (workUnits []*model.WorkUnit, err error) }
```

# pkg/store/workunit/work_unit.go

```go
package workunit import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // GetByProjectID get all work units of a project and having the status as required func (s *store) GetByProjectID(db *gorm.DB, projectID string, status model.WorkUnitStatus) ([]*model.WorkUnit, error) { var workUnits []*model.WorkUnit query := db.Where("project_id = ?", projectID) if status != "" { query = query.Where("status = ?", status) } if status == model.WorkUnitStatusActive { query = query.Preload("WorkUnitMembers", "deleted_at IS NULL and status = 'active'") } else { query = query.Preload("WorkUnitMembers", "deleted_at IS NULL") } return workUnits, query.Preload("WorkUnitMembers.Employee", "deleted_at IS NULL"). Preload("WorkUnitStacks", "deleted_at IS NULL"). Preload("WorkUnitStacks.Stack", "deleted_at IS NULL"). Find(&workUnits).Error } // Create create new WorkUnit func (s *store) Create(db *gorm.DB, workUnit *model.WorkUnit) error { return db.Create(&workUnit).Error } // One get 1 WorkUnit by ID func (s *store) One(db *gorm.DB, id string) (*model.WorkUnit, error) { var workUnit *model.WorkUnit return workUnit, db.Where("id = ?", id).First(&workUnit).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.WorkUnit, updatedFields ...string) (*model.WorkUnit, error) { workUnit := model.WorkUnit{} return &workUnit, db.Model(&workUnit).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // IsExists check work unit existence func (s *store) IsExists(db *gorm.DB, id string) (bool, error) { type res struct { Result bool } result := res{} query := db.Raw("SELECT EXISTS (SELECT * FROM work_units WHERE id = ?) as result", id) return result.Result, query.Scan(&result).Error } func (s *store) GetAllWorkUnitByEmployeeID(db *gorm.DB, employeeID string) ([]*model.WorkUnit, error) { var workUnits []*model.WorkUnit return workUnits, db.Where(`id IN ( SELECT work_unit_id FROM work_unit_members JOIN projects ON work_unit_members.project_id = projects.id WHERE employee_id = ? AND projects.status IN (?, ?) AND work_unit_members.status = ?)`, employeeID, model.ProjectStatusActive, model.ProjectStatusOnBoarding, model.WorkUnitStatusActive). Preload("WorkUnitMembers", "deleted_at IS NULL"). Preload("WorkUnitMembers.Employee", "deleted_at IS NULL"). Preload("Project", "deleted_at IS NULL"). Find(&workUnits).Error }
```

# pkg/store/workunitmember/interface.go

```go
package workunitmember import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, wum *model.WorkUnitMember) error GetByWorkUnitID(db *gorm.DB, wuID string) (wuMembers []*model.WorkUnitMember, err error) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.WorkUnitMember, updatedFields ...string) (*model.WorkUnitMember, error) DeleteByWorkUnitID(db *gorm.DB, workUnitID string) error All(db *gorm.DB, workUnitID string) (members []*model.WorkUnitMember, err error) One(db *gorm.DB, workUnitID string, employeeID string, status string) (workUnitMember *model.WorkUnitMember, err error) SoftDeleteByWorkUnitID(db *gorm.DB, workUnitID string, employeeID string) (err error) GetPeerReviewerInTimeRange(db *gorm.DB, from *time.Time, to *time.Time) ([]model.WorkUnitPeer, error) GetActivePeerReviewer(db *gorm.DB) ([]model.WorkUnitPeer, error) }
```

# pkg/store/workunitmember/work_unit_member.go

```go
package workunitmember import ( "time" "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // One return a work member by workUnitID and employeeID func (s *store) One(db *gorm.DB, workUnitID string, employeeID string, status string) (*model.WorkUnitMember, error) { var member *model.WorkUnitMember query := db.Where("work_unit_id = ? AND employee_id = ?", workUnitID, employeeID) return member, query.First(&member).Error } // Create create new WorkUnitMember func (s *store) Create(db *gorm.DB, wum *model.WorkUnitMember) error { return db.Create(&wum).Error } // GetByWorkUnitID return list member of a work unit func (s *store) GetByWorkUnitID(db *gorm.DB, wuID string) ([]*model.WorkUnitMember, error) { var members []*model.WorkUnitMember return members, db.Where("work_unit_id = ?", wuID).Find(&members).Error } // UpdateSelectedFieldsByID just update selected fields by id func (s *store) UpdateSelectedFieldsByID(db *gorm.DB, id string, updateModel model.WorkUnitMember, updatedFields ...string) (*model.WorkUnitMember, error) { member := model.WorkUnitMember{} return &member, db.Model(&member).Where("id = ?", id).Select(updatedFields).Updates(updateModel).Error } // DeleteByWorkUnitID delete many workUnitMember by workUnitID func (s *store) DeleteByWorkUnitID(db *gorm.DB, workUnitID string) error { return db.Unscoped().Where("work_unit_id = ?", workUnitID).Delete(&model.WorkUnitMember{}).Error } // SoftDeleteByWorkUnitID delete one workUnitMember by EmployeeID and workUnitID func (s *store) SoftDeleteByWorkUnitID(db *gorm.DB, workUnitID string, employeeID string) error { return db.Where("work_unit_id = ? and employee_id = ?", workUnitID, employeeID).Delete(&model.WorkUnitMember{}).Error } // All get all active members of a work unit func (s *store) All(db *gorm.DB, workUnitID string) ([]*model.WorkUnitMember, error) { var members []*model.WorkUnitMember return members, db.Where("work_unit_id = ? and status = 'active'", workUnitID).Find(&members).Error } func (s *store) GetPeerReviewerInTimeRange(db *gorm.DB, from *time.Time, to *time.Time) ([]model.WorkUnitPeer, error) { var peers []model.WorkUnitPeer query := db.Raw(` WITH peer AS ( SELECT employee_id, reviewer_id FROM ( SELECT w1.employee_id, w1.work_unit_id, w2.employee_id AS reviewer_id, w1.project_id FROM work_unit_members w1 JOIN work_unit_members w2 ON w1.work_unit_id = w2.work_unit_id WHERE (w1.start_date < ? AND(w1.end_date > ? OR w1.end_date IS NULL)) AND(w2.start_date < ? AND(w2.end_date > ? OR w2.end_date IS NULL))) a JOIN employees e ON a.employee_id = e.id WHERE employee_id <> reviewer_id AND e.working_status = 'full-time' GROUP BY employee_id, reviewer_id ) SELECT p.employee_id, p.reviewer_id FROM peer p JOIN employees e ON e.id = p.reviewer_id WHERE e.line_manager_id <> p.reviewer_id AND e.working_status = 'full-time'; `, to, from, to, from) return peers, query.Scan(&peers).Error } func (s *store) GetActivePeerReviewer(db *gorm.DB) ([]model.WorkUnitPeer, error) { var peers []model.WorkUnitPeer query := db.Raw(` WITH peer AS ( SELECT employee_id, reviewer_id FROM ( SELECT w1.employee_id, w1.work_unit_id, w2.employee_id AS reviewer_id, w1.project_id FROM work_unit_members w1 JOIN work_unit_members w2 ON w1.work_unit_id = w2.work_unit_id WHERE w1.status = 'active' AND w2.status = 'active') a JOIN employees e ON a.employee_id = e.id WHERE employee_id <> reviewer_id AND e.working_status = 'full-time' GROUP BY employee_id, reviewer_id ) SELECT p.employee_id, p.reviewer_id FROM peer p JOIN employees e ON e.id = p.reviewer_id WHERE e.line_manager_id <> p.reviewer_id AND e.working_status = 'full-time'; `) return peers, query.Scan(&peers).Error }
```

# pkg/store/workunitstack/interface.go

```go
package workunitstack import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type IStore interface { Create(db *gorm.DB, wus *model.WorkUnitStack) error DeleteByWorkUnitID(db *gorm.DB, workUnitID string) error }
```

# pkg/store/workunitstack/work_unit_stack.go

```go
package workunitstack import ( "gorm.io/gorm" "github.com/dwarvesf/fortress-api/pkg/model" ) type store struct{} func New() IStore { return &store{} } // Create create new WorkUnitStack func (s *store) Create(db *gorm.DB, wus *model.WorkUnitStack) error { return db.Create(&wus).Error } // DeleteByWorkUnitID delete many workUnitStack by workUnitID func (s *store) DeleteByWorkUnitID(db *gorm.DB, workUnitID string) error { return db.Unscoped().Where("work_unit_id = ?", workUnitID).Delete(&model.WorkUnitStack{}).Error }
```

# pkg/worker/worker.go

```go
package worker import ( "context" "github.com/dwarvesf/fortress-api/pkg/logger" "github.com/dwarvesf/fortress-api/pkg/model" "github.com/dwarvesf/fortress-api/pkg/service" bcModel "github.com/dwarvesf/fortress-api/pkg/service/basecamp/model" ) type Worker struct { ctx context.Context service *service.Service queue chan model.WorkerMessage logger logger.Logger } func New(ctx context.Context, queue chan model.WorkerMessage, service *service.Service, logger logger.Logger) *Worker { return &Worker{ ctx: ctx, service: service, queue: queue, logger: logger, } } func (w *Worker) ProcessMessage() error { consumeErr := make(chan error, 1) go func() { for { if w.ctx.Err() != nil { consumeErr <- w.ctx.Err() return } message := <-w.queue switch message.Type { case bcModel.BasecampCommentMsg: _ = w.handleCommentMessage(w.logger, message.Payload) case bcModel.BasecampTodoMsg: _ = w.handleTodoMessage(w.logger, message.Payload) default: continue } } }() select { case err := <-consumeErr: return err case <-w.ctx.Done(): return nil } } func (w *Worker) Enqueue(action string, msg interface{}) { w.queue <- model.WorkerMessage{Type: action, Payload: msg} } func (w *Worker) handleCommentMessage(l logger.Logger, payload interface{}) error { m := payload.(bcModel.BasecampCommentMessage) err := w.service.Basecamp.Comment.Create(m.ProjectID, m.RecordingID, m.Payload) if err != nil { l.Errorf(err, "failed to create basecamp comment", "payload", m.Payload.Content) return err } return nil } func (w *Worker) handleTodoMessage(l logger.Logger, payload interface{}) error { m := payload.(bcModel.BasecampTodoMessageModel) _, err := w.service.Basecamp.Todo.Create(m.ProjectID, m.ListID, m.Payload) if err != nil { l.Errorf(err, "failed to create basecamp todo", "payload", m.Payload.Content) return err } return nil }
```

